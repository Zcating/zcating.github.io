<!DOCTYPE html>
<html lang="zh">

<head>
  <meta charset="UTF-8">
  <!-- 禁止缩放，锁定屏幕方向 -->
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>丧尸围城</title>
  <style>
    body {
      margin: 0;
      overflow: hidden;
      background-color: #111;
      user-select: none;
      font-family: sans-serif;
      touch-action: none;
    }

    #ui {
      position: absolute;
      top: 20px;
      left: 20px;
      color: #fff;
      font-size: 16px;
      font-weight: bold;
      pointer-events: none;
      text-shadow: 2px 2px 0 #000;
      z-index: 10;
    }

    .weapon-status {
      margin-top: 5px;
      font-size: 14px;
      color: #ccc;
    }

    #overlay {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      color: #fff;
      text-align: center;
      background: rgba(0, 0, 0, 0.85);
      padding: 30px;
      border-radius: 10px;
      z-index: 100;
      /* 确保层级最高 */
      min-width: 200px;
      width: 70%;
    }

    /* 按钮样式优化 */
    #actionBtn {
      margin-top: 20px;
      padding: 15px 40px;
      /* 按钮做大点，方便按 */
      font-size: 20px;
      cursor: pointer;
      background: #00d2ff;
      border: none;
      color: #000;
      font-weight: bold;
      border-radius: 50px;
      box-shadow: 0 0 15px #00d2ff;
      transition: transform 0.1s;
    }

    #actionBtn:active {
      transform: scale(0.95);
    }

    /* --- 移动端控制器 --- */
    #mobile-controls {
      display: none;
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
      z-index: 50;
    }

    #joystick-zone {
      position: absolute;
      bottom: 50px;
      left: 40px;
      width: 120px;
      height: 120px;
      background: rgba(255, 255, 255, 0.1);
      border: 2px solid rgba(255, 255, 255, 0.3);
      border-radius: 50%;
      pointer-events: auto;
    }

    #joystick-stick {
      position: absolute;
      top: 50%;
      left: 50%;
      width: 50px;
      height: 50px;
      margin-top: -25px;
      margin-left: -25px;
      background: rgba(0, 210, 255, 0.8);
      border-radius: 50%;
      box-shadow: 0 0 10px rgba(0, 210, 255, 0.5);
    }

    #fire-btn {
      position: absolute;
      bottom: 50px;
      right: 40px;
      width: 90px;
      height: 90px;
      background: rgba(255, 50, 50, 0.4);
      border: 4px solid rgba(255, 50, 50, 0.8);
      border-radius: 50%;
      pointer-events: auto;
      display: flex;
      align-items: center;
      justify-content: center;
      color: #fff;
      font-weight: bold;
      font-size: 18px;
    }

    #fire-btn:active {
      background: rgba(255, 50, 50, 0.8);
      transform: scale(0.95);
    }
  </style>
  <!-- 使用 unpkg 源，通常比较稳定 -->
  <script src="https://unpkg.com/three@0.128.0/build/three.min.js"></script>
</head>

<body>

  <div id="ui">
    HP: <span id="hp" style="color:#0f0">100</span>% <br>
    Score: <span id="score">0</span>
    <div class="weapon-status">Weapon: <span id="weaponName" style="color:#fff">Pistol</span></div>
  </div>

  <!-- 移动端控件 -->
  <div id="mobile-controls">
    <div id="joystick-zone">
      <div id="joystick-stick"></div>
    </div>
    <div id="fire-btn">FIRE</div>
  </div>

  <!-- 游戏覆盖层 (开始/结束界面) -->
  <div id="overlay">
    <h2 id="statusText">正在加载资源...</h2>

    <div id="loadingTips" style="font-size:12px; color:#aaa; margin-top:10px; line-height: 1.6;">
      <span style="color:#ff3333">■ 急救</span> &nbsp;
      <span style="color:#00d2ff">◆ 加特林</span> &nbsp;
      <span style="color:#ffff00">▲ 霰弹</span>
    </div>

    <div id="pc-tips" style="font-size:12px; color:#666; margin-top:10px;">PC: WASD移动, 鼠标射击</div>
    <div id="mobile-tips" style="display:none; font-size:12px; color:#00d2ff; margin-top:10px;">
      左侧摇杆移动，右侧按钮射击<br>(自动锁定最近敌人)
    </div>

    <!-- 关键修改：移除 onclick 内联代码，改用 JS 控制 -->
    <button id="actionBtn" style="display:none;">START GAME</button>
  </div>

  <script>
    // --- 全局变量 ---
    let isMobile = false;
    let joystickVector = { x: 0, y: 0 };
    let isFiringMobile = false;

    // 游戏核心变量
    let gameStarted = false;
    let score = 0;
    let health = 100;
    let isGameOver = false;

    // 检测设备
    if (/Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent)) {
      isMobile = true;
    }

    // --- 页面加载逻辑 ---
    window.addEventListener('load', function () {
      // 1. 检查 Three.js 是否加载
      if (typeof THREE === 'undefined') {
        document.getElementById('statusText').innerText = "资源加载失败";
        document.getElementById('loadingTips').innerText = "请检查网络连接";
        return;
      }

      // 2. 界面适配
      if (isMobile) {
        document.getElementById('mobile-tips').style.display = 'block';
        document.getElementById('pc-tips').style.display = 'none';
      }

      // 3. 准备就绪，显示开始按钮
      const statusText = document.getElementById('statusText');
      const actionBtn = document.getElementById('actionBtn');

      statusText.innerText = "准备就绪";
      statusText.style.color = "#0f0";
      actionBtn.style.display = 'inline-block';

      // 4. 绑定按钮点击事件 (核心修复)
      actionBtn.addEventListener('click', function () {
        if (!gameStarted) {
          // 第一次点击：开始游戏
          startGameLogic();
        } else {
          // 游戏结束后点击：刷新页面重来
          location.reload();
        }
      });
    });

    // --- 启动游戏逻辑 ---
    function startGameLogic() {
      gameStarted = true;
      document.getElementById('overlay').style.display = 'none'; // 隐藏遮罩

      // 如果是手机，显示控制器
      if (isMobile) {
        document.getElementById('mobile-controls').style.display = 'block';
        initMobileControls();
      }

      // 初始化 Three.js 场景
      initThreeJs();
    }

    // --- Three.js 游戏主程序 ---
    function initThreeJs() {
      const CONFIG = {
        playerSpeed: isMobile ? 0.6 : 0.9,
        zombieSpeed: 0.35,
        zombieMaxForce: 0.05,
        spawnRate: 60,
        itemSpawnRate: 300,
        separationDist: 3,
        bulletSpeed: 2.2,
        camHeight: isMobile ? 95 : 80,
        camDist: isMobile ? 55 : 45
      };

      const scene = new THREE.Scene();
      scene.background = new THREE.Color(0x1a1a1a);
      scene.fog = new THREE.Fog(0x1a1a1a, 60, 200);

      // 地面
      const gridHelper = new THREE.GridHelper(200, 50, 0x444444, 0x333333);
      scene.add(gridHelper);
      const planeGeo = new THREE.PlaneGeometry(300, 300);
      const planeMat = new THREE.MeshBasicMaterial({ visible: false });
      const groundPlane = new THREE.Mesh(planeGeo, planeMat);
      groundPlane.rotation.x = -Math.PI / 2;
      scene.add(groundPlane);

      // 灯光
      const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
      scene.add(ambientLight);
      const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
      dirLight.position.set(50, 100, 50);
      dirLight.castShadow = true;
      scene.add(dirLight);

      // 相机
      const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
      camera.position.set(0, CONFIG.camHeight, CONFIG.camDist);
      camera.lookAt(0, 0, 0);

      const renderer = new THREE.WebGLRenderer({ antialias: !isMobile });
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.shadowMap.enabled = true;
      document.body.appendChild(renderer.domElement);

      // 武器状态
      const weaponState = {
        type: 'pistol',
        timer: 0,
        cooldown: 0,
        maxCooldown: 15
      };

      // --- 类定义 ---
      class Player {
        constructor() {
          const geo = new THREE.BoxGeometry(2, 2, 2);
          this.mat = new THREE.MeshLambertMaterial({ color: 0x0088ff });
          this.mesh = new THREE.Mesh(geo, this.mat);
          this.mesh.position.y = 1;
          this.mesh.castShadow = true;
          const gunGeo = new THREE.BoxGeometry(0.5, 0.5, 2.5);
          this.gunMat = new THREE.MeshBasicMaterial({ color: 0x111 });
          this.gunMesh = new THREE.Mesh(gunGeo, this.gunMat);
          this.gunMesh.position.set(0.8, 0, 1.5);
          this.mesh.add(this.gunMesh);
          scene.add(this.mesh);
          this.velocity = new THREE.Vector3();
        }

        update(keys, mouseTarget) {
          if (isGameOver) return;
          this.velocity.set(0, 0, 0);

          if (isMobile) {
            if (Math.abs(joystickVector.x) > 0.1 || Math.abs(joystickVector.y) > 0.1) {
              this.velocity.x = joystickVector.x * CONFIG.playerSpeed;
              this.velocity.z = joystickVector.y * CONFIG.playerSpeed;
            }
          } else {
            if (keys['w']) this.velocity.z = -CONFIG.playerSpeed;
            if (keys['s']) this.velocity.z = CONFIG.playerSpeed;
            if (keys['a']) this.velocity.x = -CONFIG.playerSpeed;
            if (keys['d']) this.velocity.x = CONFIG.playerSpeed;
          }

          this.mesh.position.add(this.velocity);
          const limit = 95;
          this.mesh.position.x = Math.max(-limit, Math.min(limit, this.mesh.position.x));
          this.mesh.position.z = Math.max(-limit, Math.min(limit, this.mesh.position.z));

          if (mouseTarget) {
            this.mesh.lookAt(mouseTarget.x, 1, mouseTarget.z);
          } else if (isMobile && (this.velocity.x !== 0 || this.velocity.z !== 0)) {
            const lookT = this.mesh.position.clone().add(this.velocity);
            this.mesh.lookAt(lookT.x, 1, lookT.z);
          }

          const targetCamPos = this.mesh.position.clone().add(new THREE.Vector3(0, CONFIG.camHeight, CONFIG.camDist));
          camera.position.lerp(targetCamPos, 0.15);
          camera.lookAt(this.mesh.position);
        }
      }

      class Bullet {
        constructor(position, direction) {
          this.position = position.clone();
          this.velocity = direction.clone().normalize().multiplyScalar(CONFIG.bulletSpeed);
          let color = 0xffff00;
          let size = 0.3;
          if (weaponState.type === 'machinegun') { color = 0x00d2ff; size = 0.25; }
          if (weaponState.type === 'shotgun') { color = 0xffaa00; size = 0.25; }
          const geo = new THREE.SphereGeometry(size, 4, 4);
          const mat = new THREE.MeshBasicMaterial({ color: color });
          this.mesh = new THREE.Mesh(geo, mat);
          this.mesh.position.copy(this.position);
          scene.add(this.mesh);
          this.alive = true;
          this.life = 80;
        }
        update() {
          this.position.add(this.velocity);
          this.mesh.position.copy(this.position);
          this.life--;
          if (this.life <= 0) this.alive = false;
        }
      }

      class Zombie {
        constructor() {
          const angle = Math.random() * Math.PI * 2;
          const radius = 90 + Math.random() * 30;
          const x = Math.cos(angle) * radius;
          const z = Math.sin(angle) * radius;
          this.position = new THREE.Vector3(x, 1, z);
          this.velocity = new THREE.Vector3();
          this.acceleration = new THREE.Vector3();
          const geo = new THREE.ConeGeometry(1, 2.5, 8);
          geo.rotateX(Math.PI / 2);
          const mat = new THREE.MeshLambertMaterial({ color: 0x00ff00 });
          this.mesh = new THREE.Mesh(geo, mat);
          this.mesh.position.copy(this.position);
          scene.add(this.mesh);
        }
        applyBehaviors(zombies, playerPos) {
          let separate = this.separate(zombies);
          let seek = this.seek(playerPos);
          separate.multiplyScalar(2.5);
          seek.multiplyScalar(1.0);
          this.acceleration.add(separate);
          this.acceleration.add(seek);
        }
        seek(target) {
          let desired = new THREE.Vector3().subVectors(target, this.position);
          desired.normalize();
          desired.multiplyScalar(CONFIG.zombieSpeed);
          let steer = new THREE.Vector3().subVectors(desired, this.velocity);
          steer.clampLength(0, CONFIG.zombieMaxForce);
          return steer;
        }
        separate(zombies) {
          let sum = new THREE.Vector3();
          let count = 0;
          for (let other of zombies) {
            if (other === this) continue;
            let d = this.position.distanceTo(other.position);
            if (d > 0 && d < CONFIG.separationDist) {
              let diff = new THREE.Vector3().subVectors(this.position, other.position);
              diff.normalize();
              diff.divideScalar(d);
              sum.add(diff);
              count++;
            }
          }
          if (count > 0) {
            sum.divideScalar(count);
            sum.normalize();
            sum.multiplyScalar(CONFIG.zombieSpeed);
            sum.sub(this.velocity);
            sum.clampLength(0, CONFIG.zombieMaxForce);
          }
          return sum;
        }
        update() {
          this.velocity.add(this.acceleration);
          this.velocity.clampLength(0, CONFIG.zombieSpeed);
          this.position.add(this.velocity);
          this.acceleration.set(0, 0, 0);
          this.mesh.position.copy(this.position);
          const lookTarget = this.position.clone().add(this.velocity);
          this.mesh.lookAt(lookTarget);
        }
      }

      class Item {
        constructor() {
          const rand = Math.random();
          if (rand < 0.4) this.type = 'health';
          else if (rand < 0.7) this.type = 'machinegun';
          else this.type = 'shotgun';
          const x = (Math.random() - 0.5) * 160;
          const z = (Math.random() - 0.5) * 160;
          this.position = new THREE.Vector3(x, 1.5, z);
          let geo, mat;
          if (this.type === 'health') {
            geo = new THREE.BoxGeometry(1.5, 1.5, 1.5);
            mat = new THREE.MeshLambertMaterial({ color: 0xff0000, emissive: 0x330000 });
          } else if (this.type === 'machinegun') {
            geo = new THREE.OctahedronGeometry(1);
            mat = new THREE.MeshLambertMaterial({ color: 0x00d2ff, emissive: 0x0044aa });
          } else {
            geo = new THREE.TetrahedronGeometry(1.2);
            mat = new THREE.MeshLambertMaterial({ color: 0xffff00, emissive: 0x555500 });
          }
          this.mesh = new THREE.Mesh(geo, mat);
          this.mesh.position.copy(this.position);
          scene.add(this.mesh);
        }
        update() {
          this.mesh.rotation.y += 0.03;
          this.mesh.position.y = 1.5 + Math.sin(Date.now() * 0.003) * 0.3;
        }
      }

      // --- 游戏逻辑 ---
      const player = new Player();
      const zombies = [];
      const bullets = [];
      const items = [];
      const keys = {};
      const mouse = new THREE.Vector2();
      const raycaster = new THREE.Raycaster();
      let mouseTarget = new THREE.Vector3();
      let isMouseDown = false;

      window.addEventListener('keydown', e => keys[e.key.toLowerCase()] = true);
      window.addEventListener('keyup', e => keys[e.key.toLowerCase()] = false);

      if (!isMobile) {
        window.addEventListener('mousemove', e => {
          mouse.x = (e.clientX / window.innerWidth) * 2 - 1;
          mouse.y = -(e.clientY / window.innerHeight) * 2 + 1;
        });
        window.addEventListener('mousedown', () => isMouseDown = true);
        window.addEventListener('mouseup', () => isMouseDown = false);
      }
      window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      });

      let frameCount = 0;

      function getClosestZombie(pos) {
        let minDst = Infinity;
        let target = null;
        for (let z of zombies) {
          const dst = z.position.distanceTo(pos);
          if (dst < minDst) { minDst = dst; target = z; }
        }
        return target;
      }

      function fireWeapon() {
        if (weaponState.cooldown > 0) return;
        const origin = player.mesh.position.clone();
        let aimDir;

        if (isMobile) {
          const targetZombie = getClosestZombie(origin);
          if (targetZombie) {
            aimDir = new THREE.Vector3().subVectors(targetZombie.position, origin);
          } else {
            aimDir = player.mesh.getWorldDirection(new THREE.Vector3());
          }
        } else {
          aimDir = new THREE.Vector3().subVectors(mouseTarget, origin);
        }
        aimDir.y = 0;
        aimDir.normalize();

        if (weaponState.type === 'shotgun') {
          for (let i = -2; i <= 2; i++) {
            const dir = aimDir.clone();
            const angle = i * 0.15;
            const x = dir.x * Math.cos(angle) - dir.z * Math.sin(angle);
            const z = dir.x * Math.sin(angle) + dir.z * Math.cos(angle);
            dir.set(x, 0, z);
            bullets.push(new Bullet(origin, dir));
          }
          weaponState.cooldown = 45;
        } else {
          bullets.push(new Bullet(origin, aimDir));
          weaponState.cooldown = (weaponState.type === 'machinegun') ? 4 : 15;
        }
      }

      function updateUI() {
        const weaponNameEl = document.getElementById('weaponName');
        let tName = 'Pistol';
        let color = '#fff';
        if (weaponState.type === 'machinegun') { tName = 'Minigun'; color = '#00d2ff'; }
        if (weaponState.type === 'shotgun') { tName = 'Shotgun'; color = '#ffff00'; }
        if (weaponState.type !== 'pistol') tName += ` (${Math.ceil(weaponState.timer / 60)}s)`;
        weaponNameEl.innerText = tName;
        weaponNameEl.style.color = color;
        const hpEl = document.getElementById('hp');
        hpEl.innerText = health;
        hpEl.style.color = health < 30 ? 'red' : '#0f0';
      }

      function showGameOver() {
        const overlay = document.getElementById('overlay');
        const actionBtn = document.getElementById('actionBtn');
        const statusText = document.getElementById('statusText');

        overlay.style.display = 'block';
        statusText.innerText = "GAME OVER";
        statusText.style.color = "#ff3333";

        document.getElementById('loadingTips').innerHTML = `Final Score: <span style="color:#fff; font-size:24px">${score}</span>`;
        document.getElementById('mobile-tips').style.display = 'none';
        document.getElementById('pc-tips').style.display = 'none';

        // 改变按钮文本
        actionBtn.innerText = "TRY AGAIN";

        // 隐藏手机控制
        if (isMobile) document.getElementById('mobile-controls').style.display = 'none';
      }

      function animate() {
        requestAnimationFrame(animate);
        if (isGameOver) return;
        frameCount++;

        // 武器冷却 & 计时
        if (weaponState.cooldown > 0) weaponState.cooldown--;
        if (weaponState.type !== 'pistol') {
          weaponState.timer--;
          if (weaponState.timer <= 0) {
            weaponState.type = 'pistol';
            player.gunMat.color.setHex(0x111111);
          }
        }
        updateUI();

        // 瞄准逻辑
        let currentTarget = null;
        if (!isMobile) {
          raycaster.setFromCamera(mouse, camera);
          const intersects = raycaster.intersectObject(groundPlane);
          if (intersects.length > 0) {
            mouseTarget.copy(intersects[0].point);
            currentTarget = mouseTarget;
          }
        } else {
          const closest = getClosestZombie(player.mesh.position);
          if (closest) currentTarget = closest.position;
        }

        player.update(keys, currentTarget);

        if (isMouseDown || isFiringMobile) fireWeapon();

        // 物品逻辑
        if (frameCount % CONFIG.itemSpawnRate === 0) items.push(new Item());
        for (let i = items.length - 1; i >= 0; i--) {
          const item = items[i];
          item.update();
          if (player.mesh.position.distanceTo(item.position) < 3.0) {
            if (item.type === 'health') health = Math.min(100, health + 30);
            else if (item.type === 'machinegun') {
              weaponState.type = 'machinegun'; weaponState.timer = 600;
              player.gunMat.color.setHex(0x00d2ff);
            } else if (item.type === 'shotgun') {
              weaponState.type = 'shotgun'; weaponState.timer = 600;
              player.gunMat.color.setHex(0xffff00);
            }
            scene.remove(item.mesh);
            items.splice(i, 1);
          }
        }

        // 丧尸生成逻辑
        if (frameCount % CONFIG.spawnRate === 0) {
          zombies.push(new Zombie());
          if (CONFIG.spawnRate > 10 && frameCount % 600 === 0) CONFIG.spawnRate -= 5;
        }

        // 丧尸更新
        for (let i = zombies.length - 1; i >= 0; i--) {
          const z = zombies[i];
          z.applyBehaviors(zombies, player.mesh.position);
          z.update();
          if (z.position.distanceTo(player.mesh.position) < 2.0) {
            health -= 1;
            if (health <= 0) {
              isGameOver = true;
              showGameOver();
            }
          }
        }

        // 子弹更新
        for (let i = bullets.length - 1; i >= 0; i--) {
          const b = bullets[i];
          b.update();
          if (!b.alive) { scene.remove(b.mesh); bullets.splice(i, 1); continue; }
          for (let j = zombies.length - 1; j >= 0; j--) {
            const z = zombies[j];
            if (b.position.distanceTo(z.position) < 2.0) {
              scene.remove(z.mesh); zombies.splice(j, 1);
              scene.remove(b.mesh); bullets.splice(i, 1);
              b.alive = false;
              score += 10;
              document.getElementById('score').innerText = score;
              break;
            }
          }
        }
        renderer.render(scene, camera);
      }
      animate();
    }

    // --- 手机控制器逻辑 ---
    function initMobileControls() {
      const zone = document.getElementById('joystick-zone');
      const stick = document.getElementById('joystick-stick');
      const fireBtn = document.getElementById('fire-btn');
      let stickId = null;

      zone.addEventListener('touchstart', (e) => {
        e.preventDefault();
        const touch = e.changedTouches[0];
        stickId = touch.identifier;
        updateStick(touch);
      }, { passive: false });

      zone.addEventListener('touchmove', (e) => {
        e.preventDefault();
        for (let i = 0; i < e.changedTouches.length; i++) {
          if (e.changedTouches[i].identifier === stickId) {
            updateStick(e.changedTouches[i]);
            break;
          }
        }
      }, { passive: false });

      zone.addEventListener('touchend', (e) => {
        e.preventDefault();
        for (let i = 0; i < e.changedTouches.length; i++) {
          if (e.changedTouches[i].identifier === stickId) {
            stickId = null;
            stick.style.transform = `translate(0px, 0px)`;
            joystickVector = { x: 0, y: 0 };
            break;
          }
        }
      });

      function updateStick(touch) {
        const rect = zone.getBoundingClientRect();
        const centerX = rect.left + rect.width / 2;
        const centerY = rect.top + rect.height / 2;
        let x = touch.clientX - centerX;
        let y = touch.clientY - centerY;
        const radius = rect.width / 2;
        const distance = Math.sqrt(x * x + y * y);
        if (distance > radius) {
          x = (x / distance) * radius;
          y = (y / distance) * radius;
        }
        stick.style.transform = `translate(${x}px, ${y}px)`;
        joystickVector.x = x / radius;
        joystickVector.y = y / radius;
      }

      fireBtn.addEventListener('touchstart', (e) => {
        e.preventDefault();
        isFiringMobile = true;
        fireBtn.style.background = 'rgba(255, 50, 50, 0.8)';
        fireBtn.style.transform = 'scale(0.9)';
      }, { passive: false });

      fireBtn.addEventListener('touchend', (e) => {
        e.preventDefault();
        isFiringMobile = false;
        fireBtn.style.background = 'rgba(255, 50, 50, 0.4)';
        fireBtn.style.transform = 'scale(1)';
      });
    }
  </script>
</body>

</html>
