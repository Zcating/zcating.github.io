{"meta":{"title":"Zcat's Studio","subtitle":null,"description":"Simple Coder","author":"Zcating","url":"http://www.zcating.tk"},"pages":[{"title":"","date":"2019-03-17T10:06:35.724Z","updated":"2019-03-17T10:06:35.724Z","comments":true,"path":"js/DecalGeometry.js","permalink":"http://www.zcating.tk/js/DecalGeometry.js","excerpt":"","text":"/** * @author Mugen87 / https://github.com/Mugen87 * @author spite / https://github.com/spite * * You can use this geometry to create a decal mesh, that serves different kinds of purposes. * e.g. adding unique details to models, performing dynamic visual environmental changes or covering seams. * * Constructor parameter: * * mesh — Any mesh object * position — Position of the decal projector * orientation — Orientation of the decal projector * size — Size of the decal projector * * reference: http://blog.wolfire.com/2009/06/how-to-project-decals/ * */ ( function () { function DecalGeometry( mesh, position, orientation, size ) { THREE.BufferGeometry.call( this ); // buffers var vertices = []; var normals = []; var uvs = []; // helpers var plane = new THREE.Vector3(); // this matrix represents the transformation of the decal projector var projectorMatrix = new THREE.Matrix4(); projectorMatrix.makeRotationFromEuler( orientation ); projectorMatrix.setPosition( position ); var projectorMatrixInverse = new THREE.Matrix4().getInverse( projectorMatrix ); // generate buffers generate(); // build geometry this.addAttribute( 'position', new THREE.Float32BufferAttribute( vertices, 3 ) ); this.addAttribute( 'normal', new THREE.Float32BufferAttribute( normals, 3 ) ); this.addAttribute( 'uv', new THREE.Float32BufferAttribute( uvs, 2 ) ); function generate() { var i; var geometry = new THREE.BufferGeometry(); var decalVertices = []; var vertex = new THREE.Vector3(); var normal = new THREE.Vector3(); // handle different geometry types if ( mesh.geometry.isGeometry ) { geometry.fromGeometry( mesh.geometry ); } else { geometry.copy( mesh.geometry ); } var positionAttribute = geometry.attributes.position; var normalAttribute = geometry.attributes.normal; // first, create an array of 'DecalVertex' objects // three consecutive 'DecalVertex' objects represent a single face // // this data structure will be later used to perform the clipping if ( geometry.index !== null ) { // indexed BufferGeometry var index = geometry.index; for ( i = 0; i < index.count; i ++ ) { vertex.fromBufferAttribute( positionAttribute, index.getX( i ) ); normal.fromBufferAttribute( normalAttribute, index.getX( i ) ); pushDecalVertex( decalVertices, vertex, normal ); } } else { // non-indexed BufferGeometry for ( i = 0; i < positionAttribute.count; i ++ ) { vertex.fromBufferAttribute( positionAttribute, i ); normal.fromBufferAttribute( normalAttribute, i ); pushDecalVertex( decalVertices, vertex, normal ); } } // second, clip the geometry so that it doesn't extend out from the projector decalVertices = clipGeometry( decalVertices, plane.set( 1, 0, 0 ) ); decalVertices = clipGeometry( decalVertices, plane.set( - 1, 0, 0 ) ); decalVertices = clipGeometry( decalVertices, plane.set( 0, 1, 0 ) ); decalVertices = clipGeometry( decalVertices, plane.set( 0, - 1, 0 ) ); decalVertices = clipGeometry( decalVertices, plane.set( 0, 0, 1 ) ); decalVertices = clipGeometry( decalVertices, plane.set( 0, 0, - 1 ) ); // third, generate final vertices, normals and uvs for ( i = 0; i < decalVertices.length; i ++ ) { var decalVertex = decalVertices[ i ]; // create texture coordinates (we are still in projector space) uvs.push( 0.5 + ( decalVertex.position.x / size.x ), 0.5 + ( decalVertex.position.y / size.y ) ); // transform the vertex back to world space decalVertex.position.applyMatrix4( projectorMatrix ); // now create vertex and normal buffer data vertices.push( decalVertex.position.x, decalVertex.position.y, decalVertex.position.z ); normals.push( decalVertex.normal.x, decalVertex.normal.y, decalVertex.normal.z ); } } function pushDecalVertex( decalVertices, vertex, normal ) { // transform the vertex to world space, then to projector space vertex.applyMatrix4( mesh.matrixWorld ); vertex.applyMatrix4( projectorMatrixInverse ); decalVertices.push( new DecalVertex( vertex.clone(), normal.clone() ) ); } function clipGeometry( inVertices, plane ) { var outVertices = []; var s = 0.5 * Math.abs( size.dot( plane ) ); // a single iteration clips one face, // which consists of three consecutive 'DecalVertex' objects for ( var i = 0; i < inVertices.length; i += 3 ) { var v1Out, v2Out, v3Out, total = 0; var nV1, nV2, nV3, nV4; var d1 = inVertices[ i + 0 ].position.dot( plane ) - s; var d2 = inVertices[ i + 1 ].position.dot( plane ) - s; var d3 = inVertices[ i + 2 ].position.dot( plane ) - s; v1Out = d1 > 0; v2Out = d2 > 0; v3Out = d3 > 0; // calculate, how many vertices of the face lie outside of the clipping plane total = ( v1Out ? 1 : 0 ) + ( v2Out ? 1 : 0 ) + ( v3Out ? 1 : 0 ); switch ( total ) { case 0: { // the entire face lies inside of the plane, no clipping needed outVertices.push( inVertices[ i ] ); outVertices.push( inVertices[ i + 1 ] ); outVertices.push( inVertices[ i + 2 ] ); break; } case 1: { // one vertex lies outside of the plane, perform clipping if ( v1Out ) { nV1 = inVertices[ i + 1 ]; nV2 = inVertices[ i + 2 ]; nV3 = clip( inVertices[ i ], nV1, plane, s ); nV4 = clip( inVertices[ i ], nV2, plane, s ); } if ( v2Out ) { nV1 = inVertices[ i ]; nV2 = inVertices[ i + 2 ]; nV3 = clip( inVertices[ i + 1 ], nV1, plane, s ); nV4 = clip( inVertices[ i + 1 ], nV2, plane, s ); outVertices.push( nV3 ); outVertices.push( nV2.clone() ); outVertices.push( nV1.clone() ); outVertices.push( nV2.clone() ); outVertices.push( nV3.clone() ); outVertices.push( nV4 ); break; } if ( v3Out ) { nV1 = inVertices[ i ]; nV2 = inVertices[ i + 1 ]; nV3 = clip( inVertices[ i + 2 ], nV1, plane, s ); nV4 = clip( inVertices[ i + 2 ], nV2, plane, s ); } outVertices.push( nV1.clone() ); outVertices.push( nV2.clone() ); outVertices.push( nV3 ); outVertices.push( nV4 ); outVertices.push( nV3.clone() ); outVertices.push( nV2.clone() ); break; } case 2: { // two vertices lies outside of the plane, perform clipping if ( ! v1Out ) { nV1 = inVertices[ i ].clone(); nV2 = clip( nV1, inVertices[ i + 1 ], plane, s ); nV3 = clip( nV1, inVertices[ i + 2 ], plane, s ); outVertices.push( nV1 ); outVertices.push( nV2 ); outVertices.push( nV3 ); } if ( ! v2Out ) { nV1 = inVertices[ i + 1 ].clone(); nV2 = clip( nV1, inVertices[ i + 2 ], plane, s ); nV3 = clip( nV1, inVertices[ i ], plane, s ); outVertices.push( nV1 ); outVertices.push( nV2 ); outVertices.push( nV3 ); } if ( ! v3Out ) { nV1 = inVertices[ i + 2 ].clone(); nV2 = clip( nV1, inVertices[ i ], plane, s ); nV3 = clip( nV1, inVertices[ i + 1 ], plane, s ); outVertices.push( nV1 ); outVertices.push( nV2 ); outVertices.push( nV3 ); } break; } case 3: { // the entire face lies outside of the plane, so let's discard the corresponding vertices break; } } } return outVertices; } function clip( v0, v1, p, s ) { var d0 = v0.position.dot( p ) - s; var d1 = v1.position.dot( p ) - s; var s0 = d0 / ( d0 - d1 ); var v = new DecalVertex( new THREE.Vector3( v0.position.x + s0 * ( v1.position.x - v0.position.x ), v0.position.y + s0 * ( v1.position.y - v0.position.y ), v0.position.z + s0 * ( v1.position.z - v0.position.z ) ), new THREE.Vector3( v0.normal.x + s0 * ( v1.normal.x - v0.normal.x ), v0.normal.y + s0 * ( v1.normal.y - v0.normal.y ), v0.normal.z + s0 * ( v1.normal.z - v0.normal.z ) ) ); // need to clip more values (texture coordinates)? do it this way: // intersectpoint.value = a.value + s * ( b.value - a.value ); return v; } } DecalGeometry.prototype = Object.create( THREE.BufferGeometry.prototype ); DecalGeometry.prototype.constructor = DecalGeometry; // helper function DecalVertex( position, normal ) { this.position = position; this.normal = normal; } DecalVertex.prototype.clone = function () { return new DecalVertex( this.position.clone(), this.normal.clone() ); }; // export THREE.DecalGeometry = DecalGeometry; } )();"},{"title":"","date":"2019-03-17T10:06:35.726Z","updated":"2019-03-17T10:06:35.726Z","comments":true,"path":"js/dat.gui.min.js","permalink":"http://www.zcating.tk/js/dat.gui.min.js","excerpt":"","text":"/** * dat-gui JavaScript Controller Library * https://github.com/dataarts/dat.gui * * Copyright 2016 Data Arts Team, Google Creative Lab * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 */ !function(e,t){\"object\"==typeof exports&&\"object\"==typeof module?module.exports=t():\"function\"==typeof define&&define.amd?define([],t):\"object\"==typeof exports?exports.dat=t():e.dat=t()}(this,function(){return function(e){function t(o){if(n[o])return n[o].exports;var i=n[o]={exports:{},id:o,loaded:!1};return e[o].call(i.exports,i,i.exports,t),i.loaded=!0,i.exports}var n={};return t.m=e,t.c=n,t.p=\"\",t(0)}([function(e,t,n){\"use strict\";function o(e){return e&&e.__esModule?e:{\"default\":e}}var i=n(1),r=o(i);e.exports=r[\"default\"]},function(e,t,n){\"use strict\";function o(e){return e&&e.__esModule?e:{\"default\":e}}t.__esModule=!0;var i=n(2),r=o(i),a=n(6),l=o(a),s=n(3),u=o(s),d=n(7),c=o(d),f=n(8),_=o(f),p=n(10),h=o(p),m=n(11),b=o(m),g=n(12),v=o(g),y=n(13),w=o(y),x=n(14),E=o(x),C=n(15),A=o(C),S=n(16),k=o(S),O=n(9),T=o(O),R=n(17),L=o(R);t[\"default\"]={color:{Color:r[\"default\"],math:l[\"default\"],interpret:u[\"default\"]},controllers:{Controller:c[\"default\"],BooleanController:_[\"default\"],OptionController:h[\"default\"],StringController:b[\"default\"],NumberController:v[\"default\"],NumberControllerBox:w[\"default\"],NumberControllerSlider:E[\"default\"],FunctionController:A[\"default\"],ColorController:k[\"default\"]},dom:{dom:T[\"default\"]},gui:{GUI:L[\"default\"]},GUI:L[\"default\"]}},function(e,t,n){\"use strict\";function o(e){return e&&e.__esModule?e:{\"default\":e}}function i(e,t){if(!(e instanceof t))throw new TypeError(\"Cannot call a class as a function\")}function r(e,t,n){Object.defineProperty(e,t,{get:function(){return\"RGB\"===this.__state.space?this.__state[t]:(h.recalculateRGB(this,t,n),this.__state[t])},set:function(e){\"RGB\"!==this.__state.space&&(h.recalculateRGB(this,t,n),this.__state.space=\"RGB\"),this.__state[t]=e}})}function a(e,t){Object.defineProperty(e,t,{get:function(){return\"HSV\"===this.__state.space?this.__state[t]:(h.recalculateHSV(this),this.__state[t])},set:function(e){\"HSV\"!==this.__state.space&&(h.recalculateHSV(this),this.__state.space=\"HSV\"),this.__state[t]=e}})}t.__esModule=!0;var l=n(3),s=o(l),u=n(6),d=o(u),c=n(4),f=o(c),_=n(5),p=o(_),h=function(){function e(){if(i(this,e),this.__state=s[\"default\"].apply(this,arguments),this.__state===!1)throw new Error(\"Failed to interpret color arguments\");this.__state.a=this.__state.a||1}return e.prototype.toString=function(){return(0,f[\"default\"])(this)},e.prototype.toHexString=function(){return(0,f[\"default\"])(this,!0)},e.prototype.toOriginal=function(){return this.__state.conversion.write(this)},e}();h.recalculateRGB=function(e,t,n){if(\"HEX\"===e.__state.space)e.__state[t]=d[\"default\"].component_from_hex(e.__state.hex,n);else{if(\"HSV\"!==e.__state.space)throw new Error(\"Corrupted color state\");p[\"default\"].extend(e.__state,d[\"default\"].hsv_to_rgb(e.__state.h,e.__state.s,e.__state.v))}},h.recalculateHSV=function(e){var t=d[\"default\"].rgb_to_hsv(e.r,e.g,e.b);p[\"default\"].extend(e.__state,{s:t.s,v:t.v}),p[\"default\"].isNaN(t.h)?p[\"default\"].isUndefined(e.__state.h)&&(e.__state.h=0):e.__state.h=t.h},h.COMPONENTS=[\"r\",\"g\",\"b\",\"h\",\"s\",\"v\",\"hex\",\"a\"],r(h.prototype,\"r\",2),r(h.prototype,\"g\",1),r(h.prototype,\"b\",0),a(h.prototype,\"h\"),a(h.prototype,\"s\"),a(h.prototype,\"v\"),Object.defineProperty(h.prototype,\"a\",{get:function(){return this.__state.a},set:function(e){this.__state.a=e}}),Object.defineProperty(h.prototype,\"hex\",{get:function(){return\"HEX\"!==!this.__state.space&&(this.__state.hex=d[\"default\"].rgb_to_hex(this.r,this.g,this.b)),this.__state.hex},set:function(e){this.__state.space=\"HEX\",this.__state.hex=e}}),t[\"default\"]=h},function(e,t,n){\"use strict\";function o(e){return e&&e.__esModule?e:{\"default\":e}}t.__esModule=!0;var i=n(4),r=o(i),a=n(5),l=o(a),s=[{litmus:l[\"default\"].isString,conversions:{THREE_CHAR_HEX:{read:function(e){var t=e.match(/^#([A-F0-9])([A-F0-9])([A-F0-9])$/i);return null!==t&&{space:\"HEX\",hex:parseInt(\"0x\"+t[1].toString()+t[1].toString()+t[2].toString()+t[2].toString()+t[3].toString()+t[3].toString(),0)}},write:r[\"default\"]},SIX_CHAR_HEX:{read:function(e){var t=e.match(/^#([A-F0-9]{6})$/i);return null!==t&&{space:\"HEX\",hex:parseInt(\"0x\"+t[1].toString(),0)}},write:r[\"default\"]},CSS_RGB:{read:function(e){var t=e.match(/^rgb\\(\\s*(.+)\\s*,\\s*(.+)\\s*,\\s*(.+)\\s*\\)/);return null!==t&&{space:\"RGB\",r:parseFloat(t[1]),g:parseFloat(t[2]),b:parseFloat(t[3])}},write:r[\"default\"]},CSS_RGBA:{read:function(e){var t=e.match(/^rgba\\(\\s*(.+)\\s*,\\s*(.+)\\s*,\\s*(.+)\\s*,\\s*(.+)\\s*\\)/);return null!==t&&{space:\"RGB\",r:parseFloat(t[1]),g:parseFloat(t[2]),b:parseFloat(t[3]),a:parseFloat(t[4])}},write:r[\"default\"]}}},{litmus:l[\"default\"].isNumber,conversions:{HEX:{read:function(e){return{space:\"HEX\",hex:e,conversionName:\"HEX\"}},write:function(e){return e.hex}}}},{litmus:l[\"default\"].isArray,conversions:{RGB_ARRAY:{read:function(e){return 3===e.length&&{space:\"RGB\",r:e[0],g:e[1],b:e[2]}},write:function(e){return[e.r,e.g,e.b]}},RGBA_ARRAY:{read:function(e){return 4===e.length&&{space:\"RGB\",r:e[0],g:e[1],b:e[2],a:e[3]}},write:function(e){return[e.r,e.g,e.b,e.a]}}}},{litmus:l[\"default\"].isObject,conversions:{RGBA_OBJ:{read:function(e){return!!(l[\"default\"].isNumber(e.r)&&l[\"default\"].isNumber(e.g)&&l[\"default\"].isNumber(e.b)&&l[\"default\"].isNumber(e.a))&&{space:\"RGB\",r:e.r,g:e.g,b:e.b,a:e.a}},write:function(e){return{r:e.r,g:e.g,b:e.b,a:e.a}}},RGB_OBJ:{read:function(e){return!!(l[\"default\"].isNumber(e.r)&&l[\"default\"].isNumber(e.g)&&l[\"default\"].isNumber(e.b))&&{space:\"RGB\",r:e.r,g:e.g,b:e.b}},write:function(e){return{r:e.r,g:e.g,b:e.b}}},HSVA_OBJ:{read:function(e){return!!(l[\"default\"].isNumber(e.h)&&l[\"default\"].isNumber(e.s)&&l[\"default\"].isNumber(e.v)&&l[\"default\"].isNumber(e.a))&&{space:\"HSV\",h:e.h,s:e.s,v:e.v,a:e.a}},write:function(e){return{h:e.h,s:e.s,v:e.v,a:e.a}}},HSV_OBJ:{read:function(e){return!!(l[\"default\"].isNumber(e.h)&&l[\"default\"].isNumber(e.s)&&l[\"default\"].isNumber(e.v))&&{space:\"HSV\",h:e.h,s:e.s,v:e.v}},write:function(e){return{h:e.h,s:e.s,v:e.v}}}}}],u=void 0,d=void 0,c=function(){d=!1;var e=arguments.length>1?l[\"default\"].toArray(arguments):arguments[0];return l[\"default\"].each(s,function(t){if(t.litmus(e))return l[\"default\"].each(t.conversions,function(t,n){if(u=t.read(e),d===!1&&u!==!1)return d=u,u.conversionName=n,u.conversion=t,l[\"default\"].BREAK}),l[\"default\"].BREAK}),d};t[\"default\"]=c},function(e,t){\"use strict\";t.__esModule=!0,t[\"default\"]=function(e,t){var n=e.__state.conversionName.toString(),o=Math.round(e.r),i=Math.round(e.g),r=Math.round(e.b),a=e.a,l=Math.round(e.h),s=e.s.toFixed(1),u=e.v.toFixed(1);if(t||\"THREE_CHAR_HEX\"===n||\"SIX_CHAR_HEX\"===n){for(var d=e.hex.toString(16);d.length=0;n--)t=[e[n].apply(this,t)];return t[0]}},each:function(e,t,o){if(e)if(n&&e.forEach&&e.forEach===n)e.forEach(t,o);else if(e.length===e.length+0){var i=void 0,r=void 0;for(i=0,r=e.length;iul{margin-top:27px}.dg.a.has-save>ul.closed{margin-top:0}.dg.a .save-row{position:fixed;top:0;z-index:1002}.dg li{-webkit-transition:height .1s ease-out;transition:height .1s ease-out}.dg li:not(.folder){cursor:auto;height:27px;line-height:27px;overflow:hidden;padding:0 4px 0 5px}.dg li.folder{padding:0;border-left:4px solid transparent}.dg li.title{cursor:pointer;margin-left:-4px}.dg .closed li:not(.title),.dg .closed ul li,.dg .closed ul li>*{height:0;overflow:hidden;border:0}.dg .cr{clear:both;padding-left:3px;height:27px}.dg .property-name{cursor:default;float:left;clear:left;width:40%;overflow:hidden;text-overflow:ellipsis}.dg .c{float:left;width:60%}.dg .c input[type=text]{border:0;margin-top:4px;padding:3px;width:100%;float:right}.dg .has-slider input[type=text]{width:30%;margin-left:0}.dg .slider{float:left;width:66%;margin-left:-5px;margin-right:0;height:19px;margin-top:4px}.dg .slider-fg{height:100%}.dg .c input[type=checkbox]{margin-top:9px}.dg .c select{margin-top:5px}.dg .cr.boolean,.dg .cr.boolean *,.dg .cr.function,.dg .cr.function *,.dg .cr.function .property-name{cursor:pointer}.dg .selector{display:none;position:absolute;margin-left:-9px;margin-top:23px;z-index:10}.dg .c:hover .selector,.dg .selector.drag{display:block}.dg li.save-row{padding:0}.dg li.save-row .button{display:inline-block;padding:0 6px}.dg.dialogue{background-color:#222;width:460px;padding:15px;font-size:13px;line-height:15px}#dg-new-constructor{padding:10px;color:#222;font-family:Monaco,monospace;font-size:10px;border:0;resize:none;box-shadow:inset 1px 1px 1px #888;word-wrap:break-word;margin:12px 0;display:block;width:440px;overflow-y:scroll;height:100px;position:relative}#dg-local-explain{display:none;font-size:11px;line-height:17px;border-radius:3px;background-color:#333;padding:8px;margin-top:10px}#dg-local-explain code{font-size:10px}#dat-gui-save-locally{display:none}.dg{color:#eee;font:11px Lucida Grande,sans-serif;text-shadow:0 -1px 0 #111}.dg.main::-webkit-scrollbar{width:5px;background:#1a1a1a}.dg.main::-webkit-scrollbar-corner{height:0;display:none}.dg.main::-webkit-scrollbar-thumb{border-radius:5px;background:#676767}.dg li:not(.folder){background:#1a1a1a;border-bottom:1px solid #2c2c2c}.dg li.save-row{line-height:25px;background:#dad5cb;border:0}.dg li.save-row select{margin-left:5px;width:108px}.dg li.save-row .button{margin-left:5px;margin-top:1px;border-radius:2px;font-size:9px;line-height:7px;padding:4px 4px 5px;background:#c5bdad;color:#fff;text-shadow:0 1px 0 #b0a58f;box-shadow:0 -1px 0 #b0a58f;cursor:pointer}.dg li.save-row .button.gears{background:#c5bdad url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAsAAAANCAYAAAB/9ZQ7AAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAQJJREFUeNpiYKAU/P//PwGIC/ApCABiBSAW+I8AClAcgKxQ4T9hoMAEUrxx2QSGN6+egDX+/vWT4e7N82AMYoPAx/evwWoYoSYbACX2s7KxCxzcsezDh3evFoDEBYTEEqycggWAzA9AuUSQQgeYPa9fPv6/YWm/Acx5IPb7ty/fw+QZblw67vDs8R0YHyQhgObx+yAJkBqmG5dPPDh1aPOGR/eugW0G4vlIoTIfyFcA+QekhhHJhPdQxbiAIguMBTQZrPD7108M6roWYDFQiIAAv6Aow/1bFwXgis+f2LUAynwoIaNcz8XNx3Dl7MEJUDGQpx9gtQ8YCueB+D26OECAAQDadt7e46D42QAAAABJRU5ErkJggg==) 2px 1px no-repeat;height:7px;width:8px}.dg li.save-row .button:hover{background-color:#bab19e;box-shadow:0 -1px 0 #b0a58f}.dg li.folder{border-bottom:0}.dg li.title{padding-left:16px;background:#000 url(data:image/gif;base64,R0lGODlhBQAFAJEAAP////Pz8////////yH5BAEAAAIALAAAAAAFAAUAAAIIlI+hKgFxoCgAOw==) 6px 10px no-repeat;cursor:pointer;border-bottom:1px solid hsla(0,0%,100%,.2)}.dg .closed li.title{background-image:url(data:image/gif;base64,R0lGODlhBQAFAJEAAP////Pz8////////yH5BAEAAAIALAAAAAAFAAUAAAIIlGIWqMCbWAEAOw==)}.dg .cr.boolean{border-left:3px solid #806787}.dg .cr.color{border-left:3px solid}.dg .cr.function{border-left:3px solid #e61d5f}.dg .cr.number{border-left:3px solid #2fa1d6}.dg .cr.number input[type=text]{color:#2fa1d6}.dg .cr.string{border-left:3px solid #1ed36f}.dg .cr.string input[type=text]{color:#1ed36f}.dg .cr.boolean:hover,.dg .cr.function:hover{background:#111}.dg .c input[type=text]{background:#303030;outline:none}.dg .c input[type=text]:hover{background:#3c3c3c}.dg .c input[type=text]:focus{background:#494949;color:#fff}.dg .c .slider{background:#303030;cursor:ew-resize}.dg .c .slider-fg{background:#2fa1d6;max-width:100%}.dg .c .slider:hover{background:#3c3c3c}.dg .c .slider:hover .slider-fg{background:#44abda}\",\"\"])},function(e,t){e.exports=function(){var e=[];return e.toString=function(){for(var e=[],t=0;t"},{"title":"","date":"2019-03-17T10:06:35.725Z","updated":"2019-03-17T10:06:35.725Z","comments":true,"path":"js/OrbitControls.js","permalink":"http://www.zcating.tk/js/OrbitControls.js","excerpt":"","text":"/** * @author qiao / https://github.com/qiao * @author mrdoob / http://mrdoob.com * @author alteredq / http://alteredqualia.com/ * @author WestLangley / http://github.com/WestLangley * @author erich666 / http://erichaines.com */ // This set of controls performs orbiting, dollying (zooming), and panning. // Unlike TrackballControls, it maintains the \"up\" direction object.up (+Y by default). // // Orbit - left mouse / touch: one-finger move // Zoom - middle mouse, or mousewheel / touch: two-finger spread or squish // Pan - right mouse, or left mouse + ctrl/meta/shiftKey, or arrow keys / touch: two-finger move THREE.OrbitControls = function ( object, domElement ) { this.object = object; this.domElement = ( domElement !== undefined ) ? domElement : document; // Set to false to disable this control this.enabled = true; // \"target\" sets the location of focus, where the object orbits around this.target = new THREE.Vector3(); // How far you can dolly in and out ( PerspectiveCamera only ) this.minDistance = 0; this.maxDistance = Infinity; // How far you can zoom in and out ( OrthographicCamera only ) this.minZoom = 0; this.maxZoom = Infinity; // How far you can orbit vertically, upper and lower limits. // Range is 0 to Math.PI radians. this.minPolarAngle = 0; // radians this.maxPolarAngle = Math.PI; // radians // How far you can orbit horizontally, upper and lower limits. // If set, must be a sub-interval of the interval [ - Math.PI, Math.PI ]. this.minAzimuthAngle = - Infinity; // radians this.maxAzimuthAngle = Infinity; // radians // Set to true to enable damping (inertia) // If damping is enabled, you must call controls.update() in your animation loop this.enableDamping = false; this.dampingFactor = 0.25; // This option actually enables dollying in and out; left as \"zoom\" for backwards compatibility. // Set to false to disable zooming this.enableZoom = true; this.zoomSpeed = 1.0; // Set to false to disable rotating this.enableRotate = true; this.rotateSpeed = 1.0; // Set to false to disable panning this.enablePan = true; this.panSpeed = 1.0; this.screenSpacePanning = false; // if true, pan in screen-space this.keyPanSpeed = 7.0; // pixels moved per arrow key push // Set to true to automatically rotate around the target // If auto-rotate is enabled, you must call controls.update() in your animation loop this.autoRotate = false; this.autoRotateSpeed = 2.0; // 30 seconds per round when fps is 60 // Set to false to disable use of the keys this.enableKeys = true; // The four arrow keys this.keys = { LEFT: 37, UP: 38, RIGHT: 39, BOTTOM: 40 }; // Mouse buttons this.mouseButtons = { LEFT: THREE.MOUSE.LEFT, MIDDLE: THREE.MOUSE.MIDDLE, RIGHT: THREE.MOUSE.RIGHT }; // for reset this.target0 = this.target.clone(); this.position0 = this.object.position.clone(); this.zoom0 = this.object.zoom; // // public methods // this.getPolarAngle = function () { return spherical.phi; }; this.getAzimuthalAngle = function () { return spherical.theta; }; this.saveState = function () { scope.target0.copy( scope.target ); scope.position0.copy( scope.object.position ); scope.zoom0 = scope.object.zoom; }; this.reset = function () { scope.target.copy( scope.target0 ); scope.object.position.copy( scope.position0 ); scope.object.zoom = scope.zoom0; scope.object.updateProjectionMatrix(); scope.dispatchEvent( changeEvent ); scope.update(); state = STATE.NONE; }; // this method is exposed, but perhaps it would be better if we can make it private... this.update = function () { var offset = new THREE.Vector3(); // so camera.up is the orbit axis var quat = new THREE.Quaternion().setFromUnitVectors( object.up, new THREE.Vector3( 0, 1, 0 ) ); var quatInverse = quat.clone().inverse(); var lastPosition = new THREE.Vector3(); var lastQuaternion = new THREE.Quaternion(); return function update() { var position = scope.object.position; offset.copy( position ).sub( scope.target ); // rotate offset to \"y-axis-is-up\" space offset.applyQuaternion( quat ); // angle from z-axis around y-axis spherical.setFromVector3( offset ); if ( scope.autoRotate && state === STATE.NONE ) { rotateLeft( getAutoRotationAngle() ); } spherical.theta += sphericalDelta.theta; spherical.phi += sphericalDelta.phi; // restrict theta to be between desired limits spherical.theta = Math.max( scope.minAzimuthAngle, Math.min( scope.maxAzimuthAngle, spherical.theta ) ); // restrict phi to be between desired limits spherical.phi = Math.max( scope.minPolarAngle, Math.min( scope.maxPolarAngle, spherical.phi ) ); spherical.makeSafe(); spherical.radius *= scale; // restrict radius to be between desired limits spherical.radius = Math.max( scope.minDistance, Math.min( scope.maxDistance, spherical.radius ) ); // move target to panned location scope.target.add( panOffset ); offset.setFromSpherical( spherical ); // rotate offset back to \"camera-up-vector-is-up\" space offset.applyQuaternion( quatInverse ); position.copy( scope.target ).add( offset ); scope.object.lookAt( scope.target ); if ( scope.enableDamping === true ) { sphericalDelta.theta *= ( 1 - scope.dampingFactor ); sphericalDelta.phi *= ( 1 - scope.dampingFactor ); panOffset.multiplyScalar( 1 - scope.dampingFactor ); } else { sphericalDelta.set( 0, 0, 0 ); panOffset.set( 0, 0, 0 ); } scale = 1; // update condition is: // min(camera displacement, camera rotation in radians)^2 > EPS // using small-angle approximation cos(x/2) = 1 - x^2 / 8 if ( zoomChanged || lastPosition.distanceToSquared( scope.object.position ) > EPS || 8 * ( 1 - lastQuaternion.dot( scope.object.quaternion ) ) > EPS ) { scope.dispatchEvent( changeEvent ); lastPosition.copy( scope.object.position ); lastQuaternion.copy( scope.object.quaternion ); zoomChanged = false; return true; } return false; }; }(); this.dispose = function () { scope.domElement.removeEventListener( 'contextmenu', onContextMenu, false ); scope.domElement.removeEventListener( 'mousedown', onMouseDown, false ); scope.domElement.removeEventListener( 'wheel', onMouseWheel, false ); scope.domElement.removeEventListener( 'touchstart', onTouchStart, false ); scope.domElement.removeEventListener( 'touchend', onTouchEnd, false ); scope.domElement.removeEventListener( 'touchmove', onTouchMove, false ); document.removeEventListener( 'mousemove', onMouseMove, false ); document.removeEventListener( 'mouseup', onMouseUp, false ); window.removeEventListener( 'keydown', onKeyDown, false ); //scope.dispatchEvent( { type: 'dispose' } ); // should this be added here? }; // // internals // var scope = this; var changeEvent = { type: 'change' }; var startEvent = { type: 'start' }; var endEvent = { type: 'end' }; var STATE = { NONE: - 1, ROTATE: 0, DOLLY: 1, PAN: 2, TOUCH_ROTATE: 3, TOUCH_DOLLY_PAN: 4 }; var state = STATE.NONE; var EPS = 0.000001; // current position in spherical coordinates var spherical = new THREE.Spherical(); var sphericalDelta = new THREE.Spherical(); var scale = 1; var panOffset = new THREE.Vector3(); var zoomChanged = false; var rotateStart = new THREE.Vector2(); var rotateEnd = new THREE.Vector2(); var rotateDelta = new THREE.Vector2(); var panStart = new THREE.Vector2(); var panEnd = new THREE.Vector2(); var panDelta = new THREE.Vector2(); var dollyStart = new THREE.Vector2(); var dollyEnd = new THREE.Vector2(); var dollyDelta = new THREE.Vector2(); function getAutoRotationAngle() { return 2 * Math.PI / 60 / 60 * scope.autoRotateSpeed; } function getZoomScale() { return Math.pow( 0.95, scope.zoomSpeed ); } function rotateLeft( angle ) { sphericalDelta.theta -= angle; } function rotateUp( angle ) { sphericalDelta.phi -= angle; } var panLeft = function () { var v = new THREE.Vector3(); return function panLeft( distance, objectMatrix ) { v.setFromMatrixColumn( objectMatrix, 0 ); // get X column of objectMatrix v.multiplyScalar( - distance ); panOffset.add( v ); }; }(); var panUp = function () { var v = new THREE.Vector3(); return function panUp( distance, objectMatrix ) { if ( scope.screenSpacePanning === true ) { v.setFromMatrixColumn( objectMatrix, 1 ); } else { v.setFromMatrixColumn( objectMatrix, 0 ); v.crossVectors( scope.object.up, v ); } v.multiplyScalar( distance ); panOffset.add( v ); }; }(); // deltaX and deltaY are in pixels; right and down are positive var pan = function () { var offset = new THREE.Vector3(); return function pan( deltaX, deltaY ) { var element = scope.domElement === document ? scope.domElement.body : scope.domElement; if ( scope.object.isPerspectiveCamera ) { // perspective var position = scope.object.position; offset.copy( position ).sub( scope.target ); var targetDistance = offset.length(); // half of the fov is center to top of screen targetDistance *= Math.tan( ( scope.object.fov / 2 ) * Math.PI / 180.0 ); // we use only clientHeight here so aspect ratio does not distort speed panLeft( 2 * deltaX * targetDistance / element.clientHeight, scope.object.matrix ); panUp( 2 * deltaY * targetDistance / element.clientHeight, scope.object.matrix ); } else if ( scope.object.isOrthographicCamera ) { // orthographic panLeft( deltaX * ( scope.object.right - scope.object.left ) / scope.object.zoom / element.clientWidth, scope.object.matrix ); panUp( deltaY * ( scope.object.top - scope.object.bottom ) / scope.object.zoom / element.clientHeight, scope.object.matrix ); } else { // camera neither orthographic nor perspective console.warn( 'WARNING: OrbitControls.js encountered an unknown camera type - pan disabled.' ); scope.enablePan = false; } }; }(); function dollyIn( dollyScale ) { if ( scope.object.isPerspectiveCamera ) { scale /= dollyScale; } else if ( scope.object.isOrthographicCamera ) { scope.object.zoom = Math.max( scope.minZoom, Math.min( scope.maxZoom, scope.object.zoom * dollyScale ) ); scope.object.updateProjectionMatrix(); zoomChanged = true; } else { console.warn( 'WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled.' ); scope.enableZoom = false; } } function dollyOut( dollyScale ) { if ( scope.object.isPerspectiveCamera ) { scale *= dollyScale; } else if ( scope.object.isOrthographicCamera ) { scope.object.zoom = Math.max( scope.minZoom, Math.min( scope.maxZoom, scope.object.zoom / dollyScale ) ); scope.object.updateProjectionMatrix(); zoomChanged = true; } else { console.warn( 'WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled.' ); scope.enableZoom = false; } } // // event callbacks - update the object state // function handleMouseDownRotate( event ) { //console.log( 'handleMouseDownRotate' ); rotateStart.set( event.clientX, event.clientY ); } function handleMouseDownDolly( event ) { //console.log( 'handleMouseDownDolly' ); dollyStart.set( event.clientX, event.clientY ); } function handleMouseDownPan( event ) { //console.log( 'handleMouseDownPan' ); panStart.set( event.clientX, event.clientY ); } function handleMouseMoveRotate( event ) { //console.log( 'handleMouseMoveRotate' ); rotateEnd.set( event.clientX, event.clientY ); rotateDelta.subVectors( rotateEnd, rotateStart ).multiplyScalar( scope.rotateSpeed ); var element = scope.domElement === document ? scope.domElement.body : scope.domElement; rotateLeft( 2 * Math.PI * rotateDelta.x / element.clientHeight ); // yes, height rotateUp( 2 * Math.PI * rotateDelta.y / element.clientHeight ); rotateStart.copy( rotateEnd ); scope.update(); } function handleMouseMoveDolly( event ) { //console.log( 'handleMouseMoveDolly' ); dollyEnd.set( event.clientX, event.clientY ); dollyDelta.subVectors( dollyEnd, dollyStart ); if ( dollyDelta.y > 0 ) { dollyIn( getZoomScale() ); } else if ( dollyDelta.y < 0 ) { dollyOut( getZoomScale() ); } dollyStart.copy( dollyEnd ); scope.update(); } function handleMouseMovePan( event ) { //console.log( 'handleMouseMovePan' ); panEnd.set( event.clientX, event.clientY ); panDelta.subVectors( panEnd, panStart ).multiplyScalar( scope.panSpeed ); pan( panDelta.x, panDelta.y ); panStart.copy( panEnd ); scope.update(); } function handleMouseUp( event ) { // console.log( 'handleMouseUp' ); } function handleMouseWheel( event ) { // console.log( 'handleMouseWheel' ); if ( event.deltaY < 0 ) { dollyOut( getZoomScale() ); } else if ( event.deltaY > 0 ) { dollyIn( getZoomScale() ); } scope.update(); } function handleKeyDown( event ) { // console.log( 'handleKeyDown' ); var needsUpdate = false; switch ( event.keyCode ) { case scope.keys.UP: pan( 0, scope.keyPanSpeed ); needsUpdate = true; break; case scope.keys.BOTTOM: pan( 0, - scope.keyPanSpeed ); needsUpdate = true; break; case scope.keys.LEFT: pan( scope.keyPanSpeed, 0 ); needsUpdate = true; break; case scope.keys.RIGHT: pan( - scope.keyPanSpeed, 0 ); needsUpdate = true; break; } if ( needsUpdate ) { // prevent the browser from scrolling on cursor keys event.preventDefault(); scope.update(); } } function handleTouchStartRotate( event ) { //console.log( 'handleTouchStartRotate' ); rotateStart.set( event.touches[ 0 ].pageX, event.touches[ 0 ].pageY ); } function handleTouchStartDollyPan( event ) { //console.log( 'handleTouchStartDollyPan' ); if ( scope.enableZoom ) { var dx = event.touches[ 0 ].pageX - event.touches[ 1 ].pageX; var dy = event.touches[ 0 ].pageY - event.touches[ 1 ].pageY; var distance = Math.sqrt( dx * dx + dy * dy ); dollyStart.set( 0, distance ); } if ( scope.enablePan ) { var x = 0.5 * ( event.touches[ 0 ].pageX + event.touches[ 1 ].pageX ); var y = 0.5 * ( event.touches[ 0 ].pageY + event.touches[ 1 ].pageY ); panStart.set( x, y ); } } function handleTouchMoveRotate( event ) { //console.log( 'handleTouchMoveRotate' ); rotateEnd.set( event.touches[ 0 ].pageX, event.touches[ 0 ].pageY ); rotateDelta.subVectors( rotateEnd, rotateStart ).multiplyScalar( scope.rotateSpeed ); var element = scope.domElement === document ? scope.domElement.body : scope.domElement; rotateLeft( 2 * Math.PI * rotateDelta.x / element.clientHeight ); // yes, height rotateUp( 2 * Math.PI * rotateDelta.y / element.clientHeight ); rotateStart.copy( rotateEnd ); scope.update(); } function handleTouchMoveDollyPan( event ) { //console.log( 'handleTouchMoveDollyPan' ); if ( scope.enableZoom ) { var dx = event.touches[ 0 ].pageX - event.touches[ 1 ].pageX; var dy = event.touches[ 0 ].pageY - event.touches[ 1 ].pageY; var distance = Math.sqrt( dx * dx + dy * dy ); dollyEnd.set( 0, distance ); dollyDelta.set( 0, Math.pow( dollyEnd.y / dollyStart.y, scope.zoomSpeed ) ); dollyIn( dollyDelta.y ); dollyStart.copy( dollyEnd ); } if ( scope.enablePan ) { var x = 0.5 * ( event.touches[ 0 ].pageX + event.touches[ 1 ].pageX ); var y = 0.5 * ( event.touches[ 0 ].pageY + event.touches[ 1 ].pageY ); panEnd.set( x, y ); panDelta.subVectors( panEnd, panStart ).multiplyScalar( scope.panSpeed ); pan( panDelta.x, panDelta.y ); panStart.copy( panEnd ); } scope.update(); } function handleTouchEnd( event ) { //console.log( 'handleTouchEnd' ); } // // event handlers - FSM: listen for events and reset state // function onMouseDown( event ) { if ( scope.enabled === false ) return; // Prevent the browser from scrolling. event.preventDefault(); // Manually set the focus since calling preventDefault above // prevents the browser from setting it automatically. scope.domElement.focus ? scope.domElement.focus() : window.focus(); switch ( event.button ) { case scope.mouseButtons.LEFT: if ( event.ctrlKey || event.metaKey || event.shiftKey ) { if ( scope.enablePan === false ) return; handleMouseDownPan( event ); state = STATE.PAN; } else { if ( scope.enableRotate === false ) return; handleMouseDownRotate( event ); state = STATE.ROTATE; } break; case scope.mouseButtons.MIDDLE: if ( scope.enableZoom === false ) return; handleMouseDownDolly( event ); state = STATE.DOLLY; break; case scope.mouseButtons.RIGHT: if ( scope.enablePan === false ) return; handleMouseDownPan( event ); state = STATE.PAN; break; } if ( state !== STATE.NONE ) { document.addEventListener( 'mousemove', onMouseMove, false ); document.addEventListener( 'mouseup', onMouseUp, false ); scope.dispatchEvent( startEvent ); } } function onMouseMove( event ) { if ( scope.enabled === false ) return; event.preventDefault(); switch ( state ) { case STATE.ROTATE: if ( scope.enableRotate === false ) return; handleMouseMoveRotate( event ); break; case STATE.DOLLY: if ( scope.enableZoom === false ) return; handleMouseMoveDolly( event ); break; case STATE.PAN: if ( scope.enablePan === false ) return; handleMouseMovePan( event ); break; } } function onMouseUp( event ) { if ( scope.enabled === false ) return; handleMouseUp( event ); document.removeEventListener( 'mousemove', onMouseMove, false ); document.removeEventListener( 'mouseup', onMouseUp, false ); scope.dispatchEvent( endEvent ); state = STATE.NONE; } function onMouseWheel( event ) { if ( scope.enabled === false || scope.enableZoom === false || ( state !== STATE.NONE && state !== STATE.ROTATE ) ) return; event.preventDefault(); event.stopPropagation(); scope.dispatchEvent( startEvent ); handleMouseWheel( event ); scope.dispatchEvent( endEvent ); } function onKeyDown( event ) { if ( scope.enabled === false || scope.enableKeys === false || scope.enablePan === false ) return; handleKeyDown( event ); } function onTouchStart( event ) { if ( scope.enabled === false ) return; event.preventDefault(); switch ( event.touches.length ) { case 1: // one-fingered touch: rotate if ( scope.enableRotate === false ) return; handleTouchStartRotate( event ); state = STATE.TOUCH_ROTATE; break; case 2: // two-fingered touch: dolly-pan if ( scope.enableZoom === false && scope.enablePan === false ) return; handleTouchStartDollyPan( event ); state = STATE.TOUCH_DOLLY_PAN; break; default: state = STATE.NONE; } if ( state !== STATE.NONE ) { scope.dispatchEvent( startEvent ); } } function onTouchMove( event ) { if ( scope.enabled === false ) return; event.preventDefault(); event.stopPropagation(); switch ( event.touches.length ) { case 1: // one-fingered touch: rotate if ( scope.enableRotate === false ) return; if ( state !== STATE.TOUCH_ROTATE ) return; // is this needed? handleTouchMoveRotate( event ); break; case 2: // two-fingered touch: dolly-pan if ( scope.enableZoom === false && scope.enablePan === false ) return; if ( state !== STATE.TOUCH_DOLLY_PAN ) return; // is this needed? handleTouchMoveDollyPan( event ); break; default: state = STATE.NONE; } } function onTouchEnd( event ) { if ( scope.enabled === false ) return; handleTouchEnd( event ); scope.dispatchEvent( endEvent ); state = STATE.NONE; } function onContextMenu( event ) { if ( scope.enabled === false ) return; event.preventDefault(); } // scope.domElement.addEventListener( 'contextmenu', onContextMenu, false ); scope.domElement.addEventListener( 'mousedown', onMouseDown, false ); scope.domElement.addEventListener( 'wheel', onMouseWheel, false ); scope.domElement.addEventListener( 'touchstart', onTouchStart, false ); scope.domElement.addEventListener( 'touchend', onTouchEnd, false ); scope.domElement.addEventListener( 'touchmove', onTouchMove, false ); window.addEventListener( 'keydown', onKeyDown, false ); // force an update at start this.update(); }; THREE.OrbitControls.prototype = Object.create( THREE.EventDispatcher.prototype ); THREE.OrbitControls.prototype.constructor = THREE.OrbitControls; Object.defineProperties( THREE.OrbitControls.prototype, { center: { get: function () { console.warn( 'THREE.OrbitControls: .center has been renamed to .target' ); return this.target; } }, // backward compatibility noZoom: { get: function () { console.warn( 'THREE.OrbitControls: .noZoom has been deprecated. Use .enableZoom instead.' ); return ! this.enableZoom; }, set: function ( value ) { console.warn( 'THREE.OrbitControls: .noZoom has been deprecated. Use .enableZoom instead.' ); this.enableZoom = ! value; } }, noRotate: { get: function () { console.warn( 'THREE.OrbitControls: .noRotate has been deprecated. Use .enableRotate instead.' ); return ! this.enableRotate; }, set: function ( value ) { console.warn( 'THREE.OrbitControls: .noRotate has been deprecated. Use .enableRotate instead.' ); this.enableRotate = ! value; } }, noPan: { get: function () { console.warn( 'THREE.OrbitControls: .noPan has been deprecated. Use .enablePan instead.' ); return ! this.enablePan; }, set: function ( value ) { console.warn( 'THREE.OrbitControls: .noPan has been deprecated. Use .enablePan instead.' ); this.enablePan = ! value; } }, noKeys: { get: function () { console.warn( 'THREE.OrbitControls: .noKeys has been deprecated. Use .enableKeys instead.' ); return ! this.enableKeys; }, set: function ( value ) { console.warn( 'THREE.OrbitControls: .noKeys has been deprecated. Use .enableKeys instead.' ); this.enableKeys = ! value; } }, staticMoving: { get: function () { console.warn( 'THREE.OrbitControls: .staticMoving has been deprecated. Use .enableDamping instead.' ); return ! this.enableDamping; }, set: function ( value ) { console.warn( 'THREE.OrbitControls: .staticMoving has been deprecated. Use .enableDamping instead.' ); this.enableDamping = ! value; } }, dynamicDampingFactor: { get: function () { console.warn( 'THREE.OrbitControls: .dynamicDampingFactor has been renamed. Use .dampingFactor instead.' ); return this.dampingFactor; }, set: function ( value ) { console.warn( 'THREE.OrbitControls: .dynamicDampingFactor has been renamed. Use .dampingFactor instead.' ); this.dampingFactor = value; } } } );"},{"title":"","date":"2019-03-17T10:06:35.726Z","updated":"2019-03-17T10:06:35.726Z","comments":true,"path":"js/stats.min.js","permalink":"http://www.zcating.tk/js/stats.min.js","excerpt":"","text":"// stats.js - http://github.com/mrdoob/stats.js var Stats=function(){function h(a){c.appendChild(a.dom);return a}function k(a){for(var d=0;de+1E3&&(r.update(1E3*a/(c-e),100),e=c,a=0,t)){var d=performance.memory;t.update(d.usedJSHeapSize/1048576,d.jsHeapSizeLimit/1048576)}return c},update:function(){g=this.end()},domElement:c,setMode:k}}; Stats.Panel=function(h,k,l){var c=Infinity,g=0,e=Math.round,a=e(window.devicePixelRatio||1),r=80*a,f=48*a,t=3*a,u=2*a,d=3*a,m=15*a,n=74*a,p=30*a,q=document.createElement(\"canvas\");q.width=r;q.height=f;q.style.cssText=\"width:80px;height:48px\";var b=q.getContext(\"2d\");b.font=\"bold \"+9*a+\"px Helvetica,Arial,sans-serif\";b.textBaseline=\"top\";b.fillStyle=l;b.fillRect(0,0,r,f);b.fillStyle=k;b.fillText(h,t,u);b.fillRect(d,m,n,p);b.fillStyle=l;b.globalAlpha=.9;b.fillRect(d,m,n,p);return{dom:q,update:function(f, v){c=Math.min(c,f);g=Math.max(g,f);b.fillStyle=l;b.globalAlpha=1;b.fillRect(0,0,r,m);b.fillStyle=k;b.fillText(e(f)+\" \"+h+\" (\"+e(c)+\"-\"+e(g)+\")\",t,u);b.drawImage(q,d+a,m,n-a,p,d,m,n-a,p);b.fillRect(d+n-a,m,a,p);b.fillStyle=l;b.globalAlpha=.9;b.fillRect(d+n-a,m,a,e((1-f/v)*p))}}};\"object\"===typeof module&&(module.exports=Stats);"},{"title":"","date":"2019-03-17T10:06:35.725Z","updated":"2019-03-17T10:06:35.725Z","comments":true,"path":"js/GLTFLoader.js","permalink":"http://www.zcating.tk/js/GLTFLoader.js","excerpt":"","text":"/** * @author Rich Tibbett / https://github.com/richtr * @author mrdoob / http://mrdoob.com/ * @author Tony Parisi / http://www.tonyparisi.com/ * @author Takahiro / https://github.com/takahirox * @author Don McCurdy / https://www.donmccurdy.com */ THREE.GLTFLoader = ( function () { function GLTFLoader( manager ) { this.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager; this.dracoLoader = null; } GLTFLoader.prototype = { constructor: GLTFLoader, crossOrigin: 'anonymous', load: function ( url, onLoad, onProgress, onError ) { var scope = this; var resourcePath; if ( this.resourcePath !== undefined ) { resourcePath = this.resourcePath; } else if ( this.path !== undefined ) { resourcePath = this.path; } else { resourcePath = THREE.LoaderUtils.extractUrlBase( url ); } // Tells the LoadingManager to track an extra item, which resolves after // the model is fully loaded. This means the count of items loaded will // be incorrect, but ensures manager.onLoad() does not fire early. scope.manager.itemStart( url ); var _onError = function ( e ) { if ( onError ) { onError( e ); } else { console.error( e ); } scope.manager.itemError( url ); scope.manager.itemEnd( url ); }; var loader = new THREE.FileLoader( scope.manager ); loader.setPath( this.path ); loader.setResponseType( 'arraybuffer' ); loader.load( url, function ( data ) { try { scope.parse( data, resourcePath, function ( gltf ) { onLoad( gltf ); scope.manager.itemEnd( url ); }, _onError ); } catch ( e ) { _onError( e ); } }, onProgress, _onError ); }, setCrossOrigin: function ( value ) { this.crossOrigin = value; return this; }, setPath: function ( value ) { this.path = value; return this; }, setResourcePath: function ( value ) { this.resourcePath = value; return this; }, setDRACOLoader: function ( dracoLoader ) { this.dracoLoader = dracoLoader; return this; }, parse: function ( data, path, onLoad, onError ) { var content; var extensions = {}; if ( typeof data === 'string' ) { content = data; } else { var magic = THREE.LoaderUtils.decodeText( new Uint8Array( data, 0, 4 ) ); if ( magic === BINARY_EXTENSION_HEADER_MAGIC ) { try { extensions[ EXTENSIONS.KHR_BINARY_GLTF ] = new GLTFBinaryExtension( data ); } catch ( error ) { if ( onError ) onError( error ); return; } content = extensions[ EXTENSIONS.KHR_BINARY_GLTF ].content; } else { content = THREE.LoaderUtils.decodeText( new Uint8Array( data ) ); } } var json = JSON.parse( content ); if ( json.asset === undefined || json.asset.version[ 0 ] < 2 ) { if ( onError ) onError( new Error( 'THREE.GLTFLoader: Unsupported asset. glTF versions >=2.0 are supported. Use LegacyGLTFLoader instead.' ) ); return; } if ( json.extensionsUsed ) { for ( var i = 0; i < json.extensionsUsed.length; ++ i ) { var extensionName = json.extensionsUsed[ i ]; var extensionsRequired = json.extensionsRequired || []; switch ( extensionName ) { case EXTENSIONS.KHR_LIGHTS_PUNCTUAL: extensions[ extensionName ] = new GLTFLightsExtension( json ); break; case EXTENSIONS.KHR_MATERIALS_UNLIT: extensions[ extensionName ] = new GLTFMaterialsUnlitExtension( json ); break; case EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS: extensions[ extensionName ] = new GLTFMaterialsPbrSpecularGlossinessExtension( json ); break; case EXTENSIONS.KHR_DRACO_MESH_COMPRESSION: extensions[ extensionName ] = new GLTFDracoMeshCompressionExtension( json, this.dracoLoader ); break; case EXTENSIONS.MSFT_TEXTURE_DDS: extensions[ EXTENSIONS.MSFT_TEXTURE_DDS ] = new GLTFTextureDDSExtension( json ); break; case EXTENSIONS.KHR_TEXTURE_TRANSFORM: extensions[ EXTENSIONS.KHR_TEXTURE_TRANSFORM ] = new GLTFTextureTransformExtension( json ); break; default: if ( extensionsRequired.indexOf( extensionName ) >= 0 ) { console.warn( 'THREE.GLTFLoader: Unknown extension \"' + extensionName + '\".' ); } } } } var parser = new GLTFParser( json, extensions, { path: path || this.resourcePath || '', crossOrigin: this.crossOrigin, manager: this.manager } ); parser.parse( function ( scene, scenes, cameras, animations, json ) { var glTF = { scene: scene, scenes: scenes, cameras: cameras, animations: animations, asset: json.asset, parser: parser, userData: {} }; addUnknownExtensionsToUserData( extensions, glTF, json ); onLoad( glTF ); }, onError ); } }; /* GLTFREGISTRY */ function GLTFRegistry() { var objects = {}; return { get: function ( key ) { return objects[ key ]; }, add: function ( key, object ) { objects[ key ] = object; }, remove: function ( key ) { delete objects[ key ]; }, removeAll: function () { objects = {}; } }; } /*********************************/ /********** EXTENSIONS ***********/ /*********************************/ var EXTENSIONS = { KHR_BINARY_GLTF: 'KHR_binary_glTF', KHR_DRACO_MESH_COMPRESSION: 'KHR_draco_mesh_compression', KHR_LIGHTS_PUNCTUAL: 'KHR_lights_punctual', KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS: 'KHR_materials_pbrSpecularGlossiness', KHR_MATERIALS_UNLIT: 'KHR_materials_unlit', KHR_TEXTURE_TRANSFORM: 'KHR_texture_transform', MSFT_TEXTURE_DDS: 'MSFT_texture_dds' }; /** * DDS Texture Extension * * Specification: * https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Vendor/MSFT_texture_dds * */ function GLTFTextureDDSExtension() { if ( ! THREE.DDSLoader ) { throw new Error( 'THREE.GLTFLoader: Attempting to load .dds texture without importing THREE.DDSLoader' ); } this.name = EXTENSIONS.MSFT_TEXTURE_DDS; this.ddsLoader = new THREE.DDSLoader(); } /** * Lights Extension * * Specification: PENDING */ function GLTFLightsExtension( json ) { this.name = EXTENSIONS.KHR_LIGHTS_PUNCTUAL; var extension = ( json.extensions && json.extensions[ EXTENSIONS.KHR_LIGHTS_PUNCTUAL ] ) || {}; this.lightDefs = extension.lights || []; } GLTFLightsExtension.prototype.loadLight = function ( lightIndex ) { var lightDef = this.lightDefs[ lightIndex ]; var lightNode; var color = new THREE.Color( 0xffffff ); if ( lightDef.color !== undefined ) color.fromArray( lightDef.color ); var range = lightDef.range !== undefined ? lightDef.range : 0; switch ( lightDef.type ) { case 'directional': lightNode = new THREE.DirectionalLight( color ); lightNode.target.position.set( 0, 0, - 1 ); lightNode.add( lightNode.target ); break; case 'point': lightNode = new THREE.PointLight( color ); lightNode.distance = range; break; case 'spot': lightNode = new THREE.SpotLight( color ); lightNode.distance = range; // Handle spotlight properties. lightDef.spot = lightDef.spot || {}; lightDef.spot.innerConeAngle = lightDef.spot.innerConeAngle !== undefined ? lightDef.spot.innerConeAngle : 0; lightDef.spot.outerConeAngle = lightDef.spot.outerConeAngle !== undefined ? lightDef.spot.outerConeAngle : Math.PI / 4.0; lightNode.angle = lightDef.spot.outerConeAngle; lightNode.penumbra = 1.0 - lightDef.spot.innerConeAngle / lightDef.spot.outerConeAngle; lightNode.target.position.set( 0, 0, - 1 ); lightNode.add( lightNode.target ); break; default: throw new Error( 'THREE.GLTFLoader: Unexpected light type, \"' + lightDef.type + '\".' ); } // Some lights (e.g. spot) default to a position other than the origin. Reset the position // here, because node-level parsing will only override position if explicitly specified. lightNode.position.set( 0, 0, 0 ); lightNode.decay = 2; if ( lightDef.intensity !== undefined ) lightNode.intensity = lightDef.intensity; lightNode.name = lightDef.name || ( 'light_' + lightIndex ); return Promise.resolve( lightNode ); }; /** * Unlit Materials Extension (pending) * * PR: https://github.com/KhronosGroup/glTF/pull/1163 */ function GLTFMaterialsUnlitExtension( json ) { this.name = EXTENSIONS.KHR_MATERIALS_UNLIT; } GLTFMaterialsUnlitExtension.prototype.getMaterialType = function ( material ) { return THREE.MeshBasicMaterial; }; GLTFMaterialsUnlitExtension.prototype.extendParams = function ( materialParams, material, parser ) { var pending = []; materialParams.color = new THREE.Color( 1.0, 1.0, 1.0 ); materialParams.opacity = 1.0; var metallicRoughness = material.pbrMetallicRoughness; if ( metallicRoughness ) { if ( Array.isArray( metallicRoughness.baseColorFactor ) ) { var array = metallicRoughness.baseColorFactor; materialParams.color.fromArray( array ); materialParams.opacity = array[ 3 ]; } if ( metallicRoughness.baseColorTexture !== undefined ) { pending.push( parser.assignTexture( materialParams, 'map', metallicRoughness.baseColorTexture ) ); } } return Promise.all( pending ); }; /* BINARY EXTENSION */ var BINARY_EXTENSION_BUFFER_NAME = 'binary_glTF'; var BINARY_EXTENSION_HEADER_MAGIC = 'glTF'; var BINARY_EXTENSION_HEADER_LENGTH = 12; var BINARY_EXTENSION_CHUNK_TYPES = { JSON: 0x4E4F534A, BIN: 0x004E4942 }; function GLTFBinaryExtension( data ) { this.name = EXTENSIONS.KHR_BINARY_GLTF; this.content = null; this.body = null; var headerView = new DataView( data, 0, BINARY_EXTENSION_HEADER_LENGTH ); this.header = { magic: THREE.LoaderUtils.decodeText( new Uint8Array( data.slice( 0, 4 ) ) ), version: headerView.getUint32( 4, true ), length: headerView.getUint32( 8, true ) }; if ( this.header.magic !== BINARY_EXTENSION_HEADER_MAGIC ) { throw new Error( 'THREE.GLTFLoader: Unsupported glTF-Binary header.' ); } else if ( this.header.version < 2.0 ) { throw new Error( 'THREE.GLTFLoader: Legacy binary file detected. Use LegacyGLTFLoader instead.' ); } var chunkView = new DataView( data, BINARY_EXTENSION_HEADER_LENGTH ); var chunkIndex = 0; while ( chunkIndex < chunkView.byteLength ) { var chunkLength = chunkView.getUint32( chunkIndex, true ); chunkIndex += 4; var chunkType = chunkView.getUint32( chunkIndex, true ); chunkIndex += 4; if ( chunkType === BINARY_EXTENSION_CHUNK_TYPES.JSON ) { var contentArray = new Uint8Array( data, BINARY_EXTENSION_HEADER_LENGTH + chunkIndex, chunkLength ); this.content = THREE.LoaderUtils.decodeText( contentArray ); } else if ( chunkType === BINARY_EXTENSION_CHUNK_TYPES.BIN ) { var byteOffset = BINARY_EXTENSION_HEADER_LENGTH + chunkIndex; this.body = data.slice( byteOffset, byteOffset + chunkLength ); } // Clients must ignore chunks with unknown types. chunkIndex += chunkLength; } if ( this.content === null ) { throw new Error( 'THREE.GLTFLoader: JSON content not found.' ); } } /** * DRACO Mesh Compression Extension * * Specification: https://github.com/KhronosGroup/glTF/pull/874 */ function GLTFDracoMeshCompressionExtension( json, dracoLoader ) { if ( ! dracoLoader ) { throw new Error( 'THREE.GLTFLoader: No DRACOLoader instance provided.' ); } this.name = EXTENSIONS.KHR_DRACO_MESH_COMPRESSION; this.json = json; this.dracoLoader = dracoLoader; THREE.DRACOLoader.getDecoderModule(); } GLTFDracoMeshCompressionExtension.prototype.decodePrimitive = function ( primitive, parser ) { var json = this.json; var dracoLoader = this.dracoLoader; var bufferViewIndex = primitive.extensions[ this.name ].bufferView; var gltfAttributeMap = primitive.extensions[ this.name ].attributes; var threeAttributeMap = {}; var attributeNormalizedMap = {}; var attributeTypeMap = {}; for ( var attributeName in gltfAttributeMap ) { if ( ! ( attributeName in ATTRIBUTES ) ) continue; threeAttributeMap[ ATTRIBUTES[ attributeName ] ] = gltfAttributeMap[ attributeName ]; } for ( attributeName in primitive.attributes ) { if ( ATTRIBUTES[ attributeName ] !== undefined && gltfAttributeMap[ attributeName ] !== undefined ) { var accessorDef = json.accessors[ primitive.attributes[ attributeName ] ]; var componentType = WEBGL_COMPONENT_TYPES[ accessorDef.componentType ]; attributeTypeMap[ ATTRIBUTES[ attributeName ] ] = componentType; attributeNormalizedMap[ ATTRIBUTES[ attributeName ] ] = accessorDef.normalized === true; } } return parser.getDependency( 'bufferView', bufferViewIndex ).then( function ( bufferView ) { return new Promise( function ( resolve ) { dracoLoader.decodeDracoFile( bufferView, function ( geometry ) { for ( var attributeName in geometry.attributes ) { var attribute = geometry.attributes[ attributeName ]; var normalized = attributeNormalizedMap[ attributeName ]; if ( normalized !== undefined ) attribute.normalized = normalized; } resolve( geometry ); }, threeAttributeMap, attributeTypeMap ); } ); } ); }; /** * Texture Transform Extension * * Specification: */ function GLTFTextureTransformExtension( json ) { this.name = EXTENSIONS.KHR_TEXTURE_TRANSFORM; } GLTFTextureTransformExtension.prototype.extendTexture = function ( texture, transform ) { texture = texture.clone(); if ( transform.offset !== undefined ) { texture.offset.fromArray( transform.offset ); } if ( transform.rotation !== undefined ) { texture.rotation = transform.rotation; } if ( transform.scale !== undefined ) { texture.repeat.fromArray( transform.scale ); } if ( transform.texCoord !== undefined ) { console.warn( 'THREE.GLTFLoader: Custom UV sets in \"' + this.name + '\" extension not yet supported.' ); } texture.needsUpdate = true; return texture; }; /** * Specular-Glossiness Extension * * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_pbrSpecularGlossiness */ function GLTFMaterialsPbrSpecularGlossinessExtension() { return { name: EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS, specularGlossinessParams: [ 'color', 'map', 'lightMap', 'lightMapIntensity', 'aoMap', 'aoMapIntensity', 'emissive', 'emissiveIntensity', 'emissiveMap', 'bumpMap', 'bumpScale', 'normalMap', 'displacementMap', 'displacementScale', 'displacementBias', 'specularMap', 'specular', 'glossinessMap', 'glossiness', 'alphaMap', 'envMap', 'envMapIntensity', 'refractionRatio', ], getMaterialType: function () { return THREE.ShaderMaterial; }, extendParams: function ( params, material, parser ) { var pbrSpecularGlossiness = material.extensions[ this.name ]; var shader = THREE.ShaderLib[ 'standard' ]; var uniforms = THREE.UniformsUtils.clone( shader.uniforms ); var specularMapParsFragmentChunk = [ '#ifdef USE_SPECULARMAP', ' uniform sampler2D specularMap;', '#endif' ].join( '\\n' ); var glossinessMapParsFragmentChunk = [ '#ifdef USE_GLOSSINESSMAP', ' uniform sampler2D glossinessMap;', '#endif' ].join( '\\n' ); var specularMapFragmentChunk = [ 'vec3 specularFactor = specular;', '#ifdef USE_SPECULARMAP', ' vec4 texelSpecular = texture2D( specularMap, vUv );', ' texelSpecular = sRGBToLinear( texelSpecular );', ' // reads channel RGB, compatible with a glTF Specular-Glossiness (RGBA) texture', ' specularFactor *= texelSpecular.rgb;', '#endif' ].join( '\\n' ); var glossinessMapFragmentChunk = [ 'float glossinessFactor = glossiness;', '#ifdef USE_GLOSSINESSMAP', ' vec4 texelGlossiness = texture2D( glossinessMap, vUv );', ' // reads channel A, compatible with a glTF Specular-Glossiness (RGBA) texture', ' glossinessFactor *= texelGlossiness.a;', '#endif' ].join( '\\n' ); var lightPhysicalFragmentChunk = [ 'PhysicalMaterial material;', 'material.diffuseColor = diffuseColor.rgb;', 'material.specularRoughness = clamp( 1.0 - glossinessFactor, 0.04, 1.0 );', 'material.specularColor = specularFactor.rgb;', ].join( '\\n' ); var fragmentShader = shader.fragmentShader .replace( 'uniform float roughness;', 'uniform vec3 specular;' ) .replace( 'uniform float metalness;', 'uniform float glossiness;' ) .replace( '#include ', specularMapParsFragmentChunk ) .replace( '#include ', glossinessMapParsFragmentChunk ) .replace( '#include ', specularMapFragmentChunk ) .replace( '#include ', glossinessMapFragmentChunk ) .replace( '#include ', lightPhysicalFragmentChunk ); delete uniforms.roughness; delete uniforms.metalness; delete uniforms.roughnessMap; delete uniforms.metalnessMap; uniforms.specular = { value: new THREE.Color().setHex( 0x111111 ) }; uniforms.glossiness = { value: 0.5 }; uniforms.specularMap = { value: null }; uniforms.glossinessMap = { value: null }; params.vertexShader = shader.vertexShader; params.fragmentShader = fragmentShader; params.uniforms = uniforms; params.defines = { 'STANDARD': '' }; params.color = new THREE.Color( 1.0, 1.0, 1.0 ); params.opacity = 1.0; var pending = []; if ( Array.isArray( pbrSpecularGlossiness.diffuseFactor ) ) { var array = pbrSpecularGlossiness.diffuseFactor; params.color.fromArray( array ); params.opacity = array[ 3 ]; } if ( pbrSpecularGlossiness.diffuseTexture !== undefined ) { pending.push( parser.assignTexture( params, 'map', pbrSpecularGlossiness.diffuseTexture ) ); } params.emissive = new THREE.Color( 0.0, 0.0, 0.0 ); params.glossiness = pbrSpecularGlossiness.glossinessFactor !== undefined ? pbrSpecularGlossiness.glossinessFactor : 1.0; params.specular = new THREE.Color( 1.0, 1.0, 1.0 ); if ( Array.isArray( pbrSpecularGlossiness.specularFactor ) ) { params.specular.fromArray( pbrSpecularGlossiness.specularFactor ); } if ( pbrSpecularGlossiness.specularGlossinessTexture !== undefined ) { var specGlossMapDef = pbrSpecularGlossiness.specularGlossinessTexture; pending.push( parser.assignTexture( params, 'glossinessMap', specGlossMapDef ) ); pending.push( parser.assignTexture( params, 'specularMap', specGlossMapDef ) ); } return Promise.all( pending ); }, createMaterial: function ( params ) { // setup material properties based on MeshStandardMaterial for Specular-Glossiness var material = new THREE.ShaderMaterial( { defines: params.defines, vertexShader: params.vertexShader, fragmentShader: params.fragmentShader, uniforms: params.uniforms, fog: true, lights: true, opacity: params.opacity, transparent: params.transparent } ); material.isGLTFSpecularGlossinessMaterial = true; material.color = params.color; material.map = params.map === undefined ? null : params.map; material.lightMap = null; material.lightMapIntensity = 1.0; material.aoMap = params.aoMap === undefined ? null : params.aoMap; material.aoMapIntensity = 1.0; material.emissive = params.emissive; material.emissiveIntensity = 1.0; material.emissiveMap = params.emissiveMap === undefined ? null : params.emissiveMap; material.bumpMap = params.bumpMap === undefined ? null : params.bumpMap; material.bumpScale = 1; material.normalMap = params.normalMap === undefined ? null : params.normalMap; if ( params.normalScale ) material.normalScale = params.normalScale; material.displacementMap = null; material.displacementScale = 1; material.displacementBias = 0; material.specularMap = params.specularMap === undefined ? null : params.specularMap; material.specular = params.specular; material.glossinessMap = params.glossinessMap === undefined ? null : params.glossinessMap; material.glossiness = params.glossiness; material.alphaMap = null; material.envMap = params.envMap === undefined ? null : params.envMap; material.envMapIntensity = 1.0; material.refractionRatio = 0.98; material.extensions.derivatives = true; return material; }, /** * Clones a GLTFSpecularGlossinessMaterial instance. The ShaderMaterial.copy() method can * copy only properties it knows about or inherits, and misses many properties that would * normally be defined by MeshStandardMaterial. * * This method allows GLTFSpecularGlossinessMaterials to be cloned in the process of * loading a glTF model, but cloning later (e.g. by the user) would require these changes * AND also updating `.onBeforeRender` on the parent mesh. * * @param {THREE.ShaderMaterial} source * @return {THREE.ShaderMaterial} */ cloneMaterial: function ( source ) { var target = source.clone(); target.isGLTFSpecularGlossinessMaterial = true; var params = this.specularGlossinessParams; for ( var i = 0, il = params.length; i < il; i ++ ) { target[ params[ i ] ] = source[ params[ i ] ]; } return target; }, // Here's based on refreshUniformsCommon() and refreshUniformsStandard() in WebGLRenderer. refreshUniforms: function ( renderer, scene, camera, geometry, material, group ) { if ( material.isGLTFSpecularGlossinessMaterial !== true ) { return; } var uniforms = material.uniforms; var defines = material.defines; uniforms.opacity.value = material.opacity; uniforms.diffuse.value.copy( material.color ); uniforms.emissive.value.copy( material.emissive ).multiplyScalar( material.emissiveIntensity ); uniforms.map.value = material.map; uniforms.specularMap.value = material.specularMap; uniforms.alphaMap.value = material.alphaMap; uniforms.lightMap.value = material.lightMap; uniforms.lightMapIntensity.value = material.lightMapIntensity; uniforms.aoMap.value = material.aoMap; uniforms.aoMapIntensity.value = material.aoMapIntensity; // uv repeat and offset setting priorities // 1. color map // 2. specular map // 3. normal map // 4. bump map // 5. alpha map // 6. emissive map var uvScaleMap; if ( material.map ) { uvScaleMap = material.map; } else if ( material.specularMap ) { uvScaleMap = material.specularMap; } else if ( material.displacementMap ) { uvScaleMap = material.displacementMap; } else if ( material.normalMap ) { uvScaleMap = material.normalMap; } else if ( material.bumpMap ) { uvScaleMap = material.bumpMap; } else if ( material.glossinessMap ) { uvScaleMap = material.glossinessMap; } else if ( material.alphaMap ) { uvScaleMap = material.alphaMap; } else if ( material.emissiveMap ) { uvScaleMap = material.emissiveMap; } if ( uvScaleMap !== undefined ) { // backwards compatibility if ( uvScaleMap.isWebGLRenderTarget ) { uvScaleMap = uvScaleMap.texture; } if ( uvScaleMap.matrixAutoUpdate === true ) { uvScaleMap.updateMatrix(); } uniforms.uvTransform.value.copy( uvScaleMap.matrix ); } if ( material.envMap ) { uniforms.envMap.value = material.envMap; uniforms.envMapIntensity.value = material.envMapIntensity; // don't flip CubeTexture envMaps, flip everything else: // WebGLRenderTargetCube will be flipped for backwards compatibility // WebGLRenderTargetCube.texture will be flipped because it's a Texture and NOT a CubeTexture // this check must be handled differently, or removed entirely, if WebGLRenderTargetCube uses a CubeTexture in the future uniforms.flipEnvMap.value = material.envMap.isCubeTexture ? - 1 : 1; uniforms.reflectivity.value = material.reflectivity; uniforms.refractionRatio.value = material.refractionRatio; uniforms.maxMipLevel.value = renderer.properties.get( material.envMap ).__maxMipLevel; } uniforms.specular.value.copy( material.specular ); uniforms.glossiness.value = material.glossiness; uniforms.glossinessMap.value = material.glossinessMap; uniforms.emissiveMap.value = material.emissiveMap; uniforms.bumpMap.value = material.bumpMap; uniforms.normalMap.value = material.normalMap; uniforms.displacementMap.value = material.displacementMap; uniforms.displacementScale.value = material.displacementScale; uniforms.displacementBias.value = material.displacementBias; if ( uniforms.glossinessMap.value !== null && defines.USE_GLOSSINESSMAP === undefined ) { defines.USE_GLOSSINESSMAP = ''; // set USE_ROUGHNESSMAP to enable vUv defines.USE_ROUGHNESSMAP = ''; } if ( uniforms.glossinessMap.value === null && defines.USE_GLOSSINESSMAP !== undefined ) { delete defines.USE_GLOSSINESSMAP; delete defines.USE_ROUGHNESSMAP; } } }; } /*********************************/ /********** INTERPOLATION ********/ /*********************************/ // Spline Interpolation // Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#appendix-c-spline-interpolation function GLTFCubicSplineInterpolant( parameterPositions, sampleValues, sampleSize, resultBuffer ) { THREE.Interpolant.call( this, parameterPositions, sampleValues, sampleSize, resultBuffer ); } GLTFCubicSplineInterpolant.prototype = Object.create( THREE.Interpolant.prototype ); GLTFCubicSplineInterpolant.prototype.constructor = GLTFCubicSplineInterpolant; GLTFCubicSplineInterpolant.prototype.copySampleValue_ = function ( index ) { // Copies a sample value to the result buffer. See description of glTF // CUBICSPLINE values layout in interpolate_() function below. var result = this.resultBuffer, values = this.sampleValues, valueSize = this.valueSize, offset = index * valueSize * 3 + valueSize; for ( var i = 0; i !== valueSize; i ++ ) { result[ i ] = values[ offset + i ]; } return result; }; GLTFCubicSplineInterpolant.prototype.beforeStart_ = GLTFCubicSplineInterpolant.prototype.copySampleValue_; GLTFCubicSplineInterpolant.prototype.afterEnd_ = GLTFCubicSplineInterpolant.prototype.copySampleValue_; GLTFCubicSplineInterpolant.prototype.interpolate_ = function ( i1, t0, t, t1 ) { var result = this.resultBuffer; var values = this.sampleValues; var stride = this.valueSize; var stride2 = stride * 2; var stride3 = stride * 3; var td = t1 - t0; var p = ( t - t0 ) / td; var pp = p * p; var ppp = pp * p; var offset1 = i1 * stride3; var offset0 = offset1 - stride3; var s2 = - 2 * ppp + 3 * pp; var s3 = ppp - pp; var s0 = 1 - s2; var s1 = s3 - pp + p; // Layout of keyframe output values for CUBICSPLINE animations: // [ inTangent_1, splineVertex_1, outTangent_1, inTangent_2, splineVertex_2, ... ] for ( var i = 0; i !== stride; i ++ ) { var p0 = values[ offset0 + i + stride ]; // splineVertex_k var m0 = values[ offset0 + i + stride2 ] * td; // outTangent_k * (t_k+1 - t_k) var p1 = values[ offset1 + i + stride ]; // splineVertex_k+1 var m1 = values[ offset1 + i ] * td; // inTangent_k+1 * (t_k+1 - t_k) result[ i ] = s0 * p0 + s1 * m0 + s2 * p1 + s3 * m1; } return result; }; /*********************************/ /********** INTERNALS ************/ /*********************************/ /* CONSTANTS */ var WEBGL_CONSTANTS = { FLOAT: 5126, //FLOAT_MAT2: 35674, FLOAT_MAT3: 35675, FLOAT_MAT4: 35676, FLOAT_VEC2: 35664, FLOAT_VEC3: 35665, FLOAT_VEC4: 35666, LINEAR: 9729, REPEAT: 10497, SAMPLER_2D: 35678, POINTS: 0, LINES: 1, LINE_LOOP: 2, LINE_STRIP: 3, TRIANGLES: 4, TRIANGLE_STRIP: 5, TRIANGLE_FAN: 6, UNSIGNED_BYTE: 5121, UNSIGNED_SHORT: 5123 }; var WEBGL_TYPE = { 5126: Number, //35674: THREE.Matrix2, 35675: THREE.Matrix3, 35676: THREE.Matrix4, 35664: THREE.Vector2, 35665: THREE.Vector3, 35666: THREE.Vector4, 35678: THREE.Texture }; var WEBGL_COMPONENT_TYPES = { 5120: Int8Array, 5121: Uint8Array, 5122: Int16Array, 5123: Uint16Array, 5125: Uint32Array, 5126: Float32Array }; var WEBGL_FILTERS = { 9728: THREE.NearestFilter, 9729: THREE.LinearFilter, 9984: THREE.NearestMipMapNearestFilter, 9985: THREE.LinearMipMapNearestFilter, 9986: THREE.NearestMipMapLinearFilter, 9987: THREE.LinearMipMapLinearFilter }; var WEBGL_WRAPPINGS = { 33071: THREE.ClampToEdgeWrapping, 33648: THREE.MirroredRepeatWrapping, 10497: THREE.RepeatWrapping }; var WEBGL_SIDES = { 1028: THREE.BackSide, // Culling front 1029: THREE.FrontSide // Culling back //1032: THREE.NoSide // Culling front and back, what to do? }; var WEBGL_DEPTH_FUNCS = { 512: THREE.NeverDepth, 513: THREE.LessDepth, 514: THREE.EqualDepth, 515: THREE.LessEqualDepth, 516: THREE.GreaterEqualDepth, 517: THREE.NotEqualDepth, 518: THREE.GreaterEqualDepth, 519: THREE.AlwaysDepth }; var WEBGL_BLEND_EQUATIONS = { 32774: THREE.AddEquation, 32778: THREE.SubtractEquation, 32779: THREE.ReverseSubtractEquation }; var WEBGL_BLEND_FUNCS = { 0: THREE.ZeroFactor, 1: THREE.OneFactor, 768: THREE.SrcColorFactor, 769: THREE.OneMinusSrcColorFactor, 770: THREE.SrcAlphaFactor, 771: THREE.OneMinusSrcAlphaFactor, 772: THREE.DstAlphaFactor, 773: THREE.OneMinusDstAlphaFactor, 774: THREE.DstColorFactor, 775: THREE.OneMinusDstColorFactor, 776: THREE.SrcAlphaSaturateFactor // The followings are not supported by Three.js yet //32769: CONSTANT_COLOR, //32770: ONE_MINUS_CONSTANT_COLOR, //32771: CONSTANT_ALPHA, //32772: ONE_MINUS_CONSTANT_COLOR }; var WEBGL_TYPE_SIZES = { 'SCALAR': 1, 'VEC2': 2, 'VEC3': 3, 'VEC4': 4, 'MAT2': 4, 'MAT3': 9, 'MAT4': 16 }; var ATTRIBUTES = { POSITION: 'position', NORMAL: 'normal', TEXCOORD_0: 'uv', TEXCOORD_1: 'uv2', COLOR_0: 'color', WEIGHTS_0: 'skinWeight', JOINTS_0: 'skinIndex', }; var PATH_PROPERTIES = { scale: 'scale', translation: 'position', rotation: 'quaternion', weights: 'morphTargetInfluences' }; var INTERPOLATION = { CUBICSPLINE: THREE.InterpolateSmooth, // We use custom interpolation GLTFCubicSplineInterpolation for CUBICSPLINE. // KeyframeTrack.optimize() can't handle glTF Cubic Spline output values layout, // using THREE.InterpolateSmooth for KeyframeTrack instantiation to prevent optimization. // See KeyframeTrack.optimize() for the detail. LINEAR: THREE.InterpolateLinear, STEP: THREE.InterpolateDiscrete }; var STATES_ENABLES = { 2884: 'CULL_FACE', 2929: 'DEPTH_TEST', 3042: 'BLEND', 3089: 'SCISSOR_TEST', 32823: 'POLYGON_OFFSET_FILL', 32926: 'SAMPLE_ALPHA_TO_COVERAGE' }; var ALPHA_MODES = { OPAQUE: 'OPAQUE', MASK: 'MASK', BLEND: 'BLEND' }; var MIME_TYPE_FORMATS = { 'image/png': THREE.RGBAFormat, 'image/jpeg': THREE.RGBFormat }; /* UTILITY FUNCTIONS */ function resolveURL( url, path ) { // Invalid URL if ( typeof url !== 'string' || url === '' ) return ''; // Absolute URL http://,https://,// if ( /^(https?:)?\\/\\//i.test( url ) ) return url; // Data URI if ( /^data:.*,.*$/i.test( url ) ) return url; // Blob URL if ( /^blob:.*$/i.test( url ) ) return url; // Relative URL return path + url; } /** * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#default-material */ function createDefaultMaterial() { return new THREE.MeshStandardMaterial( { color: 0xFFFFFF, emissive: 0x000000, metalness: 1, roughness: 1, transparent: false, depthTest: true, side: THREE.FrontSide } ); } function addUnknownExtensionsToUserData( knownExtensions, object, objectDef ) { // Add unknown glTF extensions to an object's userData. for ( var name in objectDef.extensions ) { if ( knownExtensions[ name ] === undefined ) { object.userData.gltfExtensions = object.userData.gltfExtensions || {}; object.userData.gltfExtensions[ name ] = objectDef.extensions[ name ]; } } } /** * @param {THREE.Object3D|THREE.Material|THREE.BufferGeometry} object * @param {GLTF.definition} gltfDef */ function assignExtrasToUserData( object, gltfDef ) { if ( gltfDef.extras !== undefined ) { if ( typeof gltfDef.extras === 'object' ) { object.userData = gltfDef.extras; } else { console.warn( 'THREE.GLTFLoader: Ignoring primitive type .extras, ' + gltfDef.extras ); } } } /** * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#morph-targets * * @param {THREE.BufferGeometry} geometry * @param {Array} targets * @param {GLTFParser} parser * @return {Promise} */ function addMorphTargets( geometry, targets, parser ) { var hasMorphPosition = false; var hasMorphNormal = false; for ( var i = 0, il = targets.length; i < il; i ++ ) { var target = targets[ i ]; if ( target.POSITION !== undefined ) hasMorphPosition = true; if ( target.NORMAL !== undefined ) hasMorphNormal = true; if ( hasMorphPosition && hasMorphNormal ) break; } if ( ! hasMorphPosition && ! hasMorphNormal ) return Promise.resolve( geometry ); var pendingPositionAccessors = []; var pendingNormalAccessors = []; for ( var i = 0, il = targets.length; i < il; i ++ ) { var target = targets[ i ]; if ( hasMorphPosition ) { // TODO: Error-prone use of a callback inside a loop. var accessor = target.POSITION !== undefined ? parser.getDependency( 'accessor', target.POSITION ) .then( function ( accessor ) { // Cloning not to pollute original accessor below return cloneBufferAttribute( accessor ); } ) : geometry.attributes.position; pendingPositionAccessors.push( accessor ); } if ( hasMorphNormal ) { // TODO: Error-prone use of a callback inside a loop. var accessor = target.NORMAL !== undefined ? parser.getDependency( 'accessor', target.NORMAL ) .then( function ( accessor ) { return cloneBufferAttribute( accessor ); } ) : geometry.attributes.normal; pendingNormalAccessors.push( accessor ); } } return Promise.all( [ Promise.all( pendingPositionAccessors ), Promise.all( pendingNormalAccessors ) ] ).then( function ( accessors ) { var morphPositions = accessors[ 0 ]; var morphNormals = accessors[ 1 ]; for ( var i = 0, il = targets.length; i < il; i ++ ) { var target = targets[ i ]; var attributeName = 'morphTarget' + i; if ( hasMorphPosition ) { // Three.js morph position is absolute value. The formula is // basePosition // + weight0 * ( morphPosition0 - basePosition ) // + weight1 * ( morphPosition1 - basePosition ) // ... // while the glTF one is relative // basePosition // + weight0 * glTFmorphPosition0 // + weight1 * glTFmorphPosition1 // ... // then we need to convert from relative to absolute here. if ( target.POSITION !== undefined ) { var positionAttribute = morphPositions[ i ]; positionAttribute.name = attributeName; var position = geometry.attributes.position; for ( var j = 0, jl = positionAttribute.count; j < jl; j ++ ) { positionAttribute.setXYZ( j, positionAttribute.getX( j ) + position.getX( j ), positionAttribute.getY( j ) + position.getY( j ), positionAttribute.getZ( j ) + position.getZ( j ) ); } } } if ( hasMorphNormal ) { // see target.POSITION's comment if ( target.NORMAL !== undefined ) { var normalAttribute = morphNormals[ i ]; normalAttribute.name = attributeName; var normal = geometry.attributes.normal; for ( var j = 0, jl = normalAttribute.count; j < jl; j ++ ) { normalAttribute.setXYZ( j, normalAttribute.getX( j ) + normal.getX( j ), normalAttribute.getY( j ) + normal.getY( j ), normalAttribute.getZ( j ) + normal.getZ( j ) ); } } } } if ( hasMorphPosition ) geometry.morphAttributes.position = morphPositions; if ( hasMorphNormal ) geometry.morphAttributes.normal = morphNormals; return geometry; } ); } /** * @param {THREE.Mesh} mesh * @param {GLTF.Mesh} meshDef */ function updateMorphTargets( mesh, meshDef ) { mesh.updateMorphTargets(); if ( meshDef.weights !== undefined ) { for ( var i = 0, il = meshDef.weights.length; i < il; i ++ ) { mesh.morphTargetInfluences[ i ] = meshDef.weights[ i ]; } } // .extras has user-defined data, so check that .extras.targetNames is an array. if ( meshDef.extras && Array.isArray( meshDef.extras.targetNames ) ) { var targetNames = meshDef.extras.targetNames; if ( mesh.morphTargetInfluences.length === targetNames.length ) { mesh.morphTargetDictionary = {}; for ( var i = 0, il = targetNames.length; i < il; i ++ ) { mesh.morphTargetDictionary[ targetNames[ i ] ] = i; } } else { console.warn( 'THREE.GLTFLoader: Invalid extras.targetNames length. Ignoring names.' ); } } } function isPrimitiveEqual( a, b ) { var dracoExtA = a.extensions ? a.extensions[ EXTENSIONS.KHR_DRACO_MESH_COMPRESSION ] : undefined; var dracoExtB = b.extensions ? b.extensions[ EXTENSIONS.KHR_DRACO_MESH_COMPRESSION ] : undefined; if ( dracoExtA && dracoExtB ) { if ( dracoExtA.bufferView !== dracoExtB.bufferView ) return false; return isObjectEqual( dracoExtA.attributes, dracoExtB.attributes ); } if ( a.indices !== b.indices ) { return false; } return isObjectEqual( a.attributes, b.attributes ); } function isObjectEqual( a, b ) { if ( Object.keys( a ).length !== Object.keys( b ).length ) return false; for ( var key in a ) { if ( a[ key ] !== b[ key ] ) return false; } return true; } function isArrayEqual( a, b ) { if ( a.length !== b.length ) return false; for ( var i = 0, il = a.length; i < il; i ++ ) { if ( a[ i ] !== b[ i ] ) return false; } return true; } function getCachedGeometry( cache, newPrimitive ) { for ( var i = 0, il = cache.length; i < il; i ++ ) { var cached = cache[ i ]; if ( isPrimitiveEqual( cached.primitive, newPrimitive ) ) return cached.promise; } return null; } function getCachedCombinedGeometry( cache, geometries ) { for ( var i = 0, il = cache.length; i < il; i ++ ) { var cached = cache[ i ]; if ( isArrayEqual( geometries, cached.baseGeometries ) ) return cached.geometry; } return null; } function getCachedMultiPassGeometry( cache, geometry, primitives ) { for ( var i = 0, il = cache.length; i < il; i ++ ) { var cached = cache[ i ]; if ( geometry === cached.baseGeometry && isArrayEqual( primitives, cached.primitives ) ) return cached.geometry; } return null; } function cloneBufferAttribute( attribute ) { if ( attribute.isInterleavedBufferAttribute ) { var count = attribute.count; var itemSize = attribute.itemSize; var array = attribute.array.slice( 0, count * itemSize ); for ( var i = 0, j = 0; i < count; ++ i ) { array[ j ++ ] = attribute.getX( i ); if ( itemSize >= 2 ) array[ j ++ ] = attribute.getY( i ); if ( itemSize >= 3 ) array[ j ++ ] = attribute.getZ( i ); if ( itemSize >= 4 ) array[ j ++ ] = attribute.getW( i ); } return new THREE.BufferAttribute( array, itemSize, attribute.normalized ); } return attribute.clone(); } /** * Checks if we can build a single Mesh with MultiMaterial from multiple primitives. * Returns true if all primitives use the same attributes/morphAttributes/mode * and also have index. Otherwise returns false. * * @param {Array} primitives * @return {Boolean} */ function isMultiPassGeometry( primitives ) { if ( primitives.length < 2 ) return false; var primitive0 = primitives[ 0 ]; var targets0 = primitive0.targets || []; if ( primitive0.indices === undefined ) return false; for ( var i = 1, il = primitives.length; i < il; i ++ ) { var primitive = primitives[ i ]; if ( primitive0.mode !== primitive.mode ) return false; if ( primitive.indices === undefined ) return false; if ( primitive.extensions && primitive.extensions[ EXTENSIONS.KHR_DRACO_MESH_COMPRESSION ] ) return false; if ( ! isObjectEqual( primitive0.attributes, primitive.attributes ) ) return false; var targets = primitive.targets || []; if ( targets0.length !== targets.length ) return false; for ( var j = 0, jl = targets0.length; j < jl; j ++ ) { if ( ! isObjectEqual( targets0[ j ], targets[ j ] ) ) return false; } } return true; } /* GLTF PARSER */ function GLTFParser( json, extensions, options ) { this.json = json || {}; this.extensions = extensions || {}; this.options = options || {}; // loader object cache this.cache = new GLTFRegistry(); // BufferGeometry caching this.primitiveCache = []; this.multiplePrimitivesCache = []; this.multiPassGeometryCache = []; this.textureLoader = new THREE.TextureLoader( this.options.manager ); this.textureLoader.setCrossOrigin( this.options.crossOrigin ); this.fileLoader = new THREE.FileLoader( this.options.manager ); this.fileLoader.setResponseType( 'arraybuffer' ); } GLTFParser.prototype.parse = function ( onLoad, onError ) { var json = this.json; // Clear the loader cache this.cache.removeAll(); // Mark the special nodes/meshes in json for efficient parse this.markDefs(); // Fire the callback on complete this.getMultiDependencies( [ 'scene', 'animation', 'camera' ] ).then( function ( dependencies ) { var scenes = dependencies.scenes || []; var scene = scenes[ json.scene || 0 ]; var animations = dependencies.animations || []; var cameras = dependencies.cameras || []; onLoad( scene, scenes, cameras, animations, json ); } ).catch( onError ); }; /** * Marks the special nodes/meshes in json for efficient parse. */ GLTFParser.prototype.markDefs = function () { var nodeDefs = this.json.nodes || []; var skinDefs = this.json.skins || []; var meshDefs = this.json.meshes || []; var meshReferences = {}; var meshUses = {}; // Nothing in the node definition indicates whether it is a Bone or an // Object3D. Use the skins' joint references to mark bones. for ( var skinIndex = 0, skinLength = skinDefs.length; skinIndex < skinLength; skinIndex ++ ) { var joints = skinDefs[ skinIndex ].joints; for ( var i = 0, il = joints.length; i < il; i ++ ) { nodeDefs[ joints[ i ] ].isBone = true; } } // Meshes can (and should) be reused by multiple nodes in a glTF asset. To // avoid having more than one THREE.Mesh with the same name, count // references and rename instances below. // // Example: CesiumMilkTruck sample model reuses \"Wheel\" meshes. for ( var nodeIndex = 0, nodeLength = nodeDefs.length; nodeIndex < nodeLength; nodeIndex ++ ) { var nodeDef = nodeDefs[ nodeIndex ]; if ( nodeDef.mesh !== undefined ) { if ( meshReferences[ nodeDef.mesh ] === undefined ) { meshReferences[ nodeDef.mesh ] = meshUses[ nodeDef.mesh ] = 0; } meshReferences[ nodeDef.mesh ] ++; // Nothing in the mesh definition indicates whether it is // a SkinnedMesh or Mesh. Use the node's mesh reference // to mark SkinnedMesh if node has skin. if ( nodeDef.skin !== undefined ) { meshDefs[ nodeDef.mesh ].isSkinnedMesh = true; } } } this.json.meshReferences = meshReferences; this.json.meshUses = meshUses; }; /** * Requests the specified dependency asynchronously, with caching. * @param {string} type * @param {number} index * @return {Promise} */ GLTFParser.prototype.getDependency = function ( type, index ) { var cacheKey = type + ':' + index; var dependency = this.cache.get( cacheKey ); if ( ! dependency ) { switch ( type ) { case 'scene': dependency = this.loadScene( index ); break; case 'node': dependency = this.loadNode( index ); break; case 'mesh': dependency = this.loadMesh( index ); break; case 'accessor': dependency = this.loadAccessor( index ); break; case 'bufferView': dependency = this.loadBufferView( index ); break; case 'buffer': dependency = this.loadBuffer( index ); break; case 'material': dependency = this.loadMaterial( index ); break; case 'texture': dependency = this.loadTexture( index ); break; case 'skin': dependency = this.loadSkin( index ); break; case 'animation': dependency = this.loadAnimation( index ); break; case 'camera': dependency = this.loadCamera( index ); break; case 'light': dependency = this.extensions[ EXTENSIONS.KHR_LIGHTS_PUNCTUAL ].loadLight( index ); break; default: throw new Error( 'Unknown type: ' + type ); } this.cache.add( cacheKey, dependency ); } return dependency; }; /** * Requests all dependencies of the specified type asynchronously, with caching. * @param {string} type * @return {Promise} */ GLTFParser.prototype.getDependencies = function ( type ) { var dependencies = this.cache.get( type ); if ( ! dependencies ) { var parser = this; var defs = this.json[ type + ( type === 'mesh' ? 'es' : 's' ) ] || []; dependencies = Promise.all( defs.map( function ( def, index ) { return parser.getDependency( type, index ); } ) ); this.cache.add( type, dependencies ); } return dependencies; }; /** * Requests all multiple dependencies of the specified types asynchronously, with caching. * @param {Array} types * @return {Promise} */ GLTFParser.prototype.getMultiDependencies = function ( types ) { var results = {}; var pending = []; for ( var i = 0, il = types.length; i < il; i ++ ) { var type = types[ i ]; var value = this.getDependencies( type ); // TODO: Error-prone use of a callback inside a loop. value = value.then( function ( key, value ) { results[ key ] = value; }.bind( this, type + ( type === 'mesh' ? 'es' : 's' ) ) ); pending.push( value ); } return Promise.all( pending ).then( function () { return results; } ); }; /** * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#buffers-and-buffer-views * @param {number} bufferIndex * @return {Promise} */ GLTFParser.prototype.loadBuffer = function ( bufferIndex ) { var bufferDef = this.json.buffers[ bufferIndex ]; var loader = this.fileLoader; if ( bufferDef.type && bufferDef.type !== 'arraybuffer' ) { throw new Error( 'THREE.GLTFLoader: ' + bufferDef.type + ' buffer type is not supported.' ); } // If present, GLB container is required to be the first buffer. if ( bufferDef.uri === undefined && bufferIndex === 0 ) { return Promise.resolve( this.extensions[ EXTENSIONS.KHR_BINARY_GLTF ].body ); } var options = this.options; return new Promise( function ( resolve, reject ) { loader.load( resolveURL( bufferDef.uri, options.path ), resolve, undefined, function () { reject( new Error( 'THREE.GLTFLoader: Failed to load buffer \"' + bufferDef.uri + '\".' ) ); } ); } ); }; /** * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#buffers-and-buffer-views * @param {number} bufferViewIndex * @return {Promise} */ GLTFParser.prototype.loadBufferView = function ( bufferViewIndex ) { var bufferViewDef = this.json.bufferViews[ bufferViewIndex ]; return this.getDependency( 'buffer', bufferViewDef.buffer ).then( function ( buffer ) { var byteLength = bufferViewDef.byteLength || 0; var byteOffset = bufferViewDef.byteOffset || 0; return buffer.slice( byteOffset, byteOffset + byteLength ); } ); }; /** * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#accessors * @param {number} accessorIndex * @return {Promise} */ GLTFParser.prototype.loadAccessor = function ( accessorIndex ) { var parser = this; var json = this.json; var accessorDef = this.json.accessors[ accessorIndex ]; if ( accessorDef.bufferView === undefined && accessorDef.sparse === undefined ) { // Ignore empty accessors, which may be used to declare runtime // information about attributes coming from another source (e.g. Draco // compression extension). return Promise.resolve( null ); } var pendingBufferViews = []; if ( accessorDef.bufferView !== undefined ) { pendingBufferViews.push( this.getDependency( 'bufferView', accessorDef.bufferView ) ); } else { pendingBufferViews.push( null ); } if ( accessorDef.sparse !== undefined ) { pendingBufferViews.push( this.getDependency( 'bufferView', accessorDef.sparse.indices.bufferView ) ); pendingBufferViews.push( this.getDependency( 'bufferView', accessorDef.sparse.values.bufferView ) ); } return Promise.all( pendingBufferViews ).then( function ( bufferViews ) { var bufferView = bufferViews[ 0 ]; var itemSize = WEBGL_TYPE_SIZES[ accessorDef.type ]; var TypedArray = WEBGL_COMPONENT_TYPES[ accessorDef.componentType ]; // For VEC3: itemSize is 3, elementBytes is 4, itemBytes is 12. var elementBytes = TypedArray.BYTES_PER_ELEMENT; var itemBytes = elementBytes * itemSize; var byteOffset = accessorDef.byteOffset || 0; var byteStride = accessorDef.bufferView !== undefined ? json.bufferViews[ accessorDef.bufferView ].byteStride : undefined; var normalized = accessorDef.normalized === true; var array, bufferAttribute; // The buffer is not interleaved if the stride is the item size in bytes. if ( byteStride && byteStride !== itemBytes ) { var ibCacheKey = 'InterleavedBuffer:' + accessorDef.bufferView + ':' + accessorDef.componentType; var ib = parser.cache.get( ibCacheKey ); if ( ! ib ) { // Use the full buffer if it's interleaved. array = new TypedArray( bufferView ); // Integer parameters to IB/IBA are in array elements, not bytes. ib = new THREE.InterleavedBuffer( array, byteStride / elementBytes ); parser.cache.add( ibCacheKey, ib ); } bufferAttribute = new THREE.InterleavedBufferAttribute( ib, itemSize, byteOffset / elementBytes, normalized ); } else { if ( bufferView === null ) { array = new TypedArray( accessorDef.count * itemSize ); } else { array = new TypedArray( bufferView, byteOffset, accessorDef.count * itemSize ); } bufferAttribute = new THREE.BufferAttribute( array, itemSize, normalized ); } // https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#sparse-accessors if ( accessorDef.sparse !== undefined ) { var itemSizeIndices = WEBGL_TYPE_SIZES.SCALAR; var TypedArrayIndices = WEBGL_COMPONENT_TYPES[ accessorDef.sparse.indices.componentType ]; var byteOffsetIndices = accessorDef.sparse.indices.byteOffset || 0; var byteOffsetValues = accessorDef.sparse.values.byteOffset || 0; var sparseIndices = new TypedArrayIndices( bufferViews[ 1 ], byteOffsetIndices, accessorDef.sparse.count * itemSizeIndices ); var sparseValues = new TypedArray( bufferViews[ 2 ], byteOffsetValues, accessorDef.sparse.count * itemSize ); if ( bufferView !== null ) { // Avoid modifying the original ArrayBuffer, if the bufferView wasn't initialized with zeroes. bufferAttribute.setArray( bufferAttribute.array.slice() ); } for ( var i = 0, il = sparseIndices.length; i < il; i ++ ) { var index = sparseIndices[ i ]; bufferAttribute.setX( index, sparseValues[ i * itemSize ] ); if ( itemSize >= 2 ) bufferAttribute.setY( index, sparseValues[ i * itemSize + 1 ] ); if ( itemSize >= 3 ) bufferAttribute.setZ( index, sparseValues[ i * itemSize + 2 ] ); if ( itemSize >= 4 ) bufferAttribute.setW( index, sparseValues[ i * itemSize + 3 ] ); if ( itemSize >= 5 ) throw new Error( 'THREE.GLTFLoader: Unsupported itemSize in sparse BufferAttribute.' ); } } return bufferAttribute; } ); }; /** * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#textures * @param {number} textureIndex * @return {Promise} */ GLTFParser.prototype.loadTexture = function ( textureIndex ) { var parser = this; var json = this.json; var options = this.options; var textureLoader = this.textureLoader; var URL = window.URL || window.webkitURL; var textureDef = json.textures[ textureIndex ]; var textureExtensions = textureDef.extensions || {}; var source; if ( textureExtensions[ EXTENSIONS.MSFT_TEXTURE_DDS ] ) { source = json.images[ textureExtensions[ EXTENSIONS.MSFT_TEXTURE_DDS ].source ]; } else { source = json.images[ textureDef.source ]; } var sourceURI = source.uri; var isObjectURL = false; if ( source.bufferView !== undefined ) { // Load binary image data from bufferView, if provided. sourceURI = parser.getDependency( 'bufferView', source.bufferView ).then( function ( bufferView ) { isObjectURL = true; var blob = new Blob( [ bufferView ], { type: source.mimeType } ); sourceURI = URL.createObjectURL( blob ); return sourceURI; } ); } return Promise.resolve( sourceURI ).then( function ( sourceURI ) { // Load Texture resource. var loader = THREE.Loader.Handlers.get( sourceURI ); if ( ! loader ) { loader = textureExtensions[ EXTENSIONS.MSFT_TEXTURE_DDS ] ? parser.extensions[ EXTENSIONS.MSFT_TEXTURE_DDS ].ddsLoader : textureLoader; } return new Promise( function ( resolve, reject ) { loader.load( resolveURL( sourceURI, options.path ), resolve, undefined, reject ); } ); } ).then( function ( texture ) { // Clean up resources and configure Texture. if ( isObjectURL === true ) { URL.revokeObjectURL( sourceURI ); } texture.flipY = false; if ( textureDef.name !== undefined ) texture.name = textureDef.name; // Ignore unknown mime types, like DDS files. if ( source.mimeType in MIME_TYPE_FORMATS ) { texture.format = MIME_TYPE_FORMATS[ source.mimeType ]; } var samplers = json.samplers || {}; var sampler = samplers[ textureDef.sampler ] || {}; texture.magFilter = WEBGL_FILTERS[ sampler.magFilter ] || THREE.LinearFilter; texture.minFilter = WEBGL_FILTERS[ sampler.minFilter ] || THREE.LinearMipMapLinearFilter; texture.wrapS = WEBGL_WRAPPINGS[ sampler.wrapS ] || THREE.RepeatWrapping; texture.wrapT = WEBGL_WRAPPINGS[ sampler.wrapT ] || THREE.RepeatWrapping; return texture; } ); }; /** * Asynchronously assigns a texture to the given material parameters. * @param {Object} materialParams * @param {string} mapName * @param {Object} mapDef * @return {Promise} */ GLTFParser.prototype.assignTexture = function ( materialParams, mapName, mapDef ) { var parser = this; return this.getDependency( 'texture', mapDef.index ).then( function ( texture ) { switch ( mapName ) { case 'aoMap': case 'emissiveMap': case 'metalnessMap': case 'normalMap': case 'roughnessMap': texture.format = THREE.RGBFormat; break; } if ( parser.extensions[ EXTENSIONS.KHR_TEXTURE_TRANSFORM ] ) { var transform = mapDef.extensions !== undefined ? mapDef.extensions[ EXTENSIONS.KHR_TEXTURE_TRANSFORM ] : undefined; if ( transform ) { texture = parser.extensions[ EXTENSIONS.KHR_TEXTURE_TRANSFORM ].extendTexture( texture, transform ); } } materialParams[ mapName ] = texture; } ); }; /** * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#materials * @param {number} materialIndex * @return {Promise} */ GLTFParser.prototype.loadMaterial = function ( materialIndex ) { var parser = this; var json = this.json; var extensions = this.extensions; var materialDef = json.materials[ materialIndex ]; var materialType; var materialParams = {}; var materialExtensions = materialDef.extensions || {}; var pending = []; if ( materialExtensions[ EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS ] ) { var sgExtension = extensions[ EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS ]; materialType = sgExtension.getMaterialType( materialDef ); pending.push( sgExtension.extendParams( materialParams, materialDef, parser ) ); } else if ( materialExtensions[ EXTENSIONS.KHR_MATERIALS_UNLIT ] ) { var kmuExtension = extensions[ EXTENSIONS.KHR_MATERIALS_UNLIT ]; materialType = kmuExtension.getMaterialType( materialDef ); pending.push( kmuExtension.extendParams( materialParams, materialDef, parser ) ); } else { // Specification: // https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#metallic-roughness-material materialType = THREE.MeshStandardMaterial; var metallicRoughness = materialDef.pbrMetallicRoughness || {}; materialParams.color = new THREE.Color( 1.0, 1.0, 1.0 ); materialParams.opacity = 1.0; if ( Array.isArray( metallicRoughness.baseColorFactor ) ) { var array = metallicRoughness.baseColorFactor; materialParams.color.fromArray( array ); materialParams.opacity = array[ 3 ]; } if ( metallicRoughness.baseColorTexture !== undefined ) { pending.push( parser.assignTexture( materialParams, 'map', metallicRoughness.baseColorTexture ) ); } materialParams.metalness = metallicRoughness.metallicFactor !== undefined ? metallicRoughness.metallicFactor : 1.0; materialParams.roughness = metallicRoughness.roughnessFactor !== undefined ? metallicRoughness.roughnessFactor : 1.0; if ( metallicRoughness.metallicRoughnessTexture !== undefined ) { pending.push( parser.assignTexture( materialParams, 'metalnessMap', metallicRoughness.metallicRoughnessTexture ) ); pending.push( parser.assignTexture( materialParams, 'roughnessMap', metallicRoughness.metallicRoughnessTexture ) ); } } if ( materialDef.doubleSided === true ) { materialParams.side = THREE.DoubleSide; } var alphaMode = materialDef.alphaMode || ALPHA_MODES.OPAQUE; if ( alphaMode === ALPHA_MODES.BLEND ) { materialParams.transparent = true; } else { materialParams.transparent = false; if ( alphaMode === ALPHA_MODES.MASK ) { materialParams.alphaTest = materialDef.alphaCutoff !== undefined ? materialDef.alphaCutoff : 0.5; } } if ( materialDef.normalTexture !== undefined && materialType !== THREE.MeshBasicMaterial ) { pending.push( parser.assignTexture( materialParams, 'normalMap', materialDef.normalTexture ) ); materialParams.normalScale = new THREE.Vector2( 1, 1 ); if ( materialDef.normalTexture.scale !== undefined ) { materialParams.normalScale.set( materialDef.normalTexture.scale, materialDef.normalTexture.scale ); } } if ( materialDef.occlusionTexture !== undefined && materialType !== THREE.MeshBasicMaterial ) { pending.push( parser.assignTexture( materialParams, 'aoMap', materialDef.occlusionTexture ) ); if ( materialDef.occlusionTexture.strength !== undefined ) { materialParams.aoMapIntensity = materialDef.occlusionTexture.strength; } } if ( materialDef.emissiveFactor !== undefined && materialType !== THREE.MeshBasicMaterial ) { materialParams.emissive = new THREE.Color().fromArray( materialDef.emissiveFactor ); } if ( materialDef.emissiveTexture !== undefined && materialType !== THREE.MeshBasicMaterial ) { pending.push( parser.assignTexture( materialParams, 'emissiveMap', materialDef.emissiveTexture ) ); } return Promise.all( pending ).then( function () { var material; if ( materialType === THREE.ShaderMaterial ) { material = extensions[ EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS ].createMaterial( materialParams ); } else { material = new materialType( materialParams ); } if ( materialDef.name !== undefined ) material.name = materialDef.name; // Normal map textures use OpenGL conventions: // https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#materialnormaltexture if ( material.normalScale ) { material.normalScale.y = - material.normalScale.y; } // baseColorTexture, emissiveTexture, and specularGlossinessTexture use sRGB encoding. if ( material.map ) material.map.encoding = THREE.sRGBEncoding; if ( material.emissiveMap ) material.emissiveMap.encoding = THREE.sRGBEncoding; if ( material.specularMap ) material.specularMap.encoding = THREE.sRGBEncoding; assignExtrasToUserData( material, materialDef ); if ( materialDef.extensions ) addUnknownExtensionsToUserData( extensions, material, materialDef ); return material; } ); }; /** * @param {THREE.BufferGeometry} geometry * @param {GLTF.Primitive} primitiveDef * @param {GLTFParser} parser * @return {Promise} */ function addPrimitiveAttributes( geometry, primitiveDef, parser ) { var attributes = primitiveDef.attributes; var pending = []; function assignAttributeAccessor( accessorIndex, attributeName ) { return parser.getDependency( 'accessor', accessorIndex ) .then( function ( accessor ) { geometry.addAttribute( attributeName, accessor ); } ); } for ( var gltfAttributeName in attributes ) { var threeAttributeName = ATTRIBUTES[ gltfAttributeName ]; if ( ! threeAttributeName ) continue; // Skip attributes already provided by e.g. Draco extension. if ( threeAttributeName in geometry.attributes ) continue; pending.push( assignAttributeAccessor( attributes[ gltfAttributeName ], threeAttributeName ) ); } if ( primitiveDef.indices !== undefined && ! geometry.index ) { var accessor = parser.getDependency( 'accessor', primitiveDef.indices ).then( function ( accessor ) { geometry.setIndex( accessor ); } ); pending.push( accessor ); } assignExtrasToUserData( geometry, primitiveDef ); return Promise.all( pending ).then( function () { return primitiveDef.targets !== undefined ? addMorphTargets( geometry, primitiveDef.targets, parser ) : geometry; } ); } /** * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#geometry * * Creates BufferGeometries from primitives. * If we can build a single BufferGeometry with .groups from multiple primitives, returns one BufferGeometry. * Otherwise, returns BufferGeometries without .groups as many as primitives. * * @param {Array} primitives * @return {Promise} */ GLTFParser.prototype.loadGeometries = function ( primitives ) { var parser = this; var extensions = this.extensions; var cache = this.primitiveCache; var isMultiPass = isMultiPassGeometry( primitives ); var originalPrimitives; if ( isMultiPass ) { originalPrimitives = primitives; // save original primitives and use later // We build a single BufferGeometry with .groups from multiple primitives // because all primitives share the same attributes/morph/mode and have indices. primitives = [ primitives[ 0 ] ]; // Sets .groups and combined indices to a geometry later in this method. } function createDracoPrimitive( primitive ) { return extensions[ EXTENSIONS.KHR_DRACO_MESH_COMPRESSION ] .decodePrimitive( primitive, parser ) .then( function ( geometry ) { return addPrimitiveAttributes( geometry, primitive, parser ); } ); } var pending = []; for ( var i = 0, il = primitives.length; i < il; i ++ ) { var primitive = primitives[ i ]; // See if we've already created this geometry var cached = getCachedGeometry( cache, primitive ); if ( cached ) { // Use the cached geometry if it exists pending.push( cached ); } else { var geometryPromise; if ( primitive.extensions && primitive.extensions[ EXTENSIONS.KHR_DRACO_MESH_COMPRESSION ] ) { // Use DRACO geometry if available geometryPromise = createDracoPrimitive( primitive ); } else { // Otherwise create a new geometry geometryPromise = addPrimitiveAttributes( new THREE.BufferGeometry(), primitive, parser ); } // Cache this geometry cache.push( { primitive: primitive, promise: geometryPromise } ); pending.push( geometryPromise ); } } return Promise.all( pending ).then( function ( geometries ) { if ( isMultiPass ) { var baseGeometry = geometries[ 0 ]; // See if we've already created this combined geometry var cache = parser.multiPassGeometryCache; var cached = getCachedMultiPassGeometry( cache, baseGeometry, originalPrimitives ); if ( cached !== null ) return [ cached.geometry ]; // Cloning geometry because of index override. // Attributes can be reused so cloning by myself here. var geometry = new THREE.BufferGeometry(); geometry.name = baseGeometry.name; geometry.userData = baseGeometry.userData; for ( var key in baseGeometry.attributes ) geometry.addAttribute( key, baseGeometry.attributes[ key ] ); for ( var key in baseGeometry.morphAttributes ) geometry.morphAttributes[ key ] = baseGeometry.morphAttributes[ key ]; var pendingIndices = []; for ( var i = 0, il = originalPrimitives.length; i < il; i ++ ) { pendingIndices.push( parser.getDependency( 'accessor', originalPrimitives[ i ].indices ) ); } return Promise.all( pendingIndices ).then( function ( accessors ) { var indices = []; var offset = 0; for ( var i = 0, il = originalPrimitives.length; i < il; i ++ ) { var accessor = accessors[ i ]; for ( var j = 0, jl = accessor.count; j < jl; j ++ ) indices.push( accessor.array[ j ] ); geometry.addGroup( offset, accessor.count, i ); offset += accessor.count; } geometry.setIndex( indices ); cache.push( { geometry: geometry, baseGeometry: baseGeometry, primitives: originalPrimitives } ); return [ geometry ]; } ); } else if ( geometries.length > 1 && THREE.BufferGeometryUtils !== undefined ) { // Tries to merge geometries with BufferGeometryUtils if possible for ( var i = 1, il = primitives.length; i < il; i ++ ) { // can't merge if draw mode is different if ( primitives[ 0 ].mode !== primitives[ i ].mode ) return geometries; } // See if we've already created this combined geometry var cache = parser.multiplePrimitivesCache; var cached = getCachedCombinedGeometry( cache, geometries ); if ( cached ) { if ( cached.geometry !== null ) return [ cached.geometry ]; } else { var geometry = THREE.BufferGeometryUtils.mergeBufferGeometries( geometries, true ); cache.push( { geometry: geometry, baseGeometries: geometries } ); if ( geometry !== null ) return [ geometry ]; } } return geometries; } ); }; /** * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#meshes * @param {number} meshIndex * @return {Promise} */ GLTFParser.prototype.loadMesh = function ( meshIndex ) { var parser = this; var json = this.json; var extensions = this.extensions; var meshDef = json.meshes[ meshIndex ]; var primitives = meshDef.primitives; var pending = []; for ( var i = 0, il = primitives.length; i < il; i ++ ) { var material = primitives[ i ].material === undefined ? createDefaultMaterial() : this.getDependency( 'material', primitives[ i ].material ); pending.push( material ); } return Promise.all( pending ).then( function ( originalMaterials ) { return parser.loadGeometries( primitives ).then( function ( geometries ) { var isMultiMaterial = geometries.length === 1 && geometries[ 0 ].groups.length > 0; var meshes = []; for ( var i = 0, il = geometries.length; i < il; i ++ ) { var geometry = geometries[ i ]; var primitive = primitives[ i ]; // 1. create Mesh var mesh; var material = isMultiMaterial ? originalMaterials : originalMaterials[ i ]; if ( primitive.mode === WEBGL_CONSTANTS.TRIANGLES || primitive.mode === WEBGL_CONSTANTS.TRIANGLE_STRIP || primitive.mode === WEBGL_CONSTANTS.TRIANGLE_FAN || primitive.mode === undefined ) { // .isSkinnedMesh isn't in glTF spec. See .markDefs() mesh = meshDef.isSkinnedMesh === true ? new THREE.SkinnedMesh( geometry, material ) : new THREE.Mesh( geometry, material ); if ( mesh.isSkinnedMesh === true ) mesh.normalizeSkinWeights(); // #15319 if ( primitive.mode === WEBGL_CONSTANTS.TRIANGLE_STRIP ) { mesh.drawMode = THREE.TriangleStripDrawMode; } else if ( primitive.mode === WEBGL_CONSTANTS.TRIANGLE_FAN ) { mesh.drawMode = THREE.TriangleFanDrawMode; } } else if ( primitive.mode === WEBGL_CONSTANTS.LINES ) { mesh = new THREE.LineSegments( geometry, material ); } else if ( primitive.mode === WEBGL_CONSTANTS.LINE_STRIP ) { mesh = new THREE.Line( geometry, material ); } else if ( primitive.mode === WEBGL_CONSTANTS.LINE_LOOP ) { mesh = new THREE.LineLoop( geometry, material ); } else if ( primitive.mode === WEBGL_CONSTANTS.POINTS ) { mesh = new THREE.Points( geometry, material ); } else { throw new Error( 'THREE.GLTFLoader: Primitive mode unsupported: ' + primitive.mode ); } if ( Object.keys( mesh.geometry.morphAttributes ).length > 0 ) { updateMorphTargets( mesh, meshDef ); } mesh.name = meshDef.name || ( 'mesh_' + meshIndex ); if ( geometries.length > 1 ) mesh.name += '_' + i; assignExtrasToUserData( mesh, meshDef ); meshes.push( mesh ); // 2. update Material depending on Mesh and BufferGeometry var materials = isMultiMaterial ? mesh.material : [ mesh.material ]; var useVertexColors = geometry.attributes.color !== undefined; var useFlatShading = geometry.attributes.normal === undefined; var useSkinning = mesh.isSkinnedMesh === true; var useMorphTargets = Object.keys( geometry.morphAttributes ).length > 0; var useMorphNormals = useMorphTargets && geometry.morphAttributes.normal !== undefined; for ( var j = 0, jl = materials.length; j < jl; j ++ ) { var material = materials[ j ]; if ( mesh.isPoints ) { var cacheKey = 'PointsMaterial:' + material.uuid; var pointsMaterial = parser.cache.get( cacheKey ); if ( ! pointsMaterial ) { pointsMaterial = new THREE.PointsMaterial(); THREE.Material.prototype.copy.call( pointsMaterial, material ); pointsMaterial.color.copy( material.color ); pointsMaterial.map = material.map; pointsMaterial.lights = false; // PointsMaterial doesn't support lights yet parser.cache.add( cacheKey, pointsMaterial ); } material = pointsMaterial; } else if ( mesh.isLine ) { var cacheKey = 'LineBasicMaterial:' + material.uuid; var lineMaterial = parser.cache.get( cacheKey ); if ( ! lineMaterial ) { lineMaterial = new THREE.LineBasicMaterial(); THREE.Material.prototype.copy.call( lineMaterial, material ); lineMaterial.color.copy( material.color ); lineMaterial.lights = false; // LineBasicMaterial doesn't support lights yet parser.cache.add( cacheKey, lineMaterial ); } material = lineMaterial; } // Clone the material if it will be modified if ( useVertexColors || useFlatShading || useSkinning || useMorphTargets ) { var cacheKey = 'ClonedMaterial:' + material.uuid + ':'; if ( material.isGLTFSpecularGlossinessMaterial ) cacheKey += 'specular-glossiness:'; if ( useSkinning ) cacheKey += 'skinning:'; if ( useVertexColors ) cacheKey += 'vertex-colors:'; if ( useFlatShading ) cacheKey += 'flat-shading:'; if ( useMorphTargets ) cacheKey += 'morph-targets:'; if ( useMorphNormals ) cacheKey += 'morph-normals:'; var cachedMaterial = parser.cache.get( cacheKey ); if ( ! cachedMaterial ) { cachedMaterial = material.isGLTFSpecularGlossinessMaterial ? extensions[ EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS ].cloneMaterial( material ) : material.clone(); if ( useSkinning ) cachedMaterial.skinning = true; if ( useVertexColors ) cachedMaterial.vertexColors = THREE.VertexColors; if ( useFlatShading ) cachedMaterial.flatShading = true; if ( useMorphTargets ) cachedMaterial.morphTargets = true; if ( useMorphNormals ) cachedMaterial.morphNormals = true; parser.cache.add( cacheKey, cachedMaterial ); } material = cachedMaterial; } materials[ j ] = material; // workarounds for mesh and geometry if ( material.aoMap && geometry.attributes.uv2 === undefined && geometry.attributes.uv !== undefined ) { console.log( 'THREE.GLTFLoader: Duplicating UVs to support aoMap.' ); geometry.addAttribute( 'uv2', new THREE.BufferAttribute( geometry.attributes.uv.array, 2 ) ); } if ( material.isGLTFSpecularGlossinessMaterial ) { // for GLTFSpecularGlossinessMaterial(ShaderMaterial) uniforms runtime update mesh.onBeforeRender = extensions[ EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS ].refreshUniforms; } } mesh.material = isMultiMaterial ? materials : materials[ 0 ]; } if ( meshes.length === 1 ) { return meshes[ 0 ]; } var group = new THREE.Group(); for ( var i = 0, il = meshes.length; i < il; i ++ ) { group.add( meshes[ i ] ); } return group; } ); } ); }; /** * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#cameras * @param {number} cameraIndex * @return {Promise} */ GLTFParser.prototype.loadCamera = function ( cameraIndex ) { var camera; var cameraDef = this.json.cameras[ cameraIndex ]; var params = cameraDef[ cameraDef.type ]; if ( ! params ) { console.warn( 'THREE.GLTFLoader: Missing camera parameters.' ); return; } if ( cameraDef.type === 'perspective' ) { camera = new THREE.PerspectiveCamera( THREE.Math.radToDeg( params.yfov ), params.aspectRatio || 1, params.znear || 1, params.zfar || 2e6 ); } else if ( cameraDef.type === 'orthographic' ) { camera = new THREE.OrthographicCamera( params.xmag / - 2, params.xmag / 2, params.ymag / 2, params.ymag / - 2, params.znear, params.zfar ); } if ( cameraDef.name !== undefined ) camera.name = cameraDef.name; assignExtrasToUserData( camera, cameraDef ); return Promise.resolve( camera ); }; /** * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#skins * @param {number} skinIndex * @return {Promise} */ GLTFParser.prototype.loadSkin = function ( skinIndex ) { var skinDef = this.json.skins[ skinIndex ]; var skinEntry = { joints: skinDef.joints }; if ( skinDef.inverseBindMatrices === undefined ) { return Promise.resolve( skinEntry ); } return this.getDependency( 'accessor', skinDef.inverseBindMatrices ).then( function ( accessor ) { skinEntry.inverseBindMatrices = accessor; return skinEntry; } ); }; /** * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#animations * @param {number} animationIndex * @return {Promise} */ GLTFParser.prototype.loadAnimation = function ( animationIndex ) { var json = this.json; var animationDef = json.animations[ animationIndex ]; var pendingNodes = []; var pendingInputAccessors = []; var pendingOutputAccessors = []; var pendingSamplers = []; var pendingTargets = []; for ( var i = 0, il = animationDef.channels.length; i < il; i ++ ) { var channel = animationDef.channels[ i ]; var sampler = animationDef.samplers[ channel.sampler ]; var target = channel.target; var name = target.node !== undefined ? target.node : target.id; // NOTE: target.id is deprecated. var input = animationDef.parameters !== undefined ? animationDef.parameters[ sampler.input ] : sampler.input; var output = animationDef.parameters !== undefined ? animationDef.parameters[ sampler.output ] : sampler.output; pendingNodes.push( this.getDependency( 'node', name ) ); pendingInputAccessors.push( this.getDependency( 'accessor', input ) ); pendingOutputAccessors.push( this.getDependency( 'accessor', output ) ); pendingSamplers.push( sampler ); pendingTargets.push( target ); } return Promise.all( [ Promise.all( pendingNodes ), Promise.all( pendingInputAccessors ), Promise.all( pendingOutputAccessors ), Promise.all( pendingSamplers ), Promise.all( pendingTargets ) ] ).then( function ( dependencies ) { var nodes = dependencies[ 0 ]; var inputAccessors = dependencies[ 1 ]; var outputAccessors = dependencies[ 2 ]; var samplers = dependencies[ 3 ]; var targets = dependencies[ 4 ]; var tracks = []; for ( var i = 0, il = nodes.length; i < il; i ++ ) { var node = nodes[ i ]; var inputAccessor = inputAccessors[ i ]; var outputAccessor = outputAccessors[ i ]; var sampler = samplers[ i ]; var target = targets[ i ]; if ( node === undefined ) continue; node.updateMatrix(); node.matrixAutoUpdate = true; var TypedKeyframeTrack; switch ( PATH_PROPERTIES[ target.path ] ) { case PATH_PROPERTIES.weights: TypedKeyframeTrack = THREE.NumberKeyframeTrack; break; case PATH_PROPERTIES.rotation: TypedKeyframeTrack = THREE.QuaternionKeyframeTrack; break; case PATH_PROPERTIES.position: case PATH_PROPERTIES.scale: default: TypedKeyframeTrack = THREE.VectorKeyframeTrack; break; } var targetName = node.name ? node.name : node.uuid; var interpolation = sampler.interpolation !== undefined ? INTERPOLATION[ sampler.interpolation ] : THREE.InterpolateLinear; var targetNames = []; if ( PATH_PROPERTIES[ target.path ] === PATH_PROPERTIES.weights ) { // node can be THREE.Group here but // PATH_PROPERTIES.weights(morphTargetInfluences) should be // the property of a mesh object under group. node.traverse( function ( object ) { if ( object.isMesh === true && object.morphTargetInfluences ) { targetNames.push( object.name ? object.name : object.uuid ); } } ); } else { targetNames.push( targetName ); } // KeyframeTrack.optimize() will modify given 'times' and 'values' // buffers before creating a truncated copy to keep. Because buffers may // be reused by other tracks, make copies here. for ( var j = 0, jl = targetNames.length; j < jl; j ++ ) { var track = new TypedKeyframeTrack( targetNames[ j ] + '.' + PATH_PROPERTIES[ target.path ], THREE.AnimationUtils.arraySlice( inputAccessor.array, 0 ), THREE.AnimationUtils.arraySlice( outputAccessor.array, 0 ), interpolation ); // Here is the trick to enable custom interpolation. // Overrides .createInterpolant in a factory method which creates custom interpolation. if ( sampler.interpolation === 'CUBICSPLINE' ) { track.createInterpolant = function InterpolantFactoryMethodGLTFCubicSpline( result ) { // A CUBICSPLINE keyframe in glTF has three output values for each input value, // representing inTangent, splineVertex, and outTangent. As a result, track.getValueSize() // must be divided by three to get the interpolant's sampleSize argument. return new GLTFCubicSplineInterpolant( this.times, this.values, this.getValueSize() / 3, result ); }; // Workaround, provide an alternate way to know if the interpolant type is cubis spline to track. // track.getInterpolation() doesn't return valid value for custom interpolant. track.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline = true; } tracks.push( track ); } } var name = animationDef.name !== undefined ? animationDef.name : 'animation_' + animationIndex; return new THREE.AnimationClip( name, undefined, tracks ); } ); }; /** * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#nodes-and-hierarchy * @param {number} nodeIndex * @return {Promise} */ GLTFParser.prototype.loadNode = function ( nodeIndex ) { var json = this.json; var extensions = this.extensions; var parser = this; var meshReferences = json.meshReferences; var meshUses = json.meshUses; var nodeDef = json.nodes[ nodeIndex ]; return ( function () { // .isBone isn't in glTF spec. See .markDefs if ( nodeDef.isBone === true ) { return Promise.resolve( new THREE.Bone() ); } else if ( nodeDef.mesh !== undefined ) { return parser.getDependency( 'mesh', nodeDef.mesh ).then( function ( mesh ) { var node; if ( meshReferences[ nodeDef.mesh ] > 1 ) { var instanceNum = meshUses[ nodeDef.mesh ] ++; node = mesh.clone(); node.name += '_instance_' + instanceNum; // onBeforeRender copy for Specular-Glossiness node.onBeforeRender = mesh.onBeforeRender; for ( var i = 0, il = node.children.length; i < il; i ++ ) { node.children[ i ].name += '_instance_' + instanceNum; node.children[ i ].onBeforeRender = mesh.children[ i ].onBeforeRender; } } else { node = mesh; } // if weights are provided on the node, override weights on the mesh. if ( nodeDef.weights !== undefined ) { node.traverse( function ( o ) { if ( ! o.isMesh ) return; for ( var i = 0, il = nodeDef.weights.length; i < il; i ++ ) { o.morphTargetInfluences[ i ] = nodeDef.weights[ i ]; } } ); } return node; } ); } else if ( nodeDef.camera !== undefined ) { return parser.getDependency( 'camera', nodeDef.camera ); } else if ( nodeDef.extensions && nodeDef.extensions[ EXTENSIONS.KHR_LIGHTS_PUNCTUAL ] && nodeDef.extensions[ EXTENSIONS.KHR_LIGHTS_PUNCTUAL ].light !== undefined ) { return parser.getDependency( 'light', nodeDef.extensions[ EXTENSIONS.KHR_LIGHTS_PUNCTUAL ].light ); } else { return Promise.resolve( new THREE.Object3D() ); } }() ).then( function ( node ) { if ( nodeDef.name !== undefined ) { node.name = THREE.PropertyBinding.sanitizeNodeName( nodeDef.name ); } assignExtrasToUserData( node, nodeDef ); if ( nodeDef.extensions ) addUnknownExtensionsToUserData( extensions, node, nodeDef ); if ( nodeDef.matrix !== undefined ) { var matrix = new THREE.Matrix4(); matrix.fromArray( nodeDef.matrix ); node.applyMatrix( matrix ); } else { if ( nodeDef.translation !== undefined ) { node.position.fromArray( nodeDef.translation ); } if ( nodeDef.rotation !== undefined ) { node.quaternion.fromArray( nodeDef.rotation ); } if ( nodeDef.scale !== undefined ) { node.scale.fromArray( nodeDef.scale ); } } return node; } ); }; /** * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#scenes * @param {number} sceneIndex * @return {Promise} */ GLTFParser.prototype.loadScene = function () { // scene node hierachy builder function buildNodeHierachy( nodeId, parentObject, json, parser ) { var nodeDef = json.nodes[ nodeId ]; return parser.getDependency( 'node', nodeId ).then( function ( node ) { if ( nodeDef.skin === undefined ) return node; // build skeleton here as well var skinEntry; return parser.getDependency( 'skin', nodeDef.skin ).then( function ( skin ) { skinEntry = skin; var pendingJoints = []; for ( var i = 0, il = skinEntry.joints.length; i < il; i ++ ) { pendingJoints.push( parser.getDependency( 'node', skinEntry.joints[ i ] ) ); } return Promise.all( pendingJoints ); } ).then( function ( jointNodes ) { var meshes = node.isGroup === true ? node.children : [ node ]; for ( var i = 0, il = meshes.length; i < il; i ++ ) { var mesh = meshes[ i ]; var bones = []; var boneInverses = []; for ( var j = 0, jl = jointNodes.length; j < jl; j ++ ) { var jointNode = jointNodes[ j ]; if ( jointNode ) { bones.push( jointNode ); var mat = new THREE.Matrix4(); if ( skinEntry.inverseBindMatrices !== undefined ) { mat.fromArray( skinEntry.inverseBindMatrices.array, j * 16 ); } boneInverses.push( mat ); } else { console.warn( 'THREE.GLTFLoader: Joint \"%s\" could not be found.', skinEntry.joints[ j ] ); } } mesh.bind( new THREE.Skeleton( bones, boneInverses ), mesh.matrixWorld ); }; return node; } ); } ).then( function ( node ) { // build node hierachy parentObject.add( node ); var pending = []; if ( nodeDef.children ) { var children = nodeDef.children; for ( var i = 0, il = children.length; i < il; i ++ ) { var child = children[ i ]; pending.push( buildNodeHierachy( child, node, json, parser ) ); } } return Promise.all( pending ); } ); } return function loadScene( sceneIndex ) { var json = this.json; var extensions = this.extensions; var sceneDef = this.json.scenes[ sceneIndex ]; var parser = this; var scene = new THREE.Scene(); if ( sceneDef.name !== undefined ) scene.name = sceneDef.name; assignExtrasToUserData( scene, sceneDef ); if ( sceneDef.extensions ) addUnknownExtensionsToUserData( extensions, scene, sceneDef ); var nodeIds = sceneDef.nodes || []; var pending = []; for ( var i = 0, il = nodeIds.length; i < il; i ++ ) { pending.push( buildNodeHierachy( nodeIds[ i ], scene, json, parser ) ); } return Promise.all( pending ).then( function () { return scene; } ); }; }(); return GLTFLoader; } )();"},{"title":"","date":"2019-03-17T10:06:35.735Z","updated":"2019-03-17T10:06:35.735Z","comments":true,"path":"js/three.min.js","permalink":"http://www.zcating.tk/js/three.min.js","excerpt":"","text":"// threejs.org/license (function(l,ja){\"object\"===typeof exports&&\"undefined\"!==typeof module?ja(exports):\"function\"===typeof define&&define.amd?define([\"exports\"],ja):(l=l||self,ja(l.THREE={}))})(this,function(l){function ja(){}function z(a,b){this.x=a||0;this.y=b||0}function J(){this.elements=[1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1];0b&&(b=a[c]);return b}function D(){Object.defineProperty(this,\"id\",{value:Tf+=2});this.uuid=G.generateUUID();this.name=\"\";this.type=\"BufferGeometry\";this.index=null;this.attributes={};this.morphAttributes={};this.groups=[];this.boundingSphere=this.boundingBox=null;this.drawRange={start:0,count:Infinity}; this.userData={}}function Mb(a,b,c,d,e,f){R.call(this);this.type=\"BoxGeometry\";this.parameters={width:a,height:b,depth:c,widthSegments:d,heightSegments:e,depthSegments:f};this.fromBufferGeometry(new pb(a,b,c,d,e,f));this.mergeVertices()}function pb(a,b,c,d,e,f){function g(a,b,c,d,e,f,g,l,ta,F,da){var r=f/ta,u=g/F,x=f/2,w=g/2,A=l/2;g=ta+1;var I=F+1,y=f=0,N,z,B=new n;for(z=0;z>24&255]).toUpperCase()}}(),clamp:function(a,b,c){return Math.max(b,Math.min(c,a))},euclideanModulo:function(a,b){return(a%b+b)%b},mapLinear:function(a,b,c, d,e){return d+(a-b)*(e-d)/(c-b)},lerp:function(a,b,c){return(1-c)*a+c*b},smoothstep:function(a,b,c){if(a=c)return 1;a=(a-b)/(c-b);return a*a*(3-2*a)},smootherstep:function(a,b,c){if(a=c)return 1;a=(a-b)/(c-b);return a*a*a*(a*(6*a-15)+10)},randInt:function(a,b){return a+Math.floor(Math.random()*(b-a+1))},randFloat:function(a,b){return a+Math.random()*(b-a)},randFloatSpread:function(a){return a*(.5-Math.random())},degToRad:function(a){return a*G.DEG2RAD},radToDeg:function(a){return a* G.RAD2DEG},isPowerOfTwo:function(a){return 0===(a&a-1)&&0!==a},ceilPowerOfTwo:function(a){return Math.pow(2,Math.ceil(Math.log(a)/Math.LN2))},floorPowerOfTwo:function(a){return Math.pow(2,Math.floor(Math.log(a)/Math.LN2))}};Object.defineProperties(z.prototype,{width:{get:function(){return this.x},set:function(a){this.x=a}},height:{get:function(){return this.y},set:function(a){this.y=a}}});Object.assign(z.prototype,{isVector2:!0,set:function(a,b){this.x=a;this.y=b;return this},setScalar:function(a){this.y= this.x=a;return this},setX:function(a){this.x=a;return this},setY:function(a){this.y=a;return this},setComponent:function(a,b){switch(a){case 0:this.x=b;break;case 1:this.y=b;break;default:throw Error(\"index is out of range: \"+a);}return this},getComponent:function(a){switch(a){case 0:return this.x;case 1:return this.y;default:throw Error(\"index is out of range: \"+a);}},clone:function(){return new this.constructor(this.x,this.y)},copy:function(a){this.x=a.x;this.y=a.y;return this},add:function(a, b){if(void 0!==b)return console.warn(\"THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead.\"),this.addVectors(a,b);this.x+=a.x;this.y+=a.y;return this},addScalar:function(a){this.x+=a;this.y+=a;return this},addVectors:function(a,b){this.x=a.x+b.x;this.y=a.y+b.y;return this},addScaledVector:function(a,b){this.x+=a.x*b;this.y+=a.y*b;return this},sub:function(a,b){if(void 0!==b)return console.warn(\"THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.\"), this.subVectors(a,b);this.x-=a.x;this.y-=a.y;return this},subScalar:function(a){this.x-=a;this.y-=a;return this},subVectors:function(a,b){this.x=a.x-b.x;this.y=a.y-b.y;return this},multiply:function(a){this.x*=a.x;this.y*=a.y;return this},multiplyScalar:function(a){this.x*=a;this.y*=a;return this},divide:function(a){this.x/=a.x;this.y/=a.y;return this},divideScalar:function(a){return this.multiplyScalar(1/a)},applyMatrix3:function(a){var b=this.x,c=this.y;a=a.elements;this.x=a[0]*b+a[3]*c+a[6];this.y= a[1]*b+a[4]*c+a[7];return this},min:function(a){this.x=Math.min(this.x,a.x);this.y=Math.min(this.y,a.y);return this},max:function(a){this.x=Math.max(this.x,a.x);this.y=Math.max(this.y,a.y);return this},clamp:function(a,b){this.x=Math.max(a.x,Math.min(b.x,this.x));this.y=Math.max(a.y,Math.min(b.y,this.y));return this},clampScalar:function(){var a=new z,b=new z;return function(c,d){a.set(c,c);b.set(d,d);return this.clamp(a,b)}}(),clampLength:function(a,b){var c=this.length();return this.divideScalar(c|| 1).multiplyScalar(Math.max(a,Math.min(b,c)))},floor:function(){this.x=Math.floor(this.x);this.y=Math.floor(this.y);return this},ceil:function(){this.x=Math.ceil(this.x);this.y=Math.ceil(this.y);return this},round:function(){this.x=Math.round(this.x);this.y=Math.round(this.y);return this},roundToZero:function(){this.x=0>this.x?Math.ceil(this.x):Math.floor(this.x);this.y=0>this.y?Math.ceil(this.y):Math.floor(this.y);return this},negate:function(){this.x=-this.x;this.y=-this.y;return this},dot:function(a){return this.x* a.x+this.y*a.y},cross:function(a){return this.x*a.y-this.y*a.x},lengthSq:function(){return this.x*this.x+this.y*this.y},length:function(){return Math.sqrt(this.x*this.x+this.y*this.y)},manhattanLength:function(){return Math.abs(this.x)+Math.abs(this.y)},normalize:function(){return this.divideScalar(this.length()||1)},angle:function(){var a=Math.atan2(this.y,this.x);0>a&&(a+=2*Math.PI);return a},distanceTo:function(a){return Math.sqrt(this.distanceToSquared(a))},distanceToSquared:function(a){var b= this.x-a.x;a=this.y-a.y;return b*b+a*a},manhattanDistanceTo:function(a){return Math.abs(this.x-a.x)+Math.abs(this.y-a.y)},setLength:function(a){return this.normalize().multiplyScalar(a)},lerp:function(a,b){this.x+=(a.x-this.x)*b;this.y+=(a.y-this.y)*b;return this},lerpVectors:function(a,b,c){return this.subVectors(b,a).multiplyScalar(c).add(a)},equals:function(a){return a.x===this.x&&a.y===this.y},fromArray:function(a,b){void 0===b&&(b=0);this.x=a[b];this.y=a[b+1];return this},toArray:function(a, b){void 0===a&&(a=[]);void 0===b&&(b=0);a[b]=this.x;a[b+1]=this.y;return a},fromBufferAttribute:function(a,b,c){void 0!==c&&console.warn(\"THREE.Vector2: offset has been removed from .fromBufferAttribute().\");this.x=a.getX(b);this.y=a.getY(b);return this},rotateAround:function(a,b){var c=Math.cos(b);b=Math.sin(b);var d=this.x-a.x,e=this.y-a.y;this.x=d*c-e*b+a.x;this.y=d*b+e*c+a.y;return this}});Object.assign(J.prototype,{isMatrix4:!0,set:function(a,b,c,d,e,f,g,h,k,m,q,l,t,v,r,n){var p=this.elements; p[0]=a;p[4]=b;p[8]=c;p[12]=d;p[1]=e;p[5]=f;p[9]=g;p[13]=h;p[2]=k;p[6]=m;p[10]=q;p[14]=l;p[3]=t;p[7]=v;p[11]=r;p[15]=n;return this},identity:function(){this.set(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1);return this},clone:function(){return(new J).fromArray(this.elements)},copy:function(a){var b=this.elements;a=a.elements;b[0]=a[0];b[1]=a[1];b[2]=a[2];b[3]=a[3];b[4]=a[4];b[5]=a[5];b[6]=a[6];b[7]=a[7];b[8]=a[8];b[9]=a[9];b[10]=a[10];b[11]=a[11];b[12]=a[12];b[13]=a[13];b[14]=a[14];b[15]=a[15];return this},copyPosition:function(a){var b= this.elements;a=a.elements;b[12]=a[12];b[13]=a[13];b[14]=a[14];return this},extractBasis:function(a,b,c){a.setFromMatrixColumn(this,0);b.setFromMatrixColumn(this,1);c.setFromMatrixColumn(this,2);return this},makeBasis:function(a,b,c){this.set(a.x,b.x,c.x,0,a.y,b.y,c.y,0,a.z,b.z,c.z,0,0,0,0,1);return this},extractRotation:function(){var a=new n;return function(b){var c=this.elements,d=b.elements,e=1/a.setFromMatrixColumn(b,0).length(),f=1/a.setFromMatrixColumn(b,1).length();b=1/a.setFromMatrixColumn(b, 2).length();c[0]=d[0]*e;c[1]=d[1]*e;c[2]=d[2]*e;c[3]=0;c[4]=d[4]*f;c[5]=d[5]*f;c[6]=d[6]*f;c[7]=0;c[8]=d[8]*b;c[9]=d[9]*b;c[10]=d[10]*b;c[11]=0;c[12]=0;c[13]=0;c[14]=0;c[15]=1;return this}}(),makeRotationFromEuler:function(a){a&&a.isEuler||console.error(\"THREE.Matrix4: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.\");var b=this.elements,c=a.x,d=a.y,e=a.z,f=Math.cos(c);c=Math.sin(c);var g=Math.cos(d);d=Math.sin(d);var h=Math.cos(e);e=Math.sin(e);if(\"XYZ\"===a.order){a= f*h;var k=f*e,m=c*h,q=c*e;b[0]=g*h;b[4]=-g*e;b[8]=d;b[1]=k+m*d;b[5]=a-q*d;b[9]=-c*g;b[2]=q-a*d;b[6]=m+k*d;b[10]=f*g}else\"YXZ\"===a.order?(a=g*h,k=g*e,m=d*h,q=d*e,b[0]=a+q*c,b[4]=m*c-k,b[8]=f*d,b[1]=f*e,b[5]=f*h,b[9]=-c,b[2]=k*c-m,b[6]=q+a*c,b[10]=f*g):\"ZXY\"===a.order?(a=g*h,k=g*e,m=d*h,q=d*e,b[0]=a-q*c,b[4]=-f*e,b[8]=m+k*c,b[1]=k+m*c,b[5]=f*h,b[9]=q-a*c,b[2]=-f*d,b[6]=c,b[10]=f*g):\"ZYX\"===a.order?(a=f*h,k=f*e,m=c*h,q=c*e,b[0]=g*h,b[4]=m*d-k,b[8]=a*d+q,b[1]=g*e,b[5]=q*d+a,b[9]=k*d-m,b[2]=-d,b[6]=c* g,b[10]=f*g):\"YZX\"===a.order?(a=f*g,k=f*d,m=c*g,q=c*d,b[0]=g*h,b[4]=q-a*e,b[8]=m*e+k,b[1]=e,b[5]=f*h,b[9]=-c*h,b[2]=-d*h,b[6]=k*e+m,b[10]=a-q*e):\"XZY\"===a.order&&(a=f*g,k=f*d,m=c*g,q=c*d,b[0]=g*h,b[4]=-e,b[8]=d*h,b[1]=a*e+q,b[5]=f*h,b[9]=k*e-m,b[2]=m*e-k,b[6]=c*h,b[10]=q*e+a);b[3]=0;b[7]=0;b[11]=0;b[12]=0;b[13]=0;b[14]=0;b[15]=1;return this},makeRotationFromQuaternion:function(){var a=new n(0,0,0),b=new n(1,1,1);return function(c){return this.compose(a,c,b)}}(),lookAt:function(){var a=new n,b=new n, c=new n;return function(d,e,f){var g=this.elements;c.subVectors(d,e);0===c.lengthSq()&&(c.z=1);c.normalize();a.crossVectors(f,c);0===a.lengthSq()&&(1===Math.abs(f.z)?c.x+=1E-4:c.z+=1E-4,c.normalize(),a.crossVectors(f,c));a.normalize();b.crossVectors(c,a);g[0]=a.x;g[4]=b.x;g[8]=c.x;g[1]=a.y;g[5]=b.y;g[9]=c.y;g[2]=a.z;g[6]=b.z;g[10]=c.z;return this}}(),multiply:function(a,b){return void 0!==b?(console.warn(\"THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead.\"), this.multiplyMatrices(a,b)):this.multiplyMatrices(this,a)},premultiply:function(a){return this.multiplyMatrices(a,this)},multiplyMatrices:function(a,b){var c=a.elements,d=b.elements;b=this.elements;a=c[0];var e=c[4],f=c[8],g=c[12],h=c[1],k=c[5],m=c[9],q=c[13],l=c[2],t=c[6],v=c[10],r=c[14],n=c[3],x=c[7],A=c[11];c=c[15];var w=d[0],I=d[4],y=d[8],N=d[12],z=d[1],F=d[5],B=d[9],D=d[13],C=d[2],G=d[6],E=d[10],H=d[14],L=d[3],J=d[7],K=d[11];d=d[15];b[0]=a*w+e*z+f*C+g*L;b[4]=a*I+e*F+f*G+g*J;b[8]=a*y+e*B+f*E+ g*K;b[12]=a*N+e*D+f*H+g*d;b[1]=h*w+k*z+m*C+q*L;b[5]=h*I+k*F+m*G+q*J;b[9]=h*y+k*B+m*E+q*K;b[13]=h*N+k*D+m*H+q*d;b[2]=l*w+t*z+v*C+r*L;b[6]=l*I+t*F+v*G+r*J;b[10]=l*y+t*B+v*E+r*K;b[14]=l*N+t*D+v*H+r*d;b[3]=n*w+x*z+A*C+c*L;b[7]=n*I+x*F+A*G+c*J;b[11]=n*y+x*B+A*E+c*K;b[15]=n*N+x*D+A*H+c*d;return this},multiplyScalar:function(a){var b=this.elements;b[0]*=a;b[4]*=a;b[8]*=a;b[12]*=a;b[1]*=a;b[5]*=a;b[9]*=a;b[13]*=a;b[2]*=a;b[6]*=a;b[10]*=a;b[14]*=a;b[3]*=a;b[7]*=a;b[11]*=a;b[15]*=a;return this},applyToBufferAttribute:function(){var a= new n;return function(b){for(var c=0,d=b.count;cthis.determinant()&&(g=-g);c.x=f[12];c.y=f[13];c.z=f[14];b.copy(this);c=1/g;f=1/h;var m=1/k;b.elements[0]*=c;b.elements[1]*=c;b.elements[2]*=c;b.elements[4]*=f;b.elements[5]*=f;b.elements[6]*=f;b.elements[8]*=m;b.elements[9]*=m;b.elements[10]*=m;d.setFromRotationMatrix(b);e.x=g;e.y=h;e.z=k;return this}}(),makePerspective:function(a,b,c,d,e,f){void 0===f&&console.warn(\"THREE.Matrix4: .makePerspective() has been redefined and has a new signature. Please check the docs.\"); var g=this.elements;g[0]=2*e/(b-a);g[4]=0;g[8]=(b+a)/(b-a);g[12]=0;g[1]=0;g[5]=2*e/(c-d);g[9]=(c+d)/(c-d);g[13]=0;g[2]=0;g[6]=0;g[10]=-(f+e)/(f-e);g[14]=-2*f*e/(f-e);g[3]=0;g[7]=0;g[11]=-1;g[15]=0;return this},makeOrthographic:function(a,b,c,d,e,f){var g=this.elements,h=1/(b-a),k=1/(c-d),m=1/(f-e);g[0]=2*h;g[4]=0;g[8]=0;g[12]=-((b+a)*h);g[1]=0;g[5]=2*k;g[9]=0;g[13]=-((c+d)*k);g[2]=0;g[6]=0;g[10]=-2*m;g[14]=-((f+e)*m);g[3]=0;g[7]=0;g[11]=0;g[15]=1;return this},equals:function(a){var b=this.elements; a=a.elements;for(var c=0;16>c;c++)if(b[c]!==a[c])return!1;return!0},fromArray:function(a,b){void 0===b&&(b=0);for(var c=0;16>c;c++)this.elements[c]=a[c+b];return this},toArray:function(a,b){void 0===a&&(a=[]);void 0===b&&(b=0);var c=this.elements;a[b]=c[0];a[b+1]=c[1];a[b+2]=c[2];a[b+3]=c[3];a[b+4]=c[4];a[b+5]=c[5];a[b+6]=c[6];a[b+7]=c[7];a[b+8]=c[8];a[b+9]=c[9];a[b+10]=c[10];a[b+11]=c[11];a[b+12]=c[12];a[b+13]=c[13];a[b+14]=c[14];a[b+15]=c[15];return a}});Object.assign(ka,{slerp:function(a,b,c,d){return c.copy(a).slerp(b, d)},slerpFlat:function(a,b,c,d,e,f,g){var h=c[d+0],k=c[d+1],m=c[d+2];c=c[d+3];d=e[f+0];var l=e[f+1],p=e[f+2];e=e[f+3];if(c!==e||h!==d||k!==l||m!==p){f=1-g;var t=h*d+k*l+m*p+c*e,n=0Number.EPSILON&&(r=Math.sqrt(r),t=Math.atan2(r,t*n),f=Math.sin(f*t)/r,g=Math.sin(g*t)/r);n*=g;h=h*f+d*n;k=k*f+l*n;m=m*f+p*n;c=c*f+e*n;f===1-g&&(g=1/Math.sqrt(h*h+k*k+m*m+c*c),h*=g,k*=g,m*=g,c*=g)}a[b]=h;a[b+1]=k;a[b+2]=m;a[b+3]=c}});Object.defineProperties(ka.prototype,{x:{get:function(){return this._x}, set:function(a){this._x=a;this.onChangeCallback()}},y:{get:function(){return this._y},set:function(a){this._y=a;this.onChangeCallback()}},z:{get:function(){return this._z},set:function(a){this._z=a;this.onChangeCallback()}},w:{get:function(){return this._w},set:function(a){this._w=a;this.onChangeCallback()}}});Object.assign(ka.prototype,{isQuaternion:!0,set:function(a,b,c,d){this._x=a;this._y=b;this._z=c;this._w=d;this.onChangeCallback();return this},clone:function(){return new this.constructor(this._x, this._y,this._z,this._w)},copy:function(a){this._x=a.x;this._y=a.y;this._z=a.z;this._w=a.w;this.onChangeCallback();return this},setFromEuler:function(a,b){if(!a||!a.isEuler)throw Error(\"THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order.\");var c=a._x,d=a._y,e=a._z;a=a.order;var f=Math.cos,g=Math.sin,h=f(c/2),k=f(d/2);f=f(e/2);c=g(c/2);d=g(d/2);e=g(e/2);\"XYZ\"===a?(this._x=c*k*f+h*d*e,this._y=h*d*f-c*k*e,this._z=h*k*e+c*d*f,this._w=h*k*f-c*d*e):\"YXZ\"===a? (this._x=c*k*f+h*d*e,this._y=h*d*f-c*k*e,this._z=h*k*e-c*d*f,this._w=h*k*f+c*d*e):\"ZXY\"===a?(this._x=c*k*f-h*d*e,this._y=h*d*f+c*k*e,this._z=h*k*e+c*d*f,this._w=h*k*f-c*d*e):\"ZYX\"===a?(this._x=c*k*f-h*d*e,this._y=h*d*f+c*k*e,this._z=h*k*e-c*d*f,this._w=h*k*f+c*d*e):\"YZX\"===a?(this._x=c*k*f+h*d*e,this._y=h*d*f+c*k*e,this._z=h*k*e-c*d*f,this._w=h*k*f-c*d*e):\"XZY\"===a&&(this._x=c*k*f-h*d*e,this._y=h*d*f-c*k*e,this._z=h*k*e+c*d*f,this._w=h*k*f+c*d*e);if(!1!==b)this.onChangeCallback();return this},setFromAxisAngle:function(a, b){b/=2;var c=Math.sin(b);this._x=a.x*c;this._y=a.y*c;this._z=a.z*c;this._w=Math.cos(b);this.onChangeCallback();return this},setFromRotationMatrix:function(a){var b=a.elements,c=b[0];a=b[4];var d=b[8],e=b[1],f=b[5],g=b[9],h=b[2],k=b[6];b=b[10];var m=c+f+b;0f&&c>b?(c=2*Math.sqrt(1+c-f-b),this._w=(k-g)/c,this._x=.25*c,this._y=(a+e)/c,this._z=(d+h)/c):f>b?(c=2*Math.sqrt(1+f-c-b),this._w=(d-h)/c,this._x=(a+e)/c,this._y= .25*c,this._z=(g+k)/c):(c=2*Math.sqrt(1+b-c-f),this._w=(e-a)/c,this._x=(d+h)/c,this._y=(g+k)/c,this._z=.25*c);this.onChangeCallback();return this},setFromUnitVectors:function(){var a=new n,b;return function(c,d){void 0===a&&(a=new n);b=c.dot(d)+1;1E-6>b?(b=0,Math.abs(c.x)>Math.abs(c.z)?a.set(-c.y,c.x,0):a.set(0,-c.z,c.y)):a.crossVectors(c,d);this._x=a.x;this._y=a.y;this._z=a.z;this._w=b;return this.normalize()}}(),angleTo:function(a){return 2*Math.acos(Math.abs(G.clamp(this.dot(a),-1,1)))},rotateTowards:function(a, b){var c=this.angleTo(a);if(0===c)return this;this.slerp(a,Math.min(1,b/c));return this},inverse:function(){return this.conjugate()},conjugate:function(){this._x*=-1;this._y*=-1;this._z*=-1;this.onChangeCallback();return this},dot:function(a){return this._x*a._x+this._y*a._y+this._z*a._z+this._w*a._w},lengthSq:function(){return this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w},length:function(){return Math.sqrt(this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w)},normalize:function(){var a= this.length();0===a?(this._z=this._y=this._x=0,this._w=1):(a=1/a,this._x*=a,this._y*=a,this._z*=a,this._w*=a);this.onChangeCallback();return this},multiply:function(a,b){return void 0!==b?(console.warn(\"THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead.\"),this.multiplyQuaternions(a,b)):this.multiplyQuaternions(this,a)},premultiply:function(a){return this.multiplyQuaternions(a,this)},multiplyQuaternions:function(a,b){var c=a._x,d=a._y,e=a._z;a=a._w; var f=b._x,g=b._y,h=b._z;b=b._w;this._x=c*b+a*f+d*h-e*g;this._y=d*b+a*g+e*f-c*h;this._z=e*b+a*h+c*g-d*f;this._w=a*b-c*f-d*g-e*h;this.onChangeCallback();return this},slerp:function(a,b){if(0===b)return this;if(1===b)return this.copy(a);var c=this._x,d=this._y,e=this._z,f=this._w,g=f*a._w+c*a._x+d*a._y+e*a._z;0>g?(this._w=-a._w,this._x=-a._x,this._y=-a._y,this._z=-a._z,g=-g):this.copy(a);if(1"},{"title":"","date":"2019-03-17T10:06:35.731Z","updated":"2019-03-17T10:06:35.731Z","comments":true,"path":"js/three.js","permalink":"http://www.zcating.tk/js/three.js","excerpt":"","text":"(function (global, factory) { typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) : typeof define === 'function' && define.amd ? define(['exports'], factory) : (global = global || self, factory(global.THREE = {})); }(this, function (exports) { 'use strict'; // Polyfills if ( Number.EPSILON === undefined ) { Number.EPSILON = Math.pow( 2, - 52 ); } if ( Number.isInteger === undefined ) { // Missing in IE // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/isInteger Number.isInteger = function ( value ) { return typeof value === 'number' && isFinite( value ) && Math.floor( value ) === value; }; } // if ( Math.sign === undefined ) { // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/sign Math.sign = function ( x ) { return ( x < 0 ) ? - 1 : ( x > 0 ) ? 1 : + x; }; } if ( 'name' in Function.prototype === false ) { // Missing in IE // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/name Object.defineProperty( Function.prototype, 'name', { get: function () { return this.toString().match( /^\\s*function\\s*([^\\(\\s]*)/ )[ 1 ]; } } ); } if ( Object.assign === undefined ) { // Missing in IE // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/assign ( function () { Object.assign = function ( target ) { if ( target === undefined || target === null ) { throw new TypeError( 'Cannot convert undefined or null to object' ); } var output = Object( target ); for ( var index = 1; index < arguments.length; index ++ ) { var source = arguments[ index ]; if ( source !== undefined && source !== null ) { for ( var nextKey in source ) { if ( Object.prototype.hasOwnProperty.call( source, nextKey ) ) { output[ nextKey ] = source[ nextKey ]; } } } } return output; }; } )(); } /** * https://github.com/mrdoob/eventdispatcher.js/ */ function EventDispatcher() {} Object.assign( EventDispatcher.prototype, { addEventListener: function ( type, listener ) { if ( this._listeners === undefined ) this._listeners = {}; var listeners = this._listeners; if ( listeners[ type ] === undefined ) { listeners[ type ] = []; } if ( listeners[ type ].indexOf( listener ) === - 1 ) { listeners[ type ].push( listener ); } }, hasEventListener: function ( type, listener ) { if ( this._listeners === undefined ) return false; var listeners = this._listeners; return listeners[ type ] !== undefined && listeners[ type ].indexOf( listener ) !== - 1; }, removeEventListener: function ( type, listener ) { if ( this._listeners === undefined ) return; var listeners = this._listeners; var listenerArray = listeners[ type ]; if ( listenerArray !== undefined ) { var index = listenerArray.indexOf( listener ); if ( index !== - 1 ) { listenerArray.splice( index, 1 ); } } }, dispatchEvent: function ( event ) { if ( this._listeners === undefined ) return; var listeners = this._listeners; var listenerArray = listeners[ event.type ]; if ( listenerArray !== undefined ) { event.target = this; var array = listenerArray.slice( 0 ); for ( var i = 0, l = array.length; i < l; i ++ ) { array[ i ].call( this, event ); } } } } ); var REVISION = '102dev'; var MOUSE = { LEFT: 0, MIDDLE: 1, RIGHT: 2 }; var CullFaceNone = 0; var CullFaceBack = 1; var CullFaceFront = 2; var CullFaceFrontBack = 3; var FrontFaceDirectionCW = 0; var FrontFaceDirectionCCW = 1; var BasicShadowMap = 0; var PCFShadowMap = 1; var PCFSoftShadowMap = 2; var FrontSide = 0; var BackSide = 1; var DoubleSide = 2; var FlatShading = 1; var SmoothShading = 2; var NoColors = 0; var FaceColors = 1; var VertexColors = 2; var NoBlending = 0; var NormalBlending = 1; var AdditiveBlending = 2; var SubtractiveBlending = 3; var MultiplyBlending = 4; var CustomBlending = 5; var AddEquation = 100; var SubtractEquation = 101; var ReverseSubtractEquation = 102; var MinEquation = 103; var MaxEquation = 104; var ZeroFactor = 200; var OneFactor = 201; var SrcColorFactor = 202; var OneMinusSrcColorFactor = 203; var SrcAlphaFactor = 204; var OneMinusSrcAlphaFactor = 205; var DstAlphaFactor = 206; var OneMinusDstAlphaFactor = 207; var DstColorFactor = 208; var OneMinusDstColorFactor = 209; var SrcAlphaSaturateFactor = 210; var NeverDepth = 0; var AlwaysDepth = 1; var LessDepth = 2; var LessEqualDepth = 3; var EqualDepth = 4; var GreaterEqualDepth = 5; var GreaterDepth = 6; var NotEqualDepth = 7; var MultiplyOperation = 0; var MixOperation = 1; var AddOperation = 2; var NoToneMapping = 0; var LinearToneMapping = 1; var ReinhardToneMapping = 2; var Uncharted2ToneMapping = 3; var CineonToneMapping = 4; var ACESFilmicToneMapping = 5; var UVMapping = 300; var CubeReflectionMapping = 301; var CubeRefractionMapping = 302; var EquirectangularReflectionMapping = 303; var EquirectangularRefractionMapping = 304; var SphericalReflectionMapping = 305; var CubeUVReflectionMapping = 306; var CubeUVRefractionMapping = 307; var RepeatWrapping = 1000; var ClampToEdgeWrapping = 1001; var MirroredRepeatWrapping = 1002; var NearestFilter = 1003; var NearestMipMapNearestFilter = 1004; var NearestMipMapLinearFilter = 1005; var LinearFilter = 1006; var LinearMipMapNearestFilter = 1007; var LinearMipMapLinearFilter = 1008; var UnsignedByteType = 1009; var ByteType = 1010; var ShortType = 1011; var UnsignedShortType = 1012; var IntType = 1013; var UnsignedIntType = 1014; var FloatType = 1015; var HalfFloatType = 1016; var UnsignedShort4444Type = 1017; var UnsignedShort5551Type = 1018; var UnsignedShort565Type = 1019; var UnsignedInt248Type = 1020; var AlphaFormat = 1021; var RGBFormat = 1022; var RGBAFormat = 1023; var LuminanceFormat = 1024; var LuminanceAlphaFormat = 1025; var RGBEFormat = RGBAFormat; var DepthFormat = 1026; var DepthStencilFormat = 1027; var RedFormat = 1028; var RGB_S3TC_DXT1_Format = 33776; var RGBA_S3TC_DXT1_Format = 33777; var RGBA_S3TC_DXT3_Format = 33778; var RGBA_S3TC_DXT5_Format = 33779; var RGB_PVRTC_4BPPV1_Format = 35840; var RGB_PVRTC_2BPPV1_Format = 35841; var RGBA_PVRTC_4BPPV1_Format = 35842; var RGBA_PVRTC_2BPPV1_Format = 35843; var RGB_ETC1_Format = 36196; var RGBA_ASTC_4x4_Format = 37808; var RGBA_ASTC_5x4_Format = 37809; var RGBA_ASTC_5x5_Format = 37810; var RGBA_ASTC_6x5_Format = 37811; var RGBA_ASTC_6x6_Format = 37812; var RGBA_ASTC_8x5_Format = 37813; var RGBA_ASTC_8x6_Format = 37814; var RGBA_ASTC_8x8_Format = 37815; var RGBA_ASTC_10x5_Format = 37816; var RGBA_ASTC_10x6_Format = 37817; var RGBA_ASTC_10x8_Format = 37818; var RGBA_ASTC_10x10_Format = 37819; var RGBA_ASTC_12x10_Format = 37820; var RGBA_ASTC_12x12_Format = 37821; var LoopOnce = 2200; var LoopRepeat = 2201; var LoopPingPong = 2202; var InterpolateDiscrete = 2300; var InterpolateLinear = 2301; var InterpolateSmooth = 2302; var ZeroCurvatureEnding = 2400; var ZeroSlopeEnding = 2401; var WrapAroundEnding = 2402; var TrianglesDrawMode = 0; var TriangleStripDrawMode = 1; var TriangleFanDrawMode = 2; var LinearEncoding = 3000; var sRGBEncoding = 3001; var GammaEncoding = 3007; var RGBEEncoding = 3002; var LogLuvEncoding = 3003; var RGBM7Encoding = 3004; var RGBM16Encoding = 3005; var RGBDEncoding = 3006; var BasicDepthPacking = 3200; var RGBADepthPacking = 3201; var TangentSpaceNormalMap = 0; var ObjectSpaceNormalMap = 1; /** * @author alteredq / http://alteredqualia.com/ * @author mrdoob / http://mrdoob.com/ */ var _Math = { DEG2RAD: Math.PI / 180, RAD2DEG: 180 / Math.PI, generateUUID: ( function () { // http://stackoverflow.com/questions/105034/how-to-create-a-guid-uuid-in-javascript/21963136#21963136 var lut = []; for ( var i = 0; i < 256; i ++ ) { lut[ i ] = ( i < 16 ? '0' : '' ) + ( i ).toString( 16 ); } return function generateUUID() { var d0 = Math.random() * 0xffffffff | 0; var d1 = Math.random() * 0xffffffff | 0; var d2 = Math.random() * 0xffffffff | 0; var d3 = Math.random() * 0xffffffff | 0; var uuid = lut[ d0 & 0xff ] + lut[ d0 >> 8 & 0xff ] + lut[ d0 >> 16 & 0xff ] + lut[ d0 >> 24 & 0xff ] + '-' + lut[ d1 & 0xff ] + lut[ d1 >> 8 & 0xff ] + '-' + lut[ d1 >> 16 & 0x0f | 0x40 ] + lut[ d1 >> 24 & 0xff ] + '-' + lut[ d2 & 0x3f | 0x80 ] + lut[ d2 >> 8 & 0xff ] + '-' + lut[ d2 >> 16 & 0xff ] + lut[ d2 >> 24 & 0xff ] + lut[ d3 & 0xff ] + lut[ d3 >> 8 & 0xff ] + lut[ d3 >> 16 & 0xff ] + lut[ d3 >> 24 & 0xff ]; // .toUpperCase() here flattens concatenated strings to save heap memory space. return uuid.toUpperCase(); }; } )(), clamp: function ( value, min, max ) { return Math.max( min, Math.min( max, value ) ); }, // compute euclidian modulo of m % n // https://en.wikipedia.org/wiki/Modulo_operation euclideanModulo: function ( n, m ) { return ( ( n % m ) + m ) % m; }, // Linear mapping from range to range mapLinear: function ( x, a1, a2, b1, b2 ) { return b1 + ( x - a1 ) * ( b2 - b1 ) / ( a2 - a1 ); }, // https://en.wikipedia.org/wiki/Linear_interpolation lerp: function ( x, y, t ) { return ( 1 - t ) * x + t * y; }, // http://en.wikipedia.org/wiki/Smoothstep smoothstep: function ( x, min, max ) { if ( x = max ) return 1; x = ( x - min ) / ( max - min ); return x * x * ( 3 - 2 * x ); }, smootherstep: function ( x, min, max ) { if ( x = max ) return 1; x = ( x - min ) / ( max - min ); return x * x * x * ( x * ( x * 6 - 15 ) + 10 ); }, // Random integer from interval randInt: function ( low, high ) { return low + Math.floor( Math.random() * ( high - low + 1 ) ); }, // Random float from interval randFloat: function ( low, high ) { return low + Math.random() * ( high - low ); }, // Random float from interval randFloatSpread: function ( range ) { return range * ( 0.5 - Math.random() ); }, degToRad: function ( degrees ) { return degrees * _Math.DEG2RAD; }, radToDeg: function ( radians ) { return radians * _Math.RAD2DEG; }, isPowerOfTwo: function ( value ) { return ( value & ( value - 1 ) ) === 0 && value !== 0; }, ceilPowerOfTwo: function ( value ) { return Math.pow( 2, Math.ceil( Math.log( value ) / Math.LN2 ) ); }, floorPowerOfTwo: function ( value ) { return Math.pow( 2, Math.floor( Math.log( value ) / Math.LN2 ) ); } }; /** * @author mrdoob / http://mrdoob.com/ * @author philogb / http://blog.thejit.org/ * @author egraether / http://egraether.com/ * @author zz85 / http://www.lab4games.net/zz85/blog */ function Vector2( x, y ) { this.x = x || 0; this.y = y || 0; } Object.defineProperties( Vector2.prototype, { \"width\": { get: function () { return this.x; }, set: function ( value ) { this.x = value; } }, \"height\": { get: function () { return this.y; }, set: function ( value ) { this.y = value; } } } ); Object.assign( Vector2.prototype, { isVector2: true, set: function ( x, y ) { this.x = x; this.y = y; return this; }, setScalar: function ( scalar ) { this.x = scalar; this.y = scalar; return this; }, setX: function ( x ) { this.x = x; return this; }, setY: function ( y ) { this.y = y; return this; }, setComponent: function ( index, value ) { switch ( index ) { case 0: this.x = value; break; case 1: this.y = value; break; default: throw new Error( 'index is out of range: ' + index ); } return this; }, getComponent: function ( index ) { switch ( index ) { case 0: return this.x; case 1: return this.y; default: throw new Error( 'index is out of range: ' + index ); } }, clone: function () { return new this.constructor( this.x, this.y ); }, copy: function ( v ) { this.x = v.x; this.y = v.y; return this; }, add: function ( v, w ) { if ( w !== undefined ) { console.warn( 'THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead.' ); return this.addVectors( v, w ); } this.x += v.x; this.y += v.y; return this; }, addScalar: function ( s ) { this.x += s; this.y += s; return this; }, addVectors: function ( a, b ) { this.x = a.x + b.x; this.y = a.y + b.y; return this; }, addScaledVector: function ( v, s ) { this.x += v.x * s; this.y += v.y * s; return this; }, sub: function ( v, w ) { if ( w !== undefined ) { console.warn( 'THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.' ); return this.subVectors( v, w ); } this.x -= v.x; this.y -= v.y; return this; }, subScalar: function ( s ) { this.x -= s; this.y -= s; return this; }, subVectors: function ( a, b ) { this.x = a.x - b.x; this.y = a.y - b.y; return this; }, multiply: function ( v ) { this.x *= v.x; this.y *= v.y; return this; }, multiplyScalar: function ( scalar ) { this.x *= scalar; this.y *= scalar; return this; }, divide: function ( v ) { this.x /= v.x; this.y /= v.y; return this; }, divideScalar: function ( scalar ) { return this.multiplyScalar( 1 / scalar ); }, applyMatrix3: function ( m ) { var x = this.x, y = this.y; var e = m.elements; this.x = e[ 0 ] * x + e[ 3 ] * y + e[ 6 ]; this.y = e[ 1 ] * x + e[ 4 ] * y + e[ 7 ]; return this; }, min: function ( v ) { this.x = Math.min( this.x, v.x ); this.y = Math.min( this.y, v.y ); return this; }, max: function ( v ) { this.x = Math.max( this.x, v.x ); this.y = Math.max( this.y, v.y ); return this; }, clamp: function ( min, max ) { // assumes min < max, componentwise this.x = Math.max( min.x, Math.min( max.x, this.x ) ); this.y = Math.max( min.y, Math.min( max.y, this.y ) ); return this; }, clampScalar: function () { var min = new Vector2(); var max = new Vector2(); return function clampScalar( minVal, maxVal ) { min.set( minVal, minVal ); max.set( maxVal, maxVal ); return this.clamp( min, max ); }; }(), clampLength: function ( min, max ) { var length = this.length(); return this.divideScalar( length || 1 ).multiplyScalar( Math.max( min, Math.min( max, length ) ) ); }, floor: function () { this.x = Math.floor( this.x ); this.y = Math.floor( this.y ); return this; }, ceil: function () { this.x = Math.ceil( this.x ); this.y = Math.ceil( this.y ); return this; }, round: function () { this.x = Math.round( this.x ); this.y = Math.round( this.y ); return this; }, roundToZero: function () { this.x = ( this.x < 0 ) ? Math.ceil( this.x ) : Math.floor( this.x ); this.y = ( this.y < 0 ) ? Math.ceil( this.y ) : Math.floor( this.y ); return this; }, negate: function () { this.x = - this.x; this.y = - this.y; return this; }, dot: function ( v ) { return this.x * v.x + this.y * v.y; }, cross: function ( v ) { return this.x * v.y - this.y * v.x; }, lengthSq: function () { return this.x * this.x + this.y * this.y; }, length: function () { return Math.sqrt( this.x * this.x + this.y * this.y ); }, manhattanLength: function () { return Math.abs( this.x ) + Math.abs( this.y ); }, normalize: function () { return this.divideScalar( this.length() || 1 ); }, angle: function () { // computes the angle in radians with respect to the positive x-axis var angle = Math.atan2( this.y, this.x ); if ( angle < 0 ) angle += 2 * Math.PI; return angle; }, distanceTo: function ( v ) { return Math.sqrt( this.distanceToSquared( v ) ); }, distanceToSquared: function ( v ) { var dx = this.x - v.x, dy = this.y - v.y; return dx * dx + dy * dy; }, manhattanDistanceTo: function ( v ) { return Math.abs( this.x - v.x ) + Math.abs( this.y - v.y ); }, setLength: function ( length ) { return this.normalize().multiplyScalar( length ); }, lerp: function ( v, alpha ) { this.x += ( v.x - this.x ) * alpha; this.y += ( v.y - this.y ) * alpha; return this; }, lerpVectors: function ( v1, v2, alpha ) { return this.subVectors( v2, v1 ).multiplyScalar( alpha ).add( v1 ); }, equals: function ( v ) { return ( ( v.x === this.x ) && ( v.y === this.y ) ); }, fromArray: function ( array, offset ) { if ( offset === undefined ) offset = 0; this.x = array[ offset ]; this.y = array[ offset + 1 ]; return this; }, toArray: function ( array, offset ) { if ( array === undefined ) array = []; if ( offset === undefined ) offset = 0; array[ offset ] = this.x; array[ offset + 1 ] = this.y; return array; }, fromBufferAttribute: function ( attribute, index, offset ) { if ( offset !== undefined ) { console.warn( 'THREE.Vector2: offset has been removed from .fromBufferAttribute().' ); } this.x = attribute.getX( index ); this.y = attribute.getY( index ); return this; }, rotateAround: function ( center, angle ) { var c = Math.cos( angle ), s = Math.sin( angle ); var x = this.x - center.x; var y = this.y - center.y; this.x = x * c - y * s + center.x; this.y = x * s + y * c + center.y; return this; } } ); /** * @author mrdoob / http://mrdoob.com/ * @author supereggbert / http://www.paulbrunt.co.uk/ * @author philogb / http://blog.thejit.org/ * @author jordi_ros / http://plattsoft.com * @author D1plo1d / http://github.com/D1plo1d * @author alteredq / http://alteredqualia.com/ * @author mikael emtinger / http://gomo.se/ * @author timknip / http://www.floorplanner.com/ * @author bhouston / http://clara.io * @author WestLangley / http://github.com/WestLangley */ function Matrix4() { this.elements = [ 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1 ]; if ( arguments.length > 0 ) { console.error( 'THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.' ); } } Object.assign( Matrix4.prototype, { isMatrix4: true, set: function ( n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44 ) { var te = this.elements; te[ 0 ] = n11; te[ 4 ] = n12; te[ 8 ] = n13; te[ 12 ] = n14; te[ 1 ] = n21; te[ 5 ] = n22; te[ 9 ] = n23; te[ 13 ] = n24; te[ 2 ] = n31; te[ 6 ] = n32; te[ 10 ] = n33; te[ 14 ] = n34; te[ 3 ] = n41; te[ 7 ] = n42; te[ 11 ] = n43; te[ 15 ] = n44; return this; }, identity: function () { this.set( 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1 ); return this; }, clone: function () { return new Matrix4().fromArray( this.elements ); }, copy: function ( m ) { var te = this.elements; var me = m.elements; te[ 0 ] = me[ 0 ]; te[ 1 ] = me[ 1 ]; te[ 2 ] = me[ 2 ]; te[ 3 ] = me[ 3 ]; te[ 4 ] = me[ 4 ]; te[ 5 ] = me[ 5 ]; te[ 6 ] = me[ 6 ]; te[ 7 ] = me[ 7 ]; te[ 8 ] = me[ 8 ]; te[ 9 ] = me[ 9 ]; te[ 10 ] = me[ 10 ]; te[ 11 ] = me[ 11 ]; te[ 12 ] = me[ 12 ]; te[ 13 ] = me[ 13 ]; te[ 14 ] = me[ 14 ]; te[ 15 ] = me[ 15 ]; return this; }, copyPosition: function ( m ) { var te = this.elements, me = m.elements; te[ 12 ] = me[ 12 ]; te[ 13 ] = me[ 13 ]; te[ 14 ] = me[ 14 ]; return this; }, extractBasis: function ( xAxis, yAxis, zAxis ) { xAxis.setFromMatrixColumn( this, 0 ); yAxis.setFromMatrixColumn( this, 1 ); zAxis.setFromMatrixColumn( this, 2 ); return this; }, makeBasis: function ( xAxis, yAxis, zAxis ) { this.set( xAxis.x, yAxis.x, zAxis.x, 0, xAxis.y, yAxis.y, zAxis.y, 0, xAxis.z, yAxis.z, zAxis.z, 0, 0, 0, 0, 1 ); return this; }, extractRotation: function () { var v1 = new Vector3(); return function extractRotation( m ) { // this method does not support reflection matrices var te = this.elements; var me = m.elements; var scaleX = 1 / v1.setFromMatrixColumn( m, 0 ).length(); var scaleY = 1 / v1.setFromMatrixColumn( m, 1 ).length(); var scaleZ = 1 / v1.setFromMatrixColumn( m, 2 ).length(); te[ 0 ] = me[ 0 ] * scaleX; te[ 1 ] = me[ 1 ] * scaleX; te[ 2 ] = me[ 2 ] * scaleX; te[ 3 ] = 0; te[ 4 ] = me[ 4 ] * scaleY; te[ 5 ] = me[ 5 ] * scaleY; te[ 6 ] = me[ 6 ] * scaleY; te[ 7 ] = 0; te[ 8 ] = me[ 8 ] * scaleZ; te[ 9 ] = me[ 9 ] * scaleZ; te[ 10 ] = me[ 10 ] * scaleZ; te[ 11 ] = 0; te[ 12 ] = 0; te[ 13 ] = 0; te[ 14 ] = 0; te[ 15 ] = 1; return this; }; }(), makeRotationFromEuler: function ( euler ) { if ( ! ( euler && euler.isEuler ) ) { console.error( 'THREE.Matrix4: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.' ); } var te = this.elements; var x = euler.x, y = euler.y, z = euler.z; var a = Math.cos( x ), b = Math.sin( x ); var c = Math.cos( y ), d = Math.sin( y ); var e = Math.cos( z ), f = Math.sin( z ); if ( euler.order === 'XYZ' ) { var ae = a * e, af = a * f, be = b * e, bf = b * f; te[ 0 ] = c * e; te[ 4 ] = - c * f; te[ 8 ] = d; te[ 1 ] = af + be * d; te[ 5 ] = ae - bf * d; te[ 9 ] = - b * c; te[ 2 ] = bf - ae * d; te[ 6 ] = be + af * d; te[ 10 ] = a * c; } else if ( euler.order === 'YXZ' ) { var ce = c * e, cf = c * f, de = d * e, df = d * f; te[ 0 ] = ce + df * b; te[ 4 ] = de * b - cf; te[ 8 ] = a * d; te[ 1 ] = a * f; te[ 5 ] = a * e; te[ 9 ] = - b; te[ 2 ] = cf * b - de; te[ 6 ] = df + ce * b; te[ 10 ] = a * c; } else if ( euler.order === 'ZXY' ) { var ce = c * e, cf = c * f, de = d * e, df = d * f; te[ 0 ] = ce - df * b; te[ 4 ] = - a * f; te[ 8 ] = de + cf * b; te[ 1 ] = cf + de * b; te[ 5 ] = a * e; te[ 9 ] = df - ce * b; te[ 2 ] = - a * d; te[ 6 ] = b; te[ 10 ] = a * c; } else if ( euler.order === 'ZYX' ) { var ae = a * e, af = a * f, be = b * e, bf = b * f; te[ 0 ] = c * e; te[ 4 ] = be * d - af; te[ 8 ] = ae * d + bf; te[ 1 ] = c * f; te[ 5 ] = bf * d + ae; te[ 9 ] = af * d - be; te[ 2 ] = - d; te[ 6 ] = b * c; te[ 10 ] = a * c; } else if ( euler.order === 'YZX' ) { var ac = a * c, ad = a * d, bc = b * c, bd = b * d; te[ 0 ] = c * e; te[ 4 ] = bd - ac * f; te[ 8 ] = bc * f + ad; te[ 1 ] = f; te[ 5 ] = a * e; te[ 9 ] = - b * e; te[ 2 ] = - d * e; te[ 6 ] = ad * f + bc; te[ 10 ] = ac - bd * f; } else if ( euler.order === 'XZY' ) { var ac = a * c, ad = a * d, bc = b * c, bd = b * d; te[ 0 ] = c * e; te[ 4 ] = - f; te[ 8 ] = d * e; te[ 1 ] = ac * f + bd; te[ 5 ] = a * e; te[ 9 ] = ad * f - bc; te[ 2 ] = bc * f - ad; te[ 6 ] = b * e; te[ 10 ] = bd * f + ac; } // bottom row te[ 3 ] = 0; te[ 7 ] = 0; te[ 11 ] = 0; // last column te[ 12 ] = 0; te[ 13 ] = 0; te[ 14 ] = 0; te[ 15 ] = 1; return this; }, makeRotationFromQuaternion: function () { var zero = new Vector3( 0, 0, 0 ); var one = new Vector3( 1, 1, 1 ); return function makeRotationFromQuaternion( q ) { return this.compose( zero, q, one ); }; }(), lookAt: function () { var x = new Vector3(); var y = new Vector3(); var z = new Vector3(); return function lookAt( eye, target, up ) { var te = this.elements; z.subVectors( eye, target ); if ( z.lengthSq() === 0 ) { // eye and target are in the same position z.z = 1; } z.normalize(); x.crossVectors( up, z ); if ( x.lengthSq() === 0 ) { // up and z are parallel if ( Math.abs( up.z ) === 1 ) { z.x += 0.0001; } else { z.z += 0.0001; } z.normalize(); x.crossVectors( up, z ); } x.normalize(); y.crossVectors( z, x ); te[ 0 ] = x.x; te[ 4 ] = y.x; te[ 8 ] = z.x; te[ 1 ] = x.y; te[ 5 ] = y.y; te[ 9 ] = z.y; te[ 2 ] = x.z; te[ 6 ] = y.z; te[ 10 ] = z.z; return this; }; }(), multiply: function ( m, n ) { if ( n !== undefined ) { console.warn( 'THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead.' ); return this.multiplyMatrices( m, n ); } return this.multiplyMatrices( this, m ); }, premultiply: function ( m ) { return this.multiplyMatrices( m, this ); }, multiplyMatrices: function ( a, b ) { var ae = a.elements; var be = b.elements; var te = this.elements; var a11 = ae[ 0 ], a12 = ae[ 4 ], a13 = ae[ 8 ], a14 = ae[ 12 ]; var a21 = ae[ 1 ], a22 = ae[ 5 ], a23 = ae[ 9 ], a24 = ae[ 13 ]; var a31 = ae[ 2 ], a32 = ae[ 6 ], a33 = ae[ 10 ], a34 = ae[ 14 ]; var a41 = ae[ 3 ], a42 = ae[ 7 ], a43 = ae[ 11 ], a44 = ae[ 15 ]; var b11 = be[ 0 ], b12 = be[ 4 ], b13 = be[ 8 ], b14 = be[ 12 ]; var b21 = be[ 1 ], b22 = be[ 5 ], b23 = be[ 9 ], b24 = be[ 13 ]; var b31 = be[ 2 ], b32 = be[ 6 ], b33 = be[ 10 ], b34 = be[ 14 ]; var b41 = be[ 3 ], b42 = be[ 7 ], b43 = be[ 11 ], b44 = be[ 15 ]; te[ 0 ] = a11 * b11 + a12 * b21 + a13 * b31 + a14 * b41; te[ 4 ] = a11 * b12 + a12 * b22 + a13 * b32 + a14 * b42; te[ 8 ] = a11 * b13 + a12 * b23 + a13 * b33 + a14 * b43; te[ 12 ] = a11 * b14 + a12 * b24 + a13 * b34 + a14 * b44; te[ 1 ] = a21 * b11 + a22 * b21 + a23 * b31 + a24 * b41; te[ 5 ] = a21 * b12 + a22 * b22 + a23 * b32 + a24 * b42; te[ 9 ] = a21 * b13 + a22 * b23 + a23 * b33 + a24 * b43; te[ 13 ] = a21 * b14 + a22 * b24 + a23 * b34 + a24 * b44; te[ 2 ] = a31 * b11 + a32 * b21 + a33 * b31 + a34 * b41; te[ 6 ] = a31 * b12 + a32 * b22 + a33 * b32 + a34 * b42; te[ 10 ] = a31 * b13 + a32 * b23 + a33 * b33 + a34 * b43; te[ 14 ] = a31 * b14 + a32 * b24 + a33 * b34 + a34 * b44; te[ 3 ] = a41 * b11 + a42 * b21 + a43 * b31 + a44 * b41; te[ 7 ] = a41 * b12 + a42 * b22 + a43 * b32 + a44 * b42; te[ 11 ] = a41 * b13 + a42 * b23 + a43 * b33 + a44 * b43; te[ 15 ] = a41 * b14 + a42 * b24 + a43 * b34 + a44 * b44; return this; }, multiplyScalar: function ( s ) { var te = this.elements; te[ 0 ] *= s; te[ 4 ] *= s; te[ 8 ] *= s; te[ 12 ] *= s; te[ 1 ] *= s; te[ 5 ] *= s; te[ 9 ] *= s; te[ 13 ] *= s; te[ 2 ] *= s; te[ 6 ] *= s; te[ 10 ] *= s; te[ 14 ] *= s; te[ 3 ] *= s; te[ 7 ] *= s; te[ 11 ] *= s; te[ 15 ] *= s; return this; }, applyToBufferAttribute: function () { var v1 = new Vector3(); return function applyToBufferAttribute( attribute ) { for ( var i = 0, l = attribute.count; i < l; i ++ ) { v1.x = attribute.getX( i ); v1.y = attribute.getY( i ); v1.z = attribute.getZ( i ); v1.applyMatrix4( this ); attribute.setXYZ( i, v1.x, v1.y, v1.z ); } return attribute; }; }(), determinant: function () { var te = this.elements; var n11 = te[ 0 ], n12 = te[ 4 ], n13 = te[ 8 ], n14 = te[ 12 ]; var n21 = te[ 1 ], n22 = te[ 5 ], n23 = te[ 9 ], n24 = te[ 13 ]; var n31 = te[ 2 ], n32 = te[ 6 ], n33 = te[ 10 ], n34 = te[ 14 ]; var n41 = te[ 3 ], n42 = te[ 7 ], n43 = te[ 11 ], n44 = te[ 15 ]; //TODO: make this more efficient //( based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm ) return ( n41 * ( + n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34 ) + n42 * ( + n11 * n23 * n34 - n11 * n24 * n33 + n14 * n21 * n33 - n13 * n21 * n34 + n13 * n24 * n31 - n14 * n23 * n31 ) + n43 * ( + n11 * n24 * n32 - n11 * n22 * n34 - n14 * n21 * n32 + n12 * n21 * n34 + n14 * n22 * n31 - n12 * n24 * n31 ) + n44 * ( - n13 * n22 * n31 - n11 * n23 * n32 + n11 * n22 * n33 + n13 * n21 * n32 - n12 * n21 * n33 + n12 * n23 * n31 ) ); }, transpose: function () { var te = this.elements; var tmp; tmp = te[ 1 ]; te[ 1 ] = te[ 4 ]; te[ 4 ] = tmp; tmp = te[ 2 ]; te[ 2 ] = te[ 8 ]; te[ 8 ] = tmp; tmp = te[ 6 ]; te[ 6 ] = te[ 9 ]; te[ 9 ] = tmp; tmp = te[ 3 ]; te[ 3 ] = te[ 12 ]; te[ 12 ] = tmp; tmp = te[ 7 ]; te[ 7 ] = te[ 13 ]; te[ 13 ] = tmp; tmp = te[ 11 ]; te[ 11 ] = te[ 14 ]; te[ 14 ] = tmp; return this; }, setPosition: function ( v ) { var te = this.elements; te[ 12 ] = v.x; te[ 13 ] = v.y; te[ 14 ] = v.z; return this; }, getInverse: function ( m, throwOnDegenerate ) { // based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm var te = this.elements, me = m.elements, n11 = me[ 0 ], n21 = me[ 1 ], n31 = me[ 2 ], n41 = me[ 3 ], n12 = me[ 4 ], n22 = me[ 5 ], n32 = me[ 6 ], n42 = me[ 7 ], n13 = me[ 8 ], n23 = me[ 9 ], n33 = me[ 10 ], n43 = me[ 11 ], n14 = me[ 12 ], n24 = me[ 13 ], n34 = me[ 14 ], n44 = me[ 15 ], t11 = n23 * n34 * n42 - n24 * n33 * n42 + n24 * n32 * n43 - n22 * n34 * n43 - n23 * n32 * n44 + n22 * n33 * n44, t12 = n14 * n33 * n42 - n13 * n34 * n42 - n14 * n32 * n43 + n12 * n34 * n43 + n13 * n32 * n44 - n12 * n33 * n44, t13 = n13 * n24 * n42 - n14 * n23 * n42 + n14 * n22 * n43 - n12 * n24 * n43 - n13 * n22 * n44 + n12 * n23 * n44, t14 = n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34; var det = n11 * t11 + n21 * t12 + n31 * t13 + n41 * t14; if ( det === 0 ) { var msg = \"THREE.Matrix4: .getInverse() can't invert matrix, determinant is 0\"; if ( throwOnDegenerate === true ) { throw new Error( msg ); } else { console.warn( msg ); } return this.identity(); } var detInv = 1 / det; te[ 0 ] = t11 * detInv; te[ 1 ] = ( n24 * n33 * n41 - n23 * n34 * n41 - n24 * n31 * n43 + n21 * n34 * n43 + n23 * n31 * n44 - n21 * n33 * n44 ) * detInv; te[ 2 ] = ( n22 * n34 * n41 - n24 * n32 * n41 + n24 * n31 * n42 - n21 * n34 * n42 - n22 * n31 * n44 + n21 * n32 * n44 ) * detInv; te[ 3 ] = ( n23 * n32 * n41 - n22 * n33 * n41 - n23 * n31 * n42 + n21 * n33 * n42 + n22 * n31 * n43 - n21 * n32 * n43 ) * detInv; te[ 4 ] = t12 * detInv; te[ 5 ] = ( n13 * n34 * n41 - n14 * n33 * n41 + n14 * n31 * n43 - n11 * n34 * n43 - n13 * n31 * n44 + n11 * n33 * n44 ) * detInv; te[ 6 ] = ( n14 * n32 * n41 - n12 * n34 * n41 - n14 * n31 * n42 + n11 * n34 * n42 + n12 * n31 * n44 - n11 * n32 * n44 ) * detInv; te[ 7 ] = ( n12 * n33 * n41 - n13 * n32 * n41 + n13 * n31 * n42 - n11 * n33 * n42 - n12 * n31 * n43 + n11 * n32 * n43 ) * detInv; te[ 8 ] = t13 * detInv; te[ 9 ] = ( n14 * n23 * n41 - n13 * n24 * n41 - n14 * n21 * n43 + n11 * n24 * n43 + n13 * n21 * n44 - n11 * n23 * n44 ) * detInv; te[ 10 ] = ( n12 * n24 * n41 - n14 * n22 * n41 + n14 * n21 * n42 - n11 * n24 * n42 - n12 * n21 * n44 + n11 * n22 * n44 ) * detInv; te[ 11 ] = ( n13 * n22 * n41 - n12 * n23 * n41 - n13 * n21 * n42 + n11 * n23 * n42 + n12 * n21 * n43 - n11 * n22 * n43 ) * detInv; te[ 12 ] = t14 * detInv; te[ 13 ] = ( n13 * n24 * n31 - n14 * n23 * n31 + n14 * n21 * n33 - n11 * n24 * n33 - n13 * n21 * n34 + n11 * n23 * n34 ) * detInv; te[ 14 ] = ( n14 * n22 * n31 - n12 * n24 * n31 - n14 * n21 * n32 + n11 * n24 * n32 + n12 * n21 * n34 - n11 * n22 * n34 ) * detInv; te[ 15 ] = ( n12 * n23 * n31 - n13 * n22 * n31 + n13 * n21 * n32 - n11 * n23 * n32 - n12 * n21 * n33 + n11 * n22 * n33 ) * detInv; return this; }, scale: function ( v ) { var te = this.elements; var x = v.x, y = v.y, z = v.z; te[ 0 ] *= x; te[ 4 ] *= y; te[ 8 ] *= z; te[ 1 ] *= x; te[ 5 ] *= y; te[ 9 ] *= z; te[ 2 ] *= x; te[ 6 ] *= y; te[ 10 ] *= z; te[ 3 ] *= x; te[ 7 ] *= y; te[ 11 ] *= z; return this; }, getMaxScaleOnAxis: function () { var te = this.elements; var scaleXSq = te[ 0 ] * te[ 0 ] + te[ 1 ] * te[ 1 ] + te[ 2 ] * te[ 2 ]; var scaleYSq = te[ 4 ] * te[ 4 ] + te[ 5 ] * te[ 5 ] + te[ 6 ] * te[ 6 ]; var scaleZSq = te[ 8 ] * te[ 8 ] + te[ 9 ] * te[ 9 ] + te[ 10 ] * te[ 10 ]; return Math.sqrt( Math.max( scaleXSq, scaleYSq, scaleZSq ) ); }, makeTranslation: function ( x, y, z ) { this.set( 1, 0, 0, x, 0, 1, 0, y, 0, 0, 1, z, 0, 0, 0, 1 ); return this; }, makeRotationX: function ( theta ) { var c = Math.cos( theta ), s = Math.sin( theta ); this.set( 1, 0, 0, 0, 0, c, - s, 0, 0, s, c, 0, 0, 0, 0, 1 ); return this; }, makeRotationY: function ( theta ) { var c = Math.cos( theta ), s = Math.sin( theta ); this.set( c, 0, s, 0, 0, 1, 0, 0, - s, 0, c, 0, 0, 0, 0, 1 ); return this; }, makeRotationZ: function ( theta ) { var c = Math.cos( theta ), s = Math.sin( theta ); this.set( c, - s, 0, 0, s, c, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1 ); return this; }, makeRotationAxis: function ( axis, angle ) { // Based on http://www.gamedev.net/reference/articles/article1199.asp var c = Math.cos( angle ); var s = Math.sin( angle ); var t = 1 - c; var x = axis.x, y = axis.y, z = axis.z; var tx = t * x, ty = t * y; this.set( tx * x + c, tx * y - s * z, tx * z + s * y, 0, tx * y + s * z, ty * y + c, ty * z - s * x, 0, tx * z - s * y, ty * z + s * x, t * z * z + c, 0, 0, 0, 0, 1 ); return this; }, makeScale: function ( x, y, z ) { this.set( x, 0, 0, 0, 0, y, 0, 0, 0, 0, z, 0, 0, 0, 0, 1 ); return this; }, makeShear: function ( x, y, z ) { this.set( 1, y, z, 0, x, 1, z, 0, x, y, 1, 0, 0, 0, 0, 1 ); return this; }, compose: function ( position, quaternion, scale ) { var te = this.elements; var x = quaternion._x, y = quaternion._y, z = quaternion._z, w = quaternion._w; var x2 = x + x, y2 = y + y, z2 = z + z; var xx = x * x2, xy = x * y2, xz = x * z2; var yy = y * y2, yz = y * z2, zz = z * z2; var wx = w * x2, wy = w * y2, wz = w * z2; var sx = scale.x, sy = scale.y, sz = scale.z; te[ 0 ] = ( 1 - ( yy + zz ) ) * sx; te[ 1 ] = ( xy + wz ) * sx; te[ 2 ] = ( xz - wy ) * sx; te[ 3 ] = 0; te[ 4 ] = ( xy - wz ) * sy; te[ 5 ] = ( 1 - ( xx + zz ) ) * sy; te[ 6 ] = ( yz + wx ) * sy; te[ 7 ] = 0; te[ 8 ] = ( xz + wy ) * sz; te[ 9 ] = ( yz - wx ) * sz; te[ 10 ] = ( 1 - ( xx + yy ) ) * sz; te[ 11 ] = 0; te[ 12 ] = position.x; te[ 13 ] = position.y; te[ 14 ] = position.z; te[ 15 ] = 1; return this; }, decompose: function () { var vector = new Vector3(); var matrix = new Matrix4(); return function decompose( position, quaternion, scale ) { var te = this.elements; var sx = vector.set( te[ 0 ], te[ 1 ], te[ 2 ] ).length(); var sy = vector.set( te[ 4 ], te[ 5 ], te[ 6 ] ).length(); var sz = vector.set( te[ 8 ], te[ 9 ], te[ 10 ] ).length(); // if determine is negative, we need to invert one scale var det = this.determinant(); if ( det < 0 ) sx = - sx; position.x = te[ 12 ]; position.y = te[ 13 ]; position.z = te[ 14 ]; // scale the rotation part matrix.copy( this ); var invSX = 1 / sx; var invSY = 1 / sy; var invSZ = 1 / sz; matrix.elements[ 0 ] *= invSX; matrix.elements[ 1 ] *= invSX; matrix.elements[ 2 ] *= invSX; matrix.elements[ 4 ] *= invSY; matrix.elements[ 5 ] *= invSY; matrix.elements[ 6 ] *= invSY; matrix.elements[ 8 ] *= invSZ; matrix.elements[ 9 ] *= invSZ; matrix.elements[ 10 ] *= invSZ; quaternion.setFromRotationMatrix( matrix ); scale.x = sx; scale.y = sy; scale.z = sz; return this; }; }(), makePerspective: function ( left, right, top, bottom, near, far ) { if ( far === undefined ) { console.warn( 'THREE.Matrix4: .makePerspective() has been redefined and has a new signature. Please check the docs.' ); } var te = this.elements; var x = 2 * near / ( right - left ); var y = 2 * near / ( top - bottom ); var a = ( right + left ) / ( right - left ); var b = ( top + bottom ) / ( top - bottom ); var c = - ( far + near ) / ( far - near ); var d = - 2 * far * near / ( far - near ); te[ 0 ] = x; te[ 4 ] = 0; te[ 8 ] = a; te[ 12 ] = 0; te[ 1 ] = 0; te[ 5 ] = y; te[ 9 ] = b; te[ 13 ] = 0; te[ 2 ] = 0; te[ 6 ] = 0; te[ 10 ] = c; te[ 14 ] = d; te[ 3 ] = 0; te[ 7 ] = 0; te[ 11 ] = - 1; te[ 15 ] = 0; return this; }, makeOrthographic: function ( left, right, top, bottom, near, far ) { var te = this.elements; var w = 1.0 / ( right - left ); var h = 1.0 / ( top - bottom ); var p = 1.0 / ( far - near ); var x = ( right + left ) * w; var y = ( top + bottom ) * h; var z = ( far + near ) * p; te[ 0 ] = 2 * w; te[ 4 ] = 0; te[ 8 ] = 0; te[ 12 ] = - x; te[ 1 ] = 0; te[ 5 ] = 2 * h; te[ 9 ] = 0; te[ 13 ] = - y; te[ 2 ] = 0; te[ 6 ] = 0; te[ 10 ] = - 2 * p; te[ 14 ] = - z; te[ 3 ] = 0; te[ 7 ] = 0; te[ 11 ] = 0; te[ 15 ] = 1; return this; }, equals: function ( matrix ) { var te = this.elements; var me = matrix.elements; for ( var i = 0; i < 16; i ++ ) { if ( te[ i ] !== me[ i ] ) return false; } return true; }, fromArray: function ( array, offset ) { if ( offset === undefined ) offset = 0; for ( var i = 0; i < 16; i ++ ) { this.elements[ i ] = array[ i + offset ]; } return this; }, toArray: function ( array, offset ) { if ( array === undefined ) array = []; if ( offset === undefined ) offset = 0; var te = this.elements; array[ offset ] = te[ 0 ]; array[ offset + 1 ] = te[ 1 ]; array[ offset + 2 ] = te[ 2 ]; array[ offset + 3 ] = te[ 3 ]; array[ offset + 4 ] = te[ 4 ]; array[ offset + 5 ] = te[ 5 ]; array[ offset + 6 ] = te[ 6 ]; array[ offset + 7 ] = te[ 7 ]; array[ offset + 8 ] = te[ 8 ]; array[ offset + 9 ] = te[ 9 ]; array[ offset + 10 ] = te[ 10 ]; array[ offset + 11 ] = te[ 11 ]; array[ offset + 12 ] = te[ 12 ]; array[ offset + 13 ] = te[ 13 ]; array[ offset + 14 ] = te[ 14 ]; array[ offset + 15 ] = te[ 15 ]; return array; } } ); /** * @author mikael emtinger / http://gomo.se/ * @author alteredq / http://alteredqualia.com/ * @author WestLangley / http://github.com/WestLangley * @author bhouston / http://clara.io */ function Quaternion( x, y, z, w ) { this._x = x || 0; this._y = y || 0; this._z = z || 0; this._w = ( w !== undefined ) ? w : 1; } Object.assign( Quaternion, { slerp: function ( qa, qb, qm, t ) { return qm.copy( qa ).slerp( qb, t ); }, slerpFlat: function ( dst, dstOffset, src0, srcOffset0, src1, srcOffset1, t ) { // fuzz-free, array-based Quaternion SLERP operation var x0 = src0[ srcOffset0 + 0 ], y0 = src0[ srcOffset0 + 1 ], z0 = src0[ srcOffset0 + 2 ], w0 = src0[ srcOffset0 + 3 ], x1 = src1[ srcOffset1 + 0 ], y1 = src1[ srcOffset1 + 1 ], z1 = src1[ srcOffset1 + 2 ], w1 = src1[ srcOffset1 + 3 ]; if ( w0 !== w1 || x0 !== x1 || y0 !== y1 || z0 !== z1 ) { var s = 1 - t, cos = x0 * x1 + y0 * y1 + z0 * z1 + w0 * w1, dir = ( cos >= 0 ? 1 : - 1 ), sqrSin = 1 - cos * cos; // Skip the Slerp for tiny steps to avoid numeric problems: if ( sqrSin > Number.EPSILON ) { var sin = Math.sqrt( sqrSin ), len = Math.atan2( sin, cos * dir ); s = Math.sin( s * len ) / sin; t = Math.sin( t * len ) / sin; } var tDir = t * dir; x0 = x0 * s + x1 * tDir; y0 = y0 * s + y1 * tDir; z0 = z0 * s + z1 * tDir; w0 = w0 * s + w1 * tDir; // Normalize in case we just did a lerp: if ( s === 1 - t ) { var f = 1 / Math.sqrt( x0 * x0 + y0 * y0 + z0 * z0 + w0 * w0 ); x0 *= f; y0 *= f; z0 *= f; w0 *= f; } } dst[ dstOffset ] = x0; dst[ dstOffset + 1 ] = y0; dst[ dstOffset + 2 ] = z0; dst[ dstOffset + 3 ] = w0; } } ); Object.defineProperties( Quaternion.prototype, { x: { get: function () { return this._x; }, set: function ( value ) { this._x = value; this.onChangeCallback(); } }, y: { get: function () { return this._y; }, set: function ( value ) { this._y = value; this.onChangeCallback(); } }, z: { get: function () { return this._z; }, set: function ( value ) { this._z = value; this.onChangeCallback(); } }, w: { get: function () { return this._w; }, set: function ( value ) { this._w = value; this.onChangeCallback(); } } } ); Object.assign( Quaternion.prototype, { isQuaternion: true, set: function ( x, y, z, w ) { this._x = x; this._y = y; this._z = z; this._w = w; this.onChangeCallback(); return this; }, clone: function () { return new this.constructor( this._x, this._y, this._z, this._w ); }, copy: function ( quaternion ) { this._x = quaternion.x; this._y = quaternion.y; this._z = quaternion.z; this._w = quaternion.w; this.onChangeCallback(); return this; }, setFromEuler: function ( euler, update ) { if ( ! ( euler && euler.isEuler ) ) { throw new Error( 'THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order.' ); } var x = euler._x, y = euler._y, z = euler._z, order = euler.order; // http://www.mathworks.com/matlabcentral/fileexchange/ // 20696-function-to-convert-between-dcm-euler-angles-quaternions-and-euler-vectors/ // content/SpinCalc.m var cos = Math.cos; var sin = Math.sin; var c1 = cos( x / 2 ); var c2 = cos( y / 2 ); var c3 = cos( z / 2 ); var s1 = sin( x / 2 ); var s2 = sin( y / 2 ); var s3 = sin( z / 2 ); if ( order === 'XYZ' ) { this._x = s1 * c2 * c3 + c1 * s2 * s3; this._y = c1 * s2 * c3 - s1 * c2 * s3; this._z = c1 * c2 * s3 + s1 * s2 * c3; this._w = c1 * c2 * c3 - s1 * s2 * s3; } else if ( order === 'YXZ' ) { this._x = s1 * c2 * c3 + c1 * s2 * s3; this._y = c1 * s2 * c3 - s1 * c2 * s3; this._z = c1 * c2 * s3 - s1 * s2 * c3; this._w = c1 * c2 * c3 + s1 * s2 * s3; } else if ( order === 'ZXY' ) { this._x = s1 * c2 * c3 - c1 * s2 * s3; this._y = c1 * s2 * c3 + s1 * c2 * s3; this._z = c1 * c2 * s3 + s1 * s2 * c3; this._w = c1 * c2 * c3 - s1 * s2 * s3; } else if ( order === 'ZYX' ) { this._x = s1 * c2 * c3 - c1 * s2 * s3; this._y = c1 * s2 * c3 + s1 * c2 * s3; this._z = c1 * c2 * s3 - s1 * s2 * c3; this._w = c1 * c2 * c3 + s1 * s2 * s3; } else if ( order === 'YZX' ) { this._x = s1 * c2 * c3 + c1 * s2 * s3; this._y = c1 * s2 * c3 + s1 * c2 * s3; this._z = c1 * c2 * s3 - s1 * s2 * c3; this._w = c1 * c2 * c3 - s1 * s2 * s3; } else if ( order === 'XZY' ) { this._x = s1 * c2 * c3 - c1 * s2 * s3; this._y = c1 * s2 * c3 - s1 * c2 * s3; this._z = c1 * c2 * s3 + s1 * s2 * c3; this._w = c1 * c2 * c3 + s1 * s2 * s3; } if ( update !== false ) this.onChangeCallback(); return this; }, setFromAxisAngle: function ( axis, angle ) { // http://www.euclideanspace.com/maths/geometry/rotations/conversions/angleToQuaternion/index.htm // assumes axis is normalized var halfAngle = angle / 2, s = Math.sin( halfAngle ); this._x = axis.x * s; this._y = axis.y * s; this._z = axis.z * s; this._w = Math.cos( halfAngle ); this.onChangeCallback(); return this; }, setFromRotationMatrix: function ( m ) { // http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToQuaternion/index.htm // assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled) var te = m.elements, m11 = te[ 0 ], m12 = te[ 4 ], m13 = te[ 8 ], m21 = te[ 1 ], m22 = te[ 5 ], m23 = te[ 9 ], m31 = te[ 2 ], m32 = te[ 6 ], m33 = te[ 10 ], trace = m11 + m22 + m33, s; if ( trace > 0 ) { s = 0.5 / Math.sqrt( trace + 1.0 ); this._w = 0.25 / s; this._x = ( m32 - m23 ) * s; this._y = ( m13 - m31 ) * s; this._z = ( m21 - m12 ) * s; } else if ( m11 > m22 && m11 > m33 ) { s = 2.0 * Math.sqrt( 1.0 + m11 - m22 - m33 ); this._w = ( m32 - m23 ) / s; this._x = 0.25 * s; this._y = ( m12 + m21 ) / s; this._z = ( m13 + m31 ) / s; } else if ( m22 > m33 ) { s = 2.0 * Math.sqrt( 1.0 + m22 - m11 - m33 ); this._w = ( m13 - m31 ) / s; this._x = ( m12 + m21 ) / s; this._y = 0.25 * s; this._z = ( m23 + m32 ) / s; } else { s = 2.0 * Math.sqrt( 1.0 + m33 - m11 - m22 ); this._w = ( m21 - m12 ) / s; this._x = ( m13 + m31 ) / s; this._y = ( m23 + m32 ) / s; this._z = 0.25 * s; } this.onChangeCallback(); return this; }, setFromUnitVectors: function () { // assumes direction vectors vFrom and vTo are normalized var v1 = new Vector3(); var r; var EPS = 0.000001; return function setFromUnitVectors( vFrom, vTo ) { if ( v1 === undefined ) v1 = new Vector3(); r = vFrom.dot( vTo ) + 1; if ( r < EPS ) { r = 0; if ( Math.abs( vFrom.x ) > Math.abs( vFrom.z ) ) { v1.set( - vFrom.y, vFrom.x, 0 ); } else { v1.set( 0, - vFrom.z, vFrom.y ); } } else { v1.crossVectors( vFrom, vTo ); } this._x = v1.x; this._y = v1.y; this._z = v1.z; this._w = r; return this.normalize(); }; }(), angleTo: function ( q ) { return 2 * Math.acos( Math.abs( _Math.clamp( this.dot( q ), - 1, 1 ) ) ); }, rotateTowards: function ( q, step ) { var angle = this.angleTo( q ); if ( angle === 0 ) return this; var t = Math.min( 1, step / angle ); this.slerp( q, t ); return this; }, inverse: function () { // quaternion is assumed to have unit length return this.conjugate(); }, conjugate: function () { this._x *= - 1; this._y *= - 1; this._z *= - 1; this.onChangeCallback(); return this; }, dot: function ( v ) { return this._x * v._x + this._y * v._y + this._z * v._z + this._w * v._w; }, lengthSq: function () { return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w; }, length: function () { return Math.sqrt( this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w ); }, normalize: function () { var l = this.length(); if ( l === 0 ) { this._x = 0; this._y = 0; this._z = 0; this._w = 1; } else { l = 1 / l; this._x = this._x * l; this._y = this._y * l; this._z = this._z * l; this._w = this._w * l; } this.onChangeCallback(); return this; }, multiply: function ( q, p ) { if ( p !== undefined ) { console.warn( 'THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead.' ); return this.multiplyQuaternions( q, p ); } return this.multiplyQuaternions( this, q ); }, premultiply: function ( q ) { return this.multiplyQuaternions( q, this ); }, multiplyQuaternions: function ( a, b ) { // from http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/code/index.htm var qax = a._x, qay = a._y, qaz = a._z, qaw = a._w; var qbx = b._x, qby = b._y, qbz = b._z, qbw = b._w; this._x = qax * qbw + qaw * qbx + qay * qbz - qaz * qby; this._y = qay * qbw + qaw * qby + qaz * qbx - qax * qbz; this._z = qaz * qbw + qaw * qbz + qax * qby - qay * qbx; this._w = qaw * qbw - qax * qbx - qay * qby - qaz * qbz; this.onChangeCallback(); return this; }, slerp: function ( qb, t ) { if ( t === 0 ) return this; if ( t === 1 ) return this.copy( qb ); var x = this._x, y = this._y, z = this._z, w = this._w; // http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/slerp/ var cosHalfTheta = w * qb._w + x * qb._x + y * qb._y + z * qb._z; if ( cosHalfTheta < 0 ) { this._w = - qb._w; this._x = - qb._x; this._y = - qb._y; this._z = - qb._z; cosHalfTheta = - cosHalfTheta; } else { this.copy( qb ); } if ( cosHalfTheta >= 1.0 ) { this._w = w; this._x = x; this._y = y; this._z = z; return this; } var sqrSinHalfTheta = 1.0 - cosHalfTheta * cosHalfTheta; if ( sqrSinHalfTheta 0 ) { console.error( 'THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.' ); } } Object.assign( Matrix3.prototype, { isMatrix3: true, set: function ( n11, n12, n13, n21, n22, n23, n31, n32, n33 ) { var te = this.elements; te[ 0 ] = n11; te[ 1 ] = n21; te[ 2 ] = n31; te[ 3 ] = n12; te[ 4 ] = n22; te[ 5 ] = n32; te[ 6 ] = n13; te[ 7 ] = n23; te[ 8 ] = n33; return this; }, identity: function () { this.set( 1, 0, 0, 0, 1, 0, 0, 0, 1 ); return this; }, clone: function () { return new this.constructor().fromArray( this.elements ); }, copy: function ( m ) { var te = this.elements; var me = m.elements; te[ 0 ] = me[ 0 ]; te[ 1 ] = me[ 1 ]; te[ 2 ] = me[ 2 ]; te[ 3 ] = me[ 3 ]; te[ 4 ] = me[ 4 ]; te[ 5 ] = me[ 5 ]; te[ 6 ] = me[ 6 ]; te[ 7 ] = me[ 7 ]; te[ 8 ] = me[ 8 ]; return this; }, setFromMatrix4: function ( m ) { var me = m.elements; this.set( me[ 0 ], me[ 4 ], me[ 8 ], me[ 1 ], me[ 5 ], me[ 9 ], me[ 2 ], me[ 6 ], me[ 10 ] ); return this; }, applyToBufferAttribute: function () { var v1 = new Vector3(); return function applyToBufferAttribute( attribute ) { for ( var i = 0, l = attribute.count; i < l; i ++ ) { v1.x = attribute.getX( i ); v1.y = attribute.getY( i ); v1.z = attribute.getZ( i ); v1.applyMatrix3( this ); attribute.setXYZ( i, v1.x, v1.y, v1.z ); } return attribute; }; }(), multiply: function ( m ) { return this.multiplyMatrices( this, m ); }, premultiply: function ( m ) { return this.multiplyMatrices( m, this ); }, multiplyMatrices: function ( a, b ) { var ae = a.elements; var be = b.elements; var te = this.elements; var a11 = ae[ 0 ], a12 = ae[ 3 ], a13 = ae[ 6 ]; var a21 = ae[ 1 ], a22 = ae[ 4 ], a23 = ae[ 7 ]; var a31 = ae[ 2 ], a32 = ae[ 5 ], a33 = ae[ 8 ]; var b11 = be[ 0 ], b12 = be[ 3 ], b13 = be[ 6 ]; var b21 = be[ 1 ], b22 = be[ 4 ], b23 = be[ 7 ]; var b31 = be[ 2 ], b32 = be[ 5 ], b33 = be[ 8 ]; te[ 0 ] = a11 * b11 + a12 * b21 + a13 * b31; te[ 3 ] = a11 * b12 + a12 * b22 + a13 * b32; te[ 6 ] = a11 * b13 + a12 * b23 + a13 * b33; te[ 1 ] = a21 * b11 + a22 * b21 + a23 * b31; te[ 4 ] = a21 * b12 + a22 * b22 + a23 * b32; te[ 7 ] = a21 * b13 + a22 * b23 + a23 * b33; te[ 2 ] = a31 * b11 + a32 * b21 + a33 * b31; te[ 5 ] = a31 * b12 + a32 * b22 + a33 * b32; te[ 8 ] = a31 * b13 + a32 * b23 + a33 * b33; return this; }, multiplyScalar: function ( s ) { var te = this.elements; te[ 0 ] *= s; te[ 3 ] *= s; te[ 6 ] *= s; te[ 1 ] *= s; te[ 4 ] *= s; te[ 7 ] *= s; te[ 2 ] *= s; te[ 5 ] *= s; te[ 8 ] *= s; return this; }, determinant: function () { var te = this.elements; var a = te[ 0 ], b = te[ 1 ], c = te[ 2 ], d = te[ 3 ], e = te[ 4 ], f = te[ 5 ], g = te[ 6 ], h = te[ 7 ], i = te[ 8 ]; return a * e * i - a * f * h - b * d * i + b * f * g + c * d * h - c * e * g; }, getInverse: function ( matrix, throwOnDegenerate ) { if ( matrix && matrix.isMatrix4 ) { console.error( \"THREE.Matrix3: .getInverse() no longer takes a Matrix4 argument.\" ); } var me = matrix.elements, te = this.elements, n11 = me[ 0 ], n21 = me[ 1 ], n31 = me[ 2 ], n12 = me[ 3 ], n22 = me[ 4 ], n32 = me[ 5 ], n13 = me[ 6 ], n23 = me[ 7 ], n33 = me[ 8 ], t11 = n33 * n22 - n32 * n23, t12 = n32 * n13 - n33 * n12, t13 = n23 * n12 - n22 * n13, det = n11 * t11 + n21 * t12 + n31 * t13; if ( det === 0 ) { var msg = \"THREE.Matrix3: .getInverse() can't invert matrix, determinant is 0\"; if ( throwOnDegenerate === true ) { throw new Error( msg ); } else { console.warn( msg ); } return this.identity(); } var detInv = 1 / det; te[ 0 ] = t11 * detInv; te[ 1 ] = ( n31 * n23 - n33 * n21 ) * detInv; te[ 2 ] = ( n32 * n21 - n31 * n22 ) * detInv; te[ 3 ] = t12 * detInv; te[ 4 ] = ( n33 * n11 - n31 * n13 ) * detInv; te[ 5 ] = ( n31 * n12 - n32 * n11 ) * detInv; te[ 6 ] = t13 * detInv; te[ 7 ] = ( n21 * n13 - n23 * n11 ) * detInv; te[ 8 ] = ( n22 * n11 - n21 * n12 ) * detInv; return this; }, transpose: function () { var tmp, m = this.elements; tmp = m[ 1 ]; m[ 1 ] = m[ 3 ]; m[ 3 ] = tmp; tmp = m[ 2 ]; m[ 2 ] = m[ 6 ]; m[ 6 ] = tmp; tmp = m[ 5 ]; m[ 5 ] = m[ 7 ]; m[ 7 ] = tmp; return this; }, getNormalMatrix: function ( matrix4 ) { return this.setFromMatrix4( matrix4 ).getInverse( this ).transpose(); }, transposeIntoArray: function ( r ) { var m = this.elements; r[ 0 ] = m[ 0 ]; r[ 1 ] = m[ 3 ]; r[ 2 ] = m[ 6 ]; r[ 3 ] = m[ 1 ]; r[ 4 ] = m[ 4 ]; r[ 5 ] = m[ 7 ]; r[ 6 ] = m[ 2 ]; r[ 7 ] = m[ 5 ]; r[ 8 ] = m[ 8 ]; return this; }, setUvTransform: function ( tx, ty, sx, sy, rotation, cx, cy ) { var c = Math.cos( rotation ); var s = Math.sin( rotation ); this.set( sx * c, sx * s, - sx * ( c * cx + s * cy ) + cx + tx, - sy * s, sy * c, - sy * ( - s * cx + c * cy ) + cy + ty, 0, 0, 1 ); }, scale: function ( sx, sy ) { var te = this.elements; te[ 0 ] *= sx; te[ 3 ] *= sx; te[ 6 ] *= sx; te[ 1 ] *= sy; te[ 4 ] *= sy; te[ 7 ] *= sy; return this; }, rotate: function ( theta ) { var c = Math.cos( theta ); var s = Math.sin( theta ); var te = this.elements; var a11 = te[ 0 ], a12 = te[ 3 ], a13 = te[ 6 ]; var a21 = te[ 1 ], a22 = te[ 4 ], a23 = te[ 7 ]; te[ 0 ] = c * a11 + s * a21; te[ 3 ] = c * a12 + s * a22; te[ 6 ] = c * a13 + s * a23; te[ 1 ] = - s * a11 + c * a21; te[ 4 ] = - s * a12 + c * a22; te[ 7 ] = - s * a13 + c * a23; return this; }, translate: function ( tx, ty ) { var te = this.elements; te[ 0 ] += tx * te[ 2 ]; te[ 3 ] += tx * te[ 5 ]; te[ 6 ] += tx * te[ 8 ]; te[ 1 ] += ty * te[ 2 ]; te[ 4 ] += ty * te[ 5 ]; te[ 7 ] += ty * te[ 8 ]; return this; }, equals: function ( matrix ) { var te = this.elements; var me = matrix.elements; for ( var i = 0; i < 9; i ++ ) { if ( te[ i ] !== me[ i ] ) return false; } return true; }, fromArray: function ( array, offset ) { if ( offset === undefined ) offset = 0; for ( var i = 0; i < 9; i ++ ) { this.elements[ i ] = array[ i + offset ]; } return this; }, toArray: function ( array, offset ) { if ( array === undefined ) array = []; if ( offset === undefined ) offset = 0; var te = this.elements; array[ offset ] = te[ 0 ]; array[ offset + 1 ] = te[ 1 ]; array[ offset + 2 ] = te[ 2 ]; array[ offset + 3 ] = te[ 3 ]; array[ offset + 4 ] = te[ 4 ]; array[ offset + 5 ] = te[ 5 ]; array[ offset + 6 ] = te[ 6 ]; array[ offset + 7 ] = te[ 7 ]; array[ offset + 8 ] = te[ 8 ]; return array; } } ); /** * @author mrdoob / http://mrdoob.com/ * @author alteredq / http://alteredqualia.com/ * @author szimek / https://github.com/szimek/ */ var _canvas; var ImageUtils = { getDataURL: function ( image ) { var canvas; if ( typeof HTMLCanvasElement == 'undefined' ) { return image.src; } else if ( image instanceof HTMLCanvasElement ) { canvas = image; } else { if ( _canvas === undefined ) _canvas = document.createElementNS( 'http://www.w3.org/1999/xhtml', 'canvas' ); _canvas.width = image.width; _canvas.height = image.height; var context = _canvas.getContext( '2d' ); if ( image instanceof ImageData ) { context.putImageData( image, 0, 0 ); } else { context.drawImage( image, 0, 0, image.width, image.height ); } canvas = _canvas; } if ( canvas.width > 2048 || canvas.height > 2048 ) { return canvas.toDataURL( 'image/jpeg', 0.6 ); } else { return canvas.toDataURL( 'image/png' ); } } }; /** * @author mrdoob / http://mrdoob.com/ * @author alteredq / http://alteredqualia.com/ * @author szimek / https://github.com/szimek/ */ var textureId = 0; function Texture( image, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding ) { Object.defineProperty( this, 'id', { value: textureId ++ } ); this.uuid = _Math.generateUUID(); this.name = ''; this.image = image !== undefined ? image : Texture.DEFAULT_IMAGE; this.mipmaps = []; this.mapping = mapping !== undefined ? mapping : Texture.DEFAULT_MAPPING; this.wrapS = wrapS !== undefined ? wrapS : ClampToEdgeWrapping; this.wrapT = wrapT !== undefined ? wrapT : ClampToEdgeWrapping; this.magFilter = magFilter !== undefined ? magFilter : LinearFilter; this.minFilter = minFilter !== undefined ? minFilter : LinearMipMapLinearFilter; this.anisotropy = anisotropy !== undefined ? anisotropy : 1; this.format = format !== undefined ? format : RGBAFormat; this.type = type !== undefined ? type : UnsignedByteType; this.offset = new Vector2( 0, 0 ); this.repeat = new Vector2( 1, 1 ); this.center = new Vector2( 0, 0 ); this.rotation = 0; this.matrixAutoUpdate = true; this.matrix = new Matrix3(); this.generateMipmaps = true; this.premultiplyAlpha = false; this.flipY = true; this.unpackAlignment = 4; // valid values: 1, 2, 4, 8 (see http://www.khronos.org/opengles/sdk/docs/man/xhtml/glPixelStorei.xml) // Values of encoding !== THREE.LinearEncoding only supported on map, envMap and emissiveMap. // // Also changing the encoding after already used by a Material will not automatically make the Material // update. You need to explicitly call Material.needsUpdate to trigger it to recompile. this.encoding = encoding !== undefined ? encoding : LinearEncoding; this.version = 0; this.onUpdate = null; } Texture.DEFAULT_IMAGE = undefined; Texture.DEFAULT_MAPPING = UVMapping; Texture.prototype = Object.assign( Object.create( EventDispatcher.prototype ), { constructor: Texture, isTexture: true, updateMatrix: function () { this.matrix.setUvTransform( this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y ); }, clone: function () { return new this.constructor().copy( this ); }, copy: function ( source ) { this.name = source.name; this.image = source.image; this.mipmaps = source.mipmaps.slice( 0 ); this.mapping = source.mapping; this.wrapS = source.wrapS; this.wrapT = source.wrapT; this.magFilter = source.magFilter; this.minFilter = source.minFilter; this.anisotropy = source.anisotropy; this.format = source.format; this.type = source.type; this.offset.copy( source.offset ); this.repeat.copy( source.repeat ); this.center.copy( source.center ); this.rotation = source.rotation; this.matrixAutoUpdate = source.matrixAutoUpdate; this.matrix.copy( source.matrix ); this.generateMipmaps = source.generateMipmaps; this.premultiplyAlpha = source.premultiplyAlpha; this.flipY = source.flipY; this.unpackAlignment = source.unpackAlignment; this.encoding = source.encoding; return this; }, toJSON: function ( meta ) { var isRootObject = ( meta === undefined || typeof meta === 'string' ); if ( ! isRootObject && meta.textures[ this.uuid ] !== undefined ) { return meta.textures[ this.uuid ]; } var output = { metadata: { version: 4.5, type: 'Texture', generator: 'Texture.toJSON' }, uuid: this.uuid, name: this.name, mapping: this.mapping, repeat: [ this.repeat.x, this.repeat.y ], offset: [ this.offset.x, this.offset.y ], center: [ this.center.x, this.center.y ], rotation: this.rotation, wrap: [ this.wrapS, this.wrapT ], format: this.format, type: this.type, encoding: this.encoding, minFilter: this.minFilter, magFilter: this.magFilter, anisotropy: this.anisotropy, flipY: this.flipY, premultiplyAlpha: this.premultiplyAlpha, unpackAlignment: this.unpackAlignment }; if ( this.image !== undefined ) { // TODO: Move to THREE.Image var image = this.image; if ( image.uuid === undefined ) { image.uuid = _Math.generateUUID(); // UGH } if ( ! isRootObject && meta.images[ image.uuid ] === undefined ) { var url; if ( Array.isArray( image ) ) { // process array of images e.g. CubeTexture url = []; for ( var i = 0, l = image.length; i < l; i ++ ) { url.push( ImageUtils.getDataURL( image[ i ] ) ); } } else { // process single image url = ImageUtils.getDataURL( image ); } meta.images[ image.uuid ] = { uuid: image.uuid, url: url }; } output.image = image.uuid; } if ( ! isRootObject ) { meta.textures[ this.uuid ] = output; } return output; }, dispose: function () { this.dispatchEvent( { type: 'dispose' } ); }, transformUv: function ( uv ) { if ( this.mapping !== UVMapping ) return uv; uv.applyMatrix3( this.matrix ); if ( uv.x < 0 || uv.x > 1 ) { switch ( this.wrapS ) { case RepeatWrapping: uv.x = uv.x - Math.floor( uv.x ); break; case ClampToEdgeWrapping: uv.x = uv.x < 0 ? 0 : 1; break; case MirroredRepeatWrapping: if ( Math.abs( Math.floor( uv.x ) % 2 ) === 1 ) { uv.x = Math.ceil( uv.x ) - uv.x; } else { uv.x = uv.x - Math.floor( uv.x ); } break; } } if ( uv.y < 0 || uv.y > 1 ) { switch ( this.wrapT ) { case RepeatWrapping: uv.y = uv.y - Math.floor( uv.y ); break; case ClampToEdgeWrapping: uv.y = uv.y < 0 ? 0 : 1; break; case MirroredRepeatWrapping: if ( Math.abs( Math.floor( uv.y ) % 2 ) === 1 ) { uv.y = Math.ceil( uv.y ) - uv.y; } else { uv.y = uv.y - Math.floor( uv.y ); } break; } } if ( this.flipY ) { uv.y = 1 - uv.y; } return uv; } } ); Object.defineProperty( Texture.prototype, \"needsUpdate\", { set: function ( value ) { if ( value === true ) this.version ++; } } ); /** * @author supereggbert / http://www.paulbrunt.co.uk/ * @author philogb / http://blog.thejit.org/ * @author mikael emtinger / http://gomo.se/ * @author egraether / http://egraether.com/ * @author WestLangley / http://github.com/WestLangley */ function Vector4( x, y, z, w ) { this.x = x || 0; this.y = y || 0; this.z = z || 0; this.w = ( w !== undefined ) ? w : 1; } Object.assign( Vector4.prototype, { isVector4: true, set: function ( x, y, z, w ) { this.x = x; this.y = y; this.z = z; this.w = w; return this; }, setScalar: function ( scalar ) { this.x = scalar; this.y = scalar; this.z = scalar; this.w = scalar; return this; }, setX: function ( x ) { this.x = x; return this; }, setY: function ( y ) { this.y = y; return this; }, setZ: function ( z ) { this.z = z; return this; }, setW: function ( w ) { this.w = w; return this; }, setComponent: function ( index, value ) { switch ( index ) { case 0: this.x = value; break; case 1: this.y = value; break; case 2: this.z = value; break; case 3: this.w = value; break; default: throw new Error( 'index is out of range: ' + index ); } return this; }, getComponent: function ( index ) { switch ( index ) { case 0: return this.x; case 1: return this.y; case 2: return this.z; case 3: return this.w; default: throw new Error( 'index is out of range: ' + index ); } }, clone: function () { return new this.constructor( this.x, this.y, this.z, this.w ); }, copy: function ( v ) { this.x = v.x; this.y = v.y; this.z = v.z; this.w = ( v.w !== undefined ) ? v.w : 1; return this; }, add: function ( v, w ) { if ( w !== undefined ) { console.warn( 'THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead.' ); return this.addVectors( v, w ); } this.x += v.x; this.y += v.y; this.z += v.z; this.w += v.w; return this; }, addScalar: function ( s ) { this.x += s; this.y += s; this.z += s; this.w += s; return this; }, addVectors: function ( a, b ) { this.x = a.x + b.x; this.y = a.y + b.y; this.z = a.z + b.z; this.w = a.w + b.w; return this; }, addScaledVector: function ( v, s ) { this.x += v.x * s; this.y += v.y * s; this.z += v.z * s; this.w += v.w * s; return this; }, sub: function ( v, w ) { if ( w !== undefined ) { console.warn( 'THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.' ); return this.subVectors( v, w ); } this.x -= v.x; this.y -= v.y; this.z -= v.z; this.w -= v.w; return this; }, subScalar: function ( s ) { this.x -= s; this.y -= s; this.z -= s; this.w -= s; return this; }, subVectors: function ( a, b ) { this.x = a.x - b.x; this.y = a.y - b.y; this.z = a.z - b.z; this.w = a.w - b.w; return this; }, multiplyScalar: function ( scalar ) { this.x *= scalar; this.y *= scalar; this.z *= scalar; this.w *= scalar; return this; }, applyMatrix4: function ( m ) { var x = this.x, y = this.y, z = this.z, w = this.w; var e = m.elements; this.x = e[ 0 ] * x + e[ 4 ] * y + e[ 8 ] * z + e[ 12 ] * w; this.y = e[ 1 ] * x + e[ 5 ] * y + e[ 9 ] * z + e[ 13 ] * w; this.z = e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z + e[ 14 ] * w; this.w = e[ 3 ] * x + e[ 7 ] * y + e[ 11 ] * z + e[ 15 ] * w; return this; }, divideScalar: function ( scalar ) { return this.multiplyScalar( 1 / scalar ); }, setAxisAngleFromQuaternion: function ( q ) { // http://www.euclideanspace.com/maths/geometry/rotations/conversions/quaternionToAngle/index.htm // q is assumed to be normalized this.w = 2 * Math.acos( q.w ); var s = Math.sqrt( 1 - q.w * q.w ); if ( s < 0.0001 ) { this.x = 1; this.y = 0; this.z = 0; } else { this.x = q.x / s; this.y = q.y / s; this.z = q.z / s; } return this; }, setAxisAngleFromRotationMatrix: function ( m ) { // http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToAngle/index.htm // assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled) var angle, x, y, z, // variables for result epsilon = 0.01, // margin to allow for rounding errors epsilon2 = 0.1, // margin to distinguish between 0 and 180 degrees te = m.elements, m11 = te[ 0 ], m12 = te[ 4 ], m13 = te[ 8 ], m21 = te[ 1 ], m22 = te[ 5 ], m23 = te[ 9 ], m31 = te[ 2 ], m32 = te[ 6 ], m33 = te[ 10 ]; if ( ( Math.abs( m12 - m21 ) < epsilon ) && ( Math.abs( m13 - m31 ) < epsilon ) && ( Math.abs( m23 - m32 ) < epsilon ) ) { // singularity found // first check for identity matrix which must have +1 for all terms // in leading diagonal and zero in other terms if ( ( Math.abs( m12 + m21 ) < epsilon2 ) && ( Math.abs( m13 + m31 ) < epsilon2 ) && ( Math.abs( m23 + m32 ) < epsilon2 ) && ( Math.abs( m11 + m22 + m33 - 3 ) < epsilon2 ) ) { // this singularity is identity matrix so angle = 0 this.set( 1, 0, 0, 0 ); return this; // zero angle, arbitrary axis } // otherwise this singularity is angle = 180 angle = Math.PI; var xx = ( m11 + 1 ) / 2; var yy = ( m22 + 1 ) / 2; var zz = ( m33 + 1 ) / 2; var xy = ( m12 + m21 ) / 4; var xz = ( m13 + m31 ) / 4; var yz = ( m23 + m32 ) / 4; if ( ( xx > yy ) && ( xx > zz ) ) { // m11 is the largest diagonal term if ( xx < epsilon ) { x = 0; y = 0.707106781; z = 0.707106781; } else { x = Math.sqrt( xx ); y = xy / x; z = xz / x; } } else if ( yy > zz ) { // m22 is the largest diagonal term if ( yy < epsilon ) { x = 0.707106781; y = 0; z = 0.707106781; } else { y = Math.sqrt( yy ); x = xy / y; z = yz / y; } } else { // m33 is the largest diagonal term so base result on this if ( zz < epsilon ) { x = 0.707106781; y = 0.707106781; z = 0; } else { z = Math.sqrt( zz ); x = xz / z; y = yz / z; } } this.set( x, y, z, angle ); return this; // return 180 deg rotation } // as we have reached here there are no singularities so we can handle normally var s = Math.sqrt( ( m32 - m23 ) * ( m32 - m23 ) + ( m13 - m31 ) * ( m13 - m31 ) + ( m21 - m12 ) * ( m21 - m12 ) ); // used to normalize if ( Math.abs( s ) < 0.001 ) s = 1; // prevent divide by zero, should not happen if matrix is orthogonal and should be // caught by singularity test above, but I've left it in just in case this.x = ( m32 - m23 ) / s; this.y = ( m13 - m31 ) / s; this.z = ( m21 - m12 ) / s; this.w = Math.acos( ( m11 + m22 + m33 - 1 ) / 2 ); return this; }, min: function ( v ) { this.x = Math.min( this.x, v.x ); this.y = Math.min( this.y, v.y ); this.z = Math.min( this.z, v.z ); this.w = Math.min( this.w, v.w ); return this; }, max: function ( v ) { this.x = Math.max( this.x, v.x ); this.y = Math.max( this.y, v.y ); this.z = Math.max( this.z, v.z ); this.w = Math.max( this.w, v.w ); return this; }, clamp: function ( min, max ) { // assumes min < max, componentwise this.x = Math.max( min.x, Math.min( max.x, this.x ) ); this.y = Math.max( min.y, Math.min( max.y, this.y ) ); this.z = Math.max( min.z, Math.min( max.z, this.z ) ); this.w = Math.max( min.w, Math.min( max.w, this.w ) ); return this; }, clampScalar: function () { var min, max; return function clampScalar( minVal, maxVal ) { if ( min === undefined ) { min = new Vector4(); max = new Vector4(); } min.set( minVal, minVal, minVal, minVal ); max.set( maxVal, maxVal, maxVal, maxVal ); return this.clamp( min, max ); }; }(), clampLength: function ( min, max ) { var length = this.length(); return this.divideScalar( length || 1 ).multiplyScalar( Math.max( min, Math.min( max, length ) ) ); }, floor: function () { this.x = Math.floor( this.x ); this.y = Math.floor( this.y ); this.z = Math.floor( this.z ); this.w = Math.floor( this.w ); return this; }, ceil: function () { this.x = Math.ceil( this.x ); this.y = Math.ceil( this.y ); this.z = Math.ceil( this.z ); this.w = Math.ceil( this.w ); return this; }, round: function () { this.x = Math.round( this.x ); this.y = Math.round( this.y ); this.z = Math.round( this.z ); this.w = Math.round( this.w ); return this; }, roundToZero: function () { this.x = ( this.x < 0 ) ? Math.ceil( this.x ) : Math.floor( this.x ); this.y = ( this.y < 0 ) ? Math.ceil( this.y ) : Math.floor( this.y ); this.z = ( this.z < 0 ) ? Math.ceil( this.z ) : Math.floor( this.z ); this.w = ( this.w < 0 ) ? Math.ceil( this.w ) : Math.floor( this.w ); return this; }, negate: function () { this.x = - this.x; this.y = - this.y; this.z = - this.z; this.w = - this.w; return this; }, dot: function ( v ) { return this.x * v.x + this.y * v.y + this.z * v.z + this.w * v.w; }, lengthSq: function () { return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w; }, length: function () { return Math.sqrt( this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w ); }, manhattanLength: function () { return Math.abs( this.x ) + Math.abs( this.y ) + Math.abs( this.z ) + Math.abs( this.w ); }, normalize: function () { return this.divideScalar( this.length() || 1 ); }, setLength: function ( length ) { return this.normalize().multiplyScalar( length ); }, lerp: function ( v, alpha ) { this.x += ( v.x - this.x ) * alpha; this.y += ( v.y - this.y ) * alpha; this.z += ( v.z - this.z ) * alpha; this.w += ( v.w - this.w ) * alpha; return this; }, lerpVectors: function ( v1, v2, alpha ) { return this.subVectors( v2, v1 ).multiplyScalar( alpha ).add( v1 ); }, equals: function ( v ) { return ( ( v.x === this.x ) && ( v.y === this.y ) && ( v.z === this.z ) && ( v.w === this.w ) ); }, fromArray: function ( array, offset ) { if ( offset === undefined ) offset = 0; this.x = array[ offset ]; this.y = array[ offset + 1 ]; this.z = array[ offset + 2 ]; this.w = array[ offset + 3 ]; return this; }, toArray: function ( array, offset ) { if ( array === undefined ) array = []; if ( offset === undefined ) offset = 0; array[ offset ] = this.x; array[ offset + 1 ] = this.y; array[ offset + 2 ] = this.z; array[ offset + 3 ] = this.w; return array; }, fromBufferAttribute: function ( attribute, index, offset ) { if ( offset !== undefined ) { console.warn( 'THREE.Vector4: offset has been removed from .fromBufferAttribute().' ); } this.x = attribute.getX( index ); this.y = attribute.getY( index ); this.z = attribute.getZ( index ); this.w = attribute.getW( index ); return this; } } ); /** * @author szimek / https://github.com/szimek/ * @author alteredq / http://alteredqualia.com/ * @author Marius Kintel / https://github.com/kintel */ /* In options, we can specify: * Texture parameters for an auto-generated target texture * depthBuffer/stencilBuffer: Booleans to indicate if we should generate these buffers */ function WebGLRenderTarget( width, height, options ) { this.width = width; this.height = height; this.scissor = new Vector4( 0, 0, width, height ); this.scissorTest = false; this.viewport = new Vector4( 0, 0, width, height ); options = options || {}; this.texture = new Texture( undefined, undefined, options.wrapS, options.wrapT, options.magFilter, options.minFilter, options.format, options.type, options.anisotropy, options.encoding ); this.texture.generateMipmaps = options.generateMipmaps !== undefined ? options.generateMipmaps : false; this.texture.minFilter = options.minFilter !== undefined ? options.minFilter : LinearFilter; this.depthBuffer = options.depthBuffer !== undefined ? options.depthBuffer : true; this.stencilBuffer = options.stencilBuffer !== undefined ? options.stencilBuffer : true; this.depthTexture = options.depthTexture !== undefined ? options.depthTexture : null; } WebGLRenderTarget.prototype = Object.assign( Object.create( EventDispatcher.prototype ), { constructor: WebGLRenderTarget, isWebGLRenderTarget: true, setSize: function ( width, height ) { if ( this.width !== width || this.height !== height ) { this.width = width; this.height = height; this.dispose(); } this.viewport.set( 0, 0, width, height ); this.scissor.set( 0, 0, width, height ); }, clone: function () { return new this.constructor().copy( this ); }, copy: function ( source ) { this.width = source.width; this.height = source.height; this.viewport.copy( source.viewport ); this.texture = source.texture.clone(); this.depthBuffer = source.depthBuffer; this.stencilBuffer = source.stencilBuffer; this.depthTexture = source.depthTexture; return this; }, dispose: function () { this.dispatchEvent( { type: 'dispose' } ); } } ); /** * @author Mugen87 / https://github.com/Mugen87 * @author Matt DesLauriers / @mattdesl */ function WebGLMultisampleRenderTarget( width, height, options ) { WebGLRenderTarget.call( this, width, height, options ); this.samples = 4; } WebGLMultisampleRenderTarget.prototype = Object.assign( Object.create( WebGLRenderTarget.prototype ), { constructor: WebGLMultisampleRenderTarget, isWebGLMultisampleRenderTarget: true, copy: function ( source ) { WebGLRenderTarget.prototype.copy.call( this, source ); this.samples = source.samples; return this; } } ); /** * @author alteredq / http://alteredqualia.com */ function WebGLRenderTargetCube( width, height, options ) { WebGLRenderTarget.call( this, width, height, options ); this.activeCubeFace = 0; // PX 0, NX 1, PY 2, NY 3, PZ 4, NZ 5 this.activeMipMapLevel = 0; } WebGLRenderTargetCube.prototype = Object.create( WebGLRenderTarget.prototype ); WebGLRenderTargetCube.prototype.constructor = WebGLRenderTargetCube; WebGLRenderTargetCube.prototype.isWebGLRenderTargetCube = true; /** * @author alteredq / http://alteredqualia.com/ */ function DataTexture( data, width, height, format, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, encoding ) { Texture.call( this, null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding ); this.image = { data: data, width: width, height: height }; this.magFilter = magFilter !== undefined ? magFilter : NearestFilter; this.minFilter = minFilter !== undefined ? minFilter : NearestFilter; this.generateMipmaps = false; this.flipY = false; this.unpackAlignment = 1; } DataTexture.prototype = Object.create( Texture.prototype ); DataTexture.prototype.constructor = DataTexture; DataTexture.prototype.isDataTexture = true; /** * @author bhouston / http://clara.io * @author WestLangley / http://github.com/WestLangley */ function Box3( min, max ) { this.min = ( min !== undefined ) ? min : new Vector3( + Infinity, + Infinity, + Infinity ); this.max = ( max !== undefined ) ? max : new Vector3( - Infinity, - Infinity, - Infinity ); } Object.assign( Box3.prototype, { isBox3: true, set: function ( min, max ) { this.min.copy( min ); this.max.copy( max ); return this; }, setFromArray: function ( array ) { var minX = + Infinity; var minY = + Infinity; var minZ = + Infinity; var maxX = - Infinity; var maxY = - Infinity; var maxZ = - Infinity; for ( var i = 0, l = array.length; i < l; i += 3 ) { var x = array[ i ]; var y = array[ i + 1 ]; var z = array[ i + 2 ]; if ( x < minX ) minX = x; if ( y < minY ) minY = y; if ( z < minZ ) minZ = z; if ( x > maxX ) maxX = x; if ( y > maxY ) maxY = y; if ( z > maxZ ) maxZ = z; } this.min.set( minX, minY, minZ ); this.max.set( maxX, maxY, maxZ ); return this; }, setFromBufferAttribute: function ( attribute ) { var minX = + Infinity; var minY = + Infinity; var minZ = + Infinity; var maxX = - Infinity; var maxY = - Infinity; var maxZ = - Infinity; for ( var i = 0, l = attribute.count; i < l; i ++ ) { var x = attribute.getX( i ); var y = attribute.getY( i ); var z = attribute.getZ( i ); if ( x < minX ) minX = x; if ( y < minY ) minY = y; if ( z < minZ ) minZ = z; if ( x > maxX ) maxX = x; if ( y > maxY ) maxY = y; if ( z > maxZ ) maxZ = z; } this.min.set( minX, minY, minZ ); this.max.set( maxX, maxY, maxZ ); return this; }, setFromPoints: function ( points ) { this.makeEmpty(); for ( var i = 0, il = points.length; i < il; i ++ ) { this.expandByPoint( points[ i ] ); } return this; }, setFromCenterAndSize: function () { var v1 = new Vector3(); return function setFromCenterAndSize( center, size ) { var halfSize = v1.copy( size ).multiplyScalar( 0.5 ); this.min.copy( center ).sub( halfSize ); this.max.copy( center ).add( halfSize ); return this; }; }(), setFromObject: function ( object ) { this.makeEmpty(); return this.expandByObject( object ); }, clone: function () { return new this.constructor().copy( this ); }, copy: function ( box ) { this.min.copy( box.min ); this.max.copy( box.max ); return this; }, makeEmpty: function () { this.min.x = this.min.y = this.min.z = + Infinity; this.max.x = this.max.y = this.max.z = - Infinity; return this; }, isEmpty: function () { // this is a more robust check for empty than ( volume this.max.y || point.z < this.min.z || point.z > this.max.z ? false : true; }, containsBox: function ( box ) { return this.min.x this.max.y || box.max.z < this.min.z || box.min.z > this.max.z ? false : true; }, intersectsSphere: ( function () { var closestPoint = new Vector3(); return function intersectsSphere( sphere ) { // Find the point on the AABB closest to the sphere center. this.clampPoint( sphere.center, closestPoint ); // If that point is inside the sphere, the AABB and sphere intersect. return closestPoint.distanceToSquared( sphere.center ) 0 ) { min = plane.normal.x * this.min.x; max = plane.normal.x * this.max.x; } else { min = plane.normal.x * this.max.x; max = plane.normal.x * this.min.x; } if ( plane.normal.y > 0 ) { min += plane.normal.y * this.min.y; max += plane.normal.y * this.max.y; } else { min += plane.normal.y * this.max.y; max += plane.normal.y * this.min.y; } if ( plane.normal.z > 0 ) { min += plane.normal.z * this.min.z; max += plane.normal.z * this.max.z; } else { min += plane.normal.z * this.max.z; max += plane.normal.z * this.min.z; } return ( min = - plane.constant ); }, intersectsTriangle: ( function () { // triangle centered vertices var v0 = new Vector3(); var v1 = new Vector3(); var v2 = new Vector3(); // triangle edge vectors var f0 = new Vector3(); var f1 = new Vector3(); var f2 = new Vector3(); var testAxis = new Vector3(); var center = new Vector3(); var extents = new Vector3(); var triangleNormal = new Vector3(); function satForAxes( axes ) { var i, j; for ( i = 0, j = axes.length - 3; i r ) { // points of the projected triangle are outside the projected half-length of the aabb // the axis is seperating and we can exit return false; } } return true; } return function intersectsTriangle( triangle ) { if ( this.isEmpty() ) { return false; } // compute box center and extents this.getCenter( center ); extents.subVectors( this.max, center ); // translate triangle to aabb origin v0.subVectors( triangle.a, center ); v1.subVectors( triangle.b, center ); v2.subVectors( triangle.c, center ); // compute edge vectors for triangle f0.subVectors( v1, v0 ); f1.subVectors( v2, v1 ); f2.subVectors( v0, v2 ); // test against axes that are given by cross product combinations of the edges of the triangle and the edges of the aabb // make an axis testing of each of the 3 sides of the aabb against each of the 3 sides of the triangle = 9 axis of separation // axis_ij = u_i x f_j (u0, u1, u2 = face normals of aabb = x,y,z axes vectors since aabb is axis aligned) var axes = [ 0, - f0.z, f0.y, 0, - f1.z, f1.y, 0, - f2.z, f2.y, f0.z, 0, - f0.x, f1.z, 0, - f1.x, f2.z, 0, - f2.x, - f0.y, f0.x, 0, - f1.y, f1.x, 0, - f2.y, f2.x, 0 ]; if ( ! satForAxes( axes ) ) { return false; } // test 3 face normals from the aabb axes = [ 1, 0, 0, 0, 1, 0, 0, 0, 1 ]; if ( ! satForAxes( axes ) ) { return false; } // finally testing the face normal of the triangle // use already existing triangle edge vectors here triangleNormal.crossVectors( f0, f1 ); axes = [ triangleNormal.x, triangleNormal.y, triangleNormal.z ]; return satForAxes( axes ); }; } )(), clampPoint: function ( point, target ) { if ( target === undefined ) { console.warn( 'THREE.Box3: .clampPoint() target is now required' ); target = new Vector3(); } return target.copy( point ).clamp( this.min, this.max ); }, distanceToPoint: function () { var v1 = new Vector3(); return function distanceToPoint( point ) { var clampedPoint = v1.copy( point ).clamp( this.min, this.max ); return clampedPoint.sub( point ).length(); }; }(), getBoundingSphere: function () { var v1 = new Vector3(); return function getBoundingSphere( target ) { if ( target === undefined ) { console.warn( 'THREE.Box3: .getBoundingSphere() target is now required' ); target = new Sphere(); } this.getCenter( target.center ); target.radius = this.getSize( v1 ).length() * 0.5; return target; }; }(), intersect: function ( box ) { this.min.max( box.min ); this.max.min( box.max ); // ensure that if there is no overlap, the result is fully empty, not slightly empty with non-inf/+inf values that will cause subsequence intersects to erroneously return valid values. if ( this.isEmpty() ) this.makeEmpty(); return this; }, union: function ( box ) { this.min.min( box.min ); this.max.max( box.max ); return this; }, applyMatrix4: function () { var points = [ new Vector3(), new Vector3(), new Vector3(), new Vector3(), new Vector3(), new Vector3(), new Vector3(), new Vector3() ]; return function applyMatrix4( matrix ) { // transform of empty box is an empty box. if ( this.isEmpty() ) return this; // NOTE: I am using a binary pattern to specify all 2^3 combinations below points[ 0 ].set( this.min.x, this.min.y, this.min.z ).applyMatrix4( matrix ); // 000 points[ 1 ].set( this.min.x, this.min.y, this.max.z ).applyMatrix4( matrix ); // 001 points[ 2 ].set( this.min.x, this.max.y, this.min.z ).applyMatrix4( matrix ); // 010 points[ 3 ].set( this.min.x, this.max.y, this.max.z ).applyMatrix4( matrix ); // 011 points[ 4 ].set( this.max.x, this.min.y, this.min.z ).applyMatrix4( matrix ); // 100 points[ 5 ].set( this.max.x, this.min.y, this.max.z ).applyMatrix4( matrix ); // 101 points[ 6 ].set( this.max.x, this.max.y, this.min.z ).applyMatrix4( matrix ); // 110 points[ 7 ].set( this.max.x, this.max.y, this.max.z ).applyMatrix4( matrix ); // 111 this.setFromPoints( points ); return this; }; }(), translate: function ( offset ) { this.min.add( offset ); this.max.add( offset ); return this; }, equals: function ( box ) { return box.min.equals( this.min ) && box.max.equals( this.max ); } } ); /** * @author bhouston / http://clara.io * @author mrdoob / http://mrdoob.com/ */ function Sphere( center, radius ) { this.center = ( center !== undefined ) ? center : new Vector3(); this.radius = ( radius !== undefined ) ? radius : 0; } Object.assign( Sphere.prototype, { set: function ( center, radius ) { this.center.copy( center ); this.radius = radius; return this; }, setFromPoints: function () { var box = new Box3(); return function setFromPoints( points, optionalCenter ) { var center = this.center; if ( optionalCenter !== undefined ) { center.copy( optionalCenter ); } else { box.setFromPoints( points ).getCenter( center ); } var maxRadiusSq = 0; for ( var i = 0, il = points.length; i < il; i ++ ) { maxRadiusSq = Math.max( maxRadiusSq, center.distanceToSquared( points[ i ] ) ); } this.radius = Math.sqrt( maxRadiusSq ); return this; }; }(), clone: function () { return new this.constructor().copy( this ); }, copy: function ( sphere ) { this.center.copy( sphere.center ); this.radius = sphere.radius; return this; }, empty: function () { return ( this.radius 1 ) { return undefined; } return target.copy( direction ).multiplyScalar( t ).add( line.start ); }; }(), intersectsLine: function ( line ) { // Note: this tests if a line intersects the plane, not whether it (or its end-points) are coplanar with it. var startSign = this.distanceToPoint( line.start ); var endSign = this.distanceToPoint( line.end ); return ( startSign < 0 && endSign > 0 ) || ( endSign < 0 && startSign > 0 ); }, intersectsBox: function ( box ) { return box.intersectsPlane( this ); }, intersectsSphere: function ( sphere ) { return sphere.intersectsPlane( this ); }, coplanarPoint: function ( target ) { if ( target === undefined ) { console.warn( 'THREE.Plane: .coplanarPoint() target is now required' ); target = new Vector3(); } return target.copy( this.normal ).multiplyScalar( - this.constant ); }, applyMatrix4: function () { var v1 = new Vector3(); var m1 = new Matrix3(); return function applyMatrix4( matrix, optionalNormalMatrix ) { var normalMatrix = optionalNormalMatrix || m1.getNormalMatrix( matrix ); var referencePoint = this.coplanarPoint( v1 ).applyMatrix4( matrix ); var normal = this.normal.applyMatrix3( normalMatrix ).normalize(); this.constant = - referencePoint.dot( normal ); return this; }; }(), translate: function ( offset ) { this.constant -= offset.dot( this.normal ); return this; }, equals: function ( plane ) { return plane.normal.equals( this.normal ) && ( plane.constant === this.constant ); } } ); /** * @author mrdoob / http://mrdoob.com/ * @author alteredq / http://alteredqualia.com/ * @author bhouston / http://clara.io */ function Frustum( p0, p1, p2, p3, p4, p5 ) { this.planes = [ ( p0 !== undefined ) ? p0 : new Plane(), ( p1 !== undefined ) ? p1 : new Plane(), ( p2 !== undefined ) ? p2 : new Plane(), ( p3 !== undefined ) ? p3 : new Plane(), ( p4 !== undefined ) ? p4 : new Plane(), ( p5 !== undefined ) ? p5 : new Plane() ]; } Object.assign( Frustum.prototype, { set: function ( p0, p1, p2, p3, p4, p5 ) { var planes = this.planes; planes[ 0 ].copy( p0 ); planes[ 1 ].copy( p1 ); planes[ 2 ].copy( p2 ); planes[ 3 ].copy( p3 ); planes[ 4 ].copy( p4 ); planes[ 5 ].copy( p5 ); return this; }, clone: function () { return new this.constructor().copy( this ); }, copy: function ( frustum ) { var planes = this.planes; for ( var i = 0; i < 6; i ++ ) { planes[ i ].copy( frustum.planes[ i ] ); } return this; }, setFromMatrix: function ( m ) { var planes = this.planes; var me = m.elements; var me0 = me[ 0 ], me1 = me[ 1 ], me2 = me[ 2 ], me3 = me[ 3 ]; var me4 = me[ 4 ], me5 = me[ 5 ], me6 = me[ 6 ], me7 = me[ 7 ]; var me8 = me[ 8 ], me9 = me[ 9 ], me10 = me[ 10 ], me11 = me[ 11 ]; var me12 = me[ 12 ], me13 = me[ 13 ], me14 = me[ 14 ], me15 = me[ 15 ]; planes[ 0 ].setComponents( me3 - me0, me7 - me4, me11 - me8, me15 - me12 ).normalize(); planes[ 1 ].setComponents( me3 + me0, me7 + me4, me11 + me8, me15 + me12 ).normalize(); planes[ 2 ].setComponents( me3 + me1, me7 + me5, me11 + me9, me15 + me13 ).normalize(); planes[ 3 ].setComponents( me3 - me1, me7 - me5, me11 - me9, me15 - me13 ).normalize(); planes[ 4 ].setComponents( me3 - me2, me7 - me6, me11 - me10, me15 - me14 ).normalize(); planes[ 5 ].setComponents( me3 + me2, me7 + me6, me11 + me10, me15 + me14 ).normalize(); return this; }, intersectsObject: function () { var sphere = new Sphere(); return function intersectsObject( object ) { var geometry = object.geometry; if ( geometry.boundingSphere === null ) geometry.computeBoundingSphere(); sphere.copy( geometry.boundingSphere ) .applyMatrix4( object.matrixWorld ); return this.intersectsSphere( sphere ); }; }(), intersectsSprite: function () { var sphere = new Sphere(); return function intersectsSprite( sprite ) { sphere.center.set( 0, 0, 0 ); sphere.radius = 0.7071067811865476; sphere.applyMatrix4( sprite.matrixWorld ); return this.intersectsSphere( sphere ); }; }(), intersectsSphere: function ( sphere ) { var planes = this.planes; var center = sphere.center; var negRadius = - sphere.radius; for ( var i = 0; i < 6; i ++ ) { var distance = planes[ i ].distanceToPoint( center ); if ( distance < negRadius ) { return false; } } return true; }, intersectsBox: function () { var p = new Vector3(); return function intersectsBox( box ) { var planes = this.planes; for ( var i = 0; i < 6; i ++ ) { var plane = planes[ i ]; // corner at max distance p.x = plane.normal.x > 0 ? box.max.x : box.min.x; p.y = plane.normal.y > 0 ? box.max.y : box.min.y; p.z = plane.normal.z > 0 ? box.max.z : box.min.z; if ( plane.distanceToPoint( p ) < 0 ) { return false; } } return true; }; }(), containsPoint: function ( point ) { var planes = this.planes; for ( var i = 0; i < 6; i ++ ) { if ( planes[ i ].distanceToPoint( point ) < 0 ) { return false; } } return true; } } ); var alphamap_fragment = \"#ifdef USE_ALPHAMAP\\n\\tdiffuseColor.a *= texture2D( alphaMap, vUv ).g;\\n#endif\"; var alphamap_pars_fragment = \"#ifdef USE_ALPHAMAP\\n\\tuniform sampler2D alphaMap;\\n#endif\"; var alphatest_fragment = \"#ifdef ALPHATEST\\n\\tif ( diffuseColor.a < ALPHATEST ) discard;\\n#endif\"; var aomap_fragment = \"#ifdef USE_AOMAP\\n\\tfloat ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\\n\\treflectedLight.indirectDiffuse *= ambientOcclusion;\\n\\t#if defined( USE_ENVMAP ) && defined( PHYSICAL )\\n\\t\\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\\n\\t\\treflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.specularRoughness );\\n\\t#endif\\n#endif\"; var aomap_pars_fragment = \"#ifdef USE_AOMAP\\n\\tuniform sampler2D aoMap;\\n\\tuniform float aoMapIntensity;\\n#endif\"; var begin_vertex = \"vec3 transformed = vec3( position );\"; var beginnormal_vertex = \"vec3 objectNormal = vec3( normal );\"; var bsdfs = \"vec2 integrateSpecularBRDF( const in float dotNV, const in float roughness ) {\\n\\tconst vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\\n\\tconst vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\\n\\tvec4 r = roughness * c0 + c1;\\n\\tfloat a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\\n\\treturn vec2( -1.04, 1.04 ) * a004 + r.zw;\\n}\\nfloat punctualLightIntensityToIrradianceFactor( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\\n#if defined ( PHYSICALLY_CORRECT_LIGHTS )\\n\\tfloat distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\\n\\tif( cutoffDistance > 0.0 ) {\\n\\t\\tdistanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\\n\\t}\\n\\treturn distanceFalloff;\\n#else\\n\\tif( cutoffDistance > 0.0 && decayExponent > 0.0 ) {\\n\\t\\treturn pow( saturate( -lightDistance / cutoffDistance + 1.0 ), decayExponent );\\n\\t}\\n\\treturn 1.0;\\n#endif\\n}\\nvec3 BRDF_Diffuse_Lambert( const in vec3 diffuseColor ) {\\n\\treturn RECIPROCAL_PI * diffuseColor;\\n}\\nvec3 F_Schlick( const in vec3 specularColor, const in float dotLH ) {\\n\\tfloat fresnel = exp2( ( -5.55473 * dotLH - 6.98316 ) * dotLH );\\n\\treturn ( 1.0 - specularColor ) * fresnel + specularColor;\\n}\\nfloat G_GGX_Smith( const in float alpha, const in float dotNL, const in float dotNV ) {\\n\\tfloat a2 = pow2( alpha );\\n\\tfloat gl = dotNL + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\\n\\tfloat gv = dotNV + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\\n\\treturn 1.0 / ( gl * gv );\\n}\\nfloat G_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\\n\\tfloat a2 = pow2( alpha );\\n\\tfloat gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\\n\\tfloat gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\\n\\treturn 0.5 / max( gv + gl, EPSILON );\\n}\\nfloat D_GGX( const in float alpha, const in float dotNH ) {\\n\\tfloat a2 = pow2( alpha );\\n\\tfloat denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\\n\\treturn RECIPROCAL_PI * a2 / pow2( denom );\\n}\\nvec3 BRDF_Specular_GGX( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float roughness ) {\\n\\tfloat alpha = pow2( roughness );\\n\\tvec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\\n\\tfloat dotNL = saturate( dot( geometry.normal, incidentLight.direction ) );\\n\\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\\n\\tfloat dotNH = saturate( dot( geometry.normal, halfDir ) );\\n\\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\\n\\tvec3 F = F_Schlick( specularColor, dotLH );\\n\\tfloat G = G_GGX_SmithCorrelated( alpha, dotNL, dotNV );\\n\\tfloat D = D_GGX( alpha, dotNH );\\n\\treturn F * ( G * D );\\n}\\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\\n\\tconst float LUT_SIZE = 64.0;\\n\\tconst float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\\n\\tconst float LUT_BIAS = 0.5 / LUT_SIZE;\\n\\tfloat dotNV = saturate( dot( N, V ) );\\n\\tvec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );\\n\\tuv = uv * LUT_SCALE + LUT_BIAS;\\n\\treturn uv;\\n}\\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\\n\\tfloat l = length( f );\\n\\treturn max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\\n}\\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\\n\\tfloat x = dot( v1, v2 );\\n\\tfloat y = abs( x );\\n\\tfloat a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;\\n\\tfloat b = 3.4175940 + ( 4.1616724 + y ) * y;\\n\\tfloat v = a / b;\\n\\tfloat theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;\\n\\treturn cross( v1, v2 ) * theta_sintheta;\\n}\\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\\n\\tvec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\\n\\tvec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\\n\\tvec3 lightNormal = cross( v1, v2 );\\n\\tif( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\\n\\tvec3 T1, T2;\\n\\tT1 = normalize( V - N * dot( V, N ) );\\n\\tT2 = - cross( N, T1 );\\n\\tmat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\\n\\tvec3 coords[ 4 ];\\n\\tcoords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\\n\\tcoords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\\n\\tcoords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\\n\\tcoords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\\n\\tcoords[ 0 ] = normalize( coords[ 0 ] );\\n\\tcoords[ 1 ] = normalize( coords[ 1 ] );\\n\\tcoords[ 2 ] = normalize( coords[ 2 ] );\\n\\tcoords[ 3 ] = normalize( coords[ 3 ] );\\n\\tvec3 vectorFormFactor = vec3( 0.0 );\\n\\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\\n\\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\\n\\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\\n\\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\\n\\tfloat result = LTC_ClippedSphereFormFactor( vectorFormFactor );\\n\\treturn vec3( result );\\n}\\nvec3 BRDF_Specular_GGX_Environment( const in GeometricContext geometry, const in vec3 specularColor, const in float roughness ) {\\n\\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\\n\\tvec2 brdf = integrateSpecularBRDF( dotNV, roughness );\\n\\treturn specularColor * brdf.x + brdf.y;\\n}\\nvoid BRDF_Specular_Multiscattering_Environment( const in GeometricContext geometry, const in vec3 specularColor, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\\n\\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\\n\\tvec3 F = F_Schlick( specularColor, dotNV );\\n\\tvec2 brdf = integrateSpecularBRDF( dotNV, roughness );\\n\\tvec3 FssEss = F * brdf.x + brdf.y;\\n\\tfloat Ess = brdf.x + brdf.y;\\n\\tfloat Ems = 1.0 - Ess;\\n\\tvec3 Favg = specularColor + ( 1.0 - specularColor ) * 0.047619;\\tvec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );\\n\\tsingleScatter += FssEss;\\n\\tmultiScatter += Fms * Ems;\\n}\\nfloat G_BlinnPhong_Implicit( ) {\\n\\treturn 0.25;\\n}\\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\\n\\treturn RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\\n}\\nvec3 BRDF_Specular_BlinnPhong( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float shininess ) {\\n\\tvec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\\n\\tfloat dotNH = saturate( dot( geometry.normal, halfDir ) );\\n\\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\\n\\tvec3 F = F_Schlick( specularColor, dotLH );\\n\\tfloat G = G_BlinnPhong_Implicit( );\\n\\tfloat D = D_BlinnPhong( shininess, dotNH );\\n\\treturn F * ( G * D );\\n}\\nfloat GGXRoughnessToBlinnExponent( const in float ggxRoughness ) {\\n\\treturn ( 2.0 / pow2( ggxRoughness + 0.0001 ) - 2.0 );\\n}\\nfloat BlinnExponentToGGXRoughness( const in float blinnExponent ) {\\n\\treturn sqrt( 2.0 / ( blinnExponent + 2.0 ) );\\n}\"; var bumpmap_pars_fragment = \"#ifdef USE_BUMPMAP\\n\\tuniform sampler2D bumpMap;\\n\\tuniform float bumpScale;\\n\\tvec2 dHdxy_fwd() {\\n\\t\\tvec2 dSTdx = dFdx( vUv );\\n\\t\\tvec2 dSTdy = dFdy( vUv );\\n\\t\\tfloat Hll = bumpScale * texture2D( bumpMap, vUv ).x;\\n\\t\\tfloat dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\\n\\t\\tfloat dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\\n\\t\\treturn vec2( dBx, dBy );\\n\\t}\\n\\tvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy ) {\\n\\t\\tvec3 vSigmaX = vec3( dFdx( surf_pos.x ), dFdx( surf_pos.y ), dFdx( surf_pos.z ) );\\n\\t\\tvec3 vSigmaY = vec3( dFdy( surf_pos.x ), dFdy( surf_pos.y ), dFdy( surf_pos.z ) );\\n\\t\\tvec3 vN = surf_norm;\\n\\t\\tvec3 R1 = cross( vSigmaY, vN );\\n\\t\\tvec3 R2 = cross( vN, vSigmaX );\\n\\t\\tfloat fDet = dot( vSigmaX, R1 );\\n\\t\\tfDet *= ( float( gl_FrontFacing ) * 2.0 - 1.0 );\\n\\t\\tvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\\n\\t\\treturn normalize( abs( fDet ) * surf_norm - vGrad );\\n\\t}\\n#endif\"; var clipping_planes_fragment = \"#if NUM_CLIPPING_PLANES > 0\\n\\tvec4 plane;\\n\\t#pragma unroll_loop\\n\\tfor ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\\n\\t\\tplane = clippingPlanes[ i ];\\n\\t\\tif ( dot( vViewPosition, plane.xyz ) > plane.w ) discard;\\n\\t}\\n\\t#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\\n\\t\\tbool clipped = true;\\n\\t\\t#pragma unroll_loop\\n\\t\\tfor ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\\n\\t\\t\\tplane = clippingPlanes[ i ];\\n\\t\\t\\tclipped = ( dot( vViewPosition, plane.xyz ) > plane.w ) && clipped;\\n\\t\\t}\\n\\t\\tif ( clipped ) discard;\\n\\t#endif\\n#endif\"; var clipping_planes_pars_fragment = \"#if NUM_CLIPPING_PLANES > 0\\n\\t#if ! defined( PHYSICAL ) && ! defined( PHONG ) && ! defined( MATCAP )\\n\\t\\tvarying vec3 vViewPosition;\\n\\t#endif\\n\\tuniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\\n#endif\"; var clipping_planes_pars_vertex = \"#if NUM_CLIPPING_PLANES > 0 && ! defined( PHYSICAL ) && ! defined( PHONG ) && ! defined( MATCAP )\\n\\tvarying vec3 vViewPosition;\\n#endif\"; var clipping_planes_vertex = \"#if NUM_CLIPPING_PLANES > 0 && ! defined( PHYSICAL ) && ! defined( PHONG ) && ! defined( MATCAP )\\n\\tvViewPosition = - mvPosition.xyz;\\n#endif\"; var color_fragment = \"#ifdef USE_COLOR\\n\\tdiffuseColor.rgb *= vColor;\\n#endif\"; var color_pars_fragment = \"#ifdef USE_COLOR\\n\\tvarying vec3 vColor;\\n#endif\"; var color_pars_vertex = \"#ifdef USE_COLOR\\n\\tvarying vec3 vColor;\\n#endif\"; var color_vertex = \"#ifdef USE_COLOR\\n\\tvColor.xyz = color.xyz;\\n#endif\"; var common = \"#define PI 3.14159265359\\n#define PI2 6.28318530718\\n#define PI_HALF 1.5707963267949\\n#define RECIPROCAL_PI 0.31830988618\\n#define RECIPROCAL_PI2 0.15915494\\n#define LOG2 1.442695\\n#define EPSILON 1e-6\\n#define saturate(a) clamp( a, 0.0, 1.0 )\\n#define whiteCompliment(a) ( 1.0 - saturate( a ) )\\nfloat pow2( const in float x ) { return x*x; }\\nfloat pow3( const in float x ) { return x*x*x; }\\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\\nfloat average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }\\nhighp float rand( const in vec2 uv ) {\\n\\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\\n\\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\\n\\treturn fract(sin(sn) * c);\\n}\\nstruct IncidentLight {\\n\\tvec3 color;\\n\\tvec3 direction;\\n\\tbool visible;\\n};\\nstruct ReflectedLight {\\n\\tvec3 directDiffuse;\\n\\tvec3 directSpecular;\\n\\tvec3 indirectDiffuse;\\n\\tvec3 indirectSpecular;\\n};\\nstruct GeometricContext {\\n\\tvec3 position;\\n\\tvec3 normal;\\n\\tvec3 viewDir;\\n};\\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\\n\\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\\n}\\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\\n\\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\\n}\\nvec3 projectOnPlane(in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\\n\\tfloat distance = dot( planeNormal, point - pointOnPlane );\\n\\treturn - distance * planeNormal + point;\\n}\\nfloat sideOfPlane( in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\\n\\treturn sign( dot( point - pointOnPlane, planeNormal ) );\\n}\\nvec3 linePlaneIntersect( in vec3 pointOnLine, in vec3 lineDirection, in vec3 pointOnPlane, in vec3 planeNormal ) {\\n\\treturn lineDirection * ( dot( planeNormal, pointOnPlane - pointOnLine ) / dot( planeNormal, lineDirection ) ) + pointOnLine;\\n}\\nmat3 transposeMat3( const in mat3 m ) {\\n\\tmat3 tmp;\\n\\ttmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\\n\\ttmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\\n\\ttmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\\n\\treturn tmp;\\n}\\nfloat linearToRelativeLuminance( const in vec3 color ) {\\n\\tvec3 weights = vec3( 0.2126, 0.7152, 0.0722 );\\n\\treturn dot( weights, color.rgb );\\n}\"; var cube_uv_reflection_fragment = \"#ifdef ENVMAP_TYPE_CUBE_UV\\n#define cubeUV_textureSize (1024.0)\\nint getFaceFromDirection(vec3 direction) {\\n\\tvec3 absDirection = abs(direction);\\n\\tint face = -1;\\n\\tif( absDirection.x > absDirection.z ) {\\n\\t\\tif(absDirection.x > absDirection.y )\\n\\t\\t\\tface = direction.x > 0.0 ? 0 : 3;\\n\\t\\telse\\n\\t\\t\\tface = direction.y > 0.0 ? 1 : 4;\\n\\t}\\n\\telse {\\n\\t\\tif(absDirection.z > absDirection.y )\\n\\t\\t\\tface = direction.z > 0.0 ? 2 : 5;\\n\\t\\telse\\n\\t\\t\\tface = direction.y > 0.0 ? 1 : 4;\\n\\t}\\n\\treturn face;\\n}\\n#define cubeUV_maxLods1 (log2(cubeUV_textureSize*0.25) - 1.0)\\n#define cubeUV_rangeClamp (exp2((6.0 - 1.0) * 2.0))\\nvec2 MipLevelInfo( vec3 vec, float roughnessLevel, float roughness ) {\\n\\tfloat scale = exp2(cubeUV_maxLods1 - roughnessLevel);\\n\\tfloat dxRoughness = dFdx(roughness);\\n\\tfloat dyRoughness = dFdy(roughness);\\n\\tvec3 dx = dFdx( vec * scale * dxRoughness );\\n\\tvec3 dy = dFdy( vec * scale * dyRoughness );\\n\\tfloat d = max( dot( dx, dx ), dot( dy, dy ) );\\n\\td = clamp(d, 1.0, cubeUV_rangeClamp);\\n\\tfloat mipLevel = 0.5 * log2(d);\\n\\treturn vec2(floor(mipLevel), fract(mipLevel));\\n}\\n#define cubeUV_maxLods2 (log2(cubeUV_textureSize*0.25) - 2.0)\\n#define cubeUV_rcpTextureSize (1.0 / cubeUV_textureSize)\\nvec2 getCubeUV(vec3 direction, float roughnessLevel, float mipLevel) {\\n\\tmipLevel = roughnessLevel > cubeUV_maxLods2 - 3.0 ? 0.0 : mipLevel;\\n\\tfloat a = 16.0 * cubeUV_rcpTextureSize;\\n\\tvec2 exp2_packed = exp2( vec2( roughnessLevel, mipLevel ) );\\n\\tvec2 rcp_exp2_packed = vec2( 1.0 ) / exp2_packed;\\n\\tfloat powScale = exp2_packed.x * exp2_packed.y;\\n\\tfloat scale = rcp_exp2_packed.x * rcp_exp2_packed.y * 0.25;\\n\\tfloat mipOffset = 0.75*(1.0 - rcp_exp2_packed.y) * rcp_exp2_packed.x;\\n\\tbool bRes = mipLevel == 0.0;\\n\\tscale = bRes && (scale < a) ? a : scale;\\n\\tvec3 r;\\n\\tvec2 offset;\\n\\tint face = getFaceFromDirection(direction);\\n\\tfloat rcpPowScale = 1.0 / powScale;\\n\\tif( face == 0) {\\n\\t\\tr = vec3(direction.x, -direction.z, direction.y);\\n\\t\\toffset = vec2(0.0+mipOffset,0.75 * rcpPowScale);\\n\\t\\toffset.y = bRes && (offset.y < 2.0*a) ? a : offset.y;\\n\\t}\\n\\telse if( face == 1) {\\n\\t\\tr = vec3(direction.y, direction.x, direction.z);\\n\\t\\toffset = vec2(scale+mipOffset, 0.75 * rcpPowScale);\\n\\t\\toffset.y = bRes && (offset.y < 2.0*a) ? a : offset.y;\\n\\t}\\n\\telse if( face == 2) {\\n\\t\\tr = vec3(direction.z, direction.x, direction.y);\\n\\t\\toffset = vec2(2.0*scale+mipOffset, 0.75 * rcpPowScale);\\n\\t\\toffset.y = bRes && (offset.y < 2.0*a) ? a : offset.y;\\n\\t}\\n\\telse if( face == 3) {\\n\\t\\tr = vec3(direction.x, direction.z, direction.y);\\n\\t\\toffset = vec2(0.0+mipOffset,0.5 * rcpPowScale);\\n\\t\\toffset.y = bRes && (offset.y < 2.0*a) ? 0.0 : offset.y;\\n\\t}\\n\\telse if( face == 4) {\\n\\t\\tr = vec3(direction.y, direction.x, -direction.z);\\n\\t\\toffset = vec2(scale+mipOffset, 0.5 * rcpPowScale);\\n\\t\\toffset.y = bRes && (offset.y < 2.0*a) ? 0.0 : offset.y;\\n\\t}\\n\\telse {\\n\\t\\tr = vec3(direction.z, -direction.x, direction.y);\\n\\t\\toffset = vec2(2.0*scale+mipOffset, 0.5 * rcpPowScale);\\n\\t\\toffset.y = bRes && (offset.y < 2.0*a) ? 0.0 : offset.y;\\n\\t}\\n\\tr = normalize(r);\\n\\tfloat texelOffset = 0.5 * cubeUV_rcpTextureSize;\\n\\tvec2 s = ( r.yz / abs( r.x ) + vec2( 1.0 ) ) * 0.5;\\n\\tvec2 base = offset + vec2( texelOffset );\\n\\treturn base + s * ( scale - 2.0 * texelOffset );\\n}\\n#define cubeUV_maxLods3 (log2(cubeUV_textureSize*0.25) - 3.0)\\nvec4 textureCubeUV( sampler2D envMap, vec3 reflectedDirection, float roughness ) {\\n\\tfloat roughnessVal = roughness* cubeUV_maxLods3;\\n\\tfloat r1 = floor(roughnessVal);\\n\\tfloat r2 = r1 + 1.0;\\n\\tfloat t = fract(roughnessVal);\\n\\tvec2 mipInfo = MipLevelInfo(reflectedDirection, r1, roughness);\\n\\tfloat s = mipInfo.y;\\n\\tfloat level0 = mipInfo.x;\\n\\tfloat level1 = level0 + 1.0;\\n\\tlevel1 = level1 > 5.0 ? 5.0 : level1;\\n\\tlevel0 += min( floor( s + 0.5 ), 5.0 );\\n\\tvec2 uv_10 = getCubeUV(reflectedDirection, r1, level0);\\n\\tvec4 color10 = envMapTexelToLinear(texture2D(envMap, uv_10));\\n\\tvec2 uv_20 = getCubeUV(reflectedDirection, r2, level0);\\n\\tvec4 color20 = envMapTexelToLinear(texture2D(envMap, uv_20));\\n\\tvec4 result = mix(color10, color20, t);\\n\\treturn vec4(result.rgb, 1.0);\\n}\\n#endif\"; var defaultnormal_vertex = \"vec3 transformedNormal = normalMatrix * objectNormal;\\n#ifdef FLIP_SIDED\\n\\ttransformedNormal = - transformedNormal;\\n#endif\"; var displacementmap_pars_vertex = \"#ifdef USE_DISPLACEMENTMAP\\n\\tuniform sampler2D displacementMap;\\n\\tuniform float displacementScale;\\n\\tuniform float displacementBias;\\n#endif\"; var displacementmap_vertex = \"#ifdef USE_DISPLACEMENTMAP\\n\\ttransformed += normalize( objectNormal ) * ( texture2D( displacementMap, uv ).x * displacementScale + displacementBias );\\n#endif\"; var emissivemap_fragment = \"#ifdef USE_EMISSIVEMAP\\n\\tvec4 emissiveColor = texture2D( emissiveMap, vUv );\\n\\temissiveColor.rgb = emissiveMapTexelToLinear( emissiveColor ).rgb;\\n\\ttotalEmissiveRadiance *= emissiveColor.rgb;\\n#endif\"; var emissivemap_pars_fragment = \"#ifdef USE_EMISSIVEMAP\\n\\tuniform sampler2D emissiveMap;\\n#endif\"; var encodings_fragment = \"gl_FragColor = linearToOutputTexel( gl_FragColor );\"; var encodings_pars_fragment = \"\\nvec4 LinearToLinear( in vec4 value ) {\\n\\treturn value;\\n}\\nvec4 GammaToLinear( in vec4 value, in float gammaFactor ) {\\n\\treturn vec4( pow( value.rgb, vec3( gammaFactor ) ), value.a );\\n}\\nvec4 LinearToGamma( in vec4 value, in float gammaFactor ) {\\n\\treturn vec4( pow( value.rgb, vec3( 1.0 / gammaFactor ) ), value.a );\\n}\\nvec4 sRGBToLinear( in vec4 value ) {\\n\\treturn vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.a );\\n}\\nvec4 LinearTosRGB( in vec4 value ) {\\n\\treturn vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );\\n}\\nvec4 RGBEToLinear( in vec4 value ) {\\n\\treturn vec4( value.rgb * exp2( value.a * 255.0 - 128.0 ), 1.0 );\\n}\\nvec4 LinearToRGBE( in vec4 value ) {\\n\\tfloat maxComponent = max( max( value.r, value.g ), value.b );\\n\\tfloat fExp = clamp( ceil( log2( maxComponent ) ), -128.0, 127.0 );\\n\\treturn vec4( value.rgb / exp2( fExp ), ( fExp + 128.0 ) / 255.0 );\\n}\\nvec4 RGBMToLinear( in vec4 value, in float maxRange ) {\\n\\treturn vec4( value.rgb * value.a * maxRange, 1.0 );\\n}\\nvec4 LinearToRGBM( in vec4 value, in float maxRange ) {\\n\\tfloat maxRGB = max( value.r, max( value.g, value.b ) );\\n\\tfloat M = clamp( maxRGB / maxRange, 0.0, 1.0 );\\n\\tM = ceil( M * 255.0 ) / 255.0;\\n\\treturn vec4( value.rgb / ( M * maxRange ), M );\\n}\\nvec4 RGBDToLinear( in vec4 value, in float maxRange ) {\\n\\treturn vec4( value.rgb * ( ( maxRange / 255.0 ) / value.a ), 1.0 );\\n}\\nvec4 LinearToRGBD( in vec4 value, in float maxRange ) {\\n\\tfloat maxRGB = max( value.r, max( value.g, value.b ) );\\n\\tfloat D = max( maxRange / maxRGB, 1.0 );\\n\\tD = min( floor( D ) / 255.0, 1.0 );\\n\\treturn vec4( value.rgb * ( D * ( 255.0 / maxRange ) ), D );\\n}\\nconst mat3 cLogLuvM = mat3( 0.2209, 0.3390, 0.4184, 0.1138, 0.6780, 0.7319, 0.0102, 0.1130, 0.2969 );\\nvec4 LinearToLogLuv( in vec4 value ) {\\n\\tvec3 Xp_Y_XYZp = cLogLuvM * value.rgb;\\n\\tXp_Y_XYZp = max( Xp_Y_XYZp, vec3( 1e-6, 1e-6, 1e-6 ) );\\n\\tvec4 vResult;\\n\\tvResult.xy = Xp_Y_XYZp.xy / Xp_Y_XYZp.z;\\n\\tfloat Le = 2.0 * log2(Xp_Y_XYZp.y) + 127.0;\\n\\tvResult.w = fract( Le );\\n\\tvResult.z = ( Le - ( floor( vResult.w * 255.0 ) ) / 255.0 ) / 255.0;\\n\\treturn vResult;\\n}\\nconst mat3 cLogLuvInverseM = mat3( 6.0014, -2.7008, -1.7996, -1.3320, 3.1029, -5.7721, 0.3008, -1.0882, 5.6268 );\\nvec4 LogLuvToLinear( in vec4 value ) {\\n\\tfloat Le = value.z * 255.0 + value.w;\\n\\tvec3 Xp_Y_XYZp;\\n\\tXp_Y_XYZp.y = exp2( ( Le - 127.0 ) / 2.0 );\\n\\tXp_Y_XYZp.z = Xp_Y_XYZp.y / value.y;\\n\\tXp_Y_XYZp.x = value.x * Xp_Y_XYZp.z;\\n\\tvec3 vRGB = cLogLuvInverseM * Xp_Y_XYZp.rgb;\\n\\treturn vec4( max( vRGB, 0.0 ), 1.0 );\\n}\"; var envmap_fragment = \"#ifdef USE_ENVMAP\\n\\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\\n\\t\\tvec3 cameraToVertex = normalize( vWorldPosition - cameraPosition );\\n\\t\\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\\n\\t\\t#ifdef ENVMAP_MODE_REFLECTION\\n\\t\\t\\tvec3 reflectVec = reflect( cameraToVertex, worldNormal );\\n\\t\\t#else\\n\\t\\t\\tvec3 reflectVec = refract( cameraToVertex, worldNormal, refractionRatio );\\n\\t\\t#endif\\n\\t#else\\n\\t\\tvec3 reflectVec = vReflect;\\n\\t#endif\\n\\t#ifdef ENVMAP_TYPE_CUBE\\n\\t\\tvec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\\n\\t#elif defined( ENVMAP_TYPE_EQUIREC )\\n\\t\\tvec2 sampleUV;\\n\\t\\treflectVec = normalize( reflectVec );\\n\\t\\tsampleUV.y = asin( clamp( reflectVec.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\\n\\t\\tsampleUV.x = atan( reflectVec.z, reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\\n\\t\\tvec4 envColor = texture2D( envMap, sampleUV );\\n\\t#elif defined( ENVMAP_TYPE_SPHERE )\\n\\t\\treflectVec = normalize( reflectVec );\\n\\t\\tvec3 reflectView = normalize( ( viewMatrix * vec4( reflectVec, 0.0 ) ).xyz + vec3( 0.0, 0.0, 1.0 ) );\\n\\t\\tvec4 envColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5 );\\n\\t#else\\n\\t\\tvec4 envColor = vec4( 0.0 );\\n\\t#endif\\n\\tenvColor = envMapTexelToLinear( envColor );\\n\\t#ifdef ENVMAP_BLENDING_MULTIPLY\\n\\t\\toutgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\\n\\t#elif defined( ENVMAP_BLENDING_MIX )\\n\\t\\toutgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\\n\\t#elif defined( ENVMAP_BLENDING_ADD )\\n\\t\\toutgoingLight += envColor.xyz * specularStrength * reflectivity;\\n\\t#endif\\n#endif\"; var envmap_pars_fragment = \"#if defined( USE_ENVMAP ) || defined( PHYSICAL )\\n\\tuniform float reflectivity;\\n\\tuniform float envMapIntensity;\\n#endif\\n#ifdef USE_ENVMAP\\n\\t#if ! defined( PHYSICAL ) && ( defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) )\\n\\t\\tvarying vec3 vWorldPosition;\\n\\t#endif\\n\\t#ifdef ENVMAP_TYPE_CUBE\\n\\t\\tuniform samplerCube envMap;\\n\\t#else\\n\\t\\tuniform sampler2D envMap;\\n\\t#endif\\n\\tuniform float flipEnvMap;\\n\\tuniform int maxMipLevel;\\n\\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( PHYSICAL )\\n\\t\\tuniform float refractionRatio;\\n\\t#else\\n\\t\\tvarying vec3 vReflect;\\n\\t#endif\\n#endif\"; var envmap_pars_vertex = \"#ifdef USE_ENVMAP\\n\\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\\n\\t\\tvarying vec3 vWorldPosition;\\n\\t#else\\n\\t\\tvarying vec3 vReflect;\\n\\t\\tuniform float refractionRatio;\\n\\t#endif\\n#endif\"; var envmap_vertex = \"#ifdef USE_ENVMAP\\n\\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\\n\\t\\tvWorldPosition = worldPosition.xyz;\\n\\t#else\\n\\t\\tvec3 cameraToVertex = normalize( worldPosition.xyz - cameraPosition );\\n\\t\\tvec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\\n\\t\\t#ifdef ENVMAP_MODE_REFLECTION\\n\\t\\t\\tvReflect = reflect( cameraToVertex, worldNormal );\\n\\t\\t#else\\n\\t\\t\\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\\n\\t\\t#endif\\n\\t#endif\\n#endif\"; var fog_vertex = \"#ifdef USE_FOG\\n\\tfogDepth = -mvPosition.z;\\n#endif\"; var fog_pars_vertex = \"#ifdef USE_FOG\\n\\tvarying float fogDepth;\\n#endif\"; var fog_fragment = \"#ifdef USE_FOG\\n\\t#ifdef FOG_EXP2\\n\\t\\tfloat fogFactor = whiteCompliment( exp2( - fogDensity * fogDensity * fogDepth * fogDepth * LOG2 ) );\\n\\t#else\\n\\t\\tfloat fogFactor = smoothstep( fogNear, fogFar, fogDepth );\\n\\t#endif\\n\\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\\n#endif\"; var fog_pars_fragment = \"#ifdef USE_FOG\\n\\tuniform vec3 fogColor;\\n\\tvarying float fogDepth;\\n\\t#ifdef FOG_EXP2\\n\\t\\tuniform float fogDensity;\\n\\t#else\\n\\t\\tuniform float fogNear;\\n\\t\\tuniform float fogFar;\\n\\t#endif\\n#endif\"; var gradientmap_pars_fragment = \"#ifdef TOON\\n\\tuniform sampler2D gradientMap;\\n\\tvec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\\n\\t\\tfloat dotNL = dot( normal, lightDirection );\\n\\t\\tvec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\\n\\t\\t#ifdef USE_GRADIENTMAP\\n\\t\\t\\treturn texture2D( gradientMap, coord ).rgb;\\n\\t\\t#else\\n\\t\\t\\treturn ( coord.x < 0.7 ) ? vec3( 0.7 ) : vec3( 1.0 );\\n\\t\\t#endif\\n\\t}\\n#endif\"; var lightmap_fragment = \"#ifdef USE_LIGHTMAP\\n\\treflectedLight.indirectDiffuse += PI * texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\\n#endif\"; var lightmap_pars_fragment = \"#ifdef USE_LIGHTMAP\\n\\tuniform sampler2D lightMap;\\n\\tuniform float lightMapIntensity;\\n#endif\"; var lights_lambert_vertex = \"vec3 diffuse = vec3( 1.0 );\\nGeometricContext geometry;\\ngeometry.position = mvPosition.xyz;\\ngeometry.normal = normalize( transformedNormal );\\ngeometry.viewDir = normalize( -mvPosition.xyz );\\nGeometricContext backGeometry;\\nbackGeometry.position = geometry.position;\\nbackGeometry.normal = -geometry.normal;\\nbackGeometry.viewDir = geometry.viewDir;\\nvLightFront = vec3( 0.0 );\\nvIndirectFront = vec3( 0.0 );\\n#ifdef DOUBLE_SIDED\\n\\tvLightBack = vec3( 0.0 );\\n\\tvIndirectBack = vec3( 0.0 );\\n#endif\\nIncidentLight directLight;\\nfloat dotNL;\\nvec3 directLightColor_Diffuse;\\n#if NUM_POINT_LIGHTS > 0\\n\\t#pragma unroll_loop\\n\\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\\n\\t\\tgetPointDirectLightIrradiance( pointLights[ i ], geometry, directLight );\\n\\t\\tdotNL = dot( geometry.normal, directLight.direction );\\n\\t\\tdirectLightColor_Diffuse = PI * directLight.color;\\n\\t\\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\\n\\t\\t#ifdef DOUBLE_SIDED\\n\\t\\t\\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\\n\\t\\t#endif\\n\\t}\\n#endif\\n#if NUM_SPOT_LIGHTS > 0\\n\\t#pragma unroll_loop\\n\\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\\n\\t\\tgetSpotDirectLightIrradiance( spotLights[ i ], geometry, directLight );\\n\\t\\tdotNL = dot( geometry.normal, directLight.direction );\\n\\t\\tdirectLightColor_Diffuse = PI * directLight.color;\\n\\t\\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\\n\\t\\t#ifdef DOUBLE_SIDED\\n\\t\\t\\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\\n\\t\\t#endif\\n\\t}\\n#endif\\n#if NUM_DIR_LIGHTS > 0\\n\\t#pragma unroll_loop\\n\\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\\n\\t\\tgetDirectionalDirectLightIrradiance( directionalLights[ i ], geometry, directLight );\\n\\t\\tdotNL = dot( geometry.normal, directLight.direction );\\n\\t\\tdirectLightColor_Diffuse = PI * directLight.color;\\n\\t\\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\\n\\t\\t#ifdef DOUBLE_SIDED\\n\\t\\t\\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\\n\\t\\t#endif\\n\\t}\\n#endif\\n#if NUM_HEMI_LIGHTS > 0\\n\\t#pragma unroll_loop\\n\\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\\n\\t\\tvIndirectFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\\n\\t\\t#ifdef DOUBLE_SIDED\\n\\t\\t\\tvIndirectBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry );\\n\\t\\t#endif\\n\\t}\\n#endif\"; var lights_pars_begin = \"uniform vec3 ambientLightColor;\\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\\n\\tvec3 irradiance = ambientLightColor;\\n\\t#ifndef PHYSICALLY_CORRECT_LIGHTS\\n\\t\\tirradiance *= PI;\\n\\t#endif\\n\\treturn irradiance;\\n}\\n#if NUM_DIR_LIGHTS > 0\\n\\tstruct DirectionalLight {\\n\\t\\tvec3 direction;\\n\\t\\tvec3 color;\\n\\t\\tint shadow;\\n\\t\\tfloat shadowBias;\\n\\t\\tfloat shadowRadius;\\n\\t\\tvec2 shadowMapSize;\\n\\t};\\n\\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\\n\\tvoid getDirectionalDirectLightIrradiance( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight directLight ) {\\n\\t\\tdirectLight.color = directionalLight.color;\\n\\t\\tdirectLight.direction = directionalLight.direction;\\n\\t\\tdirectLight.visible = true;\\n\\t}\\n#endif\\n#if NUM_POINT_LIGHTS > 0\\n\\tstruct PointLight {\\n\\t\\tvec3 position;\\n\\t\\tvec3 color;\\n\\t\\tfloat distance;\\n\\t\\tfloat decay;\\n\\t\\tint shadow;\\n\\t\\tfloat shadowBias;\\n\\t\\tfloat shadowRadius;\\n\\t\\tvec2 shadowMapSize;\\n\\t\\tfloat shadowCameraNear;\\n\\t\\tfloat shadowCameraFar;\\n\\t};\\n\\tuniform PointLight pointLights[ NUM_POINT_LIGHTS ];\\n\\tvoid getPointDirectLightIrradiance( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight directLight ) {\\n\\t\\tvec3 lVector = pointLight.position - geometry.position;\\n\\t\\tdirectLight.direction = normalize( lVector );\\n\\t\\tfloat lightDistance = length( lVector );\\n\\t\\tdirectLight.color = pointLight.color;\\n\\t\\tdirectLight.color *= punctualLightIntensityToIrradianceFactor( lightDistance, pointLight.distance, pointLight.decay );\\n\\t\\tdirectLight.visible = ( directLight.color != vec3( 0.0 ) );\\n\\t}\\n#endif\\n#if NUM_SPOT_LIGHTS > 0\\n\\tstruct SpotLight {\\n\\t\\tvec3 position;\\n\\t\\tvec3 direction;\\n\\t\\tvec3 color;\\n\\t\\tfloat distance;\\n\\t\\tfloat decay;\\n\\t\\tfloat coneCos;\\n\\t\\tfloat penumbraCos;\\n\\t\\tint shadow;\\n\\t\\tfloat shadowBias;\\n\\t\\tfloat shadowRadius;\\n\\t\\tvec2 shadowMapSize;\\n\\t};\\n\\tuniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\\n\\tvoid getSpotDirectLightIrradiance( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight directLight ) {\\n\\t\\tvec3 lVector = spotLight.position - geometry.position;\\n\\t\\tdirectLight.direction = normalize( lVector );\\n\\t\\tfloat lightDistance = length( lVector );\\n\\t\\tfloat angleCos = dot( directLight.direction, spotLight.direction );\\n\\t\\tif ( angleCos > spotLight.coneCos ) {\\n\\t\\t\\tfloat spotEffect = smoothstep( spotLight.coneCos, spotLight.penumbraCos, angleCos );\\n\\t\\t\\tdirectLight.color = spotLight.color;\\n\\t\\t\\tdirectLight.color *= spotEffect * punctualLightIntensityToIrradianceFactor( lightDistance, spotLight.distance, spotLight.decay );\\n\\t\\t\\tdirectLight.visible = true;\\n\\t\\t} else {\\n\\t\\t\\tdirectLight.color = vec3( 0.0 );\\n\\t\\t\\tdirectLight.visible = false;\\n\\t\\t}\\n\\t}\\n#endif\\n#if NUM_RECT_AREA_LIGHTS > 0\\n\\tstruct RectAreaLight {\\n\\t\\tvec3 color;\\n\\t\\tvec3 position;\\n\\t\\tvec3 halfWidth;\\n\\t\\tvec3 halfHeight;\\n\\t};\\n\\tuniform sampler2D ltc_1;\\tuniform sampler2D ltc_2;\\n\\tuniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\\n#endif\\n#if NUM_HEMI_LIGHTS > 0\\n\\tstruct HemisphereLight {\\n\\t\\tvec3 direction;\\n\\t\\tvec3 skyColor;\\n\\t\\tvec3 groundColor;\\n\\t};\\n\\tuniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\\n\\tvec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in GeometricContext geometry ) {\\n\\t\\tfloat dotNL = dot( geometry.normal, hemiLight.direction );\\n\\t\\tfloat hemiDiffuseWeight = 0.5 * dotNL + 0.5;\\n\\t\\tvec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\\n\\t\\t#ifndef PHYSICALLY_CORRECT_LIGHTS\\n\\t\\t\\tirradiance *= PI;\\n\\t\\t#endif\\n\\t\\treturn irradiance;\\n\\t}\\n#endif\"; var envmap_physical_pars_fragment = \"#if defined( USE_ENVMAP ) && defined( PHYSICAL )\\n\\tvec3 getLightProbeIndirectIrradiance( const in GeometricContext geometry, const in int maxMIPLevel ) {\\n\\t\\tvec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\\n\\t\\t#ifdef ENVMAP_TYPE_CUBE\\n\\t\\t\\tvec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\\n\\t\\t\\t#ifdef TEXTURE_LOD_EXT\\n\\t\\t\\t\\tvec4 envMapColor = textureCubeLodEXT( envMap, queryVec, float( maxMIPLevel ) );\\n\\t\\t\\t#else\\n\\t\\t\\t\\tvec4 envMapColor = textureCube( envMap, queryVec, float( maxMIPLevel ) );\\n\\t\\t\\t#endif\\n\\t\\t\\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\\n\\t\\t#elif defined( ENVMAP_TYPE_CUBE_UV )\\n\\t\\t\\tvec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\\n\\t\\t\\tvec4 envMapColor = textureCubeUV( envMap, queryVec, 1.0 );\\n\\t\\t#else\\n\\t\\t\\tvec4 envMapColor = vec4( 0.0 );\\n\\t\\t#endif\\n\\t\\treturn PI * envMapColor.rgb * envMapIntensity;\\n\\t}\\n\\tfloat getSpecularMIPLevel( const in float blinnShininessExponent, const in int maxMIPLevel ) {\\n\\t\\tfloat maxMIPLevelScalar = float( maxMIPLevel );\\n\\t\\tfloat desiredMIPLevel = maxMIPLevelScalar + 0.79248 - 0.5 * log2( pow2( blinnShininessExponent ) + 1.0 );\\n\\t\\treturn clamp( desiredMIPLevel, 0.0, maxMIPLevelScalar );\\n\\t}\\n\\tvec3 getLightProbeIndirectRadiance( const in GeometricContext geometry, const in float blinnShininessExponent, const in int maxMIPLevel ) {\\n\\t\\t#ifdef ENVMAP_MODE_REFLECTION\\n\\t\\t\\tvec3 reflectVec = reflect( -geometry.viewDir, geometry.normal );\\n\\t\\t#else\\n\\t\\t\\tvec3 reflectVec = refract( -geometry.viewDir, geometry.normal, refractionRatio );\\n\\t\\t#endif\\n\\t\\treflectVec = inverseTransformDirection( reflectVec, viewMatrix );\\n\\t\\tfloat specularMIPLevel = getSpecularMIPLevel( blinnShininessExponent, maxMIPLevel );\\n\\t\\t#ifdef ENVMAP_TYPE_CUBE\\n\\t\\t\\tvec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\\n\\t\\t\\t#ifdef TEXTURE_LOD_EXT\\n\\t\\t\\t\\tvec4 envMapColor = textureCubeLodEXT( envMap, queryReflectVec, specularMIPLevel );\\n\\t\\t\\t#else\\n\\t\\t\\t\\tvec4 envMapColor = textureCube( envMap, queryReflectVec, specularMIPLevel );\\n\\t\\t\\t#endif\\n\\t\\t\\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\\n\\t\\t#elif defined( ENVMAP_TYPE_CUBE_UV )\\n\\t\\t\\tvec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\\n\\t\\t\\tvec4 envMapColor = textureCubeUV( envMap, queryReflectVec, BlinnExponentToGGXRoughness(blinnShininessExponent ));\\n\\t\\t#elif defined( ENVMAP_TYPE_EQUIREC )\\n\\t\\t\\tvec2 sampleUV;\\n\\t\\t\\tsampleUV.y = asin( clamp( reflectVec.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\\n\\t\\t\\tsampleUV.x = atan( reflectVec.z, reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\\n\\t\\t\\t#ifdef TEXTURE_LOD_EXT\\n\\t\\t\\t\\tvec4 envMapColor = texture2DLodEXT( envMap, sampleUV, specularMIPLevel );\\n\\t\\t\\t#else\\n\\t\\t\\t\\tvec4 envMapColor = texture2D( envMap, sampleUV, specularMIPLevel );\\n\\t\\t\\t#endif\\n\\t\\t\\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\\n\\t\\t#elif defined( ENVMAP_TYPE_SPHERE )\\n\\t\\t\\tvec3 reflectView = normalize( ( viewMatrix * vec4( reflectVec, 0.0 ) ).xyz + vec3( 0.0,0.0,1.0 ) );\\n\\t\\t\\t#ifdef TEXTURE_LOD_EXT\\n\\t\\t\\t\\tvec4 envMapColor = texture2DLodEXT( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );\\n\\t\\t\\t#else\\n\\t\\t\\t\\tvec4 envMapColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );\\n\\t\\t\\t#endif\\n\\t\\t\\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\\n\\t\\t#endif\\n\\t\\treturn envMapColor.rgb * envMapIntensity;\\n\\t}\\n#endif\"; var lights_phong_fragment = \"BlinnPhongMaterial material;\\nmaterial.diffuseColor = diffuseColor.rgb;\\nmaterial.specularColor = specular;\\nmaterial.specularShininess = shininess;\\nmaterial.specularStrength = specularStrength;\"; var lights_phong_pars_fragment = \"varying vec3 vViewPosition;\\n#ifndef FLAT_SHADED\\n\\tvarying vec3 vNormal;\\n#endif\\nstruct BlinnPhongMaterial {\\n\\tvec3\\tdiffuseColor;\\n\\tvec3\\tspecularColor;\\n\\tfloat\\tspecularShininess;\\n\\tfloat\\tspecularStrength;\\n};\\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\\n\\t#ifdef TOON\\n\\t\\tvec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;\\n\\t#else\\n\\t\\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\\n\\t\\tvec3 irradiance = dotNL * directLight.color;\\n\\t#endif\\n\\t#ifndef PHYSICALLY_CORRECT_LIGHTS\\n\\t\\tirradiance *= PI;\\n\\t#endif\\n\\treflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\\n\\treflectedLight.directSpecular += irradiance * BRDF_Specular_BlinnPhong( directLight, geometry, material.specularColor, material.specularShininess ) * material.specularStrength;\\n}\\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\\n\\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\\n}\\n#define RE_Direct\\t\\t\\t\\tRE_Direct_BlinnPhong\\n#define RE_IndirectDiffuse\\t\\tRE_IndirectDiffuse_BlinnPhong\\n#define Material_LightProbeLOD( material )\\t(0)\"; var lights_physical_fragment = \"PhysicalMaterial material;\\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\\nmaterial.specularRoughness = clamp( roughnessFactor, 0.04, 1.0 );\\n#ifdef STANDARD\\n\\tmaterial.specularColor = mix( vec3( DEFAULT_SPECULAR_COEFFICIENT ), diffuseColor.rgb, metalnessFactor );\\n#else\\n\\tmaterial.specularColor = mix( vec3( MAXIMUM_SPECULAR_COEFFICIENT * pow2( reflectivity ) ), diffuseColor.rgb, metalnessFactor );\\n\\tmaterial.clearCoat = saturate( clearCoat );\\tmaterial.clearCoatRoughness = clamp( clearCoatRoughness, 0.04, 1.0 );\\n#endif\"; var lights_physical_pars_fragment = \"struct PhysicalMaterial {\\n\\tvec3\\tdiffuseColor;\\n\\tfloat\\tspecularRoughness;\\n\\tvec3\\tspecularColor;\\n\\t#ifndef STANDARD\\n\\t\\tfloat clearCoat;\\n\\t\\tfloat clearCoatRoughness;\\n\\t#endif\\n};\\n#define MAXIMUM_SPECULAR_COEFFICIENT 0.16\\n#define DEFAULT_SPECULAR_COEFFICIENT 0.04\\nfloat clearCoatDHRApprox( const in float roughness, const in float dotNL ) {\\n\\treturn DEFAULT_SPECULAR_COEFFICIENT + ( 1.0 - DEFAULT_SPECULAR_COEFFICIENT ) * ( pow( 1.0 - dotNL, 5.0 ) * pow( 1.0 - roughness, 2.0 ) );\\n}\\n#if NUM_RECT_AREA_LIGHTS > 0\\n\\tvoid RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\\n\\t\\tvec3 normal = geometry.normal;\\n\\t\\tvec3 viewDir = geometry.viewDir;\\n\\t\\tvec3 position = geometry.position;\\n\\t\\tvec3 lightPos = rectAreaLight.position;\\n\\t\\tvec3 halfWidth = rectAreaLight.halfWidth;\\n\\t\\tvec3 halfHeight = rectAreaLight.halfHeight;\\n\\t\\tvec3 lightColor = rectAreaLight.color;\\n\\t\\tfloat roughness = material.specularRoughness;\\n\\t\\tvec3 rectCoords[ 4 ];\\n\\t\\trectCoords[ 0 ] = lightPos + halfWidth - halfHeight;\\t\\trectCoords[ 1 ] = lightPos - halfWidth - halfHeight;\\n\\t\\trectCoords[ 2 ] = lightPos - halfWidth + halfHeight;\\n\\t\\trectCoords[ 3 ] = lightPos + halfWidth + halfHeight;\\n\\t\\tvec2 uv = LTC_Uv( normal, viewDir, roughness );\\n\\t\\tvec4 t1 = texture2D( ltc_1, uv );\\n\\t\\tvec4 t2 = texture2D( ltc_2, uv );\\n\\t\\tmat3 mInv = mat3(\\n\\t\\t\\tvec3( t1.x, 0, t1.y ),\\n\\t\\t\\tvec3( 0, 1, 0 ),\\n\\t\\t\\tvec3( t1.z, 0, t1.w )\\n\\t\\t);\\n\\t\\tvec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );\\n\\t\\treflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\\n\\t\\treflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );\\n\\t}\\n#endif\\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\\n\\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\\n\\tvec3 irradiance = dotNL * directLight.color;\\n\\t#ifndef PHYSICALLY_CORRECT_LIGHTS\\n\\t\\tirradiance *= PI;\\n\\t#endif\\n\\t#ifndef STANDARD\\n\\t\\tfloat clearCoatDHR = material.clearCoat * clearCoatDHRApprox( material.clearCoatRoughness, dotNL );\\n\\t#else\\n\\t\\tfloat clearCoatDHR = 0.0;\\n\\t#endif\\n\\treflectedLight.directSpecular += ( 1.0 - clearCoatDHR ) * irradiance * BRDF_Specular_GGX( directLight, geometry, material.specularColor, material.specularRoughness );\\n\\treflectedLight.directDiffuse += ( 1.0 - clearCoatDHR ) * irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\\n\\t#ifndef STANDARD\\n\\t\\treflectedLight.directSpecular += irradiance * material.clearCoat * BRDF_Specular_GGX( directLight, geometry, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearCoatRoughness );\\n\\t#endif\\n}\\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\\n\\t#ifndef ENVMAP_TYPE_CUBE_UV\\n\\t\\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\\n\\t#endif\\n}\\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearCoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {\\n\\t#ifndef STANDARD\\n\\t\\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\\n\\t\\tfloat dotNL = dotNV;\\n\\t\\tfloat clearCoatDHR = material.clearCoat * clearCoatDHRApprox( material.clearCoatRoughness, dotNL );\\n\\t#else\\n\\t\\tfloat clearCoatDHR = 0.0;\\n\\t#endif\\n\\tfloat clearCoatInv = 1.0 - clearCoatDHR;\\n\\t#if defined( ENVMAP_TYPE_CUBE_UV )\\n\\t\\tvec3 singleScattering = vec3( 0.0 );\\n\\t\\tvec3 multiScattering = vec3( 0.0 );\\n\\t\\tvec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;\\n\\t\\tBRDF_Specular_Multiscattering_Environment( geometry, material.specularColor, material.specularRoughness, singleScattering, multiScattering );\\n\\t\\tvec3 diffuse = material.diffuseColor;\\n\\t\\treflectedLight.indirectSpecular += clearCoatInv * radiance * singleScattering;\\n\\t\\treflectedLight.indirectDiffuse += multiScattering * cosineWeightedIrradiance;\\n\\t\\treflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;\\n\\t#else\\n\\t\\treflectedLight.indirectSpecular += clearCoatInv * radiance * BRDF_Specular_GGX_Environment( geometry, material.specularColor, material.specularRoughness );\\n\\t#endif\\n\\t#ifndef STANDARD\\n\\t\\treflectedLight.indirectSpecular += clearCoatRadiance * material.clearCoat * BRDF_Specular_GGX_Environment( geometry, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearCoatRoughness );\\n\\t#endif\\n}\\n#define RE_Direct\\t\\t\\t\\tRE_Direct_Physical\\n#define RE_Direct_RectArea\\t\\tRE_Direct_RectArea_Physical\\n#define RE_IndirectDiffuse\\t\\tRE_IndirectDiffuse_Physical\\n#define RE_IndirectSpecular\\t\\tRE_IndirectSpecular_Physical\\n#define Material_BlinnShininessExponent( material ) GGXRoughnessToBlinnExponent( material.specularRoughness )\\n#define Material_ClearCoat_BlinnShininessExponent( material ) GGXRoughnessToBlinnExponent( material.clearCoatRoughness )\\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\\n\\treturn saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\\n}\"; var lights_fragment_begin = \"\\nGeometricContext geometry;\\ngeometry.position = - vViewPosition;\\ngeometry.normal = normal;\\ngeometry.viewDir = normalize( vViewPosition );\\nIncidentLight directLight;\\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\\n\\tPointLight pointLight;\\n\\t#pragma unroll_loop\\n\\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\\n\\t\\tpointLight = pointLights[ i ];\\n\\t\\tgetPointDirectLightIrradiance( pointLight, geometry, directLight );\\n\\t\\t#ifdef USE_SHADOWMAP\\n\\t\\tdirectLight.color *= all( bvec2( pointLight.shadow, directLight.visible ) ) ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\\n\\t\\t#endif\\n\\t\\tRE_Direct( directLight, geometry, material, reflectedLight );\\n\\t}\\n#endif\\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\\n\\tSpotLight spotLight;\\n\\t#pragma unroll_loop\\n\\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\\n\\t\\tspotLight = spotLights[ i ];\\n\\t\\tgetSpotDirectLightIrradiance( spotLight, geometry, directLight );\\n\\t\\t#ifdef USE_SHADOWMAP\\n\\t\\tdirectLight.color *= all( bvec2( spotLight.shadow, directLight.visible ) ) ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\\n\\t\\t#endif\\n\\t\\tRE_Direct( directLight, geometry, material, reflectedLight );\\n\\t}\\n#endif\\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\\n\\tDirectionalLight directionalLight;\\n\\t#pragma unroll_loop\\n\\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\\n\\t\\tdirectionalLight = directionalLights[ i ];\\n\\t\\tgetDirectionalDirectLightIrradiance( directionalLight, geometry, directLight );\\n\\t\\t#ifdef USE_SHADOWMAP\\n\\t\\tdirectLight.color *= all( bvec2( directionalLight.shadow, directLight.visible ) ) ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\\n\\t\\t#endif\\n\\t\\tRE_Direct( directLight, geometry, material, reflectedLight );\\n\\t}\\n#endif\\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\\n\\tRectAreaLight rectAreaLight;\\n\\t#pragma unroll_loop\\n\\tfor ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\\n\\t\\trectAreaLight = rectAreaLights[ i ];\\n\\t\\tRE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );\\n\\t}\\n#endif\\n#if defined( RE_IndirectDiffuse )\\n\\tvec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\\n\\t#if ( NUM_HEMI_LIGHTS > 0 )\\n\\t\\t#pragma unroll_loop\\n\\t\\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\\n\\t\\t\\tirradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\\n\\t\\t}\\n\\t#endif\\n#endif\\n#if defined( RE_IndirectSpecular )\\n\\tvec3 radiance = vec3( 0.0 );\\n\\tvec3 clearCoatRadiance = vec3( 0.0 );\\n#endif\"; var lights_fragment_maps = \"#if defined( RE_IndirectDiffuse )\\n\\t#ifdef USE_LIGHTMAP\\n\\t\\tvec3 lightMapIrradiance = texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\\n\\t\\t#ifndef PHYSICALLY_CORRECT_LIGHTS\\n\\t\\t\\tlightMapIrradiance *= PI;\\n\\t\\t#endif\\n\\t\\tirradiance += lightMapIrradiance;\\n\\t#endif\\n\\t#if defined( USE_ENVMAP ) && defined( PHYSICAL ) && defined( ENVMAP_TYPE_CUBE_UV )\\n\\t\\tirradiance += getLightProbeIndirectIrradiance( geometry, maxMipLevel );\\n\\t#endif\\n#endif\\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\\n\\tradiance += getLightProbeIndirectRadiance( geometry, Material_BlinnShininessExponent( material ), maxMipLevel );\\n\\t#ifndef STANDARD\\n\\t\\tclearCoatRadiance += getLightProbeIndirectRadiance( geometry, Material_ClearCoat_BlinnShininessExponent( material ), maxMipLevel );\\n\\t#endif\\n#endif\"; var lights_fragment_end = \"#if defined( RE_IndirectDiffuse )\\n\\tRE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\\n#endif\\n#if defined( RE_IndirectSpecular )\\n\\tRE_IndirectSpecular( radiance, irradiance, clearCoatRadiance, geometry, material, reflectedLight );\\n#endif\"; var logdepthbuf_fragment = \"#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\\n\\tgl_FragDepthEXT = log2( vFragDepth ) * logDepthBufFC * 0.5;\\n#endif\"; var logdepthbuf_pars_fragment = \"#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\\n\\tuniform float logDepthBufFC;\\n\\tvarying float vFragDepth;\\n#endif\"; var logdepthbuf_pars_vertex = \"#ifdef USE_LOGDEPTHBUF\\n\\t#ifdef USE_LOGDEPTHBUF_EXT\\n\\t\\tvarying float vFragDepth;\\n\\t#else\\n\\t\\tuniform float logDepthBufFC;\\n\\t#endif\\n#endif\"; var logdepthbuf_vertex = \"#ifdef USE_LOGDEPTHBUF\\n\\t#ifdef USE_LOGDEPTHBUF_EXT\\n\\t\\tvFragDepth = 1.0 + gl_Position.w;\\n\\t#else\\n\\t\\tgl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;\\n\\t\\tgl_Position.z *= gl_Position.w;\\n\\t#endif\\n#endif\"; var map_fragment = \"#ifdef USE_MAP\\n\\tvec4 texelColor = texture2D( map, vUv );\\n\\ttexelColor = mapTexelToLinear( texelColor );\\n\\tdiffuseColor *= texelColor;\\n#endif\"; var map_pars_fragment = \"#ifdef USE_MAP\\n\\tuniform sampler2D map;\\n#endif\"; var map_particle_fragment = \"#ifdef USE_MAP\\n\\tvec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;\\n\\tvec4 mapTexel = texture2D( map, uv );\\n\\tdiffuseColor *= mapTexelToLinear( mapTexel );\\n#endif\"; var map_particle_pars_fragment = \"#ifdef USE_MAP\\n\\tuniform mat3 uvTransform;\\n\\tuniform sampler2D map;\\n#endif\"; var metalnessmap_fragment = \"float metalnessFactor = metalness;\\n#ifdef USE_METALNESSMAP\\n\\tvec4 texelMetalness = texture2D( metalnessMap, vUv );\\n\\tmetalnessFactor *= texelMetalness.b;\\n#endif\"; var metalnessmap_pars_fragment = \"#ifdef USE_METALNESSMAP\\n\\tuniform sampler2D metalnessMap;\\n#endif\"; var morphnormal_vertex = \"#ifdef USE_MORPHNORMALS\\n\\tobjectNormal += ( morphNormal0 - normal ) * morphTargetInfluences[ 0 ];\\n\\tobjectNormal += ( morphNormal1 - normal ) * morphTargetInfluences[ 1 ];\\n\\tobjectNormal += ( morphNormal2 - normal ) * morphTargetInfluences[ 2 ];\\n\\tobjectNormal += ( morphNormal3 - normal ) * morphTargetInfluences[ 3 ];\\n#endif\"; var morphtarget_pars_vertex = \"#ifdef USE_MORPHTARGETS\\n\\t#ifndef USE_MORPHNORMALS\\n\\tuniform float morphTargetInfluences[ 8 ];\\n\\t#else\\n\\tuniform float morphTargetInfluences[ 4 ];\\n\\t#endif\\n#endif\"; var morphtarget_vertex = \"#ifdef USE_MORPHTARGETS\\n\\ttransformed += ( morphTarget0 - position ) * morphTargetInfluences[ 0 ];\\n\\ttransformed += ( morphTarget1 - position ) * morphTargetInfluences[ 1 ];\\n\\ttransformed += ( morphTarget2 - position ) * morphTargetInfluences[ 2 ];\\n\\ttransformed += ( morphTarget3 - position ) * morphTargetInfluences[ 3 ];\\n\\t#ifndef USE_MORPHNORMALS\\n\\ttransformed += ( morphTarget4 - position ) * morphTargetInfluences[ 4 ];\\n\\ttransformed += ( morphTarget5 - position ) * morphTargetInfluences[ 5 ];\\n\\ttransformed += ( morphTarget6 - position ) * morphTargetInfluences[ 6 ];\\n\\ttransformed += ( morphTarget7 - position ) * morphTargetInfluences[ 7 ];\\n\\t#endif\\n#endif\"; var normal_fragment_begin = \"#ifdef FLAT_SHADED\\n\\tvec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );\\n\\tvec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );\\n\\tvec3 normal = normalize( cross( fdx, fdy ) );\\n#else\\n\\tvec3 normal = normalize( vNormal );\\n\\t#ifdef DOUBLE_SIDED\\n\\t\\tnormal = normal * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\\n\\t#endif\\n#endif\"; var normal_fragment_maps = \"#ifdef USE_NORMALMAP\\n\\t#ifdef OBJECTSPACE_NORMALMAP\\n\\t\\tnormal = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\\n\\t\\t#ifdef FLIP_SIDED\\n\\t\\t\\tnormal = - normal;\\n\\t\\t#endif\\n\\t\\t#ifdef DOUBLE_SIDED\\n\\t\\t\\tnormal = normal * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\\n\\t\\t#endif\\n\\t\\tnormal = normalize( normalMatrix * normal );\\n\\t#else\\n\\t\\tnormal = perturbNormal2Arb( -vViewPosition, normal );\\n\\t#endif\\n#elif defined( USE_BUMPMAP )\\n\\tnormal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd() );\\n#endif\"; var normalmap_pars_fragment = \"#ifdef USE_NORMALMAP\\n\\tuniform sampler2D normalMap;\\n\\tuniform vec2 normalScale;\\n\\t#ifdef OBJECTSPACE_NORMALMAP\\n\\t\\tuniform mat3 normalMatrix;\\n\\t#else\\n\\t\\tvec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm ) {\\n\\t\\t\\tvec3 q0 = vec3( dFdx( eye_pos.x ), dFdx( eye_pos.y ), dFdx( eye_pos.z ) );\\n\\t\\t\\tvec3 q1 = vec3( dFdy( eye_pos.x ), dFdy( eye_pos.y ), dFdy( eye_pos.z ) );\\n\\t\\t\\tvec2 st0 = dFdx( vUv.st );\\n\\t\\t\\tvec2 st1 = dFdy( vUv.st );\\n\\t\\t\\tfloat scale = sign( st1.t * st0.s - st0.t * st1.s );\\n\\t\\t\\tvec3 S = normalize( ( q0 * st1.t - q1 * st0.t ) * scale );\\n\\t\\t\\tvec3 T = normalize( ( - q0 * st1.s + q1 * st0.s ) * scale );\\n\\t\\t\\tvec3 N = normalize( surf_norm );\\n\\t\\t\\tmat3 tsn = mat3( S, T, N );\\n\\t\\t\\tvec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\\n\\t\\t\\tmapN.xy *= normalScale;\\n\\t\\t\\tmapN.xy *= ( float( gl_FrontFacing ) * 2.0 - 1.0 );\\n\\t\\t\\treturn normalize( tsn * mapN );\\n\\t\\t}\\n\\t#endif\\n#endif\"; var packing = \"vec3 packNormalToRGB( const in vec3 normal ) {\\n\\treturn normalize( normal ) * 0.5 + 0.5;\\n}\\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\\n\\treturn 2.0 * rgb.xyz - 1.0;\\n}\\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );\\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\\nconst float ShiftRight8 = 1. / 256.;\\nvec4 packDepthToRGBA( const in float v ) {\\n\\tvec4 r = vec4( fract( v * PackFactors ), v );\\n\\tr.yzw -= r.xyz * ShiftRight8;\\treturn r * PackUpscale;\\n}\\nfloat unpackRGBAToDepth( const in vec4 v ) {\\n\\treturn dot( v, UnpackFactors );\\n}\\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\\n\\treturn ( viewZ + near ) / ( near - far );\\n}\\nfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\\n\\treturn linearClipZ * ( near - far ) - near;\\n}\\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\\n\\treturn (( near + viewZ ) * far ) / (( far - near ) * viewZ );\\n}\\nfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\\n\\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\\n}\"; var premultiplied_alpha_fragment = \"#ifdef PREMULTIPLIED_ALPHA\\n\\tgl_FragColor.rgb *= gl_FragColor.a;\\n#endif\"; var project_vertex = \"vec4 mvPosition = modelViewMatrix * vec4( transformed, 1.0 );\\ngl_Position = projectionMatrix * mvPosition;\"; var dithering_fragment = \"#if defined( DITHERING )\\n\\tgl_FragColor.rgb = dithering( gl_FragColor.rgb );\\n#endif\"; var dithering_pars_fragment = \"#if defined( DITHERING )\\n\\tvec3 dithering( vec3 color ) {\\n\\t\\tfloat grid_position = rand( gl_FragCoord.xy );\\n\\t\\tvec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\\n\\t\\tdither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\\n\\t\\treturn color + dither_shift_RGB;\\n\\t}\\n#endif\"; var roughnessmap_fragment = \"float roughnessFactor = roughness;\\n#ifdef USE_ROUGHNESSMAP\\n\\tvec4 texelRoughness = texture2D( roughnessMap, vUv );\\n\\troughnessFactor *= texelRoughness.g;\\n#endif\"; var roughnessmap_pars_fragment = \"#ifdef USE_ROUGHNESSMAP\\n\\tuniform sampler2D roughnessMap;\\n#endif\"; var shadowmap_pars_fragment = \"#ifdef USE_SHADOWMAP\\n\\t#if NUM_DIR_LIGHTS > 0\\n\\t\\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHTS ];\\n\\t\\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\\n\\t#endif\\n\\t#if NUM_SPOT_LIGHTS > 0\\n\\t\\tuniform sampler2D spotShadowMap[ NUM_SPOT_LIGHTS ];\\n\\t\\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHTS ];\\n\\t#endif\\n\\t#if NUM_POINT_LIGHTS > 0\\n\\t\\tuniform sampler2D pointShadowMap[ NUM_POINT_LIGHTS ];\\n\\t\\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHTS ];\\n\\t#endif\\n\\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\\n\\t\\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\\n\\t}\\n\\tfloat texture2DShadowLerp( sampler2D depths, vec2 size, vec2 uv, float compare ) {\\n\\t\\tconst vec2 offset = vec2( 0.0, 1.0 );\\n\\t\\tvec2 texelSize = vec2( 1.0 ) / size;\\n\\t\\tvec2 centroidUV = floor( uv * size + 0.5 ) / size;\\n\\t\\tfloat lb = texture2DCompare( depths, centroidUV + texelSize * offset.xx, compare );\\n\\t\\tfloat lt = texture2DCompare( depths, centroidUV + texelSize * offset.xy, compare );\\n\\t\\tfloat rb = texture2DCompare( depths, centroidUV + texelSize * offset.yx, compare );\\n\\t\\tfloat rt = texture2DCompare( depths, centroidUV + texelSize * offset.yy, compare );\\n\\t\\tvec2 f = fract( uv * size + 0.5 );\\n\\t\\tfloat a = mix( lb, lt, f.y );\\n\\t\\tfloat b = mix( rb, rt, f.y );\\n\\t\\tfloat c = mix( a, b, f.x );\\n\\t\\treturn c;\\n\\t}\\n\\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\\n\\t\\tfloat shadow = 1.0;\\n\\t\\tshadowCoord.xyz /= shadowCoord.w;\\n\\t\\tshadowCoord.z += shadowBias;\\n\\t\\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x = 0.0, shadowCoord.y 0.0 )\\n\\t\\t\\t\\tplanar.x = 4.0 - v.x;\\n\\t\\t} else if ( absV.x >= almostOne ) {\\n\\t\\t\\tfloat signX = sign( v.x );\\n\\t\\t\\tplanar.x = v.z * signX + 2.0 * signX;\\n\\t\\t} else if ( absV.y >= almostOne ) {\\n\\t\\t\\tfloat signY = sign( v.y );\\n\\t\\t\\tplanar.x = v.x + 2.0 * signY + 2.0;\\n\\t\\t\\tplanar.y = v.z * signY - 2.0;\\n\\t\\t}\\n\\t\\treturn vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\\n\\t}\\n\\tfloat getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\\n\\t\\tvec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\\n\\t\\tvec3 lightToPosition = shadowCoord.xyz;\\n\\t\\tfloat dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );\\t\\tdp += shadowBias;\\n\\t\\tvec3 bd3D = normalize( lightToPosition );\\n\\t\\t#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT )\\n\\t\\t\\tvec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\\n\\t\\t\\treturn (\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\\n\\t\\t\\t) * ( 1.0 / 9.0 );\\n\\t\\t#else\\n\\t\\t\\treturn texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\\n\\t\\t#endif\\n\\t}\\n#endif\"; var shadowmap_pars_vertex = \"#ifdef USE_SHADOWMAP\\n\\t#if NUM_DIR_LIGHTS > 0\\n\\t\\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHTS ];\\n\\t\\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\\n\\t#endif\\n\\t#if NUM_SPOT_LIGHTS > 0\\n\\t\\tuniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHTS ];\\n\\t\\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHTS ];\\n\\t#endif\\n\\t#if NUM_POINT_LIGHTS > 0\\n\\t\\tuniform mat4 pointShadowMatrix[ NUM_POINT_LIGHTS ];\\n\\t\\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHTS ];\\n\\t#endif\\n#endif\"; var shadowmap_vertex = \"#ifdef USE_SHADOWMAP\\n\\t#if NUM_DIR_LIGHTS > 0\\n\\t#pragma unroll_loop\\n\\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\\n\\t\\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * worldPosition;\\n\\t}\\n\\t#endif\\n\\t#if NUM_SPOT_LIGHTS > 0\\n\\t#pragma unroll_loop\\n\\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\\n\\t\\tvSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * worldPosition;\\n\\t}\\n\\t#endif\\n\\t#if NUM_POINT_LIGHTS > 0\\n\\t#pragma unroll_loop\\n\\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\\n\\t\\tvPointShadowCoord[ i ] = pointShadowMatrix[ i ] * worldPosition;\\n\\t}\\n\\t#endif\\n#endif\"; var shadowmask_pars_fragment = \"float getShadowMask() {\\n\\tfloat shadow = 1.0;\\n\\t#ifdef USE_SHADOWMAP\\n\\t#if NUM_DIR_LIGHTS > 0\\n\\tDirectionalLight directionalLight;\\n\\t#pragma unroll_loop\\n\\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\\n\\t\\tdirectionalLight = directionalLights[ i ];\\n\\t\\tshadow *= bool( directionalLight.shadow ) ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\\n\\t}\\n\\t#endif\\n\\t#if NUM_SPOT_LIGHTS > 0\\n\\tSpotLight spotLight;\\n\\t#pragma unroll_loop\\n\\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\\n\\t\\tspotLight = spotLights[ i ];\\n\\t\\tshadow *= bool( spotLight.shadow ) ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\\n\\t}\\n\\t#endif\\n\\t#if NUM_POINT_LIGHTS > 0\\n\\tPointLight pointLight;\\n\\t#pragma unroll_loop\\n\\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\\n\\t\\tpointLight = pointLights[ i ];\\n\\t\\tshadow *= bool( pointLight.shadow ) ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\\n\\t}\\n\\t#endif\\n\\t#endif\\n\\treturn shadow;\\n}\"; var skinbase_vertex = \"#ifdef USE_SKINNING\\n\\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\\n\\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\\n\\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\\n\\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\\n#endif\"; var skinning_pars_vertex = \"#ifdef USE_SKINNING\\n\\tuniform mat4 bindMatrix;\\n\\tuniform mat4 bindMatrixInverse;\\n\\t#ifdef BONE_TEXTURE\\n\\t\\tuniform sampler2D boneTexture;\\n\\t\\tuniform int boneTextureSize;\\n\\t\\tmat4 getBoneMatrix( const in float i ) {\\n\\t\\t\\tfloat j = i * 4.0;\\n\\t\\t\\tfloat x = mod( j, float( boneTextureSize ) );\\n\\t\\t\\tfloat y = floor( j / float( boneTextureSize ) );\\n\\t\\t\\tfloat dx = 1.0 / float( boneTextureSize );\\n\\t\\t\\tfloat dy = 1.0 / float( boneTextureSize );\\n\\t\\t\\ty = dy * ( y + 0.5 );\\n\\t\\t\\tvec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\\n\\t\\t\\tvec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\\n\\t\\t\\tvec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\\n\\t\\t\\tvec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\\n\\t\\t\\tmat4 bone = mat4( v1, v2, v3, v4 );\\n\\t\\t\\treturn bone;\\n\\t\\t}\\n\\t#else\\n\\t\\tuniform mat4 boneMatrices[ MAX_BONES ];\\n\\t\\tmat4 getBoneMatrix( const in float i ) {\\n\\t\\t\\tmat4 bone = boneMatrices[ int(i) ];\\n\\t\\t\\treturn bone;\\n\\t\\t}\\n\\t#endif\\n#endif\"; var skinning_vertex = \"#ifdef USE_SKINNING\\n\\tvec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\\n\\tvec4 skinned = vec4( 0.0 );\\n\\tskinned += boneMatX * skinVertex * skinWeight.x;\\n\\tskinned += boneMatY * skinVertex * skinWeight.y;\\n\\tskinned += boneMatZ * skinVertex * skinWeight.z;\\n\\tskinned += boneMatW * skinVertex * skinWeight.w;\\n\\ttransformed = ( bindMatrixInverse * skinned ).xyz;\\n#endif\"; var skinnormal_vertex = \"#ifdef USE_SKINNING\\n\\tmat4 skinMatrix = mat4( 0.0 );\\n\\tskinMatrix += skinWeight.x * boneMatX;\\n\\tskinMatrix += skinWeight.y * boneMatY;\\n\\tskinMatrix += skinWeight.z * boneMatZ;\\n\\tskinMatrix += skinWeight.w * boneMatW;\\n\\tskinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;\\n\\tobjectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\\n#endif\"; var specularmap_fragment = \"float specularStrength;\\n#ifdef USE_SPECULARMAP\\n\\tvec4 texelSpecular = texture2D( specularMap, vUv );\\n\\tspecularStrength = texelSpecular.r;\\n#else\\n\\tspecularStrength = 1.0;\\n#endif\"; var specularmap_pars_fragment = \"#ifdef USE_SPECULARMAP\\n\\tuniform sampler2D specularMap;\\n#endif\"; var tonemapping_fragment = \"#if defined( TONE_MAPPING )\\n\\tgl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\\n#endif\"; var tonemapping_pars_fragment = \"#ifndef saturate\\n\\t#define saturate(a) clamp( a, 0.0, 1.0 )\\n#endif\\nuniform float toneMappingExposure;\\nuniform float toneMappingWhitePoint;\\nvec3 LinearToneMapping( vec3 color ) {\\n\\treturn toneMappingExposure * color;\\n}\\nvec3 ReinhardToneMapping( vec3 color ) {\\n\\tcolor *= toneMappingExposure;\\n\\treturn saturate( color / ( vec3( 1.0 ) + color ) );\\n}\\n#define Uncharted2Helper( x ) max( ( ( x * ( 0.15 * x + 0.10 * 0.50 ) + 0.20 * 0.02 ) / ( x * ( 0.15 * x + 0.50 ) + 0.20 * 0.30 ) ) - 0.02 / 0.30, vec3( 0.0 ) )\\nvec3 Uncharted2ToneMapping( vec3 color ) {\\n\\tcolor *= toneMappingExposure;\\n\\treturn saturate( Uncharted2Helper( color ) / Uncharted2Helper( vec3( toneMappingWhitePoint ) ) );\\n}\\nvec3 OptimizedCineonToneMapping( vec3 color ) {\\n\\tcolor *= toneMappingExposure;\\n\\tcolor = max( vec3( 0.0 ), color - 0.004 );\\n\\treturn pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\\n}\\nvec3 ACESFilmicToneMapping( vec3 color ) {\\n\\tcolor *= toneMappingExposure;\\n\\treturn saturate( ( color * ( 2.51 * color + 0.03 ) ) / ( color * ( 2.43 * color + 0.59 ) + 0.14 ) );\\n}\"; var uv_pars_fragment = \"#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\\n\\tvarying vec2 vUv;\\n#endif\"; var uv_pars_vertex = \"#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\\n\\tvarying vec2 vUv;\\n\\tuniform mat3 uvTransform;\\n#endif\"; var uv_vertex = \"#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\\n\\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\\n#endif\"; var uv2_pars_fragment = \"#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\\n\\tvarying vec2 vUv2;\\n#endif\"; var uv2_pars_vertex = \"#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\\n\\tattribute vec2 uv2;\\n\\tvarying vec2 vUv2;\\n#endif\"; var uv2_vertex = \"#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\\n\\tvUv2 = uv2;\\n#endif\"; var worldpos_vertex = \"#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP )\\n\\tvec4 worldPosition = modelMatrix * vec4( transformed, 1.0 );\\n#endif\"; var background_frag = \"uniform sampler2D t2D;\\nvarying vec2 vUv;\\nvoid main() {\\n\\tvec4 texColor = texture2D( t2D, vUv );\\n\\tgl_FragColor = mapTexelToLinear( texColor );\\n\\t#include \\n\\t#include \\n}\"; var background_vert = \"varying vec2 vUv;\\nuniform mat3 uvTransform;\\nvoid main() {\\n\\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\\n\\tgl_Position = vec4( position.xy, 1.0, 1.0 );\\n}\"; var cube_frag = \"uniform samplerCube tCube;\\nuniform float tFlip;\\nuniform float opacity;\\nvarying vec3 vWorldDirection;\\nvoid main() {\\n\\tvec4 texColor = textureCube( tCube, vec3( tFlip * vWorldDirection.x, vWorldDirection.yz ) );\\n\\tgl_FragColor = mapTexelToLinear( texColor );\\n\\tgl_FragColor.a *= opacity;\\n\\t#include \\n\\t#include \\n}\"; var cube_vert = \"varying vec3 vWorldDirection;\\n#include \\nvoid main() {\\n\\tvWorldDirection = transformDirection( position, modelMatrix );\\n\\t#include \\n\\t#include \\n\\tgl_Position.z = gl_Position.w;\\n}\"; var depth_frag = \"#if DEPTH_PACKING == 3200\\n\\tuniform float opacity;\\n#endif\\n#include \\n#include \\n#include \\n#include \\n#include \\n#include \\n#include \\nvoid main() {\\n\\t#include \\n\\tvec4 diffuseColor = vec4( 1.0 );\\n\\t#if DEPTH_PACKING == 3200\\n\\t\\tdiffuseColor.a = opacity;\\n\\t#endif\\n\\t#include \\n\\t#include \\n\\t#include \\n\\t#include \\n\\t#if DEPTH_PACKING == 3200\\n\\t\\tgl_FragColor = vec4( vec3( 1.0 - gl_FragCoord.z ), opacity );\\n\\t#elif DEPTH_PACKING == 3201\\n\\t\\tgl_FragColor = packDepthToRGBA( gl_FragCoord.z );\\n\\t#endif\\n}\"; var depth_vert = \"#include \\n#include \\n#include \\n#include \\n#include \\n#include \\n#include \\nvoid main() {\\n\\t#include \\n\\t#include \\n\\t#ifdef USE_DISPLACEMENTMAP\\n\\t\\t#include \\n\\t\\t#include \\n\\t\\t#include \\n\\t#endif\\n\\t#include \\n\\t#include \\n\\t#include \\n\\t#include \\n\\t#include \\n\\t#include \\n\\t#include \\n}\"; var distanceRGBA_frag = \"#define DISTANCE\\nuniform vec3 referencePosition;\\nuniform float nearDistance;\\nuniform float farDistance;\\nvarying vec3 vWorldPosition;\\n#include \\n#include \\n#include \\n#include \\n#include \\n#include \\nvoid main () {\\n\\t#include \\n\\tvec4 diffuseColor = vec4( 1.0 );\\n\\t#include \\n\\t#include \\n\\t#include \\n\\tfloat dist = length( vWorldPosition - referencePosition );\\n\\tdist = ( dist - nearDistance ) / ( farDistance - nearDistance );\\n\\tdist = saturate( dist );\\n\\tgl_FragColor = packDepthToRGBA( dist );\\n}\"; var distanceRGBA_vert = \"#define DISTANCE\\nvarying vec3 vWorldPosition;\\n#include \\n#include \\n#include \\n#include \\n#include \\n#include \\nvoid main() {\\n\\t#include \\n\\t#include \\n\\t#ifdef USE_DISPLACEMENTMAP\\n\\t\\t#include \\n\\t\\t#include \\n\\t\\t#include \\n\\t#endif\\n\\t#include \\n\\t#include \\n\\t#include \\n\\t#include \\n\\t#include \\n\\t#include \\n\\t#include \\n\\tvWorldPosition = worldPosition.xyz;\\n}\"; var equirect_frag = \"uniform sampler2D tEquirect;\\nvarying vec3 vWorldDirection;\\n#include \\nvoid main() {\\n\\tvec3 direction = normalize( vWorldDirection );\\n\\tvec2 sampleUV;\\n\\tsampleUV.y = asin( clamp( direction.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\\n\\tsampleUV.x = atan( direction.z, direction.x ) * RECIPROCAL_PI2 + 0.5;\\n\\tvec4 texColor = texture2D( tEquirect, sampleUV );\\n\\tgl_FragColor = mapTexelToLinear( texColor );\\n\\t#include \\n\\t#include \\n}\"; var equirect_vert = \"varying vec3 vWorldDirection;\\n#include \\nvoid main() {\\n\\tvWorldDirection = transformDirection( position, modelMatrix );\\n\\t#include \\n\\t#include \\n}\"; var linedashed_frag = \"uniform vec3 diffuse;\\nuniform float opacity;\\nuniform float dashSize;\\nuniform float totalSize;\\nvarying float vLineDistance;\\n#include \\n#include \\n#include \\n#include \\n#include \\nvoid main() {\\n\\t#include \\n\\tif ( mod( vLineDistance, totalSize ) > dashSize ) {\\n\\t\\tdiscard;\\n\\t}\\n\\tvec3 outgoingLight = vec3( 0.0 );\\n\\tvec4 diffuseColor = vec4( diffuse, opacity );\\n\\t#include \\n\\t#include \\n\\toutgoingLight = diffuseColor.rgb;\\n\\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\\n\\t#include \\n\\t#include \\n\\t#include \\n\\t#include \\n}\"; var linedashed_vert = \"uniform float scale;\\nattribute float lineDistance;\\nvarying float vLineDistance;\\n#include \\n#include \\n#include \\n#include \\n#include \\nvoid main() {\\n\\t#include \\n\\tvLineDistance = scale * lineDistance;\\n\\tvec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\\n\\tgl_Position = projectionMatrix * mvPosition;\\n\\t#include \\n\\t#include \\n\\t#include \\n}\"; var meshbasic_frag = \"uniform vec3 diffuse;\\nuniform float opacity;\\n#ifndef FLAT_SHADED\\n\\tvarying vec3 vNormal;\\n#endif\\n#include \\n#include \\n#include \\n#include \\n#include \\n#include \\n#include \\n#include \\n#include \\n#include \\n#include \\n#include \\n#include \\nvoid main() {\\n\\t#include \\n\\tvec4 diffuseColor = vec4( diffuse, opacity );\\n\\t#include \\n\\t#include \\n\\t#include \\n\\t#include \\n\\t#include \\n\\t#include \\n\\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\\n\\t#ifdef USE_LIGHTMAP\\n\\t\\treflectedLight.indirectDiffuse += texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\\n\\t#else\\n\\t\\treflectedLight.indirectDiffuse += vec3( 1.0 );\\n\\t#endif\\n\\t#include \\n\\treflectedLight.indirectDiffuse *= diffuseColor.rgb;\\n\\tvec3 outgoingLight = reflectedLight.indirectDiffuse;\\n\\t#include \\n\\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\\n\\t#include \\n\\t#include \\n\\t#include \\n\\t#include \\n}\"; var meshbasic_vert = \"#include \\n#include \\n#include \\n#include \\n#include \\n#include \\n#include \\n#include \\n#include \\n#include \\nvoid main() {\\n\\t#include \\n\\t#include \\n\\t#include \\n\\t#include \\n\\t#ifdef USE_ENVMAP\\n\\t#include \\n\\t#include \\n\\t#include \\n\\t#include \\n\\t#endif\\n\\t#include \\n\\t#include \\n\\t#include \\n\\t#include \\n\\t#include \\n\\t#include \\n\\t#include \\n\\t#include \\n\\t#include \\n}\"; var meshlambert_frag = \"uniform vec3 diffuse;\\nuniform vec3 emissive;\\nuniform float opacity;\\nvarying vec3 vLightFront;\\nvarying vec3 vIndirectFront;\\n#ifdef DOUBLE_SIDED\\n\\tvarying vec3 vLightBack;\\n\\tvarying vec3 vIndirectBack;\\n#endif\\n#include \\n#include \\n#include \\n#include \\n#include \\n#include \\n#include \\n#include \\n#include \\n#include \\n#include \\n#include \\n#include \\n#include \\n#include \\n#include \\n#include \\n#include \\n#include \\n#include \\nvoid main() {\\n\\t#include \\n\\tvec4 diffuseColor = vec4( diffuse, opacity );\\n\\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\\n\\tvec3 totalEmissiveRadiance = emissive;\\n\\t#include \\n\\t#include \\n\\t#include \\n\\t#include \\n\\t#include \\n\\t#include \\n\\t#include \\n\\treflectedLight.indirectDiffuse = getAmbientLightIrradiance( ambientLightColor );\\n\\t#ifdef DOUBLE_SIDED\\n\\t\\treflectedLight.indirectDiffuse += ( gl_FrontFacing ) ? vIndirectFront : vIndirectBack;\\n\\t#else\\n\\t\\treflectedLight.indirectDiffuse += vIndirectFront;\\n\\t#endif\\n\\t#include \\n\\treflectedLight.indirectDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb );\\n\\t#ifdef DOUBLE_SIDED\\n\\t\\treflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;\\n\\t#else\\n\\t\\treflectedLight.directDiffuse = vLightFront;\\n\\t#endif\\n\\treflectedLight.directDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb ) * getShadowMask();\\n\\t#include \\n\\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\\n\\t#include \\n\\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\\n\\t#include \\n\\t#include \\n\\t#include \\n\\t#include \\n\\t#include \\n}\"; var meshlambert_vert = \"#define LAMBERT\\nvarying vec3 vLightFront;\\nvarying vec3 vIndirectFront;\\n#ifdef DOUBLE_SIDED\\n\\tvarying vec3 vLightBack;\\n\\tvarying vec3 vIndirectBack;\\n#endif\\n#include \\n#include \\n#include \\n#include \\n#include \\n#include \\n#include \\n#include \\n#include \\n#include \\n#include \\n#include \\n#include \\nvoid main() {\\n\\t#include \\n\\t#include \\n\\t#include \\n\\t#include \\n\\t#include \\n\\t#include \\n\\t#include \\n\\t#include \\n\\t#include \\n\\t#include \\n\\t#include \\n\\t#include \\n\\t#include \\n\\t#include \\n\\t#include \\n\\t#include \\n\\t#include \\n\\t#include \\n\\t#include \\n}\"; var meshmatcap_frag = \"#define MATCAP\\nuniform vec3 diffuse;\\nuniform float opacity;\\nuniform sampler2D matcap;\\nvarying vec3 vViewPosition;\\n#ifndef FLAT_SHADED\\n\\tvarying vec3 vNormal;\\n#endif\\n#include \\n#include \\n#include \\n#include \\n#include \\n#include \\n#include \\n#include \\n#include \\nvoid main() {\\n\\t#include \\n\\tvec4 diffuseColor = vec4( diffuse, opacity );\\n\\t#include \\n\\t#include \\n\\t#include \\n\\t#include \\n\\t#include \\n\\t#include \\n\\tvec3 viewDir = normalize( vViewPosition );\\n\\tvec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );\\n\\tvec3 y = cross( viewDir, x );\\n\\tvec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;\\n\\t#ifdef USE_MATCAP\\n\\t\\tvec4 matcapColor = texture2D( matcap, uv );\\n\\t\\tmatcapColor = matcapTexelToLinear( matcapColor );\\n\\t#else\\n\\t\\tvec4 matcapColor = vec4( 1.0 );\\n\\t#endif\\n\\tvec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;\\n\\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\\n\\t#include \\n\\t#include \\n\\t#include \\n\\t#include \\n}\"; var meshmatcap_vert = \"#define MATCAP\\nvarying vec3 vViewPosition;\\n#ifndef FLAT_SHADED\\n\\tvarying vec3 vNormal;\\n#endif\\n#include \\n#include \\n#include \\n#include \\n#include \\n#include \\n#include \\n#include \\nvoid main() {\\n\\t#include \\n\\t#include \\n\\t#include \\n\\t#include \\n\\t#include \\n\\t#include \\n\\t#ifndef FLAT_SHADED\\n\\t\\tvNormal = normalize( transformedNormal );\\n\\t#endif\\n\\t#include \\n\\t#include \\n\\t#include \\n\\t#include \\n\\t#include \\n\\t#include \\n\\t#include \\n\\t#include \\n\\tvViewPosition = - mvPosition.xyz;\\n}\"; var meshphong_frag = \"#define PHONG\\nuniform vec3 diffuse;\\nuniform vec3 emissive;\\nuniform vec3 specular;\\nuniform float shininess;\\nuniform float opacity;\\n#include \\n#include \\n#include \\n#include \\n#include \\n#include \\n#include \\n#include \\n#include \\n#include \\n#include \\n#include \\n#include \\n#include \\n#include \\n#include \\n#include \\n#include \\n#include \\n#include \\n#include \\n#include \\n#include \\nvoid main() {\\n\\t#include \\n\\tvec4 diffuseColor = vec4( diffuse, opacity );\\n\\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\\n\\tvec3 totalEmissiveRadiance = emissive;\\n\\t#include \\n\\t#include \\n\\t#include \\n\\t#include \\n\\t#include \\n\\t#include \\n\\t#include \\n\\t#include \\n\\t#include \\n\\t#include \\n\\t#include \\n\\t#include \\n\\t#include \\n\\t#include \\n\\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\\n\\t#include \\n\\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\\n\\t#include \\n\\t#include \\n\\t#include \\n\\t#include \\n\\t#include \\n}\"; var meshphong_vert = \"#define PHONG\\nvarying vec3 vViewPosition;\\n#ifndef FLAT_SHADED\\n\\tvarying vec3 vNormal;\\n#endif\\n#include \\n#include \\n#include \\n#include \\n#include \\n#include \\n#include \\n#include \\n#include \\n#include \\n#include \\n#include \\nvoid main() {\\n\\t#include \\n\\t#include \\n\\t#include \\n\\t#include \\n\\t#include \\n\\t#include \\n\\t#include \\n\\t#include \\n#ifndef FLAT_SHADED\\n\\tvNormal = normalize( transformedNormal );\\n#endif\\n\\t#include \\n\\t#include \\n\\t#include \\n\\t#include \\n\\t#include \\n\\t#include \\n\\t#include \\n\\tvViewPosition = - mvPosition.xyz;\\n\\t#include \\n\\t#include \\n\\t#include \\n\\t#include \\n}\"; var meshphysical_frag = \"#define PHYSICAL\\nuniform vec3 diffuse;\\nuniform vec3 emissive;\\nuniform float roughness;\\nuniform float metalness;\\nuniform float opacity;\\n#ifndef STANDARD\\n\\tuniform float clearCoat;\\n\\tuniform float clearCoatRoughness;\\n#endif\\nvarying vec3 vViewPosition;\\n#ifndef FLAT_SHADED\\n\\tvarying vec3 vNormal;\\n#endif\\n#include \\n#include \\n#include \\n#include \\n#include \\n#include \\n#include \\n#include \\n#include \\n#include \\n#include \\n#include \\n#include \\n#include \\n#include \\n#include \\n#include \\n#include \\n#include \\n#include \\n#include \\n#include \\n#include \\n#include \\n#include \\nvoid main() {\\n\\t#include \\n\\tvec4 diffuseColor = vec4( diffuse, opacity );\\n\\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\\n\\tvec3 totalEmissiveRadiance = emissive;\\n\\t#include \\n\\t#include \\n\\t#include \\n\\t#include \\n\\t#include \\n\\t#include \\n\\t#include \\n\\t#include \\n\\t#include \\n\\t#include \\n\\t#include \\n\\t#include \\n\\t#include \\n\\t#include \\n\\t#include \\n\\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\\n\\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\\n\\t#include \\n\\t#include \\n\\t#include \\n\\t#include \\n\\t#include \\n}\"; var meshphysical_vert = \"#define PHYSICAL\\nvarying vec3 vViewPosition;\\n#ifndef FLAT_SHADED\\n\\tvarying vec3 vNormal;\\n#endif\\n#include \\n#include \\n#include \\n#include \\n#include \\n#include \\n#include \\n#include \\n#include \\n#include \\n#include \\nvoid main() {\\n\\t#include \\n\\t#include \\n\\t#include \\n\\t#include \\n\\t#include \\n\\t#include \\n\\t#include \\n\\t#include \\n#ifndef FLAT_SHADED\\n\\tvNormal = normalize( transformedNormal );\\n#endif\\n\\t#include \\n\\t#include \\n\\t#include \\n\\t#include \\n\\t#include \\n\\t#include \\n\\t#include \\n\\tvViewPosition = - mvPosition.xyz;\\n\\t#include \\n\\t#include \\n\\t#include \\n}\"; var normal_frag = \"#define NORMAL\\nuniform float opacity;\\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || ( defined( USE_NORMALMAP ) && ! defined( OBJECTSPACE_NORMALMAP ) )\\n\\tvarying vec3 vViewPosition;\\n#endif\\n#ifndef FLAT_SHADED\\n\\tvarying vec3 vNormal;\\n#endif\\n#include \\n#include \\n#include \\n#include \\n#include \\nvoid main() {\\n\\t#include \\n\\t#include \\n\\t#include \\n\\tgl_FragColor = vec4( packNormalToRGB( normal ), opacity );\\n}\"; var normal_vert = \"#define NORMAL\\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || ( defined( USE_NORMALMAP ) && ! defined( OBJECTSPACE_NORMALMAP ) )\\n\\tvarying vec3 vViewPosition;\\n#endif\\n#ifndef FLAT_SHADED\\n\\tvarying vec3 vNormal;\\n#endif\\n#include \\n#include \\n#include \\n#include \\n#include \\nvoid main() {\\n\\t#include \\n\\t#include \\n\\t#include \\n\\t#include \\n\\t#include \\n\\t#include \\n#ifndef FLAT_SHADED\\n\\tvNormal = normalize( transformedNormal );\\n#endif\\n\\t#include \\n\\t#include \\n\\t#include \\n\\t#include \\n\\t#include \\n\\t#include \\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || ( defined( USE_NORMALMAP ) && ! defined( OBJECTSPACE_NORMALMAP ) )\\n\\tvViewPosition = - mvPosition.xyz;\\n#endif\\n}\"; var points_frag = \"uniform vec3 diffuse;\\nuniform float opacity;\\n#include \\n#include \\n#include \\n#include \\n#include \\n#include \\nvoid main() {\\n\\t#include \\n\\tvec3 outgoingLight = vec3( 0.0 );\\n\\tvec4 diffuseColor = vec4( diffuse, opacity );\\n\\t#include \\n\\t#include \\n\\t#include \\n\\t#include \\n\\toutgoingLight = diffuseColor.rgb;\\n\\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\\n\\t#include \\n\\t#include \\n\\t#include \\n\\t#include \\n}\"; var points_vert = \"uniform float size;\\nuniform float scale;\\n#include \\n#include \\n#include \\n#include \\n#include \\n#include \\nvoid main() {\\n\\t#include \\n\\t#include \\n\\t#include \\n\\t#include \\n\\tgl_PointSize = size;\\n\\t#ifdef USE_SIZEATTENUATION\\n\\t\\tbool isPerspective = ( projectionMatrix[ 2 ][ 3 ] == - 1.0 );\\n\\t\\tif ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );\\n\\t#endif\\n\\t#include \\n\\t#include \\n\\t#include \\n\\t#include \\n}\"; var shadow_frag = \"uniform vec3 color;\\nuniform float opacity;\\n#include \\n#include \\n#include \\n#include \\n#include \\n#include \\n#include \\nvoid main() {\\n\\tgl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );\\n\\t#include \\n}\"; var shadow_vert = \"#include \\n#include \\nvoid main() {\\n\\t#include \\n\\t#include \\n\\t#include \\n\\t#include \\n\\t#include \\n}\"; var sprite_frag = \"uniform vec3 diffuse;\\nuniform float opacity;\\n#include \\n#include \\n#include \\n#include \\n#include \\n#include \\nvoid main() {\\n\\t#include \\n\\tvec3 outgoingLight = vec3( 0.0 );\\n\\tvec4 diffuseColor = vec4( diffuse, opacity );\\n\\t#include \\n\\t#include \\n\\t#include \\n\\toutgoingLight = diffuseColor.rgb;\\n\\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\\n\\t#include \\n\\t#include \\n\\t#include \\n}\"; var sprite_vert = \"uniform float rotation;\\nuniform vec2 center;\\n#include \\n#include \\n#include \\n#include \\n#include \\nvoid main() {\\n\\t#include \\n\\tvec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );\\n\\tvec2 scale;\\n\\tscale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );\\n\\tscale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );\\n\\t#ifndef USE_SIZEATTENUATION\\n\\t\\tbool isPerspective = ( projectionMatrix[ 2 ][ 3 ] == - 1.0 );\\n\\t\\tif ( isPerspective ) scale *= - mvPosition.z;\\n\\t#endif\\n\\tvec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;\\n\\tvec2 rotatedPosition;\\n\\trotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\\n\\trotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\\n\\tmvPosition.xy += rotatedPosition;\\n\\tgl_Position = projectionMatrix * mvPosition;\\n\\t#include \\n\\t#include \\n\\t#include \\n}\"; var ShaderChunk = { alphamap_fragment: alphamap_fragment, alphamap_pars_fragment: alphamap_pars_fragment, alphatest_fragment: alphatest_fragment, aomap_fragment: aomap_fragment, aomap_pars_fragment: aomap_pars_fragment, begin_vertex: begin_vertex, beginnormal_vertex: beginnormal_vertex, bsdfs: bsdfs, bumpmap_pars_fragment: bumpmap_pars_fragment, clipping_planes_fragment: clipping_planes_fragment, clipping_planes_pars_fragment: clipping_planes_pars_fragment, clipping_planes_pars_vertex: clipping_planes_pars_vertex, clipping_planes_vertex: clipping_planes_vertex, color_fragment: color_fragment, color_pars_fragment: color_pars_fragment, color_pars_vertex: color_pars_vertex, color_vertex: color_vertex, common: common, cube_uv_reflection_fragment: cube_uv_reflection_fragment, defaultnormal_vertex: defaultnormal_vertex, displacementmap_pars_vertex: displacementmap_pars_vertex, displacementmap_vertex: displacementmap_vertex, emissivemap_fragment: emissivemap_fragment, emissivemap_pars_fragment: emissivemap_pars_fragment, encodings_fragment: encodings_fragment, encodings_pars_fragment: encodings_pars_fragment, envmap_fragment: envmap_fragment, envmap_pars_fragment: envmap_pars_fragment, envmap_pars_vertex: envmap_pars_vertex, envmap_physical_pars_fragment: envmap_physical_pars_fragment, envmap_vertex: envmap_vertex, fog_vertex: fog_vertex, fog_pars_vertex: fog_pars_vertex, fog_fragment: fog_fragment, fog_pars_fragment: fog_pars_fragment, gradientmap_pars_fragment: gradientmap_pars_fragment, lightmap_fragment: lightmap_fragment, lightmap_pars_fragment: lightmap_pars_fragment, lights_lambert_vertex: lights_lambert_vertex, lights_pars_begin: lights_pars_begin, lights_phong_fragment: lights_phong_fragment, lights_phong_pars_fragment: lights_phong_pars_fragment, lights_physical_fragment: lights_physical_fragment, lights_physical_pars_fragment: lights_physical_pars_fragment, lights_fragment_begin: lights_fragment_begin, lights_fragment_maps: lights_fragment_maps, lights_fragment_end: lights_fragment_end, logdepthbuf_fragment: logdepthbuf_fragment, logdepthbuf_pars_fragment: logdepthbuf_pars_fragment, logdepthbuf_pars_vertex: logdepthbuf_pars_vertex, logdepthbuf_vertex: logdepthbuf_vertex, map_fragment: map_fragment, map_pars_fragment: map_pars_fragment, map_particle_fragment: map_particle_fragment, map_particle_pars_fragment: map_particle_pars_fragment, metalnessmap_fragment: metalnessmap_fragment, metalnessmap_pars_fragment: metalnessmap_pars_fragment, morphnormal_vertex: morphnormal_vertex, morphtarget_pars_vertex: morphtarget_pars_vertex, morphtarget_vertex: morphtarget_vertex, normal_fragment_begin: normal_fragment_begin, normal_fragment_maps: normal_fragment_maps, normalmap_pars_fragment: normalmap_pars_fragment, packing: packing, premultiplied_alpha_fragment: premultiplied_alpha_fragment, project_vertex: project_vertex, dithering_fragment: dithering_fragment, dithering_pars_fragment: dithering_pars_fragment, roughnessmap_fragment: roughnessmap_fragment, roughnessmap_pars_fragment: roughnessmap_pars_fragment, shadowmap_pars_fragment: shadowmap_pars_fragment, shadowmap_pars_vertex: shadowmap_pars_vertex, shadowmap_vertex: shadowmap_vertex, shadowmask_pars_fragment: shadowmask_pars_fragment, skinbase_vertex: skinbase_vertex, skinning_pars_vertex: skinning_pars_vertex, skinning_vertex: skinning_vertex, skinnormal_vertex: skinnormal_vertex, specularmap_fragment: specularmap_fragment, specularmap_pars_fragment: specularmap_pars_fragment, tonemapping_fragment: tonemapping_fragment, tonemapping_pars_fragment: tonemapping_pars_fragment, uv_pars_fragment: uv_pars_fragment, uv_pars_vertex: uv_pars_vertex, uv_vertex: uv_vertex, uv2_pars_fragment: uv2_pars_fragment, uv2_pars_vertex: uv2_pars_vertex, uv2_vertex: uv2_vertex, worldpos_vertex: worldpos_vertex, background_frag: background_frag, background_vert: background_vert, cube_frag: cube_frag, cube_vert: cube_vert, depth_frag: depth_frag, depth_vert: depth_vert, distanceRGBA_frag: distanceRGBA_frag, distanceRGBA_vert: distanceRGBA_vert, equirect_frag: equirect_frag, equirect_vert: equirect_vert, linedashed_frag: linedashed_frag, linedashed_vert: linedashed_vert, meshbasic_frag: meshbasic_frag, meshbasic_vert: meshbasic_vert, meshlambert_frag: meshlambert_frag, meshlambert_vert: meshlambert_vert, meshmatcap_frag: meshmatcap_frag, meshmatcap_vert: meshmatcap_vert, meshphong_frag: meshphong_frag, meshphong_vert: meshphong_vert, meshphysical_frag: meshphysical_frag, meshphysical_vert: meshphysical_vert, normal_frag: normal_frag, normal_vert: normal_vert, points_frag: points_frag, points_vert: points_vert, shadow_frag: shadow_frag, shadow_vert: shadow_vert, sprite_frag: sprite_frag, sprite_vert: sprite_vert }; /** * Uniform Utilities */ function cloneUniforms( src ) { var dst = {}; for ( var u in src ) { dst[ u ] = {}; for ( var p in src[ u ] ) { var property = src[ u ][ p ]; if ( property && ( property.isColor || property.isMatrix3 || property.isMatrix4 || property.isVector2 || property.isVector3 || property.isVector4 || property.isTexture ) ) { dst[ u ][ p ] = property.clone(); } else if ( Array.isArray( property ) ) { dst[ u ][ p ] = property.slice(); } else { dst[ u ][ p ] = property; } } } return dst; } function mergeUniforms( uniforms ) { var merged = {}; for ( var u = 0; u < uniforms.length; u ++ ) { var tmp = cloneUniforms( uniforms[ u ] ); for ( var p in tmp ) { merged[ p ] = tmp[ p ]; } } return merged; } // Legacy var UniformsUtils = { clone: cloneUniforms, merge: mergeUniforms }; /** * @author mrdoob / http://mrdoob.com/ */ var ColorKeywords = { 'aliceblue': 0xF0F8FF, 'antiquewhite': 0xFAEBD7, 'aqua': 0x00FFFF, 'aquamarine': 0x7FFFD4, 'azure': 0xF0FFFF, 'beige': 0xF5F5DC, 'bisque': 0xFFE4C4, 'black': 0x000000, 'blanchedalmond': 0xFFEBCD, 'blue': 0x0000FF, 'blueviolet': 0x8A2BE2, 'brown': 0xA52A2A, 'burlywood': 0xDEB887, 'cadetblue': 0x5F9EA0, 'chartreuse': 0x7FFF00, 'chocolate': 0xD2691E, 'coral': 0xFF7F50, 'cornflowerblue': 0x6495ED, 'cornsilk': 0xFFF8DC, 'crimson': 0xDC143C, 'cyan': 0x00FFFF, 'darkblue': 0x00008B, 'darkcyan': 0x008B8B, 'darkgoldenrod': 0xB8860B, 'darkgray': 0xA9A9A9, 'darkgreen': 0x006400, 'darkgrey': 0xA9A9A9, 'darkkhaki': 0xBDB76B, 'darkmagenta': 0x8B008B, 'darkolivegreen': 0x556B2F, 'darkorange': 0xFF8C00, 'darkorchid': 0x9932CC, 'darkred': 0x8B0000, 'darksalmon': 0xE9967A, 'darkseagreen': 0x8FBC8F, 'darkslateblue': 0x483D8B, 'darkslategray': 0x2F4F4F, 'darkslategrey': 0x2F4F4F, 'darkturquoise': 0x00CED1, 'darkviolet': 0x9400D3, 'deeppink': 0xFF1493, 'deepskyblue': 0x00BFFF, 'dimgray': 0x696969, 'dimgrey': 0x696969, 'dodgerblue': 0x1E90FF, 'firebrick': 0xB22222, 'floralwhite': 0xFFFAF0, 'forestgreen': 0x228B22, 'fuchsia': 0xFF00FF, 'gainsboro': 0xDCDCDC, 'ghostwhite': 0xF8F8FF, 'gold': 0xFFD700, 'goldenrod': 0xDAA520, 'gray': 0x808080, 'green': 0x008000, 'greenyellow': 0xADFF2F, 'grey': 0x808080, 'honeydew': 0xF0FFF0, 'hotpink': 0xFF69B4, 'indianred': 0xCD5C5C, 'indigo': 0x4B0082, 'ivory': 0xFFFFF0, 'khaki': 0xF0E68C, 'lavender': 0xE6E6FA, 'lavenderblush': 0xFFF0F5, 'lawngreen': 0x7CFC00, 'lemonchiffon': 0xFFFACD, 'lightblue': 0xADD8E6, 'lightcoral': 0xF08080, 'lightcyan': 0xE0FFFF, 'lightgoldenrodyellow': 0xFAFAD2, 'lightgray': 0xD3D3D3, 'lightgreen': 0x90EE90, 'lightgrey': 0xD3D3D3, 'lightpink': 0xFFB6C1, 'lightsalmon': 0xFFA07A, 'lightseagreen': 0x20B2AA, 'lightskyblue': 0x87CEFA, 'lightslategray': 0x778899, 'lightslategrey': 0x778899, 'lightsteelblue': 0xB0C4DE, 'lightyellow': 0xFFFFE0, 'lime': 0x00FF00, 'limegreen': 0x32CD32, 'linen': 0xFAF0E6, 'magenta': 0xFF00FF, 'maroon': 0x800000, 'mediumaquamarine': 0x66CDAA, 'mediumblue': 0x0000CD, 'mediumorchid': 0xBA55D3, 'mediumpurple': 0x9370DB, 'mediumseagreen': 0x3CB371, 'mediumslateblue': 0x7B68EE, 'mediumspringgreen': 0x00FA9A, 'mediumturquoise': 0x48D1CC, 'mediumvioletred': 0xC71585, 'midnightblue': 0x191970, 'mintcream': 0xF5FFFA, 'mistyrose': 0xFFE4E1, 'moccasin': 0xFFE4B5, 'navajowhite': 0xFFDEAD, 'navy': 0x000080, 'oldlace': 0xFDF5E6, 'olive': 0x808000, 'olivedrab': 0x6B8E23, 'orange': 0xFFA500, 'orangered': 0xFF4500, 'orchid': 0xDA70D6, 'palegoldenrod': 0xEEE8AA, 'palegreen': 0x98FB98, 'paleturquoise': 0xAFEEEE, 'palevioletred': 0xDB7093, 'papayawhip': 0xFFEFD5, 'peachpuff': 0xFFDAB9, 'peru': 0xCD853F, 'pink': 0xFFC0CB, 'plum': 0xDDA0DD, 'powderblue': 0xB0E0E6, 'purple': 0x800080, 'rebeccapurple': 0x663399, 'red': 0xFF0000, 'rosybrown': 0xBC8F8F, 'royalblue': 0x4169E1, 'saddlebrown': 0x8B4513, 'salmon': 0xFA8072, 'sandybrown': 0xF4A460, 'seagreen': 0x2E8B57, 'seashell': 0xFFF5EE, 'sienna': 0xA0522D, 'silver': 0xC0C0C0, 'skyblue': 0x87CEEB, 'slateblue': 0x6A5ACD, 'slategray': 0x708090, 'slategrey': 0x708090, 'snow': 0xFFFAFA, 'springgreen': 0x00FF7F, 'steelblue': 0x4682B4, 'tan': 0xD2B48C, 'teal': 0x008080, 'thistle': 0xD8BFD8, 'tomato': 0xFF6347, 'turquoise': 0x40E0D0, 'violet': 0xEE82EE, 'wheat': 0xF5DEB3, 'white': 0xFFFFFF, 'whitesmoke': 0xF5F5F5, 'yellow': 0xFFFF00, 'yellowgreen': 0x9ACD32 }; function Color( r, g, b ) { if ( g === undefined && b === undefined ) { // r is THREE.Color, hex or string return this.set( r ); } return this.setRGB( r, g, b ); } Object.assign( Color.prototype, { isColor: true, r: 1, g: 1, b: 1, set: function ( value ) { if ( value && value.isColor ) { this.copy( value ); } else if ( typeof value === 'number' ) { this.setHex( value ); } else if ( typeof value === 'string' ) { this.setStyle( value ); } return this; }, setScalar: function ( scalar ) { this.r = scalar; this.g = scalar; this.b = scalar; return this; }, setHex: function ( hex ) { hex = Math.floor( hex ); this.r = ( hex >> 16 & 255 ) / 255; this.g = ( hex >> 8 & 255 ) / 255; this.b = ( hex & 255 ) / 255; return this; }, setRGB: function ( r, g, b ) { this.r = r; this.g = g; this.b = b; return this; }, setHSL: function () { function hue2rgb( p, q, t ) { if ( t < 0 ) t += 1; if ( t > 1 ) t -= 1; if ( t < 1 / 6 ) return p + ( q - p ) * 6 * t; if ( t < 1 / 2 ) return q; if ( t < 2 / 3 ) return p + ( q - p ) * 6 * ( 2 / 3 - t ); return p; } return function setHSL( h, s, l ) { // h,s,l ranges are in 0.0 - 1.0 h = _Math.euclideanModulo( h, 1 ); s = _Math.clamp( s, 0, 1 ); l = _Math.clamp( l, 0, 1 ); if ( s === 0 ) { this.r = this.g = this.b = l; } else { var p = l 0; } else if ( geometry && geometry.isGeometry ) { useMorphing = geometry.morphTargets && geometry.morphTargets.length > 0; } } if ( object.isSkinnedMesh && material.skinning === false ) { console.warn( 'THREE.WebGLShadowMap: THREE.SkinnedMesh with material.skinning set to false:', object ); } var useSkinning = object.isSkinnedMesh && material.skinning; var variantIndex = 0; if ( useMorphing ) variantIndex |= _MorphingFlag; if ( useSkinning ) variantIndex |= _SkinningFlag; result = materialVariants[ variantIndex ]; } else { result = customMaterial; } if ( _renderer.localClippingEnabled && material.clipShadows === true && material.clippingPlanes.length !== 0 ) { // in this case we need a unique material instance reflecting the // appropriate state var keyA = result.uuid, keyB = material.uuid; var materialsForVariant = _materialCache[ keyA ]; if ( materialsForVariant === undefined ) { materialsForVariant = {}; _materialCache[ keyA ] = materialsForVariant; } var cachedMaterial = materialsForVariant[ keyB ]; if ( cachedMaterial === undefined ) { cachedMaterial = result.clone(); materialsForVariant[ keyB ] = cachedMaterial; } result = cachedMaterial; } result.visible = material.visible; result.wireframe = material.wireframe; result.side = ( material.shadowSide != null ) ? material.shadowSide : shadowSide[ material.side ]; result.clipShadows = material.clipShadows; result.clippingPlanes = material.clippingPlanes; result.clipIntersection = material.clipIntersection; result.wireframeLinewidth = material.wireframeLinewidth; result.linewidth = material.linewidth; if ( isPointLight && result.isMeshDistanceMaterial ) { result.referencePosition.copy( lightPositionWorld ); result.nearDistance = shadowCameraNear; result.farDistance = shadowCameraFar; } return result; } function renderObject( object, camera, shadowCamera, isPointLight ) { if ( object.visible === false ) return; var visible = object.layers.test( camera.layers ); if ( visible && ( object.isMesh || object.isLine || object.isPoints ) ) { if ( object.castShadow && ( ! object.frustumCulled || _frustum.intersectsObject( object ) ) ) { object.modelViewMatrix.multiplyMatrices( shadowCamera.matrixWorldInverse, object.matrixWorld ); var geometry = _objects.update( object ); var material = object.material; if ( Array.isArray( material ) ) { var groups = geometry.groups; for ( var k = 0, kl = groups.length; k < kl; k ++ ) { var group = groups[ k ]; var groupMaterial = material[ group.materialIndex ]; if ( groupMaterial && groupMaterial.visible ) { var depthMaterial = getDepthMaterial( object, groupMaterial, isPointLight, _lightPositionWorld, shadowCamera.near, shadowCamera.far ); _renderer.renderBufferDirect( shadowCamera, null, geometry, depthMaterial, object, group ); } } } else if ( material.visible ) { var depthMaterial = getDepthMaterial( object, material, isPointLight, _lightPositionWorld, shadowCamera.near, shadowCamera.far ); _renderer.renderBufferDirect( shadowCamera, null, geometry, depthMaterial, object, null ); } } } var children = object.children; for ( var i = 0, l = children.length; i < l; i ++ ) { renderObject( children[ i ], camera, shadowCamera, isPointLight ); } } } /** * @author mrdoob / http://mrdoob.com/ */ function WebGLState( gl, extensions, utils, capabilities ) { function ColorBuffer() { var locked = false; var color = new Vector4(); var currentColorMask = null; var currentColorClear = new Vector4( 0, 0, 0, 0 ); return { setMask: function ( colorMask ) { if ( currentColorMask !== colorMask && ! locked ) { gl.colorMask( colorMask, colorMask, colorMask, colorMask ); currentColorMask = colorMask; } }, setLocked: function ( lock ) { locked = lock; }, setClear: function ( r, g, b, a, premultipliedAlpha ) { if ( premultipliedAlpha === true ) { r *= a; g *= a; b *= a; } color.set( r, g, b, a ); if ( currentColorClear.equals( color ) === false ) { gl.clearColor( r, g, b, a ); currentColorClear.copy( color ); } }, reset: function () { locked = false; currentColorMask = null; currentColorClear.set( - 1, 0, 0, 0 ); // set to invalid state } }; } function DepthBuffer() { var locked = false; var currentDepthMask = null; var currentDepthFunc = null; var currentDepthClear = null; return { setTest: function ( depthTest ) { if ( depthTest ) { enable( 2929 ); } else { disable( 2929 ); } }, setMask: function ( depthMask ) { if ( currentDepthMask !== depthMask && ! locked ) { gl.depthMask( depthMask ); currentDepthMask = depthMask; } }, setFunc: function ( depthFunc ) { if ( currentDepthFunc !== depthFunc ) { if ( depthFunc ) { switch ( depthFunc ) { case NeverDepth: gl.depthFunc( 512 ); break; case AlwaysDepth: gl.depthFunc( 519 ); break; case LessDepth: gl.depthFunc( 513 ); break; case LessEqualDepth: gl.depthFunc( 515 ); break; case EqualDepth: gl.depthFunc( 514 ); break; case GreaterEqualDepth: gl.depthFunc( 518 ); break; case GreaterDepth: gl.depthFunc( 516 ); break; case NotEqualDepth: gl.depthFunc( 517 ); break; default: gl.depthFunc( 515 ); } } else { gl.depthFunc( 515 ); } currentDepthFunc = depthFunc; } }, setLocked: function ( lock ) { locked = lock; }, setClear: function ( depth ) { if ( currentDepthClear !== depth ) { gl.clearDepth( depth ); currentDepthClear = depth; } }, reset: function () { locked = false; currentDepthMask = null; currentDepthFunc = null; currentDepthClear = null; } }; } function StencilBuffer() { var locked = false; var currentStencilMask = null; var currentStencilFunc = null; var currentStencilRef = null; var currentStencilFuncMask = null; var currentStencilFail = null; var currentStencilZFail = null; var currentStencilZPass = null; var currentStencilClear = null; return { setTest: function ( stencilTest ) { if ( stencilTest ) { enable( 2960 ); } else { disable( 2960 ); } }, setMask: function ( stencilMask ) { if ( currentStencilMask !== stencilMask && ! locked ) { gl.stencilMask( stencilMask ); currentStencilMask = stencilMask; } }, setFunc: function ( stencilFunc, stencilRef, stencilMask ) { if ( currentStencilFunc !== stencilFunc || currentStencilRef !== stencilRef || currentStencilFuncMask !== stencilMask ) { gl.stencilFunc( stencilFunc, stencilRef, stencilMask ); currentStencilFunc = stencilFunc; currentStencilRef = stencilRef; currentStencilFuncMask = stencilMask; } }, setOp: function ( stencilFail, stencilZFail, stencilZPass ) { if ( currentStencilFail !== stencilFail || currentStencilZFail !== stencilZFail || currentStencilZPass !== stencilZPass ) { gl.stencilOp( stencilFail, stencilZFail, stencilZPass ); currentStencilFail = stencilFail; currentStencilZFail = stencilZFail; currentStencilZPass = stencilZPass; } }, setLocked: function ( lock ) { locked = lock; }, setClear: function ( stencil ) { if ( currentStencilClear !== stencil ) { gl.clearStencil( stencil ); currentStencilClear = stencil; } }, reset: function () { locked = false; currentStencilMask = null; currentStencilFunc = null; currentStencilRef = null; currentStencilFuncMask = null; currentStencilFail = null; currentStencilZFail = null; currentStencilZPass = null; currentStencilClear = null; } }; } // var colorBuffer = new ColorBuffer(); var depthBuffer = new DepthBuffer(); var stencilBuffer = new StencilBuffer(); var maxVertexAttributes = gl.getParameter( 34921 ); var newAttributes = new Uint8Array( maxVertexAttributes ); var enabledAttributes = new Uint8Array( maxVertexAttributes ); var attributeDivisors = new Uint8Array( maxVertexAttributes ); var enabledCapabilities = {}; var compressedTextureFormats = null; var currentProgram = null; var currentBlendingEnabled = null; var currentBlending = null; var currentBlendEquation = null; var currentBlendSrc = null; var currentBlendDst = null; var currentBlendEquationAlpha = null; var currentBlendSrcAlpha = null; var currentBlendDstAlpha = null; var currentPremultipledAlpha = false; var currentFlipSided = null; var currentCullFace = null; var currentLineWidth = null; var currentPolygonOffsetFactor = null; var currentPolygonOffsetUnits = null; var maxTextures = gl.getParameter( 35661 ); var lineWidthAvailable = false; var version = 0; var glVersion = gl.getParameter( 7938 ); if ( glVersion.indexOf( 'WebGL' ) !== - 1 ) { version = parseFloat( /^WebGL\\ ([0-9])/.exec( glVersion )[ 1 ] ); lineWidthAvailable = ( version >= 1.0 ); } else if ( glVersion.indexOf( 'OpenGL ES' ) !== - 1 ) { version = parseFloat( /^OpenGL\\ ES\\ ([0-9])/.exec( glVersion )[ 1 ] ); lineWidthAvailable = ( version >= 2.0 ); } var currentTextureSlot = null; var currentBoundTextures = {}; var currentScissor = new Vector4(); var currentViewport = new Vector4(); function createTexture( type, target, count ) { var data = new Uint8Array( 4 ); // 4 is required to match default unpack alignment of 4. var texture = gl.createTexture(); gl.bindTexture( type, texture ); gl.texParameteri( type, 10241, 9728 ); gl.texParameteri( type, 10240, 9728 ); for ( var i = 0; i < count; i ++ ) { gl.texImage2D( target + i, 0, 6408, 1, 1, 0, 6408, 5121, data ); } return texture; } var emptyTextures = {}; emptyTextures[ 3553 ] = createTexture( 3553, 3553, 1 ); emptyTextures[ 34067 ] = createTexture( 34067, 34069, 6 ); // init colorBuffer.setClear( 0, 0, 0, 1 ); depthBuffer.setClear( 1 ); stencilBuffer.setClear( 0 ); enable( 2929 ); depthBuffer.setFunc( LessEqualDepth ); setFlipSided( false ); setCullFace( CullFaceBack ); enable( 2884 ); setBlending( NoBlending ); // function initAttributes() { for ( var i = 0, l = newAttributes.length; i < l; i ++ ) { newAttributes[ i ] = 0; } } function enableAttribute( attribute ) { enableAttributeAndDivisor( attribute, 0 ); } function enableAttributeAndDivisor( attribute, meshPerAttribute ) { newAttributes[ attribute ] = 1; if ( enabledAttributes[ attribute ] === 0 ) { gl.enableVertexAttribArray( attribute ); enabledAttributes[ attribute ] = 1; } if ( attributeDivisors[ attribute ] !== meshPerAttribute ) { var extension = capabilities.isWebGL2 ? gl : extensions.get( 'ANGLE_instanced_arrays' ); extension[ capabilities.isWebGL2 ? 'vertexAttribDivisor' : 'vertexAttribDivisorANGLE' ]( attribute, meshPerAttribute ); attributeDivisors[ attribute ] = meshPerAttribute; } } function disableUnusedAttributes() { for ( var i = 0, l = enabledAttributes.length; i !== l; ++ i ) { if ( enabledAttributes[ i ] !== newAttributes[ i ] ) { gl.disableVertexAttribArray( i ); enabledAttributes[ i ] = 0; } } } function enable( id ) { if ( enabledCapabilities[ id ] !== true ) { gl.enable( id ); enabledCapabilities[ id ] = true; } } function disable( id ) { if ( enabledCapabilities[ id ] !== false ) { gl.disable( id ); enabledCapabilities[ id ] = false; } } function getCompressedTextureFormats() { if ( compressedTextureFormats === null ) { compressedTextureFormats = []; if ( extensions.get( 'WEBGL_compressed_texture_pvrtc' ) || extensions.get( 'WEBGL_compressed_texture_s3tc' ) || extensions.get( 'WEBGL_compressed_texture_etc1' ) || extensions.get( 'WEBGL_compressed_texture_astc' ) ) { var formats = gl.getParameter( 34467 ); for ( var i = 0; i < formats.length; i ++ ) { compressedTextureFormats.push( formats[ i ] ); } } } return compressedTextureFormats; } function useProgram( program ) { if ( currentProgram !== program ) { gl.useProgram( program ); currentProgram = program; return true; } return false; } function setBlending( blending, blendEquation, blendSrc, blendDst, blendEquationAlpha, blendSrcAlpha, blendDstAlpha, premultipliedAlpha ) { if ( blending === NoBlending ) { if ( currentBlendingEnabled ) { disable( 3042 ); currentBlendingEnabled = false; } return; } if ( ! currentBlendingEnabled ) { enable( 3042 ); currentBlendingEnabled = true; } if ( blending !== CustomBlending ) { if ( blending !== currentBlending || premultipliedAlpha !== currentPremultipledAlpha ) { if ( currentBlendEquation !== AddEquation || currentBlendEquationAlpha !== AddEquation ) { gl.blendEquation( 32774 ); currentBlendEquation = AddEquation; currentBlendEquationAlpha = AddEquation; } if ( premultipliedAlpha ) { switch ( blending ) { case NormalBlending: gl.blendFuncSeparate( 1, 771, 1, 771 ); break; case AdditiveBlending: gl.blendFunc( 1, 1 ); break; case SubtractiveBlending: gl.blendFuncSeparate( 0, 0, 769, 771 ); break; case MultiplyBlending: gl.blendFuncSeparate( 0, 768, 0, 770 ); break; default: console.error( 'THREE.WebGLState: Invalid blending: ', blending ); break; } } else { switch ( blending ) { case NormalBlending: gl.blendFuncSeparate( 770, 771, 1, 771 ); break; case AdditiveBlending: gl.blendFunc( 770, 1 ); break; case SubtractiveBlending: gl.blendFunc( 0, 769 ); break; case MultiplyBlending: gl.blendFunc( 0, 768 ); break; default: console.error( 'THREE.WebGLState: Invalid blending: ', blending ); break; } } currentBlendSrc = null; currentBlendDst = null; currentBlendSrcAlpha = null; currentBlendDstAlpha = null; currentBlending = blending; currentPremultipledAlpha = premultipliedAlpha; } return; } // custom blending blendEquationAlpha = blendEquationAlpha || blendEquation; blendSrcAlpha = blendSrcAlpha || blendSrc; blendDstAlpha = blendDstAlpha || blendDst; if ( blendEquation !== currentBlendEquation || blendEquationAlpha !== currentBlendEquationAlpha ) { gl.blendEquationSeparate( utils.convert( blendEquation ), utils.convert( blendEquationAlpha ) ); currentBlendEquation = blendEquation; currentBlendEquationAlpha = blendEquationAlpha; } if ( blendSrc !== currentBlendSrc || blendDst !== currentBlendDst || blendSrcAlpha !== currentBlendSrcAlpha || blendDstAlpha !== currentBlendDstAlpha ) { gl.blendFuncSeparate( utils.convert( blendSrc ), utils.convert( blendDst ), utils.convert( blendSrcAlpha ), utils.convert( blendDstAlpha ) ); currentBlendSrc = blendSrc; currentBlendDst = blendDst; currentBlendSrcAlpha = blendSrcAlpha; currentBlendDstAlpha = blendDstAlpha; } currentBlending = blending; currentPremultipledAlpha = null; } function setMaterial( material, frontFaceCW ) { material.side === DoubleSide ? disable( 2884 ) : enable( 2884 ); var flipSided = ( material.side === BackSide ); if ( frontFaceCW ) flipSided = ! flipSided; setFlipSided( flipSided ); ( material.blending === NormalBlending && material.transparent === false ) ? setBlending( NoBlending ) : setBlending( material.blending, material.blendEquation, material.blendSrc, material.blendDst, material.blendEquationAlpha, material.blendSrcAlpha, material.blendDstAlpha, material.premultipliedAlpha ); depthBuffer.setFunc( material.depthFunc ); depthBuffer.setTest( material.depthTest ); depthBuffer.setMask( material.depthWrite ); colorBuffer.setMask( material.colorWrite ); setPolygonOffset( material.polygonOffset, material.polygonOffsetFactor, material.polygonOffsetUnits ); } // function setFlipSided( flipSided ) { if ( currentFlipSided !== flipSided ) { if ( flipSided ) { gl.frontFace( 2304 ); } else { gl.frontFace( 2305 ); } currentFlipSided = flipSided; } } function setCullFace( cullFace ) { if ( cullFace !== CullFaceNone ) { enable( 2884 ); if ( cullFace !== currentCullFace ) { if ( cullFace === CullFaceBack ) { gl.cullFace( 1029 ); } else if ( cullFace === CullFaceFront ) { gl.cullFace( 1028 ); } else { gl.cullFace( 1032 ); } } } else { disable( 2884 ); } currentCullFace = cullFace; } function setLineWidth( width ) { if ( width !== currentLineWidth ) { if ( lineWidthAvailable ) gl.lineWidth( width ); currentLineWidth = width; } } function setPolygonOffset( polygonOffset, factor, units ) { if ( polygonOffset ) { enable( 32823 ); if ( currentPolygonOffsetFactor !== factor || currentPolygonOffsetUnits !== units ) { gl.polygonOffset( factor, units ); currentPolygonOffsetFactor = factor; currentPolygonOffsetUnits = units; } } else { disable( 32823 ); } } function setScissorTest( scissorTest ) { if ( scissorTest ) { enable( 3089 ); } else { disable( 3089 ); } } // texture function activeTexture( webglSlot ) { if ( webglSlot === undefined ) webglSlot = 33984 + maxTextures - 1; if ( currentTextureSlot !== webglSlot ) { gl.activeTexture( webglSlot ); currentTextureSlot = webglSlot; } } function bindTexture( webglType, webglTexture ) { if ( currentTextureSlot === null ) { activeTexture(); } var boundTexture = currentBoundTextures[ currentTextureSlot ]; if ( boundTexture === undefined ) { boundTexture = { type: undefined, texture: undefined }; currentBoundTextures[ currentTextureSlot ] = boundTexture; } if ( boundTexture.type !== webglType || boundTexture.texture !== webglTexture ) { gl.bindTexture( webglType, webglTexture || emptyTextures[ webglType ] ); boundTexture.type = webglType; boundTexture.texture = webglTexture; } } function compressedTexImage2D() { try { gl.compressedTexImage2D.apply( gl, arguments ); } catch ( error ) { console.error( 'THREE.WebGLState:', error ); } } function texImage2D() { try { gl.texImage2D.apply( gl, arguments ); } catch ( error ) { console.error( 'THREE.WebGLState:', error ); } } function texImage3D() { try { gl.texImage3D.apply( gl, arguments ); } catch ( error ) { console.error( 'THREE.WebGLState:', error ); } } // function scissor( scissor ) { if ( currentScissor.equals( scissor ) === false ) { gl.scissor( scissor.x, scissor.y, scissor.z, scissor.w ); currentScissor.copy( scissor ); } } function viewport( viewport ) { if ( currentViewport.equals( viewport ) === false ) { gl.viewport( viewport.x, viewport.y, viewport.z, viewport.w ); currentViewport.copy( viewport ); } } // function reset() { for ( var i = 0; i < enabledAttributes.length; i ++ ) { if ( enabledAttributes[ i ] === 1 ) { gl.disableVertexAttribArray( i ); enabledAttributes[ i ] = 0; } } enabledCapabilities = {}; compressedTextureFormats = null; currentTextureSlot = null; currentBoundTextures = {}; currentProgram = null; currentBlending = null; currentFlipSided = null; currentCullFace = null; colorBuffer.reset(); depthBuffer.reset(); stencilBuffer.reset(); } return { buffers: { color: colorBuffer, depth: depthBuffer, stencil: stencilBuffer }, initAttributes: initAttributes, enableAttribute: enableAttribute, enableAttributeAndDivisor: enableAttributeAndDivisor, disableUnusedAttributes: disableUnusedAttributes, enable: enable, disable: disable, getCompressedTextureFormats: getCompressedTextureFormats, useProgram: useProgram, setBlending: setBlending, setMaterial: setMaterial, setFlipSided: setFlipSided, setCullFace: setCullFace, setLineWidth: setLineWidth, setPolygonOffset: setPolygonOffset, setScissorTest: setScissorTest, activeTexture: activeTexture, bindTexture: bindTexture, compressedTexImage2D: compressedTexImage2D, texImage2D: texImage2D, texImage3D: texImage3D, scissor: scissor, viewport: viewport, reset: reset }; } /** * @author mrdoob / http://mrdoob.com/ */ function WebGLTextures( _gl, extensions, state, properties, capabilities, utils, info ) { var _videoTextures = {}; var _canvas; // function resizeImage( image, needsPowerOfTwo, needsNewCanvas, maxSize ) { var scale = 1; // handle case if texture exceeds max size if ( image.width > maxSize || image.height > maxSize ) { scale = maxSize / Math.max( image.width, image.height ); } // only perform resize if necessary if ( scale < 1 || needsPowerOfTwo === true ) { // only perform resize for certain image types if ( image instanceof HTMLImageElement || image instanceof HTMLCanvasElement || image instanceof ImageBitmap ) { if ( _canvas === undefined ) _canvas = document.createElementNS( 'http://www.w3.org/1999/xhtml', 'canvas' ); // cube textures can't reuse the same canvas var canvas = needsNewCanvas ? document.createElementNS( 'http://www.w3.org/1999/xhtml', 'canvas' ) : _canvas; var floor = needsPowerOfTwo ? _Math.floorPowerOfTwo : Math.floor; canvas.width = floor( scale * image.width ); canvas.height = floor( scale * image.height ); var context = canvas.getContext( '2d' ); context.drawImage( image, 0, 0, canvas.width, canvas.height ); console.warn( 'THREE.WebGLRenderer: Texture has been resized from (' + image.width + 'x' + image.height + ') to (' + canvas.width + 'x' + canvas.height + ').' ); return canvas; } else { if ( 'data' in image ) { console.warn( 'THREE.WebGLRenderer: Image in DataTexture is too big (' + image.width + 'x' + image.height + ').' ); } return image; } } return image; } function isPowerOfTwo( image ) { return _Math.isPowerOfTwo( image.width ) && _Math.isPowerOfTwo( image.height ); } function textureNeedsPowerOfTwo( texture ) { if ( capabilities.isWebGL2 ) return false; return ( texture.wrapS !== ClampToEdgeWrapping || texture.wrapT !== ClampToEdgeWrapping ) || ( texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter ); } function textureNeedsGenerateMipmaps( texture, supportsMips ) { return texture.generateMipmaps && supportsMips && texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter; } function generateMipmap( target, texture, width, height ) { _gl.generateMipmap( target ); var textureProperties = properties.get( texture ); // Note: Math.log( x ) * Math.LOG2E used instead of Math.log2( x ) which is not supported by IE11 textureProperties.__maxMipLevel = Math.log( Math.max( width, height ) ) * Math.LOG2E; } function getInternalFormat( glFormat, glType ) { if ( ! capabilities.isWebGL2 ) return glFormat; var internalFormat = glFormat; if ( glFormat === 6403 ) { if ( glType === 5126 ) internalFormat = 33326; if ( glType === 5131 ) internalFormat = 33325; if ( glType === 5121 ) internalFormat = 33321; } if ( glFormat === 6407 ) { if ( glType === 5126 ) internalFormat = 34837; if ( glType === 5131 ) internalFormat = 34843; if ( glType === 5121 ) internalFormat = 32849; } if ( glFormat === 6408 ) { if ( glType === 5126 ) internalFormat = 34836; if ( glType === 5131 ) internalFormat = 34842; if ( glType === 5121 ) internalFormat = 32856; } if ( internalFormat === 33325 || internalFormat === 33326 || internalFormat === 34842 || internalFormat === 34836 ) { extensions.get( 'EXT_color_buffer_float' ); } else if ( internalFormat === 34843 || internalFormat === 34837 ) { console.warn( 'THREE.WebGLRenderer: Floating point textures with RGB format not supported. Please use RGBA instead.' ); } return internalFormat; } // Fallback filters for non-power-of-2 textures function filterFallback( f ) { if ( f === NearestFilter || f === NearestMipMapNearestFilter || f === NearestMipMapLinearFilter ) { return 9728; } return 9729; } // function onTextureDispose( event ) { var texture = event.target; texture.removeEventListener( 'dispose', onTextureDispose ); deallocateTexture( texture ); if ( texture.isVideoTexture ) { delete _videoTextures[ texture.id ]; } info.memory.textures --; } function onRenderTargetDispose( event ) { var renderTarget = event.target; renderTarget.removeEventListener( 'dispose', onRenderTargetDispose ); deallocateRenderTarget( renderTarget ); info.memory.textures --; } // function deallocateTexture( texture ) { var textureProperties = properties.get( texture ); if ( textureProperties.__webglInit === undefined ) return; _gl.deleteTexture( textureProperties.__webglTexture ); properties.remove( texture ); } function deallocateRenderTarget( renderTarget ) { var renderTargetProperties = properties.get( renderTarget ); var textureProperties = properties.get( renderTarget.texture ); if ( ! renderTarget ) return; if ( textureProperties.__webglTexture !== undefined ) { _gl.deleteTexture( textureProperties.__webglTexture ); } if ( renderTarget.depthTexture ) { renderTarget.depthTexture.dispose(); } if ( renderTarget.isWebGLRenderTargetCube ) { for ( var i = 0; i < 6; i ++ ) { _gl.deleteFramebuffer( renderTargetProperties.__webglFramebuffer[ i ] ); if ( renderTargetProperties.__webglDepthbuffer ) _gl.deleteRenderbuffer( renderTargetProperties.__webglDepthbuffer[ i ] ); } } else { _gl.deleteFramebuffer( renderTargetProperties.__webglFramebuffer ); if ( renderTargetProperties.__webglDepthbuffer ) _gl.deleteRenderbuffer( renderTargetProperties.__webglDepthbuffer ); } properties.remove( renderTarget.texture ); properties.remove( renderTarget ); } // function setTexture2D( texture, slot ) { var textureProperties = properties.get( texture ); if ( texture.isVideoTexture ) updateVideoTexture( texture ); if ( texture.version > 0 && textureProperties.__version !== texture.version ) { var image = texture.image; if ( image === undefined ) { console.warn( 'THREE.WebGLRenderer: Texture marked for update but image is undefined' ); } else if ( image.complete === false ) { console.warn( 'THREE.WebGLRenderer: Texture marked for update but image is incomplete' ); } else { uploadTexture( textureProperties, texture, slot ); return; } } state.activeTexture( 33984 + slot ); state.bindTexture( 3553, textureProperties.__webglTexture ); } function setTexture3D( texture, slot ) { var textureProperties = properties.get( texture ); if ( texture.version > 0 && textureProperties.__version !== texture.version ) { uploadTexture( textureProperties, texture, slot ); return; } state.activeTexture( 33984 + slot ); state.bindTexture( 32879, textureProperties.__webglTexture ); } function setTextureCube( texture, slot ) { var textureProperties = properties.get( texture ); if ( texture.image.length === 6 ) { if ( texture.version > 0 && textureProperties.__version !== texture.version ) { initTexture( textureProperties, texture ); state.activeTexture( 33984 + slot ); state.bindTexture( 34067, textureProperties.__webglTexture ); _gl.pixelStorei( 37440, texture.flipY ); var isCompressed = ( texture && texture.isCompressedTexture ); var isDataTexture = ( texture.image[ 0 ] && texture.image[ 0 ].isDataTexture ); var cubeImage = []; for ( var i = 0; i < 6; i ++ ) { if ( ! isCompressed && ! isDataTexture ) { cubeImage[ i ] = resizeImage( texture.image[ i ], false, true, capabilities.maxCubemapSize ); } else { cubeImage[ i ] = isDataTexture ? texture.image[ i ].image : texture.image[ i ]; } } var image = cubeImage[ 0 ], supportsMips = isPowerOfTwo( image ) || capabilities.isWebGL2, glFormat = utils.convert( texture.format ), glType = utils.convert( texture.type ), glInternalFormat = getInternalFormat( glFormat, glType ); setTextureParameters( 34067, texture, supportsMips ); for ( var i = 0; i < 6; i ++ ) { if ( ! isCompressed ) { if ( isDataTexture ) { state.texImage2D( 34069 + i, 0, glInternalFormat, cubeImage[ i ].width, cubeImage[ i ].height, 0, glFormat, glType, cubeImage[ i ].data ); } else { state.texImage2D( 34069 + i, 0, glInternalFormat, glFormat, glType, cubeImage[ i ] ); } } else { var mipmap, mipmaps = cubeImage[ i ].mipmaps; for ( var j = 0, jl = mipmaps.length; j < jl; j ++ ) { mipmap = mipmaps[ j ]; if ( texture.format !== RGBAFormat && texture.format !== RGBFormat ) { if ( state.getCompressedTextureFormats().indexOf( glFormat ) > - 1 ) { state.compressedTexImage2D( 34069 + i, j, glInternalFormat, mipmap.width, mipmap.height, 0, mipmap.data ); } else { console.warn( 'THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()' ); } } else { state.texImage2D( 34069 + i, j, glInternalFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data ); } } } } if ( ! isCompressed ) { textureProperties.__maxMipLevel = 0; } else { textureProperties.__maxMipLevel = mipmaps.length - 1; } if ( textureNeedsGenerateMipmaps( texture, supportsMips ) ) { // We assume images for cube map have the same size. generateMipmap( 34067, texture, image.width, image.height ); } textureProperties.__version = texture.version; if ( texture.onUpdate ) texture.onUpdate( texture ); } else { state.activeTexture( 33984 + slot ); state.bindTexture( 34067, textureProperties.__webglTexture ); } } } function setTextureCubeDynamic( texture, slot ) { state.activeTexture( 33984 + slot ); state.bindTexture( 34067, properties.get( texture ).__webglTexture ); } function setTextureParameters( textureType, texture, supportsMips ) { var extension; if ( supportsMips ) { _gl.texParameteri( textureType, 10242, utils.convert( texture.wrapS ) ); _gl.texParameteri( textureType, 10243, utils.convert( texture.wrapT ) ); if ( textureType === 32879 ) { _gl.texParameteri( textureType, 32882, utils.convert( texture.wrapR ) ); } _gl.texParameteri( textureType, 10240, utils.convert( texture.magFilter ) ); _gl.texParameteri( textureType, 10241, utils.convert( texture.minFilter ) ); } else { _gl.texParameteri( textureType, 10242, 33071 ); _gl.texParameteri( textureType, 10243, 33071 ); if ( textureType === 32879 ) { _gl.texParameteri( textureType, 32882, 33071 ); } if ( texture.wrapS !== ClampToEdgeWrapping || texture.wrapT !== ClampToEdgeWrapping ) { console.warn( 'THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping.' ); } _gl.texParameteri( textureType, 10240, filterFallback( texture.magFilter ) ); _gl.texParameteri( textureType, 10241, filterFallback( texture.minFilter ) ); if ( texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter ) { console.warn( 'THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.' ); } } extension = extensions.get( 'EXT_texture_filter_anisotropic' ); if ( extension ) { if ( texture.type === FloatType && extensions.get( 'OES_texture_float_linear' ) === null ) return; if ( texture.type === HalfFloatType && ( capabilities.isWebGL2 || extensions.get( 'OES_texture_half_float_linear' ) ) === null ) return; if ( texture.anisotropy > 1 || properties.get( texture ).__currentAnisotropy ) { _gl.texParameterf( textureType, extension.TEXTURE_MAX_ANISOTROPY_EXT, Math.min( texture.anisotropy, capabilities.getMaxAnisotropy() ) ); properties.get( texture ).__currentAnisotropy = texture.anisotropy; } } } function initTexture( textureProperties, texture ) { if ( textureProperties.__webglInit === undefined ) { textureProperties.__webglInit = true; texture.addEventListener( 'dispose', onTextureDispose ); textureProperties.__webglTexture = _gl.createTexture(); info.memory.textures ++; } } function uploadTexture( textureProperties, texture, slot ) { var textureType = ( texture.isDataTexture3D ) ? 32879 : 3553; initTexture( textureProperties, texture ); state.activeTexture( 33984 + slot ); state.bindTexture( textureType, textureProperties.__webglTexture ); _gl.pixelStorei( 37440, texture.flipY ); _gl.pixelStorei( 37441, texture.premultiplyAlpha ); _gl.pixelStorei( 3317, texture.unpackAlignment ); var needsPowerOfTwo = textureNeedsPowerOfTwo( texture ) && isPowerOfTwo( texture.image ) === false; var image = resizeImage( texture.image, needsPowerOfTwo, false, capabilities.maxTextureSize ); var supportsMips = isPowerOfTwo( image ) || capabilities.isWebGL2, glFormat = utils.convert( texture.format ), glType = utils.convert( texture.type ), glInternalFormat = getInternalFormat( glFormat, glType ); setTextureParameters( textureType, texture, supportsMips ); var mipmap, mipmaps = texture.mipmaps; if ( texture.isDepthTexture ) { // populate depth texture with dummy data glInternalFormat = 6402; if ( texture.type === FloatType ) { if ( ! capabilities.isWebGL2 ) throw new Error( 'Float Depth Texture only supported in WebGL2.0' ); glInternalFormat = 36012; } else if ( capabilities.isWebGL2 ) { // WebGL 2.0 requires signed internalformat for glTexImage2D glInternalFormat = 33189; } if ( texture.format === DepthFormat && glInternalFormat === 6402 ) { // The error INVALID_OPERATION is generated by texImage2D if format and internalformat are // DEPTH_COMPONENT and type is not UNSIGNED_SHORT or UNSIGNED_INT // (https://www.khronos.org/registry/webgl/extensions/WEBGL_depth_texture/) if ( texture.type !== UnsignedShortType && texture.type !== UnsignedIntType ) { console.warn( 'THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture.' ); texture.type = UnsignedShortType; glType = utils.convert( texture.type ); } } // Depth stencil textures need the DEPTH_STENCIL internal format // (https://www.khronos.org/registry/webgl/extensions/WEBGL_depth_texture/) if ( texture.format === DepthStencilFormat ) { glInternalFormat = 34041; // The error INVALID_OPERATION is generated by texImage2D if format and internalformat are // DEPTH_STENCIL and type is not UNSIGNED_INT_24_8_WEBGL. // (https://www.khronos.org/registry/webgl/extensions/WEBGL_depth_texture/) if ( texture.type !== UnsignedInt248Type ) { console.warn( 'THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture.' ); texture.type = UnsignedInt248Type; glType = utils.convert( texture.type ); } } state.texImage2D( 3553, 0, glInternalFormat, image.width, image.height, 0, glFormat, glType, null ); } else if ( texture.isDataTexture ) { // use manually created mipmaps if available // if there are no manual mipmaps // set 0 level mipmap and then use GL to generate other mipmap levels if ( mipmaps.length > 0 && supportsMips ) { for ( var i = 0, il = mipmaps.length; i < il; i ++ ) { mipmap = mipmaps[ i ]; state.texImage2D( 3553, i, glInternalFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data ); } texture.generateMipmaps = false; textureProperties.__maxMipLevel = mipmaps.length - 1; } else { state.texImage2D( 3553, 0, glInternalFormat, image.width, image.height, 0, glFormat, glType, image.data ); textureProperties.__maxMipLevel = 0; } } else if ( texture.isCompressedTexture ) { for ( var i = 0, il = mipmaps.length; i < il; i ++ ) { mipmap = mipmaps[ i ]; if ( texture.format !== RGBAFormat && texture.format !== RGBFormat ) { if ( state.getCompressedTextureFormats().indexOf( glFormat ) > - 1 ) { state.compressedTexImage2D( 3553, i, glInternalFormat, mipmap.width, mipmap.height, 0, mipmap.data ); } else { console.warn( 'THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()' ); } } else { state.texImage2D( 3553, i, glInternalFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data ); } } textureProperties.__maxMipLevel = mipmaps.length - 1; } else if ( texture.isDataTexture3D ) { state.texImage3D( 32879, 0, glInternalFormat, image.width, image.height, image.depth, 0, glFormat, glType, image.data ); textureProperties.__maxMipLevel = 0; } else { // regular Texture (image, video, canvas) // use manually created mipmaps if available // if there are no manual mipmaps // set 0 level mipmap and then use GL to generate other mipmap levels if ( mipmaps.length > 0 && supportsMips ) { for ( var i = 0, il = mipmaps.length; i < il; i ++ ) { mipmap = mipmaps[ i ]; state.texImage2D( 3553, i, glInternalFormat, glFormat, glType, mipmap ); } texture.generateMipmaps = false; textureProperties.__maxMipLevel = mipmaps.length - 1; } else { state.texImage2D( 3553, 0, glInternalFormat, glFormat, glType, image ); textureProperties.__maxMipLevel = 0; } } if ( textureNeedsGenerateMipmaps( texture, supportsMips ) ) { generateMipmap( 3553, texture, image.width, image.height ); } textureProperties.__version = texture.version; if ( texture.onUpdate ) texture.onUpdate( texture ); } // Render targets // Setup storage for target texture and bind it to correct framebuffer function setupFrameBufferTexture( framebuffer, renderTarget, attachment, textureTarget ) { var glFormat = utils.convert( renderTarget.texture.format ); var glType = utils.convert( renderTarget.texture.type ); var glInternalFormat = getInternalFormat( glFormat, glType ); state.texImage2D( textureTarget, 0, glInternalFormat, renderTarget.width, renderTarget.height, 0, glFormat, glType, null ); _gl.bindFramebuffer( 36160, framebuffer ); _gl.framebufferTexture2D( 36160, attachment, textureTarget, properties.get( renderTarget.texture ).__webglTexture, 0 ); _gl.bindFramebuffer( 36160, null ); } // Setup storage for internal depth/stencil buffers and bind to correct framebuffer function setupRenderBufferStorage( renderbuffer, renderTarget, isMultisample ) { _gl.bindRenderbuffer( 36161, renderbuffer ); if ( renderTarget.depthBuffer && ! renderTarget.stencilBuffer ) { if ( isMultisample ) { var samples = getRenderTargetSamples( renderTarget ); _gl.renderbufferStorageMultisample( 36161, samples, 33189, renderTarget.width, renderTarget.height ); } else { _gl.renderbufferStorage( 36161, 33189, renderTarget.width, renderTarget.height ); } _gl.framebufferRenderbuffer( 36160, 36096, 36161, renderbuffer ); } else if ( renderTarget.depthBuffer && renderTarget.stencilBuffer ) { if ( isMultisample ) { var samples = getRenderTargetSamples( renderTarget ); _gl.renderbufferStorageMultisample( 36161, samples, 34041, renderTarget.width, renderTarget.height ); } else { _gl.renderbufferStorage( 36161, 34041, renderTarget.width, renderTarget.height ); } _gl.framebufferRenderbuffer( 36160, 33306, 36161, renderbuffer ); } else { var glFormat = utils.convert( renderTarget.texture.format ); var glType = utils.convert( renderTarget.texture.type ); var glInternalFormat = getInternalFormat( glFormat, glType ); if ( isMultisample ) { var samples = getRenderTargetSamples( renderTarget ); _gl.renderbufferStorageMultisample( 36161, samples, glInternalFormat, renderTarget.width, renderTarget.height ); } else { _gl.renderbufferStorage( 36161, glInternalFormat, renderTarget.width, renderTarget.height ); } } _gl.bindRenderbuffer( 36161, null ); } // Setup resources for a Depth Texture for a FBO (needs an extension) function setupDepthTexture( framebuffer, renderTarget ) { var isCube = ( renderTarget && renderTarget.isWebGLRenderTargetCube ); if ( isCube ) throw new Error( 'Depth Texture with cube render targets is not supported' ); _gl.bindFramebuffer( 36160, framebuffer ); if ( ! ( renderTarget.depthTexture && renderTarget.depthTexture.isDepthTexture ) ) { throw new Error( 'renderTarget.depthTexture must be an instance of THREE.DepthTexture' ); } // upload an empty depth texture with framebuffer size if ( ! properties.get( renderTarget.depthTexture ).__webglTexture || renderTarget.depthTexture.image.width !== renderTarget.width || renderTarget.depthTexture.image.height !== renderTarget.height ) { renderTarget.depthTexture.image.width = renderTarget.width; renderTarget.depthTexture.image.height = renderTarget.height; renderTarget.depthTexture.needsUpdate = true; } setTexture2D( renderTarget.depthTexture, 0 ); var webglDepthTexture = properties.get( renderTarget.depthTexture ).__webglTexture; if ( renderTarget.depthTexture.format === DepthFormat ) { _gl.framebufferTexture2D( 36160, 36096, 3553, webglDepthTexture, 0 ); } else if ( renderTarget.depthTexture.format === DepthStencilFormat ) { _gl.framebufferTexture2D( 36160, 33306, 3553, webglDepthTexture, 0 ); } else { throw new Error( 'Unknown depthTexture format' ); } } // Setup GL resources for a non-texture depth buffer function setupDepthRenderbuffer( renderTarget ) { var renderTargetProperties = properties.get( renderTarget ); var isCube = ( renderTarget.isWebGLRenderTargetCube === true ); if ( renderTarget.depthTexture ) { if ( isCube ) throw new Error( 'target.depthTexture not supported in Cube render targets' ); setupDepthTexture( renderTargetProperties.__webglFramebuffer, renderTarget ); } else { if ( isCube ) { renderTargetProperties.__webglDepthbuffer = []; for ( var i = 0; i < 6; i ++ ) { _gl.bindFramebuffer( 36160, renderTargetProperties.__webglFramebuffer[ i ] ); renderTargetProperties.__webglDepthbuffer[ i ] = _gl.createRenderbuffer(); setupRenderBufferStorage( renderTargetProperties.__webglDepthbuffer[ i ], renderTarget ); } } else { _gl.bindFramebuffer( 36160, renderTargetProperties.__webglFramebuffer ); renderTargetProperties.__webglDepthbuffer = _gl.createRenderbuffer(); setupRenderBufferStorage( renderTargetProperties.__webglDepthbuffer, renderTarget ); } } _gl.bindFramebuffer( 36160, null ); } // Set up GL resources for the render target function setupRenderTarget( renderTarget ) { var renderTargetProperties = properties.get( renderTarget ); var textureProperties = properties.get( renderTarget.texture ); renderTarget.addEventListener( 'dispose', onRenderTargetDispose ); textureProperties.__webglTexture = _gl.createTexture(); info.memory.textures ++; var isCube = ( renderTarget.isWebGLRenderTargetCube === true ); var isMultisample = ( renderTarget.isWebGLMultisampleRenderTarget === true ); var supportsMips = isPowerOfTwo( renderTarget ) || capabilities.isWebGL2; // Setup framebuffer if ( isCube ) { renderTargetProperties.__webglFramebuffer = []; for ( var i = 0; i < 6; i ++ ) { renderTargetProperties.__webglFramebuffer[ i ] = _gl.createFramebuffer(); } } else { renderTargetProperties.__webglFramebuffer = _gl.createFramebuffer(); if ( isMultisample ) { if ( capabilities.isWebGL2 ) { renderTargetProperties.__webglMultisampledFramebuffer = _gl.createFramebuffer(); renderTargetProperties.__webglColorRenderbuffer = _gl.createRenderbuffer(); _gl.bindRenderbuffer( 36161, renderTargetProperties.__webglColorRenderbuffer ); var glFormat = utils.convert( renderTarget.texture.format ); var glType = utils.convert( renderTarget.texture.type ); var glInternalFormat = getInternalFormat( glFormat, glType ); var samples = getRenderTargetSamples( renderTarget ); _gl.renderbufferStorageMultisample( 36161, samples, glInternalFormat, renderTarget.width, renderTarget.height ); _gl.bindFramebuffer( 36160, renderTargetProperties.__webglMultisampledFramebuffer ); _gl.framebufferRenderbuffer( 36160, 36064, 36161, renderTargetProperties.__webglColorRenderbuffer ); _gl.bindRenderbuffer( 36161, null ); if ( renderTarget.depthBuffer ) { renderTargetProperties.__webglDepthRenderbuffer = _gl.createRenderbuffer(); setupRenderBufferStorage( renderTargetProperties.__webglDepthRenderbuffer, renderTarget, true ); } _gl.bindFramebuffer( 36160, null ); } else { console.warn( 'THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.' ); } } } // Setup color buffer if ( isCube ) { state.bindTexture( 34067, textureProperties.__webglTexture ); setTextureParameters( 34067, renderTarget.texture, supportsMips ); for ( var i = 0; i < 6; i ++ ) { setupFrameBufferTexture( renderTargetProperties.__webglFramebuffer[ i ], renderTarget, 36064, 34069 + i ); } if ( textureNeedsGenerateMipmaps( renderTarget.texture, supportsMips ) ) { generateMipmap( 34067, renderTarget.texture, renderTarget.width, renderTarget.height ); } state.bindTexture( 34067, null ); } else { state.bindTexture( 3553, textureProperties.__webglTexture ); setTextureParameters( 3553, renderTarget.texture, supportsMips ); setupFrameBufferTexture( renderTargetProperties.__webglFramebuffer, renderTarget, 36064, 3553 ); if ( textureNeedsGenerateMipmaps( renderTarget.texture, supportsMips ) ) { generateMipmap( 3553, renderTarget.texture, renderTarget.width, renderTarget.height ); } state.bindTexture( 3553, null ); } // Setup depth and stencil buffers if ( renderTarget.depthBuffer ) { setupDepthRenderbuffer( renderTarget ); } } function updateRenderTargetMipmap( renderTarget ) { var texture = renderTarget.texture; var supportsMips = isPowerOfTwo( renderTarget ) || capabilities.isWebGL2; if ( textureNeedsGenerateMipmaps( texture, supportsMips ) ) { var target = renderTarget.isWebGLRenderTargetCube ? 34067 : 3553; var webglTexture = properties.get( texture ).__webglTexture; state.bindTexture( target, webglTexture ); generateMipmap( target, texture, renderTarget.width, renderTarget.height ); state.bindTexture( target, null ); } } function updateMultisampleRenderTarget( renderTarget ) { if ( renderTarget.isWebGLMultisampleRenderTarget ) { if ( capabilities.isWebGL2 ) { var renderTargetProperties = properties.get( renderTarget ); _gl.bindFramebuffer( 36008, renderTargetProperties.__webglMultisampledFramebuffer ); _gl.bindFramebuffer( 36009, renderTargetProperties.__webglFramebuffer ); var width = renderTarget.width; var height = renderTarget.height; var mask = 16384; if ( renderTarget.depthBuffer ) mask |= 256; if ( renderTarget.stencilBuffer ) mask |= 1024; _gl.blitFramebuffer( 0, 0, width, height, 0, 0, width, height, mask, 9728 ); } else { console.warn( 'THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.' ); } } } function getRenderTargetSamples( renderTarget ) { return ( capabilities.isWebGL2 && renderTarget.isWebGLMultisampleRenderTarget ) ? Math.min( capabilities.maxSamples, renderTarget.samples ) : 0; } function updateVideoTexture( texture ) { var id = texture.id; var frame = info.render.frame; // Check the last frame we updated the VideoTexture if ( _videoTextures[ id ] !== frame ) { _videoTextures[ id ] = frame; texture.update(); } } this.setTexture2D = setTexture2D; this.setTexture3D = setTexture3D; this.setTextureCube = setTextureCube; this.setTextureCubeDynamic = setTextureCubeDynamic; this.setupRenderTarget = setupRenderTarget; this.updateRenderTargetMipmap = updateRenderTargetMipmap; this.updateMultisampleRenderTarget = updateMultisampleRenderTarget; } /** * @author thespite / http://www.twitter.com/thespite */ function WebGLUtils( gl, extensions, capabilities ) { function convert( p ) { var extension; if ( p === RepeatWrapping ) return 10497; if ( p === ClampToEdgeWrapping ) return 33071; if ( p === MirroredRepeatWrapping ) return 33648; if ( p === NearestFilter ) return 9728; if ( p === NearestMipMapNearestFilter ) return 9984; if ( p === NearestMipMapLinearFilter ) return 9986; if ( p === LinearFilter ) return 9729; if ( p === LinearMipMapNearestFilter ) return 9985; if ( p === LinearMipMapLinearFilter ) return 9987; if ( p === UnsignedByteType ) return 5121; if ( p === UnsignedShort4444Type ) return 32819; if ( p === UnsignedShort5551Type ) return 32820; if ( p === UnsignedShort565Type ) return 33635; if ( p === ByteType ) return 5120; if ( p === ShortType ) return 5122; if ( p === UnsignedShortType ) return 5123; if ( p === IntType ) return 5124; if ( p === UnsignedIntType ) return 5125; if ( p === FloatType ) return 5126; if ( p === HalfFloatType ) { if ( capabilities.isWebGL2 ) return 5131; extension = extensions.get( 'OES_texture_half_float' ); if ( extension !== null ) return extension.HALF_FLOAT_OES; } if ( p === AlphaFormat ) return 6406; if ( p === RGBFormat ) return 6407; if ( p === RGBAFormat ) return 6408; if ( p === LuminanceFormat ) return 6409; if ( p === LuminanceAlphaFormat ) return 6410; if ( p === DepthFormat ) return 6402; if ( p === DepthStencilFormat ) return 34041; if ( p === RedFormat ) return 6403; if ( p === AddEquation ) return 32774; if ( p === SubtractEquation ) return 32778; if ( p === ReverseSubtractEquation ) return 32779; if ( p === ZeroFactor ) return 0; if ( p === OneFactor ) return 1; if ( p === SrcColorFactor ) return 768; if ( p === OneMinusSrcColorFactor ) return 769; if ( p === SrcAlphaFactor ) return 770; if ( p === OneMinusSrcAlphaFactor ) return 771; if ( p === DstAlphaFactor ) return 772; if ( p === OneMinusDstAlphaFactor ) return 773; if ( p === DstColorFactor ) return 774; if ( p === OneMinusDstColorFactor ) return 775; if ( p === SrcAlphaSaturateFactor ) return 776; if ( p === RGB_S3TC_DXT1_Format || p === RGBA_S3TC_DXT1_Format || p === RGBA_S3TC_DXT3_Format || p === RGBA_S3TC_DXT5_Format ) { extension = extensions.get( 'WEBGL_compressed_texture_s3tc' ); if ( extension !== null ) { if ( p === RGB_S3TC_DXT1_Format ) return extension.COMPRESSED_RGB_S3TC_DXT1_EXT; if ( p === RGBA_S3TC_DXT1_Format ) return extension.COMPRESSED_RGBA_S3TC_DXT1_EXT; if ( p === RGBA_S3TC_DXT3_Format ) return extension.COMPRESSED_RGBA_S3TC_DXT3_EXT; if ( p === RGBA_S3TC_DXT5_Format ) return extension.COMPRESSED_RGBA_S3TC_DXT5_EXT; } } if ( p === RGB_PVRTC_4BPPV1_Format || p === RGB_PVRTC_2BPPV1_Format || p === RGBA_PVRTC_4BPPV1_Format || p === RGBA_PVRTC_2BPPV1_Format ) { extension = extensions.get( 'WEBGL_compressed_texture_pvrtc' ); if ( extension !== null ) { if ( p === RGB_PVRTC_4BPPV1_Format ) return extension.COMPRESSED_RGB_PVRTC_4BPPV1_IMG; if ( p === RGB_PVRTC_2BPPV1_Format ) return extension.COMPRESSED_RGB_PVRTC_2BPPV1_IMG; if ( p === RGBA_PVRTC_4BPPV1_Format ) return extension.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG; if ( p === RGBA_PVRTC_2BPPV1_Format ) return extension.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG; } } if ( p === RGB_ETC1_Format ) { extension = extensions.get( 'WEBGL_compressed_texture_etc1' ); if ( extension !== null ) return extension.COMPRESSED_RGB_ETC1_WEBGL; } if ( p === RGBA_ASTC_4x4_Format || p === RGBA_ASTC_5x4_Format || p === RGBA_ASTC_5x5_Format || p === RGBA_ASTC_6x5_Format || p === RGBA_ASTC_6x6_Format || p === RGBA_ASTC_8x5_Format || p === RGBA_ASTC_8x6_Format || p === RGBA_ASTC_8x8_Format || p === RGBA_ASTC_10x5_Format || p === RGBA_ASTC_10x6_Format || p === RGBA_ASTC_10x8_Format || p === RGBA_ASTC_10x10_Format || p === RGBA_ASTC_12x10_Format || p === RGBA_ASTC_12x12_Format ) { extension = extensions.get( 'WEBGL_compressed_texture_astc' ); if ( extension !== null ) { return p; } } if ( p === MinEquation || p === MaxEquation ) { if ( capabilities.isWebGL2 ) { if ( p === MinEquation ) return 32775; if ( p === MaxEquation ) return 32776; } extension = extensions.get( 'EXT_blend_minmax' ); if ( extension !== null ) { if ( p === MinEquation ) return extension.MIN_EXT; if ( p === MaxEquation ) return extension.MAX_EXT; } } if ( p === UnsignedInt248Type ) { if ( capabilities.isWebGL2 ) return 34042; extension = extensions.get( 'WEBGL_depth_texture' ); if ( extension !== null ) return extension.UNSIGNED_INT_24_8_WEBGL; } return 0; } return { convert: convert }; } /** * @author mrdoob / http://mrdoob.com/ */ function Group() { Object3D.call( this ); this.type = 'Group'; } Group.prototype = Object.assign( Object.create( Object3D.prototype ), { constructor: Group, isGroup: true } ); /** * @author mrdoob / http://mrdoob.com/ * @author mikael emtinger / http://gomo.se/ * @author WestLangley / http://github.com/WestLangley */ function Camera() { Object3D.call( this ); this.type = 'Camera'; this.matrixWorldInverse = new Matrix4(); this.projectionMatrix = new Matrix4(); this.projectionMatrixInverse = new Matrix4(); } Camera.prototype = Object.assign( Object.create( Object3D.prototype ), { constructor: Camera, isCamera: true, copy: function ( source, recursive ) { Object3D.prototype.copy.call( this, source, recursive ); this.matrixWorldInverse.copy( source.matrixWorldInverse ); this.projectionMatrix.copy( source.projectionMatrix ); this.projectionMatrixInverse.copy( source.projectionMatrixInverse ); return this; }, getWorldDirection: function ( target ) { if ( target === undefined ) { console.warn( 'THREE.Camera: .getWorldDirection() target is now required' ); target = new Vector3(); } this.updateMatrixWorld( true ); var e = this.matrixWorld.elements; return target.set( - e[ 8 ], - e[ 9 ], - e[ 10 ] ).normalize(); }, updateMatrixWorld: function ( force ) { Object3D.prototype.updateMatrixWorld.call( this, force ); this.matrixWorldInverse.getInverse( this.matrixWorld ); }, clone: function () { return new this.constructor().copy( this ); } } ); /** * @author mrdoob / http://mrdoob.com/ * @author greggman / http://games.greggman.com/ * @author zz85 / http://www.lab4games.net/zz85/blog * @author tschw */ function PerspectiveCamera( fov, aspect, near, far ) { Camera.call( this ); this.type = 'PerspectiveCamera'; this.fov = fov !== undefined ? fov : 50; this.zoom = 1; this.near = near !== undefined ? near : 0.1; this.far = far !== undefined ? far : 2000; this.focus = 10; this.aspect = aspect !== undefined ? aspect : 1; this.view = null; this.filmGauge = 35; // width of the film (default in millimeters) this.filmOffset = 0; // horizontal film offset (same unit as gauge) this.updateProjectionMatrix(); } PerspectiveCamera.prototype = Object.assign( Object.create( Camera.prototype ), { constructor: PerspectiveCamera, isPerspectiveCamera: true, copy: function ( source, recursive ) { Camera.prototype.copy.call( this, source, recursive ); this.fov = source.fov; this.zoom = source.zoom; this.near = source.near; this.far = source.far; this.focus = source.focus; this.aspect = source.aspect; this.view = source.view === null ? null : Object.assign( {}, source.view ); this.filmGauge = source.filmGauge; this.filmOffset = source.filmOffset; return this; }, /** * Sets the FOV by focal length in respect to the current .filmGauge. * * The default film gauge is 35, so that the focal length can be specified for * a 35mm (full frame) camera. * * Values for focal length and film gauge must have the same unit. */ setFocalLength: function ( focalLength ) { // see http://www.bobatkins.com/photography/technical/field_of_view.html var vExtentSlope = 0.5 * this.getFilmHeight() / focalLength; this.fov = _Math.RAD2DEG * 2 * Math.atan( vExtentSlope ); this.updateProjectionMatrix(); }, /** * Calculates the focal length from the current .fov and .filmGauge. */ getFocalLength: function () { var vExtentSlope = Math.tan( _Math.DEG2RAD * 0.5 * this.fov ); return 0.5 * this.getFilmHeight() / vExtentSlope; }, getEffectiveFOV: function () { return _Math.RAD2DEG * 2 * Math.atan( Math.tan( _Math.DEG2RAD * 0.5 * this.fov ) / this.zoom ); }, getFilmWidth: function () { // film not completely covered in portrait format (aspect < 1) return this.filmGauge * Math.min( this.aspect, 1 ); }, getFilmHeight: function () { // film not completely covered in landscape format (aspect > 1) return this.filmGauge / Math.max( this.aspect, 1 ); }, /** * Sets an offset in a larger frustum. This is useful for multi-window or * multi-monitor/multi-machine setups. * * For example, if you have 3x2 monitors and each monitor is 1920x1080 and * the monitors are in grid like this * * +---+---+---+ * | A | B | C | * +---+---+---+ * | D | E | F | * +---+---+---+ * * then for each monitor you would call it like this * * var w = 1920; * var h = 1080; * var fullWidth = w * 3; * var fullHeight = h * 2; * * --A-- * camera.setOffset( fullWidth, fullHeight, w * 0, h * 0, w, h ); * --B-- * camera.setOffset( fullWidth, fullHeight, w * 1, h * 0, w, h ); * --C-- * camera.setOffset( fullWidth, fullHeight, w * 2, h * 0, w, h ); * --D-- * camera.setOffset( fullWidth, fullHeight, w * 0, h * 1, w, h ); * --E-- * camera.setOffset( fullWidth, fullHeight, w * 1, h * 1, w, h ); * --F-- * camera.setOffset( fullWidth, fullHeight, w * 2, h * 1, w, h ); * * Note there is no reason monitors have to be the same size or in a grid. */ setViewOffset: function ( fullWidth, fullHeight, x, y, width, height ) { this.aspect = fullWidth / fullHeight; if ( this.view === null ) { this.view = { enabled: true, fullWidth: 1, fullHeight: 1, offsetX: 0, offsetY: 0, width: 1, height: 1 }; } this.view.enabled = true; this.view.fullWidth = fullWidth; this.view.fullHeight = fullHeight; this.view.offsetX = x; this.view.offsetY = y; this.view.width = width; this.view.height = height; this.updateProjectionMatrix(); }, clearViewOffset: function () { if ( this.view !== null ) { this.view.enabled = false; } this.updateProjectionMatrix(); }, updateProjectionMatrix: function () { var near = this.near, top = near * Math.tan( _Math.DEG2RAD * 0.5 * this.fov ) / this.zoom, height = 2 * top, width = this.aspect * height, left = - 0.5 * width, view = this.view; if ( this.view !== null && this.view.enabled ) { var fullWidth = view.fullWidth, fullHeight = view.fullHeight; left += view.offsetX * width / fullWidth; top -= view.offsetY * height / fullHeight; width *= view.width / fullWidth; height *= view.height / fullHeight; } var skew = this.filmOffset; if ( skew !== 0 ) left += near * skew / this.getFilmWidth(); this.projectionMatrix.makePerspective( left, left + width, top, top - height, near, this.far ); this.projectionMatrixInverse.getInverse( this.projectionMatrix ); }, toJSON: function ( meta ) { var data = Object3D.prototype.toJSON.call( this, meta ); data.object.fov = this.fov; data.object.zoom = this.zoom; data.object.near = this.near; data.object.far = this.far; data.object.focus = this.focus; data.object.aspect = this.aspect; if ( this.view !== null ) data.object.view = Object.assign( {}, this.view ); data.object.filmGauge = this.filmGauge; data.object.filmOffset = this.filmOffset; return data; } } ); /** * @author mrdoob / http://mrdoob.com/ */ function ArrayCamera( array ) { PerspectiveCamera.call( this ); this.cameras = array || []; } ArrayCamera.prototype = Object.assign( Object.create( PerspectiveCamera.prototype ), { constructor: ArrayCamera, isArrayCamera: true } ); /** * @author jsantell / https://www.jsantell.com/ * @author mrdoob / http://mrdoob.com/ */ var cameraLPos = new Vector3(); var cameraRPos = new Vector3(); /** * Assumes 2 cameras that are parallel and share an X-axis, and that * the cameras' projection and world matrices have already been set. * And that near and far planes are identical for both cameras. * Visualization of this technique: https://computergraphics.stackexchange.com/a/4765 */ function setProjectionFromUnion( camera, cameraL, cameraR ) { cameraLPos.setFromMatrixPosition( cameraL.matrixWorld ); cameraRPos.setFromMatrixPosition( cameraR.matrixWorld ); var ipd = cameraLPos.distanceTo( cameraRPos ); var projL = cameraL.projectionMatrix.elements; var projR = cameraR.projectionMatrix.elements; // VR systems will have identical far and near planes, and // most likely identical top and bottom frustum extents. // Use the left camera for these values. var near = projL[ 14 ] / ( projL[ 10 ] - 1 ); var far = projL[ 14 ] / ( projL[ 10 ] + 1 ); var topFov = ( projL[ 9 ] + 1 ) / projL[ 5 ]; var bottomFov = ( projL[ 9 ] - 1 ) / projL[ 5 ]; var leftFov = ( projL[ 8 ] - 1 ) / projL[ 0 ]; var rightFov = ( projR[ 8 ] + 1 ) / projR[ 0 ]; var left = near * leftFov; var right = near * rightFov; // Calculate the new camera's position offset from the // left camera. xOffset should be roughly half `ipd`. var zOffset = ipd / ( - leftFov + rightFov ); var xOffset = zOffset * - leftFov; // TODO: Better way to apply this offset? cameraL.matrixWorld.decompose( camera.position, camera.quaternion, camera.scale ); camera.translateX( xOffset ); camera.translateZ( zOffset ); camera.matrixWorld.compose( camera.position, camera.quaternion, camera.scale ); camera.matrixWorldInverse.getInverse( camera.matrixWorld ); // Find the union of the frustum values of the cameras and scale // the values so that the near plane's position does not change in world space, // although must now be relative to the new union camera. var near2 = near + zOffset; var far2 = far + zOffset; var left2 = left - xOffset; var right2 = right + ( ipd - xOffset ); var top2 = topFov * far / far2 * near2; var bottom2 = bottomFov * far / far2 * near2; camera.projectionMatrix.makePerspective( left2, right2, top2, bottom2, near2, far2 ); } /** * @author mrdoob / http://mrdoob.com/ */ function WebVRManager( renderer ) { var scope = this; var device = null; var frameData = null; var poseTarget = null; var controllers = []; var standingMatrix = new Matrix4(); var standingMatrixInverse = new Matrix4(); var framebufferScaleFactor = 1.0; var frameOfReferenceType = 'stage'; if ( typeof window !== 'undefined' && 'VRFrameData' in window ) { frameData = new window.VRFrameData(); window.addEventListener( 'vrdisplaypresentchange', onVRDisplayPresentChange, false ); } var matrixWorldInverse = new Matrix4(); var tempQuaternion = new Quaternion(); var tempPosition = new Vector3(); var cameraL = new PerspectiveCamera(); cameraL.bounds = new Vector4( 0.0, 0.0, 0.5, 1.0 ); cameraL.layers.enable( 1 ); var cameraR = new PerspectiveCamera(); cameraR.bounds = new Vector4( 0.5, 0.0, 0.5, 1.0 ); cameraR.layers.enable( 2 ); var cameraVR = new ArrayCamera( [ cameraL, cameraR ] ); cameraVR.layers.enable( 1 ); cameraVR.layers.enable( 2 ); // function isPresenting() { return device !== null && device.isPresenting === true; } var currentSize, currentPixelRatio; function onVRDisplayPresentChange() { if ( isPresenting() ) { var eyeParameters = device.getEyeParameters( 'left' ); var renderWidth = eyeParameters.renderWidth * framebufferScaleFactor; var renderHeight = eyeParameters.renderHeight * framebufferScaleFactor; currentPixelRatio = renderer.getPixelRatio(); currentSize = renderer.getSize(); renderer.setDrawingBufferSize( renderWidth * 2, renderHeight, 1 ); animation.start(); } else { if ( scope.enabled ) { renderer.setDrawingBufferSize( currentSize.width, currentSize.height, currentPixelRatio ); } animation.stop(); } } // var triggers = []; function findGamepad( id ) { var gamepads = navigator.getGamepads && navigator.getGamepads(); for ( var i = 0, j = 0, l = gamepads.length; i < l; i ++ ) { var gamepad = gamepads[ i ]; if ( gamepad && ( gamepad.id === 'Daydream Controller' || gamepad.id === 'Gear VR Controller' || gamepad.id === 'Oculus Go Controller' || gamepad.id === 'OpenVR Gamepad' || gamepad.id.startsWith( 'Oculus Touch' ) || gamepad.id.startsWith( 'Spatial Controller' ) ) ) { if ( j === id ) return gamepad; j ++; } } } function updateControllers() { for ( var i = 0; i < controllers.length; i ++ ) { var controller = controllers[ i ]; var gamepad = findGamepad( i ); if ( gamepad !== undefined && gamepad.pose !== undefined ) { if ( gamepad.pose === null ) return; // Pose var pose = gamepad.pose; if ( pose.hasPosition === false ) controller.position.set( 0.2, - 0.6, - 0.05 ); if ( pose.position !== null ) controller.position.fromArray( pose.position ); if ( pose.orientation !== null ) controller.quaternion.fromArray( pose.orientation ); controller.matrix.compose( controller.position, controller.quaternion, controller.scale ); controller.matrix.premultiply( standingMatrix ); controller.matrix.decompose( controller.position, controller.quaternion, controller.scale ); controller.matrixWorldNeedsUpdate = true; controller.visible = true; // Trigger var buttonId = gamepad.id === 'Daydream Controller' ? 0 : 1; if ( triggers[ i ] !== gamepad.buttons[ buttonId ].pressed ) { triggers[ i ] = gamepad.buttons[ buttonId ].pressed; if ( triggers[ i ] === true ) { controller.dispatchEvent( { type: 'selectstart' } ); } else { controller.dispatchEvent( { type: 'selectend' } ); controller.dispatchEvent( { type: 'select' } ); } } } else { controller.visible = false; } } } // this.enabled = false; this.getController = function ( id ) { var controller = controllers[ id ]; if ( controller === undefined ) { controller = new Group(); controller.matrixAutoUpdate = false; controller.visible = false; controllers[ id ] = controller; } return controller; }; this.getDevice = function () { return device; }; this.setDevice = function ( value ) { if ( value !== undefined ) device = value; animation.setContext( value ); }; this.setFramebufferScaleFactor = function ( value ) { framebufferScaleFactor = value; }; this.setFrameOfReferenceType = function ( value ) { frameOfReferenceType = value; }; this.setPoseTarget = function ( object ) { if ( object !== undefined ) poseTarget = object; }; this.getCamera = function ( camera ) { var userHeight = frameOfReferenceType === 'stage' ? 1.6 : 0; if ( device === null ) { camera.position.set( 0, userHeight, 0 ); return camera; } device.depthNear = camera.near; device.depthFar = camera.far; device.getFrameData( frameData ); // if ( frameOfReferenceType === 'stage' ) { var stageParameters = device.stageParameters; if ( stageParameters ) { standingMatrix.fromArray( stageParameters.sittingToStandingTransform ); } else { standingMatrix.makeTranslation( 0, userHeight, 0 ); } } var pose = frameData.pose; var poseObject = poseTarget !== null ? poseTarget : camera; // We want to manipulate poseObject by its position and quaternion components since users may rely on them. poseObject.matrix.copy( standingMatrix ); poseObject.matrix.decompose( poseObject.position, poseObject.quaternion, poseObject.scale ); if ( pose.orientation !== null ) { tempQuaternion.fromArray( pose.orientation ); poseObject.quaternion.multiply( tempQuaternion ); } if ( pose.position !== null ) { tempQuaternion.setFromRotationMatrix( standingMatrix ); tempPosition.fromArray( pose.position ); tempPosition.applyQuaternion( tempQuaternion ); poseObject.position.add( tempPosition ); } poseObject.updateMatrixWorld(); if ( device.isPresenting === false ) return camera; // cameraL.near = camera.near; cameraR.near = camera.near; cameraL.far = camera.far; cameraR.far = camera.far; cameraL.matrixWorldInverse.fromArray( frameData.leftViewMatrix ); cameraR.matrixWorldInverse.fromArray( frameData.rightViewMatrix ); // TODO (mrdoob) Double check this code standingMatrixInverse.getInverse( standingMatrix ); if ( frameOfReferenceType === 'stage' ) { cameraL.matrixWorldInverse.multiply( standingMatrixInverse ); cameraR.matrixWorldInverse.multiply( standingMatrixInverse ); } var parent = poseObject.parent; if ( parent !== null ) { matrixWorldInverse.getInverse( parent.matrixWorld ); cameraL.matrixWorldInverse.multiply( matrixWorldInverse ); cameraR.matrixWorldInverse.multiply( matrixWorldInverse ); } // envMap and Mirror needs camera.matrixWorld cameraL.matrixWorld.getInverse( cameraL.matrixWorldInverse ); cameraR.matrixWorld.getInverse( cameraR.matrixWorldInverse ); cameraL.projectionMatrix.fromArray( frameData.leftProjectionMatrix ); cameraR.projectionMatrix.fromArray( frameData.rightProjectionMatrix ); setProjectionFromUnion( cameraVR, cameraL, cameraR ); // var layers = device.getLayers(); if ( layers.length ) { var layer = layers[ 0 ]; if ( layer.leftBounds !== null && layer.leftBounds.length === 4 ) { cameraL.bounds.fromArray( layer.leftBounds ); } if ( layer.rightBounds !== null && layer.rightBounds.length === 4 ) { cameraR.bounds.fromArray( layer.rightBounds ); } } updateControllers(); return cameraVR; }; this.getStandingMatrix = function () { return standingMatrix; }; this.isPresenting = isPresenting; // Animation Loop var animation = new WebGLAnimation(); this.setAnimationLoop = function ( callback ) { animation.setAnimationLoop( callback ); }; this.submitFrame = function () { if ( isPresenting() ) device.submitFrame(); }; this.dispose = function () { if ( typeof window !== 'undefined' ) { window.removeEventListener( 'vrdisplaypresentchange', onVRDisplayPresentChange ); } }; } /** * @author mrdoob / http://mrdoob.com/ */ function WebXRManager( renderer ) { var gl = renderer.context; var device = null; var session = null; var framebufferScaleFactor = 1.0; var frameOfReference = null; var frameOfReferenceType = 'stage'; var pose = null; var controllers = []; var inputSources = []; function isPresenting() { return session !== null && frameOfReference !== null; } // var cameraL = new PerspectiveCamera(); cameraL.layers.enable( 1 ); cameraL.viewport = new Vector4(); var cameraR = new PerspectiveCamera(); cameraR.layers.enable( 2 ); cameraR.viewport = new Vector4(); var cameraVR = new ArrayCamera( [ cameraL, cameraR ] ); cameraVR.layers.enable( 1 ); cameraVR.layers.enable( 2 ); // this.enabled = false; this.getController = function ( id ) { var controller = controllers[ id ]; if ( controller === undefined ) { controller = new Group(); controller.matrixAutoUpdate = false; controller.visible = false; controllers[ id ] = controller; } return controller; }; this.getDevice = function () { return device; }; this.setDevice = function ( value ) { if ( value !== undefined ) device = value; if ( value instanceof XRDevice ) gl.setCompatibleXRDevice( value ); }; // function onSessionEvent( event ) { var controller = controllers[ inputSources.indexOf( event.inputSource ) ]; if ( controller ) controller.dispatchEvent( { type: event.type } ); } function onSessionEnd() { renderer.setFramebuffer( null ); animation.stop(); } this.setFramebufferScaleFactor = function ( value ) { framebufferScaleFactor = value; }; this.setFrameOfReferenceType = function ( value ) { frameOfReferenceType = value; }; this.setSession = function ( value ) { session = value; if ( session !== null ) { session.addEventListener( 'select', onSessionEvent ); session.addEventListener( 'selectstart', onSessionEvent ); session.addEventListener( 'selectend', onSessionEvent ); session.addEventListener( 'end', onSessionEnd ); session.baseLayer = new XRWebGLLayer( session, gl, { framebufferScaleFactor: framebufferScaleFactor } ); session.requestFrameOfReference( frameOfReferenceType ).then( function ( value ) { frameOfReference = value; renderer.setFramebuffer( session.baseLayer.framebuffer ); animation.setContext( session ); animation.start(); } ); // inputSources = session.getInputSources(); session.addEventListener( 'inputsourceschange', function () { inputSources = session.getInputSources(); console.log( inputSources ); for ( var i = 0; i < controllers.length; i ++ ) { var controller = controllers[ i ]; controller.userData.inputSource = inputSources[ i ]; } } ); } }; function updateCamera( camera, parent ) { if ( parent === null ) { camera.matrixWorld.copy( camera.matrix ); } else { camera.matrixWorld.multiplyMatrices( parent.matrixWorld, camera.matrix ); } camera.matrixWorldInverse.getInverse( camera.matrixWorld ); } this.getCamera = function ( camera ) { if ( isPresenting() ) { var parent = camera.parent; var cameras = cameraVR.cameras; updateCamera( cameraVR, parent ); for ( var i = 0; i < cameras.length; i ++ ) { updateCamera( cameras[ i ], parent ); } // update camera and its children camera.matrixWorld.copy( cameraVR.matrixWorld ); var children = camera.children; for ( var i = 0, l = children.length; i < l; i ++ ) { children[ i ].updateMatrixWorld( true ); } setProjectionFromUnion( cameraVR, cameraL, cameraR ); return cameraVR; } return camera; }; this.isPresenting = isPresenting; // Animation Loop var onAnimationFrameCallback = null; function onAnimationFrame( time, frame ) { pose = frame.getDevicePose( frameOfReference ); if ( pose !== null ) { var layer = session.baseLayer; var views = frame.views; for ( var i = 0; i < views.length; i ++ ) { var view = views[ i ]; var viewport = layer.getViewport( view ); var viewMatrix = pose.getViewMatrix( view ); var camera = cameraVR.cameras[ i ]; camera.matrix.fromArray( viewMatrix ).getInverse( camera.matrix ); camera.projectionMatrix.fromArray( view.projectionMatrix ); camera.viewport.set( viewport.x, viewport.y, viewport.width, viewport.height ); if ( i === 0 ) { cameraVR.matrix.copy( camera.matrix ); } } } // for ( var i = 0; i < controllers.length; i ++ ) { var controller = controllers[ i ]; var inputSource = inputSources[ i ]; if ( inputSource ) { var inputPose = frame.getInputPose( inputSource, frameOfReference ); if ( inputPose !== null ) { if ( 'targetRay' in inputPose ) { controller.matrix.elements = inputPose.targetRay.transformMatrix; } else if ( 'pointerMatrix' in inputPose ) { // DEPRECATED controller.matrix.elements = inputPose.pointerMatrix; } controller.matrix.decompose( controller.position, controller.rotation, controller.scale ); controller.visible = true; continue; } } controller.visible = false; } if ( onAnimationFrameCallback ) onAnimationFrameCallback( time ); } var animation = new WebGLAnimation(); animation.setAnimationLoop( onAnimationFrame ); this.setAnimationLoop = function ( callback ) { onAnimationFrameCallback = callback; }; this.dispose = function () {}; // DEPRECATED this.getStandingMatrix = function () { console.warn( 'THREE.WebXRManager: getStandingMatrix() is no longer needed.' ); return new THREE.Matrix4(); }; this.submitFrame = function () {}; } /** * @author supereggbert / http://www.paulbrunt.co.uk/ * @author mrdoob / http://mrdoob.com/ * @author alteredq / http://alteredqualia.com/ * @author szimek / https://github.com/szimek/ * @author tschw */ function WebGLRenderer( parameters ) { console.log( 'THREE.WebGLRenderer', REVISION ); parameters = parameters || {}; var _canvas = parameters.canvas !== undefined ? parameters.canvas : document.createElementNS( 'http://www.w3.org/1999/xhtml', 'canvas' ), _context = parameters.context !== undefined ? parameters.context : null, _alpha = parameters.alpha !== undefined ? parameters.alpha : false, _depth = parameters.depth !== undefined ? parameters.depth : true, _stencil = parameters.stencil !== undefined ? parameters.stencil : true, _antialias = parameters.antialias !== undefined ? parameters.antialias : false, _premultipliedAlpha = parameters.premultipliedAlpha !== undefined ? parameters.premultipliedAlpha : true, _preserveDrawingBuffer = parameters.preserveDrawingBuffer !== undefined ? parameters.preserveDrawingBuffer : false, _powerPreference = parameters.powerPreference !== undefined ? parameters.powerPreference : 'default'; var currentRenderList = null; var currentRenderState = null; // public properties this.domElement = _canvas; this.context = null; // clearing this.autoClear = true; this.autoClearColor = true; this.autoClearDepth = true; this.autoClearStencil = true; // scene graph this.sortObjects = true; // user-defined clipping this.clippingPlanes = []; this.localClippingEnabled = false; // physically based shading this.gammaFactor = 2.0; // for backwards compatibility this.gammaInput = false; this.gammaOutput = false; // physical lights this.physicallyCorrectLights = false; // tone mapping this.toneMapping = LinearToneMapping; this.toneMappingExposure = 1.0; this.toneMappingWhitePoint = 1.0; // morphs this.maxMorphTargets = 8; this.maxMorphNormals = 4; // internal properties var _this = this, _isContextLost = false, // internal state cache _framebuffer = null, _currentRenderTarget = null, _currentFramebuffer = null, _currentMaterialId = - 1, // geometry and program caching _currentGeometryProgram = { geometry: null, program: null, wireframe: false }, _currentCamera = null, _currentArrayCamera = null, _currentViewport = new Vector4(), _currentScissor = new Vector4(), _currentScissorTest = null, // _usedTextureUnits = 0, // _width = _canvas.width, _height = _canvas.height, _pixelRatio = 1, _viewport = new Vector4( 0, 0, _width, _height ), _scissor = new Vector4( 0, 0, _width, _height ), _scissorTest = false, // frustum _frustum = new Frustum(), // clipping _clipping = new WebGLClipping(), _clippingEnabled = false, _localClippingEnabled = false, // camera matrices cache _projScreenMatrix = new Matrix4(), _vector3 = new Vector3(); function getTargetPixelRatio() { return _currentRenderTarget === null ? _pixelRatio : 1; } // initialize var _gl; try { var contextAttributes = { alpha: _alpha, depth: _depth, stencil: _stencil, antialias: _antialias, premultipliedAlpha: _premultipliedAlpha, preserveDrawingBuffer: _preserveDrawingBuffer, powerPreference: _powerPreference }; // event listeners must be registered before WebGL context is created, see #12753 _canvas.addEventListener( 'webglcontextlost', onContextLost, false ); _canvas.addEventListener( 'webglcontextrestored', onContextRestore, false ); _gl = _context || _canvas.getContext( 'webgl', contextAttributes ) || _canvas.getContext( 'experimental-webgl', contextAttributes ); if ( _gl === null ) { if ( _canvas.getContext( 'webgl' ) !== null ) { throw new Error( 'Error creating WebGL context with your selected attributes.' ); } else { throw new Error( 'Error creating WebGL context.' ); } } // Some experimental-webgl implementations do not have getShaderPrecisionFormat if ( _gl.getShaderPrecisionFormat === undefined ) { _gl.getShaderPrecisionFormat = function () { return { 'rangeMin': 1, 'rangeMax': 1, 'precision': 1 }; }; } } catch ( error ) { console.error( 'THREE.WebGLRenderer: ' + error.message ); } var extensions, capabilities, state, info; var properties, textures, attributes, geometries, objects; var programCache, renderLists, renderStates; var background, morphtargets, bufferRenderer, indexedBufferRenderer; var utils; function initGLContext() { extensions = new WebGLExtensions( _gl ); capabilities = new WebGLCapabilities( _gl, extensions, parameters ); if ( ! capabilities.isWebGL2 ) { extensions.get( 'WEBGL_depth_texture' ); extensions.get( 'OES_texture_float' ); extensions.get( 'OES_texture_half_float' ); extensions.get( 'OES_texture_half_float_linear' ); extensions.get( 'OES_standard_derivatives' ); extensions.get( 'OES_element_index_uint' ); extensions.get( 'ANGLE_instanced_arrays' ); } extensions.get( 'OES_texture_float_linear' ); utils = new WebGLUtils( _gl, extensions, capabilities ); state = new WebGLState( _gl, extensions, utils, capabilities ); state.scissor( _currentScissor.copy( _scissor ).multiplyScalar( _pixelRatio ) ); state.viewport( _currentViewport.copy( _viewport ).multiplyScalar( _pixelRatio ) ); info = new WebGLInfo( _gl ); properties = new WebGLProperties(); textures = new WebGLTextures( _gl, extensions, state, properties, capabilities, utils, info ); attributes = new WebGLAttributes( _gl ); geometries = new WebGLGeometries( _gl, attributes, info ); objects = new WebGLObjects( geometries, info ); morphtargets = new WebGLMorphtargets( _gl ); programCache = new WebGLPrograms( _this, extensions, capabilities ); renderLists = new WebGLRenderLists(); renderStates = new WebGLRenderStates(); background = new WebGLBackground( _this, state, objects, _premultipliedAlpha ); bufferRenderer = new WebGLBufferRenderer( _gl, extensions, info, capabilities ); indexedBufferRenderer = new WebGLIndexedBufferRenderer( _gl, extensions, info, capabilities ); info.programs = programCache.programs; _this.context = _gl; _this.capabilities = capabilities; _this.extensions = extensions; _this.properties = properties; _this.renderLists = renderLists; _this.state = state; _this.info = info; } initGLContext(); // vr var vr = null; if ( typeof navigator !== 'undefined' ) { vr = ( 'xr' in navigator ) ? new WebXRManager( _this ) : new WebVRManager( _this ); } this.vr = vr; // shadow map var shadowMap = new WebGLShadowMap( _this, objects, capabilities.maxTextureSize ); this.shadowMap = shadowMap; // API this.getContext = function () { return _gl; }; this.getContextAttributes = function () { return _gl.getContextAttributes(); }; this.forceContextLoss = function () { var extension = extensions.get( 'WEBGL_lose_context' ); if ( extension ) extension.loseContext(); }; this.forceContextRestore = function () { var extension = extensions.get( 'WEBGL_lose_context' ); if ( extension ) extension.restoreContext(); }; this.getPixelRatio = function () { return _pixelRatio; }; this.setPixelRatio = function ( value ) { if ( value === undefined ) return; _pixelRatio = value; this.setSize( _width, _height, false ); }; this.getSize = function () { return { width: _width, height: _height }; }; this.setSize = function ( width, height, updateStyle ) { if ( vr.isPresenting() ) { console.warn( 'THREE.WebGLRenderer: Can\\'t change size while VR device is presenting.' ); return; } _width = width; _height = height; _canvas.width = width * _pixelRatio; _canvas.height = height * _pixelRatio; if ( updateStyle !== false ) { _canvas.style.width = width + 'px'; _canvas.style.height = height + 'px'; } this.setViewport( 0, 0, width, height ); }; this.getDrawingBufferSize = function () { return { width: _width * _pixelRatio, height: _height * _pixelRatio }; }; this.setDrawingBufferSize = function ( width, height, pixelRatio ) { _width = width; _height = height; _pixelRatio = pixelRatio; _canvas.width = width * pixelRatio; _canvas.height = height * pixelRatio; this.setViewport( 0, 0, width, height ); }; this.getCurrentViewport = function () { return _currentViewport; }; this.setViewport = function ( x, y, width, height ) { _viewport.set( x, _height - y - height, width, height ); state.viewport( _currentViewport.copy( _viewport ).multiplyScalar( _pixelRatio ) ); }; this.setScissor = function ( x, y, width, height ) { _scissor.set( x, _height - y - height, width, height ); state.scissor( _currentScissor.copy( _scissor ).multiplyScalar( _pixelRatio ) ); }; this.setScissorTest = function ( boolean ) { state.setScissorTest( _scissorTest = boolean ); }; // Clearing this.getClearColor = function () { return background.getClearColor(); }; this.setClearColor = function () { background.setClearColor.apply( background, arguments ); }; this.getClearAlpha = function () { return background.getClearAlpha(); }; this.setClearAlpha = function () { background.setClearAlpha.apply( background, arguments ); }; this.clear = function ( color, depth, stencil ) { var bits = 0; if ( color === undefined || color ) bits |= 16384; if ( depth === undefined || depth ) bits |= 256; if ( stencil === undefined || stencil ) bits |= 1024; _gl.clear( bits ); }; this.clearColor = function () { this.clear( true, false, false ); }; this.clearDepth = function () { this.clear( false, true, false ); }; this.clearStencil = function () { this.clear( false, false, true ); }; // this.dispose = function () { _canvas.removeEventListener( 'webglcontextlost', onContextLost, false ); _canvas.removeEventListener( 'webglcontextrestored', onContextRestore, false ); renderLists.dispose(); renderStates.dispose(); properties.dispose(); objects.dispose(); vr.dispose(); animation.stop(); }; // Events function onContextLost( event ) { event.preventDefault(); console.log( 'THREE.WebGLRenderer: Context Lost.' ); _isContextLost = true; } function onContextRestore( /* event */ ) { console.log( 'THREE.WebGLRenderer: Context Restored.' ); _isContextLost = false; initGLContext(); } function onMaterialDispose( event ) { var material = event.target; material.removeEventListener( 'dispose', onMaterialDispose ); deallocateMaterial( material ); } // Buffer deallocation function deallocateMaterial( material ) { releaseMaterialProgramReference( material ); properties.remove( material ); } function releaseMaterialProgramReference( material ) { var programInfo = properties.get( material ).program; material.program = undefined; if ( programInfo !== undefined ) { programCache.releaseProgram( programInfo ); } } // Buffer rendering function renderObjectImmediate( object, program ) { object.render( function ( object ) { _this.renderBufferImmediate( object, program ); } ); } this.renderBufferImmediate = function ( object, program ) { state.initAttributes(); var buffers = properties.get( object ); if ( object.hasPositions && ! buffers.position ) buffers.position = _gl.createBuffer(); if ( object.hasNormals && ! buffers.normal ) buffers.normal = _gl.createBuffer(); if ( object.hasUvs && ! buffers.uv ) buffers.uv = _gl.createBuffer(); if ( object.hasColors && ! buffers.color ) buffers.color = _gl.createBuffer(); var programAttributes = program.getAttributes(); if ( object.hasPositions ) { _gl.bindBuffer( 34962, buffers.position ); _gl.bufferData( 34962, object.positionArray, 35048 ); state.enableAttribute( programAttributes.position ); _gl.vertexAttribPointer( programAttributes.position, 3, 5126, false, 0, 0 ); } if ( object.hasNormals ) { _gl.bindBuffer( 34962, buffers.normal ); _gl.bufferData( 34962, object.normalArray, 35048 ); state.enableAttribute( programAttributes.normal ); _gl.vertexAttribPointer( programAttributes.normal, 3, 5126, false, 0, 0 ); } if ( object.hasUvs ) { _gl.bindBuffer( 34962, buffers.uv ); _gl.bufferData( 34962, object.uvArray, 35048 ); state.enableAttribute( programAttributes.uv ); _gl.vertexAttribPointer( programAttributes.uv, 2, 5126, false, 0, 0 ); } if ( object.hasColors ) { _gl.bindBuffer( 34962, buffers.color ); _gl.bufferData( 34962, object.colorArray, 35048 ); state.enableAttribute( programAttributes.color ); _gl.vertexAttribPointer( programAttributes.color, 3, 5126, false, 0, 0 ); } state.disableUnusedAttributes(); _gl.drawArrays( 4, 0, object.count ); object.count = 0; }; this.renderBufferDirect = function ( camera, fog, geometry, material, object, group ) { var frontFaceCW = ( object.isMesh && object.normalMatrix.determinant() < 0 ); state.setMaterial( material, frontFaceCW ); var program = setProgram( camera, fog, material, object ); var updateBuffers = false; if ( _currentGeometryProgram.geometry !== geometry.id || _currentGeometryProgram.program !== program.id || _currentGeometryProgram.wireframe !== ( material.wireframe === true ) ) { _currentGeometryProgram.geometry = geometry.id; _currentGeometryProgram.program = program.id; _currentGeometryProgram.wireframe = material.wireframe === true; updateBuffers = true; } if ( object.morphTargetInfluences ) { morphtargets.update( object, geometry, material, program ); updateBuffers = true; } // var index = geometry.index; var position = geometry.attributes.position; var rangeFactor = 1; if ( material.wireframe === true ) { index = geometries.getWireframeAttribute( geometry ); rangeFactor = 2; } var attribute; var renderer = bufferRenderer; if ( index !== null ) { attribute = attributes.get( index ); renderer = indexedBufferRenderer; renderer.setIndex( attribute ); } if ( updateBuffers ) { setupVertexAttributes( material, program, geometry ); if ( index !== null ) { _gl.bindBuffer( 34963, attribute.buffer ); } } // var dataCount = Infinity; if ( index !== null ) { dataCount = index.count; } else if ( position !== undefined ) { dataCount = position.count; } var rangeStart = geometry.drawRange.start * rangeFactor; var rangeCount = geometry.drawRange.count * rangeFactor; var groupStart = group !== null ? group.start * rangeFactor : 0; var groupCount = group !== null ? group.count * rangeFactor : Infinity; var drawStart = Math.max( rangeStart, groupStart ); var drawEnd = Math.min( dataCount, rangeStart + rangeCount, groupStart + groupCount ) - 1; var drawCount = Math.max( 0, drawEnd - drawStart + 1 ); if ( drawCount === 0 ) return; // if ( object.isMesh ) { if ( material.wireframe === true ) { state.setLineWidth( material.wireframeLinewidth * getTargetPixelRatio() ); renderer.setMode( 1 ); } else { switch ( object.drawMode ) { case TrianglesDrawMode: renderer.setMode( 4 ); break; case TriangleStripDrawMode: renderer.setMode( 5 ); break; case TriangleFanDrawMode: renderer.setMode( 6 ); break; } } } else if ( object.isLine ) { var lineWidth = material.linewidth; if ( lineWidth === undefined ) lineWidth = 1; // Not using Line*Material state.setLineWidth( lineWidth * getTargetPixelRatio() ); if ( object.isLineSegments ) { renderer.setMode( 1 ); } else if ( object.isLineLoop ) { renderer.setMode( 2 ); } else { renderer.setMode( 3 ); } } else if ( object.isPoints ) { renderer.setMode( 0 ); } else if ( object.isSprite ) { renderer.setMode( 4 ); } if ( geometry && geometry.isInstancedBufferGeometry ) { if ( geometry.maxInstancedCount > 0 ) { renderer.renderInstances( geometry, drawStart, drawCount ); } } else { renderer.render( drawStart, drawCount ); } }; function setupVertexAttributes( material, program, geometry ) { if ( geometry && geometry.isInstancedBufferGeometry && ! capabilities.isWebGL2 ) { if ( extensions.get( 'ANGLE_instanced_arrays' ) === null ) { console.error( 'THREE.WebGLRenderer.setupVertexAttributes: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.' ); return; } } state.initAttributes(); var geometryAttributes = geometry.attributes; var programAttributes = program.getAttributes(); var materialDefaultAttributeValues = material.defaultAttributeValues; for ( var name in programAttributes ) { var programAttribute = programAttributes[ name ]; if ( programAttribute >= 0 ) { var geometryAttribute = geometryAttributes[ name ]; if ( geometryAttribute !== undefined ) { var normalized = geometryAttribute.normalized; var size = geometryAttribute.itemSize; var attribute = attributes.get( geometryAttribute ); // TODO Attribute may not be available on context restore if ( attribute === undefined ) continue; var buffer = attribute.buffer; var type = attribute.type; var bytesPerElement = attribute.bytesPerElement; if ( geometryAttribute.isInterleavedBufferAttribute ) { var data = geometryAttribute.data; var stride = data.stride; var offset = geometryAttribute.offset; if ( data && data.isInstancedInterleavedBuffer ) { state.enableAttributeAndDivisor( programAttribute, data.meshPerAttribute ); if ( geometry.maxInstancedCount === undefined ) { geometry.maxInstancedCount = data.meshPerAttribute * data.count; } } else { state.enableAttribute( programAttribute ); } _gl.bindBuffer( 34962, buffer ); _gl.vertexAttribPointer( programAttribute, size, type, normalized, stride * bytesPerElement, offset * bytesPerElement ); } else { if ( geometryAttribute.isInstancedBufferAttribute ) { state.enableAttributeAndDivisor( programAttribute, geometryAttribute.meshPerAttribute ); if ( geometry.maxInstancedCount === undefined ) { geometry.maxInstancedCount = geometryAttribute.meshPerAttribute * geometryAttribute.count; } } else { state.enableAttribute( programAttribute ); } _gl.bindBuffer( 34962, buffer ); _gl.vertexAttribPointer( programAttribute, size, type, normalized, 0, 0 ); } } else if ( materialDefaultAttributeValues !== undefined ) { var value = materialDefaultAttributeValues[ name ]; if ( value !== undefined ) { switch ( value.length ) { case 2: _gl.vertexAttrib2fv( programAttribute, value ); break; case 3: _gl.vertexAttrib3fv( programAttribute, value ); break; case 4: _gl.vertexAttrib4fv( programAttribute, value ); break; default: _gl.vertexAttrib1fv( programAttribute, value ); } } } } } state.disableUnusedAttributes(); } // Compile this.compile = function ( scene, camera ) { currentRenderState = renderStates.get( scene, camera ); currentRenderState.init(); scene.traverse( function ( object ) { if ( object.isLight ) { currentRenderState.pushLight( object ); if ( object.castShadow ) { currentRenderState.pushShadow( object ); } } } ); currentRenderState.setupLights( camera ); scene.traverse( function ( object ) { if ( object.material ) { if ( Array.isArray( object.material ) ) { for ( var i = 0; i < object.material.length; i ++ ) { initMaterial( object.material[ i ], scene.fog, object ); } } else { initMaterial( object.material, scene.fog, object ); } } } ); }; // Animation Loop var onAnimationFrameCallback = null; function onAnimationFrame( time ) { if ( vr.isPresenting() ) return; if ( onAnimationFrameCallback ) onAnimationFrameCallback( time ); } var animation = new WebGLAnimation(); animation.setAnimationLoop( onAnimationFrame ); if ( typeof window !== 'undefined' ) animation.setContext( window ); this.setAnimationLoop = function ( callback ) { onAnimationFrameCallback = callback; vr.setAnimationLoop( callback ); animation.start(); }; // Rendering this.render = function ( scene, camera ) { var renderTarget, forceClear; if ( arguments[ 2 ] !== undefined ) { console.warn( 'THREE.WebGLRenderer.render(): the renderTarget argument has been removed. Use .setRenderTarget() instead.' ); renderTarget = arguments[ 2 ]; } if ( arguments[ 3 ] !== undefined ) { console.warn( 'THREE.WebGLRenderer.render(): the forceClear argument has been removed. Use .clear() instead.' ); forceClear = arguments[ 3 ]; } if ( ! ( camera && camera.isCamera ) ) { console.error( 'THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.' ); return; } if ( _isContextLost ) return; // reset caching for this frame _currentGeometryProgram.geometry = null; _currentGeometryProgram.program = null; _currentGeometryProgram.wireframe = false; _currentMaterialId = - 1; _currentCamera = null; // update scene graph if ( scene.autoUpdate === true ) scene.updateMatrixWorld(); // update camera matrices and frustum if ( camera.parent === null ) camera.updateMatrixWorld(); if ( vr.enabled ) { camera = vr.getCamera( camera ); } // currentRenderState = renderStates.get( scene, camera ); currentRenderState.init(); scene.onBeforeRender( _this, scene, camera, renderTarget ); _projScreenMatrix.multiplyMatrices( camera.projectionMatrix, camera.matrixWorldInverse ); _frustum.setFromMatrix( _projScreenMatrix ); _localClippingEnabled = this.localClippingEnabled; _clippingEnabled = _clipping.init( this.clippingPlanes, _localClippingEnabled, camera ); currentRenderList = renderLists.get( scene, camera ); currentRenderList.init(); projectObject( scene, camera, 0, _this.sortObjects ); if ( _this.sortObjects === true ) { currentRenderList.sort(); } // if ( _clippingEnabled ) _clipping.beginShadows(); var shadowsArray = currentRenderState.state.shadowsArray; shadowMap.render( shadowsArray, scene, camera ); currentRenderState.setupLights( camera ); if ( _clippingEnabled ) _clipping.endShadows(); // if ( this.info.autoReset ) this.info.reset(); if ( renderTarget !== undefined ) { this.setRenderTarget( renderTarget ); } // background.render( currentRenderList, scene, camera, forceClear ); // render scene var opaqueObjects = currentRenderList.opaque; var transparentObjects = currentRenderList.transparent; if ( scene.overrideMaterial ) { var overrideMaterial = scene.overrideMaterial; if ( opaqueObjects.length ) renderObjects( opaqueObjects, scene, camera, overrideMaterial ); if ( transparentObjects.length ) renderObjects( transparentObjects, scene, camera, overrideMaterial ); } else { // opaque pass (front-to-back order) if ( opaqueObjects.length ) renderObjects( opaqueObjects, scene, camera ); // transparent pass (back-to-front order) if ( transparentObjects.length ) renderObjects( transparentObjects, scene, camera ); } // if ( renderTarget ) { // Generate mipmap if we're using any kind of mipmap filtering textures.updateRenderTargetMipmap( renderTarget ); // resolve multisample renderbuffers to a single-sample texture if necessary textures.updateMultisampleRenderTarget( renderTarget ); } // Ensure depth buffer writing is enabled so it can be cleared on next render state.buffers.depth.setTest( true ); state.buffers.depth.setMask( true ); state.buffers.color.setMask( true ); state.setPolygonOffset( false ); scene.onAfterRender( _this, scene, camera ); if ( vr.enabled ) { vr.submitFrame(); } // _gl.finish(); currentRenderList = null; currentRenderState = null; }; function projectObject( object, camera, groupOrder, sortObjects ) { if ( object.visible === false ) return; var visible = object.layers.test( camera.layers ); if ( visible ) { if ( object.isGroup ) { groupOrder = object.renderOrder; } else if ( object.isLight ) { currentRenderState.pushLight( object ); if ( object.castShadow ) { currentRenderState.pushShadow( object ); } } else if ( object.isSprite ) { if ( ! object.frustumCulled || _frustum.intersectsSprite( object ) ) { if ( sortObjects ) { _vector3.setFromMatrixPosition( object.matrixWorld ) .applyMatrix4( _projScreenMatrix ); } var geometry = objects.update( object ); var material = object.material; currentRenderList.push( object, geometry, material, groupOrder, _vector3.z, null ); } } else if ( object.isImmediateRenderObject ) { if ( sortObjects ) { _vector3.setFromMatrixPosition( object.matrixWorld ) .applyMatrix4( _projScreenMatrix ); } currentRenderList.push( object, null, object.material, groupOrder, _vector3.z, null ); } else if ( object.isMesh || object.isLine || object.isPoints ) { if ( object.isSkinnedMesh ) { object.skeleton.update(); } if ( ! object.frustumCulled || _frustum.intersectsObject( object ) ) { if ( sortObjects ) { _vector3.setFromMatrixPosition( object.matrixWorld ) .applyMatrix4( _projScreenMatrix ); } var geometry = objects.update( object ); var material = object.material; if ( Array.isArray( material ) ) { var groups = geometry.groups; for ( var i = 0, l = groups.length; i < l; i ++ ) { var group = groups[ i ]; var groupMaterial = material[ group.materialIndex ]; if ( groupMaterial && groupMaterial.visible ) { currentRenderList.push( object, geometry, groupMaterial, groupOrder, _vector3.z, group ); } } } else if ( material.visible ) { currentRenderList.push( object, geometry, material, groupOrder, _vector3.z, null ); } } } } var children = object.children; for ( var i = 0, l = children.length; i < l; i ++ ) { projectObject( children[ i ], camera, groupOrder, sortObjects ); } } function renderObjects( renderList, scene, camera, overrideMaterial ) { for ( var i = 0, l = renderList.length; i < l; i ++ ) { var renderItem = renderList[ i ]; var object = renderItem.object; var geometry = renderItem.geometry; var material = overrideMaterial === undefined ? renderItem.material : overrideMaterial; var group = renderItem.group; if ( camera.isArrayCamera ) { _currentArrayCamera = camera; var cameras = camera.cameras; for ( var j = 0, jl = cameras.length; j < jl; j ++ ) { var camera2 = cameras[ j ]; if ( object.layers.test( camera2.layers ) ) { if ( 'viewport' in camera2 ) { // XR state.viewport( _currentViewport.copy( camera2.viewport ) ); } else { var bounds = camera2.bounds; var x = bounds.x * _width; var y = bounds.y * _height; var width = bounds.z * _width; var height = bounds.w * _height; state.viewport( _currentViewport.set( x, y, width, height ).multiplyScalar( _pixelRatio ) ); } currentRenderState.setupLights( camera2 ); renderObject( object, scene, camera2, geometry, material, group ); } } } else { _currentArrayCamera = null; renderObject( object, scene, camera, geometry, material, group ); } } } function renderObject( object, scene, camera, geometry, material, group ) { object.onBeforeRender( _this, scene, camera, geometry, material, group ); currentRenderState = renderStates.get( scene, _currentArrayCamera || camera ); object.modelViewMatrix.multiplyMatrices( camera.matrixWorldInverse, object.matrixWorld ); object.normalMatrix.getNormalMatrix( object.modelViewMatrix ); if ( object.isImmediateRenderObject ) { state.setMaterial( material ); var program = setProgram( camera, scene.fog, material, object ); _currentGeometryProgram.geometry = null; _currentGeometryProgram.program = null; _currentGeometryProgram.wireframe = false; renderObjectImmediate( object, program ); } else { _this.renderBufferDirect( camera, scene.fog, geometry, material, object, group ); } object.onAfterRender( _this, scene, camera, geometry, material, group ); currentRenderState = renderStates.get( scene, _currentArrayCamera || camera ); } function initMaterial( material, fog, object ) { var materialProperties = properties.get( material ); var lights = currentRenderState.state.lights; var shadowsArray = currentRenderState.state.shadowsArray; var lightsHash = materialProperties.lightsHash; var lightsStateHash = lights.state.hash; var parameters = programCache.getParameters( material, lights.state, shadowsArray, fog, _clipping.numPlanes, _clipping.numIntersection, object ); var code = programCache.getProgramCode( material, parameters ); var program = materialProperties.program; var programChange = true; if ( program === undefined ) { // new material material.addEventListener( 'dispose', onMaterialDispose ); } else if ( program.code !== code ) { // changed glsl or parameters releaseMaterialProgramReference( material ); } else if ( lightsHash.stateID !== lightsStateHash.stateID || lightsHash.directionalLength !== lightsStateHash.directionalLength || lightsHash.pointLength !== lightsStateHash.pointLength || lightsHash.spotLength !== lightsStateHash.spotLength || lightsHash.rectAreaLength !== lightsStateHash.rectAreaLength || lightsHash.hemiLength !== lightsStateHash.hemiLength || lightsHash.shadowsLength !== lightsStateHash.shadowsLength ) { lightsHash.stateID = lightsStateHash.stateID; lightsHash.directionalLength = lightsStateHash.directionalLength; lightsHash.pointLength = lightsStateHash.pointLength; lightsHash.spotLength = lightsStateHash.spotLength; lightsHash.rectAreaLength = lightsStateHash.rectAreaLength; lightsHash.hemiLength = lightsStateHash.hemiLength; lightsHash.shadowsLength = lightsStateHash.shadowsLength; programChange = false; } else if ( parameters.shaderID !== undefined ) { // same glsl and uniform list return; } else { // only rebuild uniform list programChange = false; } if ( programChange ) { if ( parameters.shaderID ) { var shader = ShaderLib[ parameters.shaderID ]; materialProperties.shader = { name: material.type, uniforms: cloneUniforms( shader.uniforms ), vertexShader: shader.vertexShader, fragmentShader: shader.fragmentShader }; } else { materialProperties.shader = { name: material.type, uniforms: material.uniforms, vertexShader: material.vertexShader, fragmentShader: material.fragmentShader }; } material.onBeforeCompile( materialProperties.shader, _this ); // Computing code again as onBeforeCompile may have changed the shaders code = programCache.getProgramCode( material, parameters ); program = programCache.acquireProgram( material, materialProperties.shader, parameters, code ); materialProperties.program = program; material.program = program; } var programAttributes = program.getAttributes(); if ( material.morphTargets ) { material.numSupportedMorphTargets = 0; for ( var i = 0; i < _this.maxMorphTargets; i ++ ) { if ( programAttributes[ 'morphTarget' + i ] >= 0 ) { material.numSupportedMorphTargets ++; } } } if ( material.morphNormals ) { material.numSupportedMorphNormals = 0; for ( var i = 0; i < _this.maxMorphNormals; i ++ ) { if ( programAttributes[ 'morphNormal' + i ] >= 0 ) { material.numSupportedMorphNormals ++; } } } var uniforms = materialProperties.shader.uniforms; if ( ! material.isShaderMaterial && ! material.isRawShaderMaterial || material.clipping === true ) { materialProperties.numClippingPlanes = _clipping.numPlanes; materialProperties.numIntersection = _clipping.numIntersection; uniforms.clippingPlanes = _clipping.uniform; } materialProperties.fog = fog; // store the light setup it was created for if ( lightsHash === undefined ) { materialProperties.lightsHash = lightsHash = {}; } lightsHash.stateID = lightsStateHash.stateID; lightsHash.directionalLength = lightsStateHash.directionalLength; lightsHash.pointLength = lightsStateHash.pointLength; lightsHash.spotLength = lightsStateHash.spotLength; lightsHash.rectAreaLength = lightsStateHash.rectAreaLength; lightsHash.hemiLength = lightsStateHash.hemiLength; lightsHash.shadowsLength = lightsStateHash.shadowsLength; if ( material.lights ) { // wire up the material to this renderer's lighting state uniforms.ambientLightColor.value = lights.state.ambient; uniforms.directionalLights.value = lights.state.directional; uniforms.spotLights.value = lights.state.spot; uniforms.rectAreaLights.value = lights.state.rectArea; uniforms.pointLights.value = lights.state.point; uniforms.hemisphereLights.value = lights.state.hemi; uniforms.directionalShadowMap.value = lights.state.directionalShadowMap; uniforms.directionalShadowMatrix.value = lights.state.directionalShadowMatrix; uniforms.spotShadowMap.value = lights.state.spotShadowMap; uniforms.spotShadowMatrix.value = lights.state.spotShadowMatrix; uniforms.pointShadowMap.value = lights.state.pointShadowMap; uniforms.pointShadowMatrix.value = lights.state.pointShadowMatrix; // TODO (abelnation): add area lights shadow info to uniforms } var progUniforms = materialProperties.program.getUniforms(), uniformsList = WebGLUniforms.seqWithValue( progUniforms.seq, uniforms ); materialProperties.uniformsList = uniformsList; } function setProgram( camera, fog, material, object ) { _usedTextureUnits = 0; var materialProperties = properties.get( material ); var lights = currentRenderState.state.lights; var lightsHash = materialProperties.lightsHash; var lightsStateHash = lights.state.hash; if ( _clippingEnabled ) { if ( _localClippingEnabled || camera !== _currentCamera ) { var useCache = camera === _currentCamera && material.id === _currentMaterialId; // we might want to call this function with some ClippingGroup // object instead of the material, once it becomes feasible // (#8465, #8379) _clipping.setState( material.clippingPlanes, material.clipIntersection, material.clipShadows, camera, materialProperties, useCache ); } } if ( material.needsUpdate === false ) { if ( materialProperties.program === undefined ) { material.needsUpdate = true; } else if ( material.fog && materialProperties.fog !== fog ) { material.needsUpdate = true; } else if ( material.lights && ( lightsHash.stateID !== lightsStateHash.stateID || lightsHash.directionalLength !== lightsStateHash.directionalLength || lightsHash.pointLength !== lightsStateHash.pointLength || lightsHash.spotLength !== lightsStateHash.spotLength || lightsHash.rectAreaLength !== lightsStateHash.rectAreaLength || lightsHash.hemiLength !== lightsStateHash.hemiLength || lightsHash.shadowsLength !== lightsStateHash.shadowsLength ) ) { material.needsUpdate = true; } else if ( materialProperties.numClippingPlanes !== undefined && ( materialProperties.numClippingPlanes !== _clipping.numPlanes || materialProperties.numIntersection !== _clipping.numIntersection ) ) { material.needsUpdate = true; } } if ( material.needsUpdate ) { initMaterial( material, fog, object ); material.needsUpdate = false; } var refreshProgram = false; var refreshMaterial = false; var refreshLights = false; var program = materialProperties.program, p_uniforms = program.getUniforms(), m_uniforms = materialProperties.shader.uniforms; if ( state.useProgram( program.program ) ) { refreshProgram = true; refreshMaterial = true; refreshLights = true; } if ( material.id !== _currentMaterialId ) { _currentMaterialId = material.id; refreshMaterial = true; } if ( refreshProgram || _currentCamera !== camera ) { p_uniforms.setValue( _gl, 'projectionMatrix', camera.projectionMatrix ); if ( capabilities.logarithmicDepthBuffer ) { p_uniforms.setValue( _gl, 'logDepthBufFC', 2.0 / ( Math.log( camera.far + 1.0 ) / Math.LN2 ) ); } if ( _currentCamera !== camera ) { _currentCamera = camera; // lighting uniforms depend on the camera so enforce an update // now, in case this material supports lights - or later, when // the next material that does gets activated: refreshMaterial = true; // set to true on material change refreshLights = true; // remains set until update done } // load material specific uniforms // (shader material also gets them for the sake of genericity) if ( material.isShaderMaterial || material.isMeshPhongMaterial || material.isMeshStandardMaterial || material.envMap ) { var uCamPos = p_uniforms.map.cameraPosition; if ( uCamPos !== undefined ) { uCamPos.setValue( _gl, _vector3.setFromMatrixPosition( camera.matrixWorld ) ); } } if ( material.isMeshPhongMaterial || material.isMeshLambertMaterial || material.isMeshBasicMaterial || material.isMeshStandardMaterial || material.isShaderMaterial || material.skinning ) { p_uniforms.setValue( _gl, 'viewMatrix', camera.matrixWorldInverse ); } } // skinning uniforms must be set even if material didn't change // auto-setting of texture unit for bone texture must go before other textures // not sure why, but otherwise weird things happen if ( material.skinning ) { p_uniforms.setOptional( _gl, object, 'bindMatrix' ); p_uniforms.setOptional( _gl, object, 'bindMatrixInverse' ); var skeleton = object.skeleton; if ( skeleton ) { var bones = skeleton.bones; if ( capabilities.floatVertexTextures ) { if ( skeleton.boneTexture === undefined ) { // layout (1 matrix = 4 pixels) // RGBA RGBA RGBA RGBA (=> column1, column2, column3, column4) // with 8x8 pixel texture max 16 bones * 4 pixels = (8 * 8) // 16x16 pixel texture max 64 bones * 4 pixels = (16 * 16) // 32x32 pixel texture max 256 bones * 4 pixels = (32 * 32) // 64x64 pixel texture max 1024 bones * 4 pixels = (64 * 64) var size = Math.sqrt( bones.length * 4 ); // 4 pixels needed for 1 matrix size = _Math.ceilPowerOfTwo( size ); size = Math.max( size, 4 ); var boneMatrices = new Float32Array( size * size * 4 ); // 4 floats per RGBA pixel boneMatrices.set( skeleton.boneMatrices ); // copy current values var boneTexture = new DataTexture( boneMatrices, size, size, RGBAFormat, FloatType ); boneTexture.needsUpdate = true; skeleton.boneMatrices = boneMatrices; skeleton.boneTexture = boneTexture; skeleton.boneTextureSize = size; } p_uniforms.setValue( _gl, 'boneTexture', skeleton.boneTexture ); p_uniforms.setValue( _gl, 'boneTextureSize', skeleton.boneTextureSize ); } else { p_uniforms.setOptional( _gl, skeleton, 'boneMatrices' ); } } } if ( refreshMaterial ) { p_uniforms.setValue( _gl, 'toneMappingExposure', _this.toneMappingExposure ); p_uniforms.setValue( _gl, 'toneMappingWhitePoint', _this.toneMappingWhitePoint ); if ( material.lights ) { // the current material requires lighting info // note: all lighting uniforms are always set correctly // they simply reference the renderer's state for their // values // // use the current material's .needsUpdate flags to set // the GL state when required markUniformsLightsNeedsUpdate( m_uniforms, refreshLights ); } // refresh uniforms common to several materials if ( fog && material.fog ) { refreshUniformsFog( m_uniforms, fog ); } if ( material.isMeshBasicMaterial ) { refreshUniformsCommon( m_uniforms, material ); } else if ( material.isMeshLambertMaterial ) { refreshUniformsCommon( m_uniforms, material ); refreshUniformsLambert( m_uniforms, material ); } else if ( material.isMeshPhongMaterial ) { refreshUniformsCommon( m_uniforms, material ); if ( material.isMeshToonMaterial ) { refreshUniformsToon( m_uniforms, material ); } else { refreshUniformsPhong( m_uniforms, material ); } } else if ( material.isMeshStandardMaterial ) { refreshUniformsCommon( m_uniforms, material ); if ( material.isMeshPhysicalMaterial ) { refreshUniformsPhysical( m_uniforms, material ); } else { refreshUniformsStandard( m_uniforms, material ); } } else if ( material.isMeshMatcapMaterial ) { refreshUniformsCommon( m_uniforms, material ); refreshUniformsMatcap( m_uniforms, material ); } else if ( material.isMeshDepthMaterial ) { refreshUniformsCommon( m_uniforms, material ); refreshUniformsDepth( m_uniforms, material ); } else if ( material.isMeshDistanceMaterial ) { refreshUniformsCommon( m_uniforms, material ); refreshUniformsDistance( m_uniforms, material ); } else if ( material.isMeshNormalMaterial ) { refreshUniformsCommon( m_uniforms, material ); refreshUniformsNormal( m_uniforms, material ); } else if ( material.isLineBasicMaterial ) { refreshUniformsLine( m_uniforms, material ); if ( material.isLineDashedMaterial ) { refreshUniformsDash( m_uniforms, material ); } } else if ( material.isPointsMaterial ) { refreshUniformsPoints( m_uniforms, material ); } else if ( material.isSpriteMaterial ) { refreshUniformsSprites( m_uniforms, material ); } else if ( material.isShadowMaterial ) { m_uniforms.color.value = material.color; m_uniforms.opacity.value = material.opacity; } // RectAreaLight Texture // TODO (mrdoob): Find a nicer implementation if ( m_uniforms.ltc_1 !== undefined ) m_uniforms.ltc_1.value = UniformsLib.LTC_1; if ( m_uniforms.ltc_2 !== undefined ) m_uniforms.ltc_2.value = UniformsLib.LTC_2; WebGLUniforms.upload( _gl, materialProperties.uniformsList, m_uniforms, _this ); } if ( material.isShaderMaterial && material.uniformsNeedUpdate === true ) { WebGLUniforms.upload( _gl, materialProperties.uniformsList, m_uniforms, _this ); material.uniformsNeedUpdate = false; } if ( material.isSpriteMaterial ) { p_uniforms.setValue( _gl, 'center', object.center ); } // common matrices p_uniforms.setValue( _gl, 'modelViewMatrix', object.modelViewMatrix ); p_uniforms.setValue( _gl, 'normalMatrix', object.normalMatrix ); p_uniforms.setValue( _gl, 'modelMatrix', object.matrixWorld ); return program; } // Uniforms (refresh uniforms objects) function refreshUniformsCommon( uniforms, material ) { uniforms.opacity.value = material.opacity; if ( material.color ) { uniforms.diffuse.value = material.color; } if ( material.emissive ) { uniforms.emissive.value.copy( material.emissive ).multiplyScalar( material.emissiveIntensity ); } if ( material.map ) { uniforms.map.value = material.map; } if ( material.alphaMap ) { uniforms.alphaMap.value = material.alphaMap; } if ( material.specularMap ) { uniforms.specularMap.value = material.specularMap; } if ( material.envMap ) { uniforms.envMap.value = material.envMap; // don't flip CubeTexture envMaps, flip everything else: // WebGLRenderTargetCube will be flipped for backwards compatibility // WebGLRenderTargetCube.texture will be flipped because it's a Texture and NOT a CubeTexture // this check must be handled differently, or removed entirely, if WebGLRenderTargetCube uses a CubeTexture in the future uniforms.flipEnvMap.value = material.envMap.isCubeTexture ? - 1 : 1; uniforms.reflectivity.value = material.reflectivity; uniforms.refractionRatio.value = material.refractionRatio; uniforms.maxMipLevel.value = properties.get( material.envMap ).__maxMipLevel; } if ( material.lightMap ) { uniforms.lightMap.value = material.lightMap; uniforms.lightMapIntensity.value = material.lightMapIntensity; } if ( material.aoMap ) { uniforms.aoMap.value = material.aoMap; uniforms.aoMapIntensity.value = material.aoMapIntensity; } // uv repeat and offset setting priorities // 1. color map // 2. specular map // 3. normal map // 4. bump map // 5. alpha map // 6. emissive map var uvScaleMap; if ( material.map ) { uvScaleMap = material.map; } else if ( material.specularMap ) { uvScaleMap = material.specularMap; } else if ( material.displacementMap ) { uvScaleMap = material.displacementMap; } else if ( material.normalMap ) { uvScaleMap = material.normalMap; } else if ( material.bumpMap ) { uvScaleMap = material.bumpMap; } else if ( material.roughnessMap ) { uvScaleMap = material.roughnessMap; } else if ( material.metalnessMap ) { uvScaleMap = material.metalnessMap; } else if ( material.alphaMap ) { uvScaleMap = material.alphaMap; } else if ( material.emissiveMap ) { uvScaleMap = material.emissiveMap; } if ( uvScaleMap !== undefined ) { // backwards compatibility if ( uvScaleMap.isWebGLRenderTarget ) { uvScaleMap = uvScaleMap.texture; } if ( uvScaleMap.matrixAutoUpdate === true ) { uvScaleMap.updateMatrix(); } uniforms.uvTransform.value.copy( uvScaleMap.matrix ); } } function refreshUniformsLine( uniforms, material ) { uniforms.diffuse.value = material.color; uniforms.opacity.value = material.opacity; } function refreshUniformsDash( uniforms, material ) { uniforms.dashSize.value = material.dashSize; uniforms.totalSize.value = material.dashSize + material.gapSize; uniforms.scale.value = material.scale; } function refreshUniformsPoints( uniforms, material ) { uniforms.diffuse.value = material.color; uniforms.opacity.value = material.opacity; uniforms.size.value = material.size * _pixelRatio; uniforms.scale.value = _height * 0.5; uniforms.map.value = material.map; if ( material.map !== null ) { if ( material.map.matrixAutoUpdate === true ) { material.map.updateMatrix(); } uniforms.uvTransform.value.copy( material.map.matrix ); } } function refreshUniformsSprites( uniforms, material ) { uniforms.diffuse.value = material.color; uniforms.opacity.value = material.opacity; uniforms.rotation.value = material.rotation; uniforms.map.value = material.map; if ( material.map !== null ) { if ( material.map.matrixAutoUpdate === true ) { material.map.updateMatrix(); } uniforms.uvTransform.value.copy( material.map.matrix ); } } function refreshUniformsFog( uniforms, fog ) { uniforms.fogColor.value = fog.color; if ( fog.isFog ) { uniforms.fogNear.value = fog.near; uniforms.fogFar.value = fog.far; } else if ( fog.isFogExp2 ) { uniforms.fogDensity.value = fog.density; } } function refreshUniformsLambert( uniforms, material ) { if ( material.emissiveMap ) { uniforms.emissiveMap.value = material.emissiveMap; } } function refreshUniformsPhong( uniforms, material ) { uniforms.specular.value = material.specular; uniforms.shininess.value = Math.max( material.shininess, 1e-4 ); // to prevent pow( 0.0, 0.0 ) if ( material.emissiveMap ) { uniforms.emissiveMap.value = material.emissiveMap; } if ( material.bumpMap ) { uniforms.bumpMap.value = material.bumpMap; uniforms.bumpScale.value = material.bumpScale; if ( material.side === BackSide ) uniforms.bumpScale.value *= - 1; } if ( material.normalMap ) { uniforms.normalMap.value = material.normalMap; uniforms.normalScale.value.copy( material.normalScale ); if ( material.side === BackSide ) uniforms.normalScale.value.negate(); } if ( material.displacementMap ) { uniforms.displacementMap.value = material.displacementMap; uniforms.displacementScale.value = material.displacementScale; uniforms.displacementBias.value = material.displacementBias; } } function refreshUniformsToon( uniforms, material ) { refreshUniformsPhong( uniforms, material ); if ( material.gradientMap ) { uniforms.gradientMap.value = material.gradientMap; } } function refreshUniformsStandard( uniforms, material ) { uniforms.roughness.value = material.roughness; uniforms.metalness.value = material.metalness; if ( material.roughnessMap ) { uniforms.roughnessMap.value = material.roughnessMap; } if ( material.metalnessMap ) { uniforms.metalnessMap.value = material.metalnessMap; } if ( material.emissiveMap ) { uniforms.emissiveMap.value = material.emissiveMap; } if ( material.bumpMap ) { uniforms.bumpMap.value = material.bumpMap; uniforms.bumpScale.value = material.bumpScale; if ( material.side === BackSide ) uniforms.bumpScale.value *= - 1; } if ( material.normalMap ) { uniforms.normalMap.value = material.normalMap; uniforms.normalScale.value.copy( material.normalScale ); if ( material.side === BackSide ) uniforms.normalScale.value.negate(); } if ( material.displacementMap ) { uniforms.displacementMap.value = material.displacementMap; uniforms.displacementScale.value = material.displacementScale; uniforms.displacementBias.value = material.displacementBias; } if ( material.envMap ) { //uniforms.envMap.value = material.envMap; // part of uniforms common uniforms.envMapIntensity.value = material.envMapIntensity; } } function refreshUniformsPhysical( uniforms, material ) { refreshUniformsStandard( uniforms, material ); uniforms.reflectivity.value = material.reflectivity; // also part of uniforms common uniforms.clearCoat.value = material.clearCoat; uniforms.clearCoatRoughness.value = material.clearCoatRoughness; } function refreshUniformsMatcap( uniforms, material ) { if ( material.matcap ) { uniforms.matcap.value = material.matcap; } if ( material.bumpMap ) { uniforms.bumpMap.value = material.bumpMap; uniforms.bumpScale.value = material.bumpScale; if ( material.side === BackSide ) uniforms.bumpScale.value *= - 1; } if ( material.normalMap ) { uniforms.normalMap.value = material.normalMap; uniforms.normalScale.value.copy( material.normalScale ); if ( material.side === BackSide ) uniforms.normalScale.value.negate(); } if ( material.displacementMap ) { uniforms.displacementMap.value = material.displacementMap; uniforms.displacementScale.value = material.displacementScale; uniforms.displacementBias.value = material.displacementBias; } } function refreshUniformsDepth( uniforms, material ) { if ( material.displacementMap ) { uniforms.displacementMap.value = material.displacementMap; uniforms.displacementScale.value = material.displacementScale; uniforms.displacementBias.value = material.displacementBias; } } function refreshUniformsDistance( uniforms, material ) { if ( material.displacementMap ) { uniforms.displacementMap.value = material.displacementMap; uniforms.displacementScale.value = material.displacementScale; uniforms.displacementBias.value = material.displacementBias; } uniforms.referencePosition.value.copy( material.referencePosition ); uniforms.nearDistance.value = material.nearDistance; uniforms.farDistance.value = material.farDistance; } function refreshUniformsNormal( uniforms, material ) { if ( material.bumpMap ) { uniforms.bumpMap.value = material.bumpMap; uniforms.bumpScale.value = material.bumpScale; if ( material.side === BackSide ) uniforms.bumpScale.value *= - 1; } if ( material.normalMap ) { uniforms.normalMap.value = material.normalMap; uniforms.normalScale.value.copy( material.normalScale ); if ( material.side === BackSide ) uniforms.normalScale.value.negate(); } if ( material.displacementMap ) { uniforms.displacementMap.value = material.displacementMap; uniforms.displacementScale.value = material.displacementScale; uniforms.displacementBias.value = material.displacementBias; } } // If uniforms are marked as clean, they don't need to be loaded to the GPU. function markUniformsLightsNeedsUpdate( uniforms, value ) { uniforms.ambientLightColor.needsUpdate = value; uniforms.directionalLights.needsUpdate = value; uniforms.pointLights.needsUpdate = value; uniforms.spotLights.needsUpdate = value; uniforms.rectAreaLights.needsUpdate = value; uniforms.hemisphereLights.needsUpdate = value; } // Textures function allocTextureUnit() { var textureUnit = _usedTextureUnits; if ( textureUnit >= capabilities.maxTextures ) { console.warn( 'THREE.WebGLRenderer: Trying to use ' + textureUnit + ' texture units while this GPU supports only ' + capabilities.maxTextures ); } _usedTextureUnits += 1; return textureUnit; } this.allocTextureUnit = allocTextureUnit; // this.setTexture2D = setTexture2D; this.setTexture2D = ( function () { var warned = false; // backwards compatibility: peel texture.texture return function setTexture2D( texture, slot ) { if ( texture && texture.isWebGLRenderTarget ) { if ( ! warned ) { console.warn( \"THREE.WebGLRenderer.setTexture2D: don't use render targets as textures. Use their .texture property instead.\" ); warned = true; } texture = texture.texture; } textures.setTexture2D( texture, slot ); }; }() ); this.setTexture3D = ( function () { // backwards compatibility: peel texture.texture return function setTexture3D( texture, slot ) { textures.setTexture3D( texture, slot ); }; }() ); this.setTexture = ( function () { var warned = false; return function setTexture( texture, slot ) { if ( ! warned ) { console.warn( \"THREE.WebGLRenderer: .setTexture is deprecated, use setTexture2D instead.\" ); warned = true; } textures.setTexture2D( texture, slot ); }; }() ); this.setTextureCube = ( function () { var warned = false; return function setTextureCube( texture, slot ) { // backwards compatibility: peel texture.texture if ( texture && texture.isWebGLRenderTargetCube ) { if ( ! warned ) { console.warn( \"THREE.WebGLRenderer.setTextureCube: don't use cube render targets as textures. Use their .texture property instead.\" ); warned = true; } texture = texture.texture; } // currently relying on the fact that WebGLRenderTargetCube.texture is a Texture and NOT a CubeTexture // TODO: unify these code paths if ( ( texture && texture.isCubeTexture ) || ( Array.isArray( texture.image ) && texture.image.length === 6 ) ) { // CompressedTexture can have Array in image :/ // this function alone should take care of cube textures textures.setTextureCube( texture, slot ); } else { // assumed: texture property of THREE.WebGLRenderTargetCube textures.setTextureCubeDynamic( texture, slot ); } }; }() ); // this.setFramebuffer = function ( value ) { _framebuffer = value; }; this.getRenderTarget = function () { return _currentRenderTarget; }; this.setRenderTarget = function ( renderTarget ) { _currentRenderTarget = renderTarget; if ( renderTarget && properties.get( renderTarget ).__webglFramebuffer === undefined ) { textures.setupRenderTarget( renderTarget ); } var framebuffer = _framebuffer; var isCube = false; if ( renderTarget ) { var __webglFramebuffer = properties.get( renderTarget ).__webglFramebuffer; if ( renderTarget.isWebGLRenderTargetCube ) { framebuffer = __webglFramebuffer[ renderTarget.activeCubeFace ]; isCube = true; } else if ( renderTarget.isWebGLMultisampleRenderTarget ) { framebuffer = properties.get( renderTarget ).__webglMultisampledFramebuffer; } else { framebuffer = __webglFramebuffer; } _currentViewport.copy( renderTarget.viewport ); _currentScissor.copy( renderTarget.scissor ); _currentScissorTest = renderTarget.scissorTest; } else { _currentViewport.copy( _viewport ).multiplyScalar( _pixelRatio ); _currentScissor.copy( _scissor ).multiplyScalar( _pixelRatio ); _currentScissorTest = _scissorTest; } if ( _currentFramebuffer !== framebuffer ) { _gl.bindFramebuffer( 36160, framebuffer ); _currentFramebuffer = framebuffer; } state.viewport( _currentViewport ); state.scissor( _currentScissor ); state.setScissorTest( _currentScissorTest ); if ( isCube ) { var textureProperties = properties.get( renderTarget.texture ); _gl.framebufferTexture2D( 36160, 36064, 34069 + renderTarget.activeCubeFace, textureProperties.__webglTexture, renderTarget.activeMipMapLevel ); } }; this.readRenderTargetPixels = function ( renderTarget, x, y, width, height, buffer ) { if ( ! ( renderTarget && renderTarget.isWebGLRenderTarget ) ) { console.error( 'THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.' ); return; } var framebuffer = properties.get( renderTarget ).__webglFramebuffer; if ( framebuffer ) { var restore = false; if ( framebuffer !== _currentFramebuffer ) { _gl.bindFramebuffer( 36160, framebuffer ); restore = true; } try { var texture = renderTarget.texture; var textureFormat = texture.format; var textureType = texture.type; if ( textureFormat !== RGBAFormat && utils.convert( textureFormat ) !== _gl.getParameter( 35739 ) ) { console.error( 'THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.' ); return; } if ( textureType !== UnsignedByteType && utils.convert( textureType ) !== _gl.getParameter( 35738 ) && // IE11, Edge and Chrome Mac < 52 (#9513) ! ( textureType === FloatType && ( capabilities.isWebGL2 || extensions.get( 'OES_texture_float' ) || extensions.get( 'WEBGL_color_buffer_float' ) ) ) && // Chrome Mac >= 52 and Firefox ! ( textureType === HalfFloatType && ( capabilities.isWebGL2 ? extensions.get( 'EXT_color_buffer_float' ) : extensions.get( 'EXT_color_buffer_half_float' ) ) ) ) { console.error( 'THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.' ); return; } if ( _gl.checkFramebufferStatus( 36160 ) === 36053 ) { // the following if statement ensures valid read requests (no out-of-bounds pixels, see #8604) if ( ( x >= 0 && x = 0 && y 1 ) { v1.setFromMatrixPosition( camera.matrixWorld ); v2.setFromMatrixPosition( this.matrixWorld ); var distance = v1.distanceTo( v2 ); levels[ 0 ].object.visible = true; for ( var i = 1, l = levels.length; i < l; i ++ ) { if ( distance >= levels[ i ].distance ) { levels[ i - 1 ].object.visible = false; levels[ i ].object.visible = true; } else { break; } } for ( ; i < l; i ++ ) { levels[ i ].object.visible = false; } } }; }(), toJSON: function ( meta ) { var data = Object3D.prototype.toJSON.call( this, meta ); data.object.levels = []; var levels = this.levels; for ( var i = 0, l = levels.length; i < l; i ++ ) { var level = levels[ i ]; data.object.levels.push( { object: level.object.uuid, distance: level.distance } ); } return data; } } ); /** * @author mikael emtinger / http://gomo.se/ * @author alteredq / http://alteredqualia.com/ * @author ikerr / http://verold.com */ function SkinnedMesh( geometry, material ) { if ( geometry && geometry.isGeometry ) { console.error( 'THREE.SkinnedMesh no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.' ); } Mesh.call( this, geometry, material ); this.type = 'SkinnedMesh'; this.bindMode = 'attached'; this.bindMatrix = new Matrix4(); this.bindMatrixInverse = new Matrix4(); } SkinnedMesh.prototype = Object.assign( Object.create( Mesh.prototype ), { constructor: SkinnedMesh, isSkinnedMesh: true, bind: function ( skeleton, bindMatrix ) { this.skeleton = skeleton; if ( bindMatrix === undefined ) { this.updateMatrixWorld( true ); this.skeleton.calculateInverses(); bindMatrix = this.matrixWorld; } this.bindMatrix.copy( bindMatrix ); this.bindMatrixInverse.getInverse( bindMatrix ); }, pose: function () { this.skeleton.pose(); }, normalizeSkinWeights: function () { var vector = new Vector4(); var skinWeight = this.geometry.attributes.skinWeight; for ( var i = 0, l = skinWeight.count; i < l; i ++ ) { vector.x = skinWeight.getX( i ); vector.y = skinWeight.getY( i ); vector.z = skinWeight.getZ( i ); vector.w = skinWeight.getW( i ); var scale = 1.0 / vector.manhattanLength(); if ( scale !== Infinity ) { vector.multiplyScalar( scale ); } else { vector.set( 1, 0, 0, 0 ); // do something reasonable } skinWeight.setXYZW( i, vector.x, vector.y, vector.z, vector.w ); } }, updateMatrixWorld: function ( force ) { Mesh.prototype.updateMatrixWorld.call( this, force ); if ( this.bindMode === 'attached' ) { this.bindMatrixInverse.getInverse( this.matrixWorld ); } else if ( this.bindMode === 'detached' ) { this.bindMatrixInverse.getInverse( this.bindMatrix ); } else { console.warn( 'THREE.SkinnedMesh: Unrecognized bindMode: ' + this.bindMode ); } }, clone: function () { return new this.constructor( this.geometry, this.material ).copy( this ); } } ); /** * @author mikael emtinger / http://gomo.se/ * @author alteredq / http://alteredqualia.com/ * @author michael guerrero / http://realitymeltdown.com * @author ikerr / http://verold.com */ function Skeleton( bones, boneInverses ) { // copy the bone array bones = bones || []; this.bones = bones.slice( 0 ); this.boneMatrices = new Float32Array( this.bones.length * 16 ); // use the supplied bone inverses or calculate the inverses if ( boneInverses === undefined ) { this.calculateInverses(); } else { if ( this.bones.length === boneInverses.length ) { this.boneInverses = boneInverses.slice( 0 ); } else { console.warn( 'THREE.Skeleton boneInverses is the wrong length.' ); this.boneInverses = []; for ( var i = 0, il = this.bones.length; i < il; i ++ ) { this.boneInverses.push( new Matrix4() ); } } } } Object.assign( Skeleton.prototype, { calculateInverses: function () { this.boneInverses = []; for ( var i = 0, il = this.bones.length; i < il; i ++ ) { var inverse = new Matrix4(); if ( this.bones[ i ] ) { inverse.getInverse( this.bones[ i ].matrixWorld ); } this.boneInverses.push( inverse ); } }, pose: function () { var bone, i, il; // recover the bind-time world matrices for ( i = 0, il = this.bones.length; i < il; i ++ ) { bone = this.bones[ i ]; if ( bone ) { bone.matrixWorld.getInverse( this.boneInverses[ i ] ); } } // compute the local matrices, positions, rotations and scales for ( i = 0, il = this.bones.length; i < il; i ++ ) { bone = this.bones[ i ]; if ( bone ) { if ( bone.parent && bone.parent.isBone ) { bone.matrix.getInverse( bone.parent.matrixWorld ); bone.matrix.multiply( bone.matrixWorld ); } else { bone.matrix.copy( bone.matrixWorld ); } bone.matrix.decompose( bone.position, bone.quaternion, bone.scale ); } } }, update: ( function () { var offsetMatrix = new Matrix4(); var identityMatrix = new Matrix4(); return function update() { var bones = this.bones; var boneInverses = this.boneInverses; var boneMatrices = this.boneMatrices; var boneTexture = this.boneTexture; // flatten bone matrices to array for ( var i = 0, il = bones.length; i < il; i ++ ) { // compute the offset between the current and the original transform var matrix = bones[ i ] ? bones[ i ].matrixWorld : identityMatrix; offsetMatrix.multiplyMatrices( matrix, boneInverses[ i ] ); offsetMatrix.toArray( boneMatrices, i * 16 ); } if ( boneTexture !== undefined ) { boneTexture.needsUpdate = true; } }; } )(), clone: function () { return new Skeleton( this.bones, this.boneInverses ); }, getBoneByName: function ( name ) { for ( var i = 0, il = this.bones.length; i < il; i ++ ) { var bone = this.bones[ i ]; if ( bone.name === name ) { return bone; } } return undefined; } } ); /** * @author mikael emtinger / http://gomo.se/ * @author alteredq / http://alteredqualia.com/ * @author ikerr / http://verold.com */ function Bone() { Object3D.call( this ); this.type = 'Bone'; } Bone.prototype = Object.assign( Object.create( Object3D.prototype ), { constructor: Bone, isBone: true } ); /** * @author mrdoob / http://mrdoob.com/ * @author alteredq / http://alteredqualia.com/ * * parameters = { * color: , * opacity: , * * linewidth: , * linecap: \"round\", * linejoin: \"round\" * } */ function LineBasicMaterial( parameters ) { Material.call( this ); this.type = 'LineBasicMaterial'; this.color = new Color( 0xffffff ); this.linewidth = 1; this.linecap = 'round'; this.linejoin = 'round'; this.lights = false; this.setValues( parameters ); } LineBasicMaterial.prototype = Object.create( Material.prototype ); LineBasicMaterial.prototype.constructor = LineBasicMaterial; LineBasicMaterial.prototype.isLineBasicMaterial = true; LineBasicMaterial.prototype.copy = function ( source ) { Material.prototype.copy.call( this, source ); this.color.copy( source.color ); this.linewidth = source.linewidth; this.linecap = source.linecap; this.linejoin = source.linejoin; return this; }; /** * @author mrdoob / http://mrdoob.com/ */ function Line( geometry, material, mode ) { if ( mode === 1 ) { console.error( 'THREE.Line: parameter THREE.LinePieces no longer supported. Use THREE.LineSegments instead.' ); } Object3D.call( this ); this.type = 'Line'; this.geometry = geometry !== undefined ? geometry : new BufferGeometry(); this.material = material !== undefined ? material : new LineBasicMaterial( { color: Math.random() * 0xffffff } ); } Line.prototype = Object.assign( Object.create( Object3D.prototype ), { constructor: Line, isLine: true, computeLineDistances: ( function () { var start = new Vector3(); var end = new Vector3(); return function computeLineDistances() { var geometry = this.geometry; if ( geometry.isBufferGeometry ) { // we assume non-indexed geometry if ( geometry.index === null ) { var positionAttribute = geometry.attributes.position; var lineDistances = [ 0 ]; for ( var i = 1, l = positionAttribute.count; i < l; i ++ ) { start.fromBufferAttribute( positionAttribute, i - 1 ); end.fromBufferAttribute( positionAttribute, i ); lineDistances[ i ] = lineDistances[ i - 1 ]; lineDistances[ i ] += start.distanceTo( end ); } geometry.addAttribute( 'lineDistance', new Float32BufferAttribute( lineDistances, 1 ) ); } else { console.warn( 'THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.' ); } } else if ( geometry.isGeometry ) { var vertices = geometry.vertices; var lineDistances = geometry.lineDistances; lineDistances[ 0 ] = 0; for ( var i = 1, l = vertices.length; i < l; i ++ ) { lineDistances[ i ] = lineDistances[ i - 1 ]; lineDistances[ i ] += vertices[ i - 1 ].distanceTo( vertices[ i ] ); } } return this; }; }() ), raycast: ( function () { var inverseMatrix = new Matrix4(); var ray = new Ray(); var sphere = new Sphere(); return function raycast( raycaster, intersects ) { var precision = raycaster.linePrecision; var geometry = this.geometry; var matrixWorld = this.matrixWorld; // Checking boundingSphere distance to ray if ( geometry.boundingSphere === null ) geometry.computeBoundingSphere(); sphere.copy( geometry.boundingSphere ); sphere.applyMatrix4( matrixWorld ); sphere.radius += precision; if ( raycaster.ray.intersectsSphere( sphere ) === false ) return; // inverseMatrix.getInverse( matrixWorld ); ray.copy( raycaster.ray ).applyMatrix4( inverseMatrix ); var localPrecision = precision / ( ( this.scale.x + this.scale.y + this.scale.z ) / 3 ); var localPrecisionSq = localPrecision * localPrecision; var vStart = new Vector3(); var vEnd = new Vector3(); var interSegment = new Vector3(); var interRay = new Vector3(); var step = ( this && this.isLineSegments ) ? 2 : 1; if ( geometry.isBufferGeometry ) { var index = geometry.index; var attributes = geometry.attributes; var positions = attributes.position.array; if ( index !== null ) { var indices = index.array; for ( var i = 0, l = indices.length - 1; i < l; i += step ) { var a = indices[ i ]; var b = indices[ i + 1 ]; vStart.fromArray( positions, a * 3 ); vEnd.fromArray( positions, b * 3 ); var distSq = ray.distanceSqToSegment( vStart, vEnd, interRay, interSegment ); if ( distSq > localPrecisionSq ) continue; interRay.applyMatrix4( this.matrixWorld ); //Move back to world space for distance calculation var distance = raycaster.ray.origin.distanceTo( interRay ); if ( distance < raycaster.near || distance > raycaster.far ) continue; intersects.push( { distance: distance, // What do we want? intersection point on the ray or on the segment?? // point: raycaster.ray.at( distance ), point: interSegment.clone().applyMatrix4( this.matrixWorld ), index: i, face: null, faceIndex: null, object: this } ); } } else { for ( var i = 0, l = positions.length / 3 - 1; i < l; i += step ) { vStart.fromArray( positions, 3 * i ); vEnd.fromArray( positions, 3 * i + 3 ); var distSq = ray.distanceSqToSegment( vStart, vEnd, interRay, interSegment ); if ( distSq > localPrecisionSq ) continue; interRay.applyMatrix4( this.matrixWorld ); //Move back to world space for distance calculation var distance = raycaster.ray.origin.distanceTo( interRay ); if ( distance < raycaster.near || distance > raycaster.far ) continue; intersects.push( { distance: distance, // What do we want? intersection point on the ray or on the segment?? // point: raycaster.ray.at( distance ), point: interSegment.clone().applyMatrix4( this.matrixWorld ), index: i, face: null, faceIndex: null, object: this } ); } } } else if ( geometry.isGeometry ) { var vertices = geometry.vertices; var nbVertices = vertices.length; for ( var i = 0; i < nbVertices - 1; i += step ) { var distSq = ray.distanceSqToSegment( vertices[ i ], vertices[ i + 1 ], interRay, interSegment ); if ( distSq > localPrecisionSq ) continue; interRay.applyMatrix4( this.matrixWorld ); //Move back to world space for distance calculation var distance = raycaster.ray.origin.distanceTo( interRay ); if ( distance < raycaster.near || distance > raycaster.far ) continue; intersects.push( { distance: distance, // What do we want? intersection point on the ray or on the segment?? // point: raycaster.ray.at( distance ), point: interSegment.clone().applyMatrix4( this.matrixWorld ), index: i, face: null, faceIndex: null, object: this } ); } } }; }() ), copy: function ( source ) { Object3D.prototype.copy.call( this, source ); this.geometry.copy( source.geometry ); this.material.copy( source.material ); return this; }, clone: function () { return new this.constructor().copy( this ); } } ); /** * @author mrdoob / http://mrdoob.com/ */ function LineSegments( geometry, material ) { Line.call( this, geometry, material ); this.type = 'LineSegments'; } LineSegments.prototype = Object.assign( Object.create( Line.prototype ), { constructor: LineSegments, isLineSegments: true, computeLineDistances: ( function () { var start = new Vector3(); var end = new Vector3(); return function computeLineDistances() { var geometry = this.geometry; if ( geometry.isBufferGeometry ) { // we assume non-indexed geometry if ( geometry.index === null ) { var positionAttribute = geometry.attributes.position; var lineDistances = []; for ( var i = 0, l = positionAttribute.count; i < l; i += 2 ) { start.fromBufferAttribute( positionAttribute, i ); end.fromBufferAttribute( positionAttribute, i + 1 ); lineDistances[ i ] = ( i === 0 ) ? 0 : lineDistances[ i - 1 ]; lineDistances[ i + 1 ] = lineDistances[ i ] + start.distanceTo( end ); } geometry.addAttribute( 'lineDistance', new Float32BufferAttribute( lineDistances, 1 ) ); } else { console.warn( 'THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.' ); } } else if ( geometry.isGeometry ) { var vertices = geometry.vertices; var lineDistances = geometry.lineDistances; for ( var i = 0, l = vertices.length; i < l; i += 2 ) { start.copy( vertices[ i ] ); end.copy( vertices[ i + 1 ] ); lineDistances[ i ] = ( i === 0 ) ? 0 : lineDistances[ i - 1 ]; lineDistances[ i + 1 ] = lineDistances[ i ] + start.distanceTo( end ); } } return this; }; }() ) } ); /** * @author mgreter / http://github.com/mgreter */ function LineLoop( geometry, material ) { Line.call( this, geometry, material ); this.type = 'LineLoop'; } LineLoop.prototype = Object.assign( Object.create( Line.prototype ), { constructor: LineLoop, isLineLoop: true, } ); /** * @author mrdoob / http://mrdoob.com/ * @author alteredq / http://alteredqualia.com/ * * parameters = { * color: , * opacity: , * map: new THREE.Texture( ), * * size: , * sizeAttenuation: * * morphTargets: * } */ function PointsMaterial( parameters ) { Material.call( this ); this.type = 'PointsMaterial'; this.color = new Color( 0xffffff ); this.map = null; this.size = 1; this.sizeAttenuation = true; this.morphTargets = false; this.lights = false; this.setValues( parameters ); } PointsMaterial.prototype = Object.create( Material.prototype ); PointsMaterial.prototype.constructor = PointsMaterial; PointsMaterial.prototype.isPointsMaterial = true; PointsMaterial.prototype.copy = function ( source ) { Material.prototype.copy.call( this, source ); this.color.copy( source.color ); this.map = source.map; this.size = source.size; this.sizeAttenuation = source.sizeAttenuation; this.morphTargets = source.morphTargets; return this; }; /** * @author alteredq / http://alteredqualia.com/ */ function Points( geometry, material ) { Object3D.call( this ); this.type = 'Points'; this.geometry = geometry !== undefined ? geometry : new BufferGeometry(); this.material = material !== undefined ? material : new PointsMaterial( { color: Math.random() * 0xffffff } ); } Points.prototype = Object.assign( Object.create( Object3D.prototype ), { constructor: Points, isPoints: true, raycast: ( function () { var inverseMatrix = new Matrix4(); var ray = new Ray(); var sphere = new Sphere(); return function raycast( raycaster, intersects ) { var object = this; var geometry = this.geometry; var matrixWorld = this.matrixWorld; var threshold = raycaster.params.Points.threshold; // Checking boundingSphere distance to ray if ( geometry.boundingSphere === null ) geometry.computeBoundingSphere(); sphere.copy( geometry.boundingSphere ); sphere.applyMatrix4( matrixWorld ); sphere.radius += threshold; if ( raycaster.ray.intersectsSphere( sphere ) === false ) return; // inverseMatrix.getInverse( matrixWorld ); ray.copy( raycaster.ray ).applyMatrix4( inverseMatrix ); var localThreshold = threshold / ( ( this.scale.x + this.scale.y + this.scale.z ) / 3 ); var localThresholdSq = localThreshold * localThreshold; var position = new Vector3(); var intersectPoint = new Vector3(); function testPoint( point, index ) { var rayPointDistanceSq = ray.distanceSqToPoint( point ); if ( rayPointDistanceSq < localThresholdSq ) { ray.closestPointToPoint( point, intersectPoint ); intersectPoint.applyMatrix4( matrixWorld ); var distance = raycaster.ray.origin.distanceTo( intersectPoint ); if ( distance < raycaster.near || distance > raycaster.far ) return; intersects.push( { distance: distance, distanceToRay: Math.sqrt( rayPointDistanceSq ), point: intersectPoint.clone(), index: index, face: null, object: object } ); } } if ( geometry.isBufferGeometry ) { var index = geometry.index; var attributes = geometry.attributes; var positions = attributes.position.array; if ( index !== null ) { var indices = index.array; for ( var i = 0, il = indices.length; i < il; i ++ ) { var a = indices[ i ]; position.fromArray( positions, a * 3 ); testPoint( position, a ); } } else { for ( var i = 0, l = positions.length / 3; i < l; i ++ ) { position.fromArray( positions, i * 3 ); testPoint( position, i ); } } } else { var vertices = geometry.vertices; for ( var i = 0, l = vertices.length; i < l; i ++ ) { testPoint( vertices[ i ], i ); } } }; }() ), clone: function () { return new this.constructor( this.geometry, this.material ).copy( this ); } } ); /** * @author mrdoob / http://mrdoob.com/ */ function VideoTexture( video, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy ) { Texture.call( this, video, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy ); this.format = format !== undefined ? format : RGBFormat; this.minFilter = minFilter !== undefined ? minFilter : LinearFilter; this.magFilter = magFilter !== undefined ? magFilter : LinearFilter; this.generateMipmaps = false; } VideoTexture.prototype = Object.assign( Object.create( Texture.prototype ), { constructor: VideoTexture, isVideoTexture: true, update: function () { var video = this.image; if ( video.readyState >= video.HAVE_CURRENT_DATA ) { this.needsUpdate = true; } } } ); /** * @author alteredq / http://alteredqualia.com/ */ function CompressedTexture( mipmaps, width, height, format, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, encoding ) { Texture.call( this, null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding ); this.image = { width: width, height: height }; this.mipmaps = mipmaps; // no flipping for cube textures // (also flipping doesn't work for compressed textures ) this.flipY = false; // can't generate mipmaps for compressed textures // mips must be embedded in DDS files this.generateMipmaps = false; } CompressedTexture.prototype = Object.create( Texture.prototype ); CompressedTexture.prototype.constructor = CompressedTexture; CompressedTexture.prototype.isCompressedTexture = true; /** * @author mrdoob / http://mrdoob.com/ */ function CanvasTexture( canvas, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy ) { Texture.call( this, canvas, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy ); this.needsUpdate = true; } CanvasTexture.prototype = Object.create( Texture.prototype ); CanvasTexture.prototype.constructor = CanvasTexture; CanvasTexture.prototype.isCanvasTexture = true; /** * @author Matt DesLauriers / @mattdesl * @author atix / arthursilber.de */ function DepthTexture( width, height, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, format ) { format = format !== undefined ? format : DepthFormat; if ( format !== DepthFormat && format !== DepthStencilFormat ) { throw new Error( 'DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat' ); } if ( type === undefined && format === DepthFormat ) type = UnsignedShortType; if ( type === undefined && format === DepthStencilFormat ) type = UnsignedInt248Type; Texture.call( this, null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy ); this.image = { width: width, height: height }; this.magFilter = magFilter !== undefined ? magFilter : NearestFilter; this.minFilter = minFilter !== undefined ? minFilter : NearestFilter; this.flipY = false; this.generateMipmaps = false; } DepthTexture.prototype = Object.create( Texture.prototype ); DepthTexture.prototype.constructor = DepthTexture; DepthTexture.prototype.isDepthTexture = true; /** * @author mrdoob / http://mrdoob.com/ * @author Mugen87 / https://github.com/Mugen87 */ function WireframeGeometry( geometry ) { BufferGeometry.call( this ); this.type = 'WireframeGeometry'; // buffer var vertices = []; // helper variables var i, j, l, o, ol; var edge = [ 0, 0 ], edges = {}, e, edge1, edge2; var key, keys = [ 'a', 'b', 'c' ]; var vertex; // different logic for Geometry and BufferGeometry if ( geometry && geometry.isGeometry ) { // create a data structure that contains all edges without duplicates var faces = geometry.faces; for ( i = 0, l = faces.length; i < l; i ++ ) { var face = faces[ i ]; for ( j = 0; j < 3; j ++ ) { edge1 = face[ keys[ j ] ]; edge2 = face[ keys[ ( j + 1 ) % 3 ] ]; edge[ 0 ] = Math.min( edge1, edge2 ); // sorting prevents duplicates edge[ 1 ] = Math.max( edge1, edge2 ); key = edge[ 0 ] + ',' + edge[ 1 ]; if ( edges[ key ] === undefined ) { edges[ key ] = { index1: edge[ 0 ], index2: edge[ 1 ] }; } } } // generate vertices for ( key in edges ) { e = edges[ key ]; vertex = geometry.vertices[ e.index1 ]; vertices.push( vertex.x, vertex.y, vertex.z ); vertex = geometry.vertices[ e.index2 ]; vertices.push( vertex.x, vertex.y, vertex.z ); } } else if ( geometry && geometry.isBufferGeometry ) { var position, indices, groups; var group, start, count; var index1, index2; vertex = new Vector3(); if ( geometry.index !== null ) { // indexed BufferGeometry position = geometry.attributes.position; indices = geometry.index; groups = geometry.groups; if ( groups.length === 0 ) { groups = [ { start: 0, count: indices.count, materialIndex: 0 } ]; } // create a data structure that contains all eges without duplicates for ( o = 0, ol = groups.length; o < ol; ++ o ) { group = groups[ o ]; start = group.start; count = group.count; for ( i = start, l = ( start + count ); i < l; i += 3 ) { for ( j = 0; j < 3; j ++ ) { edge1 = indices.getX( i + j ); edge2 = indices.getX( i + ( j + 1 ) % 3 ); edge[ 0 ] = Math.min( edge1, edge2 ); // sorting prevents duplicates edge[ 1 ] = Math.max( edge1, edge2 ); key = edge[ 0 ] + ',' + edge[ 1 ]; if ( edges[ key ] === undefined ) { edges[ key ] = { index1: edge[ 0 ], index2: edge[ 1 ] }; } } } } // generate vertices for ( key in edges ) { e = edges[ key ]; vertex.fromBufferAttribute( position, e.index1 ); vertices.push( vertex.x, vertex.y, vertex.z ); vertex.fromBufferAttribute( position, e.index2 ); vertices.push( vertex.x, vertex.y, vertex.z ); } } else { // non-indexed BufferGeometry position = geometry.attributes.position; for ( i = 0, l = ( position.count / 3 ); i < l; i ++ ) { for ( j = 0; j < 3; j ++ ) { // three edges per triangle, an edge is represented as (index1, index2) // e.g. the first triangle has the following edges: (0,1),(1,2),(2,0) index1 = 3 * i + j; vertex.fromBufferAttribute( position, index1 ); vertices.push( vertex.x, vertex.y, vertex.z ); index2 = 3 * i + ( ( j + 1 ) % 3 ); vertex.fromBufferAttribute( position, index2 ); vertices.push( vertex.x, vertex.y, vertex.z ); } } } } // build geometry this.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) ); } WireframeGeometry.prototype = Object.create( BufferGeometry.prototype ); WireframeGeometry.prototype.constructor = WireframeGeometry; /** * @author zz85 / https://github.com/zz85 * @author Mugen87 / https://github.com/Mugen87 * * Parametric Surfaces Geometry * based on the brilliant article by @prideout http://prideout.net/blog/?p=44 */ // ParametricGeometry function ParametricGeometry( func, slices, stacks ) { Geometry.call( this ); this.type = 'ParametricGeometry'; this.parameters = { func: func, slices: slices, stacks: stacks }; this.fromBufferGeometry( new ParametricBufferGeometry( func, slices, stacks ) ); this.mergeVertices(); } ParametricGeometry.prototype = Object.create( Geometry.prototype ); ParametricGeometry.prototype.constructor = ParametricGeometry; // ParametricBufferGeometry function ParametricBufferGeometry( func, slices, stacks ) { BufferGeometry.call( this ); this.type = 'ParametricBufferGeometry'; this.parameters = { func: func, slices: slices, stacks: stacks }; // buffers var indices = []; var vertices = []; var normals = []; var uvs = []; var EPS = 0.00001; var normal = new Vector3(); var p0 = new Vector3(), p1 = new Vector3(); var pu = new Vector3(), pv = new Vector3(); var i, j; if ( func.length < 3 ) { console.error( 'THREE.ParametricGeometry: Function must now modify a Vector3 as third parameter.' ); } // generate vertices, normals and uvs var sliceCount = slices + 1; for ( i = 0; i = 0 ) { func( u, v - EPS, p1 ); pv.subVectors( p0, p1 ); } else { func( u, v + EPS, p1 ); pv.subVectors( p1, p0 ); } // cross product of tangent vectors returns surface normal normal.crossVectors( pu, pv ).normalize(); normals.push( normal.x, normal.y, normal.z ); // uv uvs.push( u, v ); } } // generate indices for ( i = 0; i < stacks; i ++ ) { for ( j = 0; j < slices; j ++ ) { var a = i * sliceCount + j; var b = i * sliceCount + j + 1; var c = ( i + 1 ) * sliceCount + j + 1; var d = ( i + 1 ) * sliceCount + j; // faces one and two indices.push( a, b, d ); indices.push( b, c, d ); } } // build geometry this.setIndex( indices ); this.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) ); this.addAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) ); this.addAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) ); } ParametricBufferGeometry.prototype = Object.create( BufferGeometry.prototype ); ParametricBufferGeometry.prototype.constructor = ParametricBufferGeometry; /** * @author clockworkgeek / https://github.com/clockworkgeek * @author timothypratley / https://github.com/timothypratley * @author WestLangley / http://github.com/WestLangley * @author Mugen87 / https://github.com/Mugen87 */ // PolyhedronGeometry function PolyhedronGeometry( vertices, indices, radius, detail ) { Geometry.call( this ); this.type = 'PolyhedronGeometry'; this.parameters = { vertices: vertices, indices: indices, radius: radius, detail: detail }; this.fromBufferGeometry( new PolyhedronBufferGeometry( vertices, indices, radius, detail ) ); this.mergeVertices(); } PolyhedronGeometry.prototype = Object.create( Geometry.prototype ); PolyhedronGeometry.prototype.constructor = PolyhedronGeometry; // PolyhedronBufferGeometry function PolyhedronBufferGeometry( vertices, indices, radius, detail ) { BufferGeometry.call( this ); this.type = 'PolyhedronBufferGeometry'; this.parameters = { vertices: vertices, indices: indices, radius: radius, detail: detail }; radius = radius || 1; detail = detail || 0; // default buffer data var vertexBuffer = []; var uvBuffer = []; // the subdivision creates the vertex buffer data subdivide( detail ); // all vertices should lie on a conceptual sphere with a given radius appplyRadius( radius ); // finally, create the uv data generateUVs(); // build non-indexed geometry this.addAttribute( 'position', new Float32BufferAttribute( vertexBuffer, 3 ) ); this.addAttribute( 'normal', new Float32BufferAttribute( vertexBuffer.slice(), 3 ) ); this.addAttribute( 'uv', new Float32BufferAttribute( uvBuffer, 2 ) ); if ( detail === 0 ) { this.computeVertexNormals(); // flat normals } else { this.normalizeNormals(); // smooth normals } // helper functions function subdivide( detail ) { var a = new Vector3(); var b = new Vector3(); var c = new Vector3(); // iterate over all faces and apply a subdivison with the given detail value for ( var i = 0; i < indices.length; i += 3 ) { // get the vertices of the face getVertexByIndex( indices[ i + 0 ], a ); getVertexByIndex( indices[ i + 1 ], b ); getVertexByIndex( indices[ i + 2 ], c ); // perform subdivision subdivideFace( a, b, c, detail ); } } function subdivideFace( a, b, c, detail ) { var cols = Math.pow( 2, detail ); // we use this multidimensional array as a data structure for creating the subdivision var v = []; var i, j; // construct all of the vertices for this subdivision for ( i = 0; i maxY ) maxY = y; } // minX, minY and invSize are later used to transform coords into integers for z-order calculation invSize = Math.max( maxX - minX, maxY - minY ); invSize = invSize !== 0 ? 1 / invSize : 0; } earcutLinked( outerNode, triangles, dim, minX, minY, invSize ); return triangles; } }; // create a circular doubly linked list from polygon points in the specified winding order function linkedList( data, start, end, dim, clockwise ) { var i, last; if ( clockwise === ( signedArea( data, start, end, dim ) > 0 ) ) { for ( i = start; i < end; i += dim ) last = insertNode( i, data[ i ], data[ i + 1 ], last ); } else { for ( i = end - dim; i >= start; i -= dim ) last = insertNode( i, data[ i ], data[ i + 1 ], last ); } if ( last && equals( last, last.next ) ) { removeNode( last ); last = last.next; } return last; } // eliminate colinear or duplicate points function filterPoints( start, end ) { if ( ! start ) return start; if ( ! end ) end = start; var p = start, again; do { again = false; if ( ! p.steiner && ( equals( p, p.next ) || area( p.prev, p, p.next ) === 0 ) ) { removeNode( p ); p = end = p.prev; if ( p === p.next ) break; again = true; } else { p = p.next; } } while ( again || p !== end ); return end; } // main ear slicing loop which triangulates a polygon (given as a linked list) function earcutLinked( ear, triangles, dim, minX, minY, invSize, pass ) { if ( ! ear ) return; // interlink polygon nodes in z-order if ( ! pass && invSize ) indexCurve( ear, minX, minY, invSize ); var stop = ear, prev, next; // iterate through ears, slicing them one by one while ( ear.prev !== ear.next ) { prev = ear.prev; next = ear.next; if ( invSize ? isEarHashed( ear, minX, minY, invSize ) : isEar( ear ) ) { // cut off the triangle triangles.push( prev.i / dim ); triangles.push( ear.i / dim ); triangles.push( next.i / dim ); removeNode( ear ); // skipping the next vertice leads to less sliver triangles ear = next.next; stop = next.next; continue; } ear = next; // if we looped through the whole remaining polygon and can't find any more ears if ( ear === stop ) { // try filtering points and slicing again if ( ! pass ) { earcutLinked( filterPoints( ear ), triangles, dim, minX, minY, invSize, 1 ); // if this didn't work, try curing all small self-intersections locally } else if ( pass === 1 ) { ear = cureLocalIntersections( ear, triangles, dim ); earcutLinked( ear, triangles, dim, minX, minY, invSize, 2 ); // as a last resort, try splitting the remaining polygon into two } else if ( pass === 2 ) { splitEarcut( ear, triangles, dim, minX, minY, invSize ); } break; } } } // check whether a polygon node forms a valid ear with adjacent nodes function isEar( ear ) { var a = ear.prev, b = ear, c = ear.next; if ( area( a, b, c ) >= 0 ) return false; // reflex, can't be an ear // now make sure we don't have other points inside the potential ear var p = ear.next.next; while ( p !== ear.prev ) { if ( pointInTriangle( a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y ) && area( p.prev, p, p.next ) >= 0 ) { return false; } p = p.next; } return true; } function isEarHashed( ear, minX, minY, invSize ) { var a = ear.prev, b = ear, c = ear.next; if ( area( a, b, c ) >= 0 ) return false; // reflex, can't be an ear // triangle bbox; min & max are calculated like this for speed var minTX = a.x < b.x ? ( a.x < c.x ? a.x : c.x ) : ( b.x < c.x ? b.x : c.x ), minTY = a.y < b.y ? ( a.y < c.y ? a.y : c.y ) : ( b.y < c.y ? b.y : c.y ), maxTX = a.x > b.x ? ( a.x > c.x ? a.x : c.x ) : ( b.x > c.x ? b.x : c.x ), maxTY = a.y > b.y ? ( a.y > c.y ? a.y : c.y ) : ( b.y > c.y ? b.y : c.y ); // z-order range for the current triangle bbox; var minZ = zOrder( minTX, minTY, minX, minY, invSize ), maxZ = zOrder( maxTX, maxTY, minX, minY, invSize ); // first look for points inside the triangle in increasing z-order var p = ear.nextZ; while ( p && p.z = 0 ) return false; p = p.nextZ; } // then look for points in decreasing z-order p = ear.prevZ; while ( p && p.z >= minZ ) { if ( p !== ear.prev && p !== ear.next && pointInTriangle( a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y ) && area( p.prev, p, p.next ) >= 0 ) return false; p = p.prevZ; } return true; } // go through all polygon nodes and cure small local self-intersections function cureLocalIntersections( start, triangles, dim ) { var p = start; do { var a = p.prev, b = p.next.next; if ( ! equals( a, b ) && intersects( a, p, p.next, b ) && locallyInside( a, b ) && locallyInside( b, a ) ) { triangles.push( a.i / dim ); triangles.push( p.i / dim ); triangles.push( b.i / dim ); // remove two nodes involved removeNode( p ); removeNode( p.next ); p = start = b; } p = p.next; } while ( p !== start ); return p; } // try splitting polygon into two and triangulate them independently function splitEarcut( start, triangles, dim, minX, minY, invSize ) { // look for a valid diagonal that divides the polygon into two var a = start; do { var b = a.next.next; while ( b !== a.prev ) { if ( a.i !== b.i && isValidDiagonal( a, b ) ) { // split the polygon in two by the diagonal var c = splitPolygon( a, b ); // filter colinear points around the cuts a = filterPoints( a, a.next ); c = filterPoints( c, c.next ); // run earcut on each half earcutLinked( a, triangles, dim, minX, minY, invSize ); earcutLinked( c, triangles, dim, minX, minY, invSize ); return; } b = b.next; } a = a.next; } while ( a !== start ); } // link every hole into the outer loop, producing a single-ring polygon without holes function eliminateHoles( data, holeIndices, outerNode, dim ) { var queue = [], i, len, start, end, list; for ( i = 0, len = holeIndices.length; i < len; i ++ ) { start = holeIndices[ i ] * dim; end = i < len - 1 ? holeIndices[ i + 1 ] * dim : data.length; list = linkedList( data, start, end, dim, false ); if ( list === list.next ) list.steiner = true; queue.push( getLeftmost( list ) ); } queue.sort( compareX ); // process holes from left to right for ( i = 0; i < queue.length; i ++ ) { eliminateHole( queue[ i ], outerNode ); outerNode = filterPoints( outerNode, outerNode.next ); } return outerNode; } function compareX( a, b ) { return a.x - b.x; } // find a bridge between vertices that connects hole with an outer ring and and link it function eliminateHole( hole, outerNode ) { outerNode = findHoleBridge( hole, outerNode ); if ( outerNode ) { var b = splitPolygon( outerNode, hole ); filterPoints( b, b.next ); } } // David Eberly's algorithm for finding a bridge between hole and outer polygon function findHoleBridge( hole, outerNode ) { var p = outerNode, hx = hole.x, hy = hole.y, qx = - Infinity, m; // find a segment intersected by a ray from the hole's leftmost point to the left; // segment's endpoint with lesser x will be potential connection point do { if ( hy = p.next.y && p.next.y !== p.y ) { var x = p.x + ( hy - p.y ) * ( p.next.x - p.x ) / ( p.next.y - p.y ); if ( x qx ) { qx = x; if ( x === hx ) { if ( hy === p.y ) return p; if ( hy === p.next.y ) return p.next; } m = p.x < p.next.x ? p : p.next; } } p = p.next; } while ( p !== outerNode ); if ( ! m ) return null; if ( hx === qx ) return m.prev; // hole touches outer segment; pick lower endpoint // look for points inside the triangle of hole point, segment intersection and endpoint; // if there are no points found, we have a valid connection; // otherwise choose the point of the minimum angle with the ray as connection point var stop = m, mx = m.x, my = m.y, tanMin = Infinity, tan; p = m.next; while ( p !== stop ) { if ( hx >= p.x && p.x >= mx && hx !== p.x && pointInTriangle( hy < my ? hx : qx, hy, mx, my, hy < my ? qx : hx, hy, p.x, p.y ) ) { tan = Math.abs( hy - p.y ) / ( hx - p.x ); // tangential if ( ( tan < tanMin || ( tan === tanMin && p.x > m.x ) ) && locallyInside( p, hole ) ) { m = p; tanMin = tan; } } p = p.next; } return m; } // interlink polygon nodes in z-order function indexCurve( start, minX, minY, invSize ) { var p = start; do { if ( p.z === null ) p.z = zOrder( p.x, p.y, minX, minY, invSize ); p.prevZ = p.prev; p.nextZ = p.next; p = p.next; } while ( p !== start ); p.prevZ.nextZ = null; p.prevZ = null; sortLinked( p ); } // Simon Tatham's linked list merge sort algorithm // http://www.chiark.greenend.org.uk/~sgtatham/algorithms/listsort.html function sortLinked( list ) { var i, p, q, e, tail, numMerges, pSize, qSize, inSize = 1; do { p = list; list = null; tail = null; numMerges = 0; while ( p ) { numMerges ++; q = p; pSize = 0; for ( i = 0; i < inSize; i ++ ) { pSize ++; q = q.nextZ; if ( ! q ) break; } qSize = inSize; while ( pSize > 0 || ( qSize > 0 && q ) ) { if ( pSize !== 0 && ( qSize === 0 || ! q || p.z 1 ); return list; } // z-order of a point given coords and inverse of the longer side of data bbox function zOrder( x, y, minX, minY, invSize ) { // coords are transformed into non-negative 15-bit integer range x = 32767 * ( x - minX ) * invSize; y = 32767 * ( y - minY ) * invSize; x = ( x | ( x = 0 : area( a, b, a.prev ) < 0 || area( a, a.next, b ) < 0; } // check if the middle point of a polygon diagonal is inside the polygon function middleInside( a, b ) { var p = a, inside = false, px = ( a.x + b.x ) / 2, py = ( a.y + b.y ) / 2; do { if ( ( ( p.y > py ) !== ( p.next.y > py ) ) && p.next.y !== p.y && ( px < ( p.next.x - p.x ) * ( py - p.y ) / ( p.next.y - p.y ) + p.x ) ) { inside = ! inside; } p = p.next; } while ( p !== a ); return inside; } // link two polygon vertices with a bridge; if the vertices belong to the same ring, it splits polygon into two; // if one belongs to the outer ring and another to a hole, it merges it into a single ring function splitPolygon( a, b ) { var a2 = new Node( a.i, a.x, a.y ), b2 = new Node( b.i, b.x, b.y ), an = a.next, bp = b.prev; a.next = b; b.prev = a; a2.next = an; an.prev = a2; b2.next = a2; a2.prev = b2; bp.next = b2; b2.prev = bp; return b2; } // create a node and optionally link it with previous one (in a circular doubly linked list) function insertNode( i, x, y, last ) { var p = new Node( i, x, y ); if ( ! last ) { p.prev = p; p.next = p; } else { p.next = last.next; p.prev = last; last.next.prev = p; last.next = p; } return p; } function removeNode( p ) { p.next.prev = p.prev; p.prev.next = p.next; if ( p.prevZ ) p.prevZ.nextZ = p.nextZ; if ( p.nextZ ) p.nextZ.prevZ = p.prevZ; } function Node( i, x, y ) { // vertice index in coordinates array this.i = i; // vertex coordinates this.x = x; this.y = y; // previous and next vertice nodes in a polygon ring this.prev = null; this.next = null; // z-order curve value this.z = null; // previous and next nodes in z-order this.prevZ = null; this.nextZ = null; // indicates whether this is a steiner point this.steiner = false; } function signedArea( data, start, end, dim ) { var sum = 0; for ( var i = start, j = end - dim; i < end; i += dim ) { sum += ( data[ j ] - data[ i ] ) * ( data[ i + 1 ] + data[ j + 1 ] ); j = i; } return sum; } /** * @author zz85 / http://www.lab4games.net/zz85/blog */ var ShapeUtils = { // calculate area of the contour polygon area: function ( contour ) { var n = contour.length; var a = 0.0; for ( var p = n - 1, q = 0; q < n; p = q ++ ) { a += contour[ p ].x * contour[ q ].y - contour[ q ].x * contour[ p ].y; } return a * 0.5; }, isClockWise: function ( pts ) { return ShapeUtils.area( pts ) < 0; }, triangulateShape: function ( contour, holes ) { var vertices = []; // flat array of vertices like [ x0,y0, x1,y1, x2,y2, ... ] var holeIndices = []; // array of hole indices var faces = []; // final array of vertex indices like [ [ a,b,d ], [ b,c,d ] ] removeDupEndPts( contour ); addContour( vertices, contour ); // var holeIndex = contour.length; holes.forEach( removeDupEndPts ); for ( var i = 0; i < holes.length; i ++ ) { holeIndices.push( holeIndex ); holeIndex += holes[ i ].length; addContour( vertices, holes[ i ] ); } // var triangles = Earcut.triangulate( vertices, holeIndices ); // for ( var i = 0; i < triangles.length; i += 3 ) { faces.push( triangles.slice( i, i + 3 ) ); } return faces; } }; function removeDupEndPts( points ) { var l = points.length; if ( l > 2 && points[ l - 1 ].equals( points[ 0 ] ) ) { points.pop(); } } function addContour( vertices, contour ) { for ( var i = 0; i < contour.length; i ++ ) { vertices.push( contour[ i ].x ); vertices.push( contour[ i ].y ); } } /** * @author zz85 / http://www.lab4games.net/zz85/blog * * Creates extruded geometry from a path shape. * * parameters = { * * curveSegments: , // number of points on the curves * steps: , // number of points for z-side extrusions / used for subdividing segments of extrude spline too * depth: , // Depth to extrude the shape * * bevelEnabled: , // turn on bevel * bevelThickness: , // how deep into the original shape bevel goes * bevelSize: , // how far from shape outline is bevel * bevelSegments: , // number of bevel layers * * extrudePath: // curve to extrude shape along * * UVGenerator: // object that provides UV generator functions * * } */ // ExtrudeGeometry function ExtrudeGeometry( shapes, options ) { Geometry.call( this ); this.type = 'ExtrudeGeometry'; this.parameters = { shapes: shapes, options: options }; this.fromBufferGeometry( new ExtrudeBufferGeometry( shapes, options ) ); this.mergeVertices(); } ExtrudeGeometry.prototype = Object.create( Geometry.prototype ); ExtrudeGeometry.prototype.constructor = ExtrudeGeometry; ExtrudeGeometry.prototype.toJSON = function () { var data = Geometry.prototype.toJSON.call( this ); var shapes = this.parameters.shapes; var options = this.parameters.options; return toJSON( shapes, options, data ); }; // ExtrudeBufferGeometry function ExtrudeBufferGeometry( shapes, options ) { BufferGeometry.call( this ); this.type = 'ExtrudeBufferGeometry'; this.parameters = { shapes: shapes, options: options }; shapes = Array.isArray( shapes ) ? shapes : [ shapes ]; var scope = this; var verticesArray = []; var uvArray = []; for ( var i = 0, l = shapes.length; i < l; i ++ ) { var shape = shapes[ i ]; addShape( shape ); } // build geometry this.addAttribute( 'position', new Float32BufferAttribute( verticesArray, 3 ) ); this.addAttribute( 'uv', new Float32BufferAttribute( uvArray, 2 ) ); this.computeVertexNormals(); // functions function addShape( shape ) { var placeholder = []; // options var curveSegments = options.curveSegments !== undefined ? options.curveSegments : 12; var steps = options.steps !== undefined ? options.steps : 1; var depth = options.depth !== undefined ? options.depth : 100; var bevelEnabled = options.bevelEnabled !== undefined ? options.bevelEnabled : true; var bevelThickness = options.bevelThickness !== undefined ? options.bevelThickness : 6; var bevelSize = options.bevelSize !== undefined ? options.bevelSize : bevelThickness - 2; var bevelSegments = options.bevelSegments !== undefined ? options.bevelSegments : 3; var extrudePath = options.extrudePath; var uvgen = options.UVGenerator !== undefined ? options.UVGenerator : WorldUVGenerator; // deprecated options if ( options.amount !== undefined ) { console.warn( 'THREE.ExtrudeBufferGeometry: amount has been renamed to depth.' ); depth = options.amount; } // var extrudePts, extrudeByPath = false; var splineTube, binormal, normal, position2; if ( extrudePath ) { extrudePts = extrudePath.getSpacedPoints( steps ); extrudeByPath = true; bevelEnabled = false; // bevels not supported for path extrusion // SETUP TNB variables // TODO1 - have a .isClosed in spline? splineTube = extrudePath.computeFrenetFrames( steps, false ); // console.log(splineTube, 'splineTube', splineTube.normals.length, 'steps', steps, 'extrudePts', extrudePts.length); binormal = new Vector3(); normal = new Vector3(); position2 = new Vector3(); } // Safeguards if bevels are not enabled if ( ! bevelEnabled ) { bevelSegments = 0; bevelThickness = 0; bevelSize = 0; } // Variables initialization var ahole, h, hl; // looping of holes var shapePoints = shape.extractPoints( curveSegments ); var vertices = shapePoints.shape; var holes = shapePoints.holes; var reverse = ! ShapeUtils.isClockWise( vertices ); if ( reverse ) { vertices = vertices.reverse(); // Maybe we should also check if holes are in the opposite direction, just to be safe ... for ( h = 0, hl = holes.length; h < hl; h ++ ) { ahole = holes[ h ]; if ( ShapeUtils.isClockWise( ahole ) ) { holes[ h ] = ahole.reverse(); } } } var faces = ShapeUtils.triangulateShape( vertices, holes ); /* Vertices */ var contour = vertices; // vertices has all points but contour has only points of circumference for ( h = 0, hl = holes.length; h < hl; h ++ ) { ahole = holes[ h ]; vertices = vertices.concat( ahole ); } function scalePt2( pt, vec, size ) { if ( ! vec ) console.error( \"THREE.ExtrudeGeometry: vec does not exist\" ); return vec.clone().multiplyScalar( size ).add( pt ); } var b, bs, t, z, vert, vlen = vertices.length, face, flen = faces.length; // Find directions for point movement function getBevelVec( inPt, inPrev, inNext ) { // computes for inPt the corresponding point inPt' on a new contour // shifted by 1 unit (length of normalized vector) to the left // if we walk along contour clockwise, this new contour is outside the old one // // inPt' is the intersection of the two lines parallel to the two // adjacent edges of inPt at a distance of 1 unit on the left side. var v_trans_x, v_trans_y, shrink_by; // resulting translation vector for inPt // good reading for geometry algorithms (here: line-line intersection) // http://geomalgorithms.com/a05-_intersect-1.html var v_prev_x = inPt.x - inPrev.x, v_prev_y = inPt.y - inPrev.y; var v_next_x = inNext.x - inPt.x, v_next_y = inNext.y - inPt.y; var v_prev_lensq = ( v_prev_x * v_prev_x + v_prev_y * v_prev_y ); // check for collinear edges var collinear0 = ( v_prev_x * v_next_y - v_prev_y * v_next_x ); if ( Math.abs( collinear0 ) > Number.EPSILON ) { // not collinear // length of vectors for normalizing var v_prev_len = Math.sqrt( v_prev_lensq ); var v_next_len = Math.sqrt( v_next_x * v_next_x + v_next_y * v_next_y ); // shift adjacent points by unit vectors to the left var ptPrevShift_x = ( inPrev.x - v_prev_y / v_prev_len ); var ptPrevShift_y = ( inPrev.y + v_prev_x / v_prev_len ); var ptNextShift_x = ( inNext.x - v_next_y / v_next_len ); var ptNextShift_y = ( inNext.y + v_next_x / v_next_len ); // scaling factor for v_prev to intersection point var sf = ( ( ptNextShift_x - ptPrevShift_x ) * v_next_y - ( ptNextShift_y - ptPrevShift_y ) * v_next_x ) / ( v_prev_x * v_next_y - v_prev_y * v_next_x ); // vector from inPt to intersection point v_trans_x = ( ptPrevShift_x + v_prev_x * sf - inPt.x ); v_trans_y = ( ptPrevShift_y + v_prev_y * sf - inPt.y ); // Don't normalize!, otherwise sharp corners become ugly // but prevent crazy spikes var v_trans_lensq = ( v_trans_x * v_trans_x + v_trans_y * v_trans_y ); if ( v_trans_lensq Number.EPSILON ) { if ( v_next_x > Number.EPSILON ) { direction_eq = true; } } else { if ( v_prev_x < - Number.EPSILON ) { if ( v_next_x < - Number.EPSILON ) { direction_eq = true; } } else { if ( Math.sign( v_prev_y ) === Math.sign( v_next_y ) ) { direction_eq = true; } } } if ( direction_eq ) { // console.log(\"Warning: lines are a straight sequence\"); v_trans_x = - v_prev_y; v_trans_y = v_prev_x; shrink_by = Math.sqrt( v_prev_lensq ); } else { // console.log(\"Warning: lines are a straight spike\"); v_trans_x = v_prev_x; v_trans_y = v_prev_y; shrink_by = Math.sqrt( v_prev_lensq / 2 ); } } return new Vector2( v_trans_x / shrink_by, v_trans_y / shrink_by ); } var contourMovements = []; for ( var i = 0, il = contour.length, j = il - 1, k = i + 1; i < il; i ++, j ++, k ++ ) { if ( j === il ) j = 0; if ( k === il ) k = 0; // (j)---(i)---(k) // console.log('i,j,k', i, j , k) contourMovements[ i ] = getBevelVec( contour[ i ], contour[ j ], contour[ k ] ); } var holesMovements = [], oneHoleMovements, verticesMovements = contourMovements.concat(); for ( h = 0, hl = holes.length; h < hl; h ++ ) { ahole = holes[ h ]; oneHoleMovements = []; for ( i = 0, il = ahole.length, j = il - 1, k = i + 1; i < il; i ++, j ++, k ++ ) { if ( j === il ) j = 0; if ( k === il ) k = 0; // (j)---(i)---(k) oneHoleMovements[ i ] = getBevelVec( ahole[ i ], ahole[ j ], ahole[ k ] ); } holesMovements.push( oneHoleMovements ); verticesMovements = verticesMovements.concat( oneHoleMovements ); } // Loop bevelSegments, 1 for the front, 1 for the back for ( b = 0; b < bevelSegments; b ++ ) { //for ( b = bevelSegments; b > 0; b -- ) { t = b / bevelSegments; z = bevelThickness * Math.cos( t * Math.PI / 2 ); bs = bevelSize * Math.sin( t * Math.PI / 2 ); // contract shape for ( i = 0, il = contour.length; i < il; i ++ ) { vert = scalePt2( contour[ i ], contourMovements[ i ], bs ); v( vert.x, vert.y, - z ); } // expand holes for ( h = 0, hl = holes.length; h < hl; h ++ ) { ahole = holes[ h ]; oneHoleMovements = holesMovements[ h ]; for ( i = 0, il = ahole.length; i < il; i ++ ) { vert = scalePt2( ahole[ i ], oneHoleMovements[ i ], bs ); v( vert.x, vert.y, - z ); } } } bs = bevelSize; // Back facing vertices for ( i = 0; i < vlen; i ++ ) { vert = bevelEnabled ? scalePt2( vertices[ i ], verticesMovements[ i ], bs ) : vertices[ i ]; if ( ! extrudeByPath ) { v( vert.x, vert.y, 0 ); } else { // v( vert.x, vert.y + extrudePts[ 0 ].y, extrudePts[ 0 ].x ); normal.copy( splineTube.normals[ 0 ] ).multiplyScalar( vert.x ); binormal.copy( splineTube.binormals[ 0 ] ).multiplyScalar( vert.y ); position2.copy( extrudePts[ 0 ] ).add( normal ).add( binormal ); v( position2.x, position2.y, position2.z ); } } // Add stepped vertices... // Including front facing vertices var s; for ( s = 1; s = 0 ) { j = i; k = i - 1; if ( k < 0 ) k = contour.length - 1; //console.log('b', i,j, i-1, k,vertices.length); var s = 0, sl = steps + bevelSegments * 2; for ( s = 0; s < sl; s ++ ) { var slen1 = vlen * s; var slen2 = vlen * ( s + 1 ); var a = layeroffset + j + slen1, b = layeroffset + k + slen1, c = layeroffset + k + slen2, d = layeroffset + j + slen2; f4( a, b, c, d ); } } } function v( x, y, z ) { placeholder.push( x ); placeholder.push( y ); placeholder.push( z ); } function f3( a, b, c ) { addVertex( a ); addVertex( b ); addVertex( c ); var nextIndex = verticesArray.length / 3; var uvs = uvgen.generateTopUV( scope, verticesArray, nextIndex - 3, nextIndex - 2, nextIndex - 1 ); addUV( uvs[ 0 ] ); addUV( uvs[ 1 ] ); addUV( uvs[ 2 ] ); } function f4( a, b, c, d ) { addVertex( a ); addVertex( b ); addVertex( d ); addVertex( b ); addVertex( c ); addVertex( d ); var nextIndex = verticesArray.length / 3; var uvs = uvgen.generateSideWallUV( scope, verticesArray, nextIndex - 6, nextIndex - 3, nextIndex - 2, nextIndex - 1 ); addUV( uvs[ 0 ] ); addUV( uvs[ 1 ] ); addUV( uvs[ 3 ] ); addUV( uvs[ 1 ] ); addUV( uvs[ 2 ] ); addUV( uvs[ 3 ] ); } function addVertex( index ) { verticesArray.push( placeholder[ index * 3 + 0 ] ); verticesArray.push( placeholder[ index * 3 + 1 ] ); verticesArray.push( placeholder[ index * 3 + 2 ] ); } function addUV( vector2 ) { uvArray.push( vector2.x ); uvArray.push( vector2.y ); } } } ExtrudeBufferGeometry.prototype = Object.create( BufferGeometry.prototype ); ExtrudeBufferGeometry.prototype.constructor = ExtrudeBufferGeometry; ExtrudeBufferGeometry.prototype.toJSON = function () { var data = BufferGeometry.prototype.toJSON.call( this ); var shapes = this.parameters.shapes; var options = this.parameters.options; return toJSON( shapes, options, data ); }; // var WorldUVGenerator = { generateTopUV: function ( geometry, vertices, indexA, indexB, indexC ) { var a_x = vertices[ indexA * 3 ]; var a_y = vertices[ indexA * 3 + 1 ]; var b_x = vertices[ indexB * 3 ]; var b_y = vertices[ indexB * 3 + 1 ]; var c_x = vertices[ indexC * 3 ]; var c_y = vertices[ indexC * 3 + 1 ]; return [ new Vector2( a_x, a_y ), new Vector2( b_x, b_y ), new Vector2( c_x, c_y ) ]; }, generateSideWallUV: function ( geometry, vertices, indexA, indexB, indexC, indexD ) { var a_x = vertices[ indexA * 3 ]; var a_y = vertices[ indexA * 3 + 1 ]; var a_z = vertices[ indexA * 3 + 2 ]; var b_x = vertices[ indexB * 3 ]; var b_y = vertices[ indexB * 3 + 1 ]; var b_z = vertices[ indexB * 3 + 2 ]; var c_x = vertices[ indexC * 3 ]; var c_y = vertices[ indexC * 3 + 1 ]; var c_z = vertices[ indexC * 3 + 2 ]; var d_x = vertices[ indexD * 3 ]; var d_y = vertices[ indexD * 3 + 1 ]; var d_z = vertices[ indexD * 3 + 2 ]; if ( Math.abs( a_y - b_y ) < 0.01 ) { return [ new Vector2( a_x, 1 - a_z ), new Vector2( b_x, 1 - b_z ), new Vector2( c_x, 1 - c_z ), new Vector2( d_x, 1 - d_z ) ]; } else { return [ new Vector2( a_y, 1 - a_z ), new Vector2( b_y, 1 - b_z ), new Vector2( c_y, 1 - c_z ), new Vector2( d_y, 1 - d_z ) ]; } } }; function toJSON( shapes, options, data ) { // data.shapes = []; if ( Array.isArray( shapes ) ) { for ( var i = 0, l = shapes.length; i < l; i ++ ) { var shape = shapes[ i ]; data.shapes.push( shape.uuid ); } } else { data.shapes.push( shapes.uuid ); } // if ( options.extrudePath !== undefined ) data.options.extrudePath = options.extrudePath.toJSON(); return data; } /** * @author zz85 / http://www.lab4games.net/zz85/blog * @author alteredq / http://alteredqualia.com/ * * Text = 3D Text * * parameters = { * font: , // font * * size: , // size of the text * height: , // thickness to extrude text * curveSegments: , // number of points on the curves * * bevelEnabled: , // turn on bevel * bevelThickness: , // how deep into text bevel goes * bevelSize: // how far from text outline is bevel * } */ // TextGeometry function TextGeometry( text, parameters ) { Geometry.call( this ); this.type = 'TextGeometry'; this.parameters = { text: text, parameters: parameters }; this.fromBufferGeometry( new TextBufferGeometry( text, parameters ) ); this.mergeVertices(); } TextGeometry.prototype = Object.create( Geometry.prototype ); TextGeometry.prototype.constructor = TextGeometry; // TextBufferGeometry function TextBufferGeometry( text, parameters ) { parameters = parameters || {}; var font = parameters.font; if ( ! ( font && font.isFont ) ) { console.error( 'THREE.TextGeometry: font parameter is not an instance of THREE.Font.' ); return new Geometry(); } var shapes = font.generateShapes( text, parameters.size ); // translate parameters to ExtrudeGeometry API parameters.depth = parameters.height !== undefined ? parameters.height : 50; // defaults if ( parameters.bevelThickness === undefined ) parameters.bevelThickness = 10; if ( parameters.bevelSize === undefined ) parameters.bevelSize = 8; if ( parameters.bevelEnabled === undefined ) parameters.bevelEnabled = false; ExtrudeBufferGeometry.call( this, shapes, parameters ); this.type = 'TextBufferGeometry'; } TextBufferGeometry.prototype = Object.create( ExtrudeBufferGeometry.prototype ); TextBufferGeometry.prototype.constructor = TextBufferGeometry; /** * @author mrdoob / http://mrdoob.com/ * @author benaadams / https://twitter.com/ben_a_adams * @author Mugen87 / https://github.com/Mugen87 */ // SphereGeometry function SphereGeometry( radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength ) { Geometry.call( this ); this.type = 'SphereGeometry'; this.parameters = { radius: radius, widthSegments: widthSegments, heightSegments: heightSegments, phiStart: phiStart, phiLength: phiLength, thetaStart: thetaStart, thetaLength: thetaLength }; this.fromBufferGeometry( new SphereBufferGeometry( radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength ) ); this.mergeVertices(); } SphereGeometry.prototype = Object.create( Geometry.prototype ); SphereGeometry.prototype.constructor = SphereGeometry; // SphereBufferGeometry function SphereBufferGeometry( radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength ) { BufferGeometry.call( this ); this.type = 'SphereBufferGeometry'; this.parameters = { radius: radius, widthSegments: widthSegments, heightSegments: heightSegments, phiStart: phiStart, phiLength: phiLength, thetaStart: thetaStart, thetaLength: thetaLength }; radius = radius || 1; widthSegments = Math.max( 3, Math.floor( widthSegments ) || 8 ); heightSegments = Math.max( 2, Math.floor( heightSegments ) || 6 ); phiStart = phiStart !== undefined ? phiStart : 0; phiLength = phiLength !== undefined ? phiLength : Math.PI * 2; thetaStart = thetaStart !== undefined ? thetaStart : 0; thetaLength = thetaLength !== undefined ? thetaLength : Math.PI; var thetaEnd = thetaStart + thetaLength; var ix, iy; var index = 0; var grid = []; var vertex = new Vector3(); var normal = new Vector3(); // buffers var indices = []; var vertices = []; var normals = []; var uvs = []; // generate vertices, normals and uvs for ( iy = 0; iy 0 ) { high = i - 1; } else { high = i; break; // DONE } } i = high; if ( arcLengths[ i ] === targetArcLength ) { return i / ( il - 1 ); } // we could get finer grain at lengths, or use simple interpolation between two points var lengthBefore = arcLengths[ i ]; var lengthAfter = arcLengths[ i + 1 ]; var segmentLength = lengthAfter - lengthBefore; // determine where we are between the 'before' and 'after' points var segmentFraction = ( targetArcLength - lengthBefore ) / segmentLength; // add that fractional amount to t var t = ( i + segmentFraction ) / ( il - 1 ); return t; }, // Returns a unit vector tangent at t // In case any sub curve does not implement its tangent derivation, // 2 points a small delta apart will be used to find its gradient // which seems to give a reasonable approximation getTangent: function ( t ) { var delta = 0.0001; var t1 = t - delta; var t2 = t + delta; // Capping in case of danger if ( t1 < 0 ) t1 = 0; if ( t2 > 1 ) t2 = 1; var pt1 = this.getPoint( t1 ); var pt2 = this.getPoint( t2 ); var vec = pt2.clone().sub( pt1 ); return vec.normalize(); }, getTangentAt: function ( u ) { var t = this.getUtoTmapping( u ); return this.getTangent( t ); }, computeFrenetFrames: function ( segments, closed ) { // see http://www.cs.indiana.edu/pub/techreports/TR425.pdf var normal = new Vector3(); var tangents = []; var normals = []; var binormals = []; var vec = new Vector3(); var mat = new Matrix4(); var i, u, theta; // compute the tangent vectors for each segment on the curve for ( i = 0; i 0 ) { theta = - theta; } for ( i = 1; i 0 ? 0 : ( Math.floor( Math.abs( intPoint ) / l ) + 1 ) * l; } else if ( weight === 0 && intPoint === l - 1 ) { intPoint = l - 2; weight = 1; } var p0, p1, p2, p3; // 4 points if ( this.closed || intPoint > 0 ) { p0 = points[ ( intPoint - 1 ) % l ]; } else { // extrapolate first point tmp.subVectors( points[ 0 ], points[ 1 ] ).add( points[ 0 ] ); p0 = tmp; } p1 = points[ intPoint % l ]; p2 = points[ ( intPoint + 1 ) % l ]; if ( this.closed || intPoint + 2 < l ) { p3 = points[ ( intPoint + 2 ) % l ]; } else { // extrapolate last point tmp.subVectors( points[ l - 1 ], points[ l - 2 ] ).add( points[ l - 1 ] ); p3 = tmp; } if ( this.curveType === 'centripetal' || this.curveType === 'chordal' ) { // init Centripetal / Chordal Catmull-Rom var pow = this.curveType === 'chordal' ? 0.5 : 0.25; var dt0 = Math.pow( p0.distanceToSquared( p1 ), pow ); var dt1 = Math.pow( p1.distanceToSquared( p2 ), pow ); var dt2 = Math.pow( p2.distanceToSquared( p3 ), pow ); // safety check for repeated points if ( dt1 < 1e-4 ) dt1 = 1.0; if ( dt0 < 1e-4 ) dt0 = dt1; if ( dt2 < 1e-4 ) dt2 = dt1; px.initNonuniformCatmullRom( p0.x, p1.x, p2.x, p3.x, dt0, dt1, dt2 ); py.initNonuniformCatmullRom( p0.y, p1.y, p2.y, p3.y, dt0, dt1, dt2 ); pz.initNonuniformCatmullRom( p0.z, p1.z, p2.z, p3.z, dt0, dt1, dt2 ); } else if ( this.curveType === 'catmullrom' ) { px.initCatmullRom( p0.x, p1.x, p2.x, p3.x, this.tension ); py.initCatmullRom( p0.y, p1.y, p2.y, p3.y, this.tension ); pz.initCatmullRom( p0.z, p1.z, p2.z, p3.z, this.tension ); } point.set( px.calc( weight ), py.calc( weight ), pz.calc( weight ) ); return point; }; CatmullRomCurve3.prototype.copy = function ( source ) { Curve.prototype.copy.call( this, source ); this.points = []; for ( var i = 0, l = source.points.length; i < l; i ++ ) { var point = source.points[ i ]; this.points.push( point.clone() ); } this.closed = source.closed; this.curveType = source.curveType; this.tension = source.tension; return this; }; CatmullRomCurve3.prototype.toJSON = function () { var data = Curve.prototype.toJSON.call( this ); data.points = []; for ( var i = 0, l = this.points.length; i < l; i ++ ) { var point = this.points[ i ]; data.points.push( point.toArray() ); } data.closed = this.closed; data.curveType = this.curveType; data.tension = this.tension; return data; }; CatmullRomCurve3.prototype.fromJSON = function ( json ) { Curve.prototype.fromJSON.call( this, json ); this.points = []; for ( var i = 0, l = json.points.length; i < l; i ++ ) { var point = json.points[ i ]; this.points.push( new Vector3().fromArray( point ) ); } this.closed = json.closed; this.curveType = json.curveType; this.tension = json.tension; return this; }; /** * @author zz85 / http://www.lab4games.net/zz85/blog * * Bezier Curves formulas obtained from * http://en.wikipedia.org/wiki/Bézier_curve */ function CatmullRom( t, p0, p1, p2, p3 ) { var v0 = ( p2 - p0 ) * 0.5; var v1 = ( p3 - p1 ) * 0.5; var t2 = t * t; var t3 = t * t2; return ( 2 * p1 - 2 * p2 + v0 + v1 ) * t3 + ( - 3 * p1 + 3 * p2 - 2 * v0 - v1 ) * t2 + v0 * t + p1; } // function QuadraticBezierP0( t, p ) { var k = 1 - t; return k * k * p; } function QuadraticBezierP1( t, p ) { return 2 * ( 1 - t ) * t * p; } function QuadraticBezierP2( t, p ) { return t * t * p; } function QuadraticBezier( t, p0, p1, p2 ) { return QuadraticBezierP0( t, p0 ) + QuadraticBezierP1( t, p1 ) + QuadraticBezierP2( t, p2 ); } // function CubicBezierP0( t, p ) { var k = 1 - t; return k * k * k * p; } function CubicBezierP1( t, p ) { var k = 1 - t; return 3 * k * k * t * p; } function CubicBezierP2( t, p ) { return 3 * ( 1 - t ) * t * t * p; } function CubicBezierP3( t, p ) { return t * t * t * p; } function CubicBezier( t, p0, p1, p2, p3 ) { return CubicBezierP0( t, p0 ) + CubicBezierP1( t, p1 ) + CubicBezierP2( t, p2 ) + CubicBezierP3( t, p3 ); } function CubicBezierCurve( v0, v1, v2, v3 ) { Curve.call( this ); this.type = 'CubicBezierCurve'; this.v0 = v0 || new Vector2(); this.v1 = v1 || new Vector2(); this.v2 = v2 || new Vector2(); this.v3 = v3 || new Vector2(); } CubicBezierCurve.prototype = Object.create( Curve.prototype ); CubicBezierCurve.prototype.constructor = CubicBezierCurve; CubicBezierCurve.prototype.isCubicBezierCurve = true; CubicBezierCurve.prototype.getPoint = function ( t, optionalTarget ) { var point = optionalTarget || new Vector2(); var v0 = this.v0, v1 = this.v1, v2 = this.v2, v3 = this.v3; point.set( CubicBezier( t, v0.x, v1.x, v2.x, v3.x ), CubicBezier( t, v0.y, v1.y, v2.y, v3.y ) ); return point; }; CubicBezierCurve.prototype.copy = function ( source ) { Curve.prototype.copy.call( this, source ); this.v0.copy( source.v0 ); this.v1.copy( source.v1 ); this.v2.copy( source.v2 ); this.v3.copy( source.v3 ); return this; }; CubicBezierCurve.prototype.toJSON = function () { var data = Curve.prototype.toJSON.call( this ); data.v0 = this.v0.toArray(); data.v1 = this.v1.toArray(); data.v2 = this.v2.toArray(); data.v3 = this.v3.toArray(); return data; }; CubicBezierCurve.prototype.fromJSON = function ( json ) { Curve.prototype.fromJSON.call( this, json ); this.v0.fromArray( json.v0 ); this.v1.fromArray( json.v1 ); this.v2.fromArray( json.v2 ); this.v3.fromArray( json.v3 ); return this; }; function CubicBezierCurve3( v0, v1, v2, v3 ) { Curve.call( this ); this.type = 'CubicBezierCurve3'; this.v0 = v0 || new Vector3(); this.v1 = v1 || new Vector3(); this.v2 = v2 || new Vector3(); this.v3 = v3 || new Vector3(); } CubicBezierCurve3.prototype = Object.create( Curve.prototype ); CubicBezierCurve3.prototype.constructor = CubicBezierCurve3; CubicBezierCurve3.prototype.isCubicBezierCurve3 = true; CubicBezierCurve3.prototype.getPoint = function ( t, optionalTarget ) { var point = optionalTarget || new Vector3(); var v0 = this.v0, v1 = this.v1, v2 = this.v2, v3 = this.v3; point.set( CubicBezier( t, v0.x, v1.x, v2.x, v3.x ), CubicBezier( t, v0.y, v1.y, v2.y, v3.y ), CubicBezier( t, v0.z, v1.z, v2.z, v3.z ) ); return point; }; CubicBezierCurve3.prototype.copy = function ( source ) { Curve.prototype.copy.call( this, source ); this.v0.copy( source.v0 ); this.v1.copy( source.v1 ); this.v2.copy( source.v2 ); this.v3.copy( source.v3 ); return this; }; CubicBezierCurve3.prototype.toJSON = function () { var data = Curve.prototype.toJSON.call( this ); data.v0 = this.v0.toArray(); data.v1 = this.v1.toArray(); data.v2 = this.v2.toArray(); data.v3 = this.v3.toArray(); return data; }; CubicBezierCurve3.prototype.fromJSON = function ( json ) { Curve.prototype.fromJSON.call( this, json ); this.v0.fromArray( json.v0 ); this.v1.fromArray( json.v1 ); this.v2.fromArray( json.v2 ); this.v3.fromArray( json.v3 ); return this; }; function LineCurve( v1, v2 ) { Curve.call( this ); this.type = 'LineCurve'; this.v1 = v1 || new Vector2(); this.v2 = v2 || new Vector2(); } LineCurve.prototype = Object.create( Curve.prototype ); LineCurve.prototype.constructor = LineCurve; LineCurve.prototype.isLineCurve = true; LineCurve.prototype.getPoint = function ( t, optionalTarget ) { var point = optionalTarget || new Vector2(); if ( t === 1 ) { point.copy( this.v2 ); } else { point.copy( this.v2 ).sub( this.v1 ); point.multiplyScalar( t ).add( this.v1 ); } return point; }; // Line curve is linear, so we can overwrite default getPointAt LineCurve.prototype.getPointAt = function ( u, optionalTarget ) { return this.getPoint( u, optionalTarget ); }; LineCurve.prototype.getTangent = function ( /* t */ ) { var tangent = this.v2.clone().sub( this.v1 ); return tangent.normalize(); }; LineCurve.prototype.copy = function ( source ) { Curve.prototype.copy.call( this, source ); this.v1.copy( source.v1 ); this.v2.copy( source.v2 ); return this; }; LineCurve.prototype.toJSON = function () { var data = Curve.prototype.toJSON.call( this ); data.v1 = this.v1.toArray(); data.v2 = this.v2.toArray(); return data; }; LineCurve.prototype.fromJSON = function ( json ) { Curve.prototype.fromJSON.call( this, json ); this.v1.fromArray( json.v1 ); this.v2.fromArray( json.v2 ); return this; }; function LineCurve3( v1, v2 ) { Curve.call( this ); this.type = 'LineCurve3'; this.v1 = v1 || new Vector3(); this.v2 = v2 || new Vector3(); } LineCurve3.prototype = Object.create( Curve.prototype ); LineCurve3.prototype.constructor = LineCurve3; LineCurve3.prototype.isLineCurve3 = true; LineCurve3.prototype.getPoint = function ( t, optionalTarget ) { var point = optionalTarget || new Vector3(); if ( t === 1 ) { point.copy( this.v2 ); } else { point.copy( this.v2 ).sub( this.v1 ); point.multiplyScalar( t ).add( this.v1 ); } return point; }; // Line curve is linear, so we can overwrite default getPointAt LineCurve3.prototype.getPointAt = function ( u, optionalTarget ) { return this.getPoint( u, optionalTarget ); }; LineCurve3.prototype.copy = function ( source ) { Curve.prototype.copy.call( this, source ); this.v1.copy( source.v1 ); this.v2.copy( source.v2 ); return this; }; LineCurve3.prototype.toJSON = function () { var data = Curve.prototype.toJSON.call( this ); data.v1 = this.v1.toArray(); data.v2 = this.v2.toArray(); return data; }; LineCurve3.prototype.fromJSON = function ( json ) { Curve.prototype.fromJSON.call( this, json ); this.v1.fromArray( json.v1 ); this.v2.fromArray( json.v2 ); return this; }; function QuadraticBezierCurve( v0, v1, v2 ) { Curve.call( this ); this.type = 'QuadraticBezierCurve'; this.v0 = v0 || new Vector2(); this.v1 = v1 || new Vector2(); this.v2 = v2 || new Vector2(); } QuadraticBezierCurve.prototype = Object.create( Curve.prototype ); QuadraticBezierCurve.prototype.constructor = QuadraticBezierCurve; QuadraticBezierCurve.prototype.isQuadraticBezierCurve = true; QuadraticBezierCurve.prototype.getPoint = function ( t, optionalTarget ) { var point = optionalTarget || new Vector2(); var v0 = this.v0, v1 = this.v1, v2 = this.v2; point.set( QuadraticBezier( t, v0.x, v1.x, v2.x ), QuadraticBezier( t, v0.y, v1.y, v2.y ) ); return point; }; QuadraticBezierCurve.prototype.copy = function ( source ) { Curve.prototype.copy.call( this, source ); this.v0.copy( source.v0 ); this.v1.copy( source.v1 ); this.v2.copy( source.v2 ); return this; }; QuadraticBezierCurve.prototype.toJSON = function () { var data = Curve.prototype.toJSON.call( this ); data.v0 = this.v0.toArray(); data.v1 = this.v1.toArray(); data.v2 = this.v2.toArray(); return data; }; QuadraticBezierCurve.prototype.fromJSON = function ( json ) { Curve.prototype.fromJSON.call( this, json ); this.v0.fromArray( json.v0 ); this.v1.fromArray( json.v1 ); this.v2.fromArray( json.v2 ); return this; }; function QuadraticBezierCurve3( v0, v1, v2 ) { Curve.call( this ); this.type = 'QuadraticBezierCurve3'; this.v0 = v0 || new Vector3(); this.v1 = v1 || new Vector3(); this.v2 = v2 || new Vector3(); } QuadraticBezierCurve3.prototype = Object.create( Curve.prototype ); QuadraticBezierCurve3.prototype.constructor = QuadraticBezierCurve3; QuadraticBezierCurve3.prototype.isQuadraticBezierCurve3 = true; QuadraticBezierCurve3.prototype.getPoint = function ( t, optionalTarget ) { var point = optionalTarget || new Vector3(); var v0 = this.v0, v1 = this.v1, v2 = this.v2; point.set( QuadraticBezier( t, v0.x, v1.x, v2.x ), QuadraticBezier( t, v0.y, v1.y, v2.y ), QuadraticBezier( t, v0.z, v1.z, v2.z ) ); return point; }; QuadraticBezierCurve3.prototype.copy = function ( source ) { Curve.prototype.copy.call( this, source ); this.v0.copy( source.v0 ); this.v1.copy( source.v1 ); this.v2.copy( source.v2 ); return this; }; QuadraticBezierCurve3.prototype.toJSON = function () { var data = Curve.prototype.toJSON.call( this ); data.v0 = this.v0.toArray(); data.v1 = this.v1.toArray(); data.v2 = this.v2.toArray(); return data; }; QuadraticBezierCurve3.prototype.fromJSON = function ( json ) { Curve.prototype.fromJSON.call( this, json ); this.v0.fromArray( json.v0 ); this.v1.fromArray( json.v1 ); this.v2.fromArray( json.v2 ); return this; }; function SplineCurve( points /* array of Vector2 */ ) { Curve.call( this ); this.type = 'SplineCurve'; this.points = points || []; } SplineCurve.prototype = Object.create( Curve.prototype ); SplineCurve.prototype.constructor = SplineCurve; SplineCurve.prototype.isSplineCurve = true; SplineCurve.prototype.getPoint = function ( t, optionalTarget ) { var point = optionalTarget || new Vector2(); var points = this.points; var p = ( points.length - 1 ) * t; var intPoint = Math.floor( p ); var weight = p - intPoint; var p0 = points[ intPoint === 0 ? intPoint : intPoint - 1 ]; var p1 = points[ intPoint ]; var p2 = points[ intPoint > points.length - 2 ? points.length - 1 : intPoint + 1 ]; var p3 = points[ intPoint > points.length - 3 ? points.length - 1 : intPoint + 2 ]; point.set( CatmullRom( weight, p0.x, p1.x, p2.x, p3.x ), CatmullRom( weight, p0.y, p1.y, p2.y, p3.y ) ); return point; }; SplineCurve.prototype.copy = function ( source ) { Curve.prototype.copy.call( this, source ); this.points = []; for ( var i = 0, l = source.points.length; i < l; i ++ ) { var point = source.points[ i ]; this.points.push( point.clone() ); } return this; }; SplineCurve.prototype.toJSON = function () { var data = Curve.prototype.toJSON.call( this ); data.points = []; for ( var i = 0, l = this.points.length; i < l; i ++ ) { var point = this.points[ i ]; data.points.push( point.toArray() ); } return data; }; SplineCurve.prototype.fromJSON = function ( json ) { Curve.prototype.fromJSON.call( this, json ); this.points = []; for ( var i = 0, l = json.points.length; i < l; i ++ ) { var point = json.points[ i ]; this.points.push( new Vector2().fromArray( point ) ); } return this; }; var Curves = /*#__PURE__*/Object.freeze({ ArcCurve: ArcCurve, CatmullRomCurve3: CatmullRomCurve3, CubicBezierCurve: CubicBezierCurve, CubicBezierCurve3: CubicBezierCurve3, EllipseCurve: EllipseCurve, LineCurve: LineCurve, LineCurve3: LineCurve3, QuadraticBezierCurve: QuadraticBezierCurve, QuadraticBezierCurve3: QuadraticBezierCurve3, SplineCurve: SplineCurve }); /** * @author zz85 / http://www.lab4games.net/zz85/blog * **/ /************************************************************** * Curved Path - a curve path is simply a array of connected * curves, but retains the api of a curve **************************************************************/ function CurvePath() { Curve.call( this ); this.type = 'CurvePath'; this.curves = []; this.autoClose = false; // Automatically closes the path } CurvePath.prototype = Object.assign( Object.create( Curve.prototype ), { constructor: CurvePath, add: function ( curve ) { this.curves.push( curve ); }, closePath: function () { // Add a line curve if start and end of lines are not connected var startPoint = this.curves[ 0 ].getPoint( 0 ); var endPoint = this.curves[ this.curves.length - 1 ].getPoint( 1 ); if ( ! startPoint.equals( endPoint ) ) { this.curves.push( new LineCurve( endPoint, startPoint ) ); } }, // To get accurate point with reference to // entire path distance at time t, // following has to be done: // 1. Length of each sub path have to be known // 2. Locate and identify type of curve // 3. Get t for the curve // 4. Return curve.getPointAt(t') getPoint: function ( t ) { var d = t * this.getLength(); var curveLengths = this.getCurveLengths(); var i = 0; // To think about boundaries points. while ( i < curveLengths.length ) { if ( curveLengths[ i ] >= d ) { var diff = curveLengths[ i ] - d; var curve = this.curves[ i ]; var segmentLength = curve.getLength(); var u = segmentLength === 0 ? 0 : 1 - diff / segmentLength; return curve.getPointAt( u ); } i ++; } return null; // loop where sum != 0, sum > d , sum+1 0 ) { // if a previous curve is present, attempt to join var firstPoint = curve.getPoint( 0 ); if ( ! firstPoint.equals( this.currentPoint ) ) { this.lineTo( firstPoint.x, firstPoint.y ); } } this.curves.push( curve ); var lastPoint = curve.getPoint( 1 ); this.currentPoint.copy( lastPoint ); }, copy: function ( source ) { CurvePath.prototype.copy.call( this, source ); this.currentPoint.copy( source.currentPoint ); return this; }, toJSON: function () { var data = CurvePath.prototype.toJSON.call( this ); data.currentPoint = this.currentPoint.toArray(); return data; }, fromJSON: function ( json ) { CurvePath.prototype.fromJSON.call( this, json ); this.currentPoint.fromArray( json.currentPoint ); return this; } } ); /** * @author zz85 / http://www.lab4games.net/zz85/blog * Defines a 2d shape plane using paths. **/ // STEP 1 Create a path. // STEP 2 Turn path into shape. // STEP 3 ExtrudeGeometry takes in Shape/Shapes // STEP 3a - Extract points from each shape, turn to vertices // STEP 3b - Triangulate each shape, add faces. function Shape( points ) { Path.call( this, points ); this.uuid = _Math.generateUUID(); this.type = 'Shape'; this.holes = []; } Shape.prototype = Object.assign( Object.create( Path.prototype ), { constructor: Shape, getPointsHoles: function ( divisions ) { var holesPts = []; for ( var i = 0, l = this.holes.length; i < l; i ++ ) { holesPts[ i ] = this.holes[ i ].getPoints( divisions ); } return holesPts; }, // get points of shape and holes (keypoints based on segments parameter) extractPoints: function ( divisions ) { return { shape: this.getPoints( divisions ), holes: this.getPointsHoles( divisions ) }; }, copy: function ( source ) { Path.prototype.copy.call( this, source ); this.holes = []; for ( var i = 0, l = source.holes.length; i < l; i ++ ) { var hole = source.holes[ i ]; this.holes.push( hole.clone() ); } return this; }, toJSON: function () { var data = Path.prototype.toJSON.call( this ); data.uuid = this.uuid; data.holes = []; for ( var i = 0, l = this.holes.length; i < l; i ++ ) { var hole = this.holes[ i ]; data.holes.push( hole.toJSON() ); } return data; }, fromJSON: function ( json ) { Path.prototype.fromJSON.call( this, json ); this.uuid = json.uuid; this.holes = []; for ( var i = 0, l = json.holes.length; i < l; i ++ ) { var hole = json.holes[ i ]; this.holes.push( new Path().fromJSON( hole ) ); } return this; } } ); /** * @author mrdoob / http://mrdoob.com/ * @author alteredq / http://alteredqualia.com/ */ function Light( color, intensity ) { Object3D.call( this ); this.type = 'Light'; this.color = new Color( color ); this.intensity = intensity !== undefined ? intensity : 1; this.receiveShadow = undefined; } Light.prototype = Object.assign( Object.create( Object3D.prototype ), { constructor: Light, isLight: true, copy: function ( source ) { Object3D.prototype.copy.call( this, source ); this.color.copy( source.color ); this.intensity = source.intensity; return this; }, toJSON: function ( meta ) { var data = Object3D.prototype.toJSON.call( this, meta ); data.object.color = this.color.getHex(); data.object.intensity = this.intensity; if ( this.groundColor !== undefined ) data.object.groundColor = this.groundColor.getHex(); if ( this.distance !== undefined ) data.object.distance = this.distance; if ( this.angle !== undefined ) data.object.angle = this.angle; if ( this.decay !== undefined ) data.object.decay = this.decay; if ( this.penumbra !== undefined ) data.object.penumbra = this.penumbra; if ( this.shadow !== undefined ) data.object.shadow = this.shadow.toJSON(); return data; } } ); /** * @author alteredq / http://alteredqualia.com/ */ function HemisphereLight( skyColor, groundColor, intensity ) { Light.call( this, skyColor, intensity ); this.type = 'HemisphereLight'; this.castShadow = undefined; this.position.copy( Object3D.DefaultUp ); this.updateMatrix(); this.groundColor = new Color( groundColor ); } HemisphereLight.prototype = Object.assign( Object.create( Light.prototype ), { constructor: HemisphereLight, isHemisphereLight: true, copy: function ( source ) { Light.prototype.copy.call( this, source ); this.groundColor.copy( source.groundColor ); return this; } } ); /** * @author mrdoob / http://mrdoob.com/ */ function LightShadow( camera ) { this.camera = camera; this.bias = 0; this.radius = 1; this.mapSize = new Vector2( 512, 512 ); this.map = null; this.matrix = new Matrix4(); } Object.assign( LightShadow.prototype, { copy: function ( source ) { this.camera = source.camera.clone(); this.bias = source.bias; this.radius = source.radius; this.mapSize.copy( source.mapSize ); return this; }, clone: function () { return new this.constructor().copy( this ); }, toJSON: function () { var object = {}; if ( this.bias !== 0 ) object.bias = this.bias; if ( this.radius !== 1 ) object.radius = this.radius; if ( this.mapSize.x !== 512 || this.mapSize.y !== 512 ) object.mapSize = this.mapSize.toArray(); object.camera = this.camera.toJSON( false ).object; delete object.camera.matrix; return object; } } ); /** * @author mrdoob / http://mrdoob.com/ */ function SpotLightShadow() { LightShadow.call( this, new PerspectiveCamera( 50, 1, 0.5, 500 ) ); } SpotLightShadow.prototype = Object.assign( Object.create( LightShadow.prototype ), { constructor: SpotLightShadow, isSpotLightShadow: true, update: function ( light ) { var camera = this.camera; var fov = _Math.RAD2DEG * 2 * light.angle; var aspect = this.mapSize.width / this.mapSize.height; var far = light.distance || camera.far; if ( fov !== camera.fov || aspect !== camera.aspect || far !== camera.far ) { camera.fov = fov; camera.aspect = aspect; camera.far = far; camera.updateProjectionMatrix(); } } } ); /** * @author alteredq / http://alteredqualia.com/ */ function SpotLight( color, intensity, distance, angle, penumbra, decay ) { Light.call( this, color, intensity ); this.type = 'SpotLight'; this.position.copy( Object3D.DefaultUp ); this.updateMatrix(); this.target = new Object3D(); Object.defineProperty( this, 'power', { get: function () { // intensity = power per solid angle. // ref: equation (17) from https://seblagarde.files.wordpress.com/2015/07/course_notes_moving_frostbite_to_pbr_v32.pdf return this.intensity * Math.PI; }, set: function ( power ) { // intensity = power per solid angle. // ref: equation (17) from https://seblagarde.files.wordpress.com/2015/07/course_notes_moving_frostbite_to_pbr_v32.pdf this.intensity = power / Math.PI; } } ); this.distance = ( distance !== undefined ) ? distance : 0; this.angle = ( angle !== undefined ) ? angle : Math.PI / 3; this.penumbra = ( penumbra !== undefined ) ? penumbra : 0; this.decay = ( decay !== undefined ) ? decay : 1; // for physically correct lights, should be 2. this.shadow = new SpotLightShadow(); } SpotLight.prototype = Object.assign( Object.create( Light.prototype ), { constructor: SpotLight, isSpotLight: true, copy: function ( source ) { Light.prototype.copy.call( this, source ); this.distance = source.distance; this.angle = source.angle; this.penumbra = source.penumbra; this.decay = source.decay; this.target = source.target.clone(); this.shadow = source.shadow.clone(); return this; } } ); /** * @author mrdoob / http://mrdoob.com/ */ function PointLight( color, intensity, distance, decay ) { Light.call( this, color, intensity ); this.type = 'PointLight'; Object.defineProperty( this, 'power', { get: function () { // intensity = power per solid angle. // ref: equation (15) from https://seblagarde.files.wordpress.com/2015/07/course_notes_moving_frostbite_to_pbr_v32.pdf return this.intensity * 4 * Math.PI; }, set: function ( power ) { // intensity = power per solid angle. // ref: equation (15) from https://seblagarde.files.wordpress.com/2015/07/course_notes_moving_frostbite_to_pbr_v32.pdf this.intensity = power / ( 4 * Math.PI ); } } ); this.distance = ( distance !== undefined ) ? distance : 0; this.decay = ( decay !== undefined ) ? decay : 1; // for physically correct lights, should be 2. this.shadow = new LightShadow( new PerspectiveCamera( 90, 1, 0.5, 500 ) ); } PointLight.prototype = Object.assign( Object.create( Light.prototype ), { constructor: PointLight, isPointLight: true, copy: function ( source ) { Light.prototype.copy.call( this, source ); this.distance = source.distance; this.decay = source.decay; this.shadow = source.shadow.clone(); return this; } } ); /** * @author alteredq / http://alteredqualia.com/ * @author arose / http://github.com/arose */ function OrthographicCamera( left, right, top, bottom, near, far ) { Camera.call( this ); this.type = 'OrthographicCamera'; this.zoom = 1; this.view = null; this.left = ( left !== undefined ) ? left : - 1; this.right = ( right !== undefined ) ? right : 1; this.top = ( top !== undefined ) ? top : 1; this.bottom = ( bottom !== undefined ) ? bottom : - 1; this.near = ( near !== undefined ) ? near : 0.1; this.far = ( far !== undefined ) ? far : 2000; this.updateProjectionMatrix(); } OrthographicCamera.prototype = Object.assign( Object.create( Camera.prototype ), { constructor: OrthographicCamera, isOrthographicCamera: true, copy: function ( source, recursive ) { Camera.prototype.copy.call( this, source, recursive ); this.left = source.left; this.right = source.right; this.top = source.top; this.bottom = source.bottom; this.near = source.near; this.far = source.far; this.zoom = source.zoom; this.view = source.view === null ? null : Object.assign( {}, source.view ); return this; }, setViewOffset: function ( fullWidth, fullHeight, x, y, width, height ) { if ( this.view === null ) { this.view = { enabled: true, fullWidth: 1, fullHeight: 1, offsetX: 0, offsetY: 0, width: 1, height: 1 }; } this.view.enabled = true; this.view.fullWidth = fullWidth; this.view.fullHeight = fullHeight; this.view.offsetX = x; this.view.offsetY = y; this.view.width = width; this.view.height = height; this.updateProjectionMatrix(); }, clearViewOffset: function () { if ( this.view !== null ) { this.view.enabled = false; } this.updateProjectionMatrix(); }, updateProjectionMatrix: function () { var dx = ( this.right - this.left ) / ( 2 * this.zoom ); var dy = ( this.top - this.bottom ) / ( 2 * this.zoom ); var cx = ( this.right + this.left ) / 2; var cy = ( this.top + this.bottom ) / 2; var left = cx - dx; var right = cx + dx; var top = cy + dy; var bottom = cy - dy; if ( this.view !== null && this.view.enabled ) { var zoomW = this.zoom / ( this.view.width / this.view.fullWidth ); var zoomH = this.zoom / ( this.view.height / this.view.fullHeight ); var scaleW = ( this.right - this.left ) / this.view.width; var scaleH = ( this.top - this.bottom ) / this.view.height; left += scaleW * ( this.view.offsetX / zoomW ); right = left + scaleW * ( this.view.width / zoomW ); top -= scaleH * ( this.view.offsetY / zoomH ); bottom = top - scaleH * ( this.view.height / zoomH ); } this.projectionMatrix.makeOrthographic( left, right, top, bottom, this.near, this.far ); this.projectionMatrixInverse.getInverse( this.projectionMatrix ); }, toJSON: function ( meta ) { var data = Object3D.prototype.toJSON.call( this, meta ); data.object.zoom = this.zoom; data.object.left = this.left; data.object.right = this.right; data.object.top = this.top; data.object.bottom = this.bottom; data.object.near = this.near; data.object.far = this.far; if ( this.view !== null ) data.object.view = Object.assign( {}, this.view ); return data; } } ); /** * @author mrdoob / http://mrdoob.com/ */ function DirectionalLightShadow( ) { LightShadow.call( this, new OrthographicCamera( - 5, 5, 5, - 5, 0.5, 500 ) ); } DirectionalLightShadow.prototype = Object.assign( Object.create( LightShadow.prototype ), { constructor: DirectionalLightShadow } ); /** * @author mrdoob / http://mrdoob.com/ * @author alteredq / http://alteredqualia.com/ */ function DirectionalLight( color, intensity ) { Light.call( this, color, intensity ); this.type = 'DirectionalLight'; this.position.copy( Object3D.DefaultUp ); this.updateMatrix(); this.target = new Object3D(); this.shadow = new DirectionalLightShadow(); } DirectionalLight.prototype = Object.assign( Object.create( Light.prototype ), { constructor: DirectionalLight, isDirectionalLight: true, copy: function ( source ) { Light.prototype.copy.call( this, source ); this.target = source.target.clone(); this.shadow = source.shadow.clone(); return this; } } ); /** * @author mrdoob / http://mrdoob.com/ */ function AmbientLight( color, intensity ) { Light.call( this, color, intensity ); this.type = 'AmbientLight'; this.castShadow = undefined; } AmbientLight.prototype = Object.assign( Object.create( Light.prototype ), { constructor: AmbientLight, isAmbientLight: true } ); /** * @author abelnation / http://github.com/abelnation */ function RectAreaLight( color, intensity, width, height ) { Light.call( this, color, intensity ); this.type = 'RectAreaLight'; this.width = ( width !== undefined ) ? width : 10; this.height = ( height !== undefined ) ? height : 10; } RectAreaLight.prototype = Object.assign( Object.create( Light.prototype ), { constructor: RectAreaLight, isRectAreaLight: true, copy: function ( source ) { Light.prototype.copy.call( this, source ); this.width = source.width; this.height = source.height; return this; }, toJSON: function ( meta ) { var data = Light.prototype.toJSON.call( this, meta ); data.object.width = this.width; data.object.height = this.height; return data; } } ); /** * @author mrdoob / http://mrdoob.com/ */ function MaterialLoader( manager ) { this.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager; this.textures = {}; } Object.assign( MaterialLoader.prototype, { load: function ( url, onLoad, onProgress, onError ) { var scope = this; var loader = new FileLoader( scope.manager ); loader.setPath( scope.path ); loader.load( url, function ( text ) { onLoad( scope.parse( JSON.parse( text ) ) ); }, onProgress, onError ); }, parse: function ( json ) { var textures = this.textures; function getTexture( name ) { if ( textures[ name ] === undefined ) { console.warn( 'THREE.MaterialLoader: Undefined texture', name ); } return textures[ name ]; } var material = new Materials[ json.type ](); if ( json.uuid !== undefined ) material.uuid = json.uuid; if ( json.name !== undefined ) material.name = json.name; if ( json.color !== undefined ) material.color.setHex( json.color ); if ( json.roughness !== undefined ) material.roughness = json.roughness; if ( json.metalness !== undefined ) material.metalness = json.metalness; if ( json.emissive !== undefined ) material.emissive.setHex( json.emissive ); if ( json.specular !== undefined ) material.specular.setHex( json.specular ); if ( json.shininess !== undefined ) material.shininess = json.shininess; if ( json.clearCoat !== undefined ) material.clearCoat = json.clearCoat; if ( json.clearCoatRoughness !== undefined ) material.clearCoatRoughness = json.clearCoatRoughness; if ( json.vertexColors !== undefined ) material.vertexColors = json.vertexColors; if ( json.fog !== undefined ) material.fog = json.fog; if ( json.flatShading !== undefined ) material.flatShading = json.flatShading; if ( json.blending !== undefined ) material.blending = json.blending; if ( json.combine !== undefined ) material.combine = json.combine; if ( json.side !== undefined ) material.side = json.side; if ( json.opacity !== undefined ) material.opacity = json.opacity; if ( json.transparent !== undefined ) material.transparent = json.transparent; if ( json.alphaTest !== undefined ) material.alphaTest = json.alphaTest; if ( json.depthTest !== undefined ) material.depthTest = json.depthTest; if ( json.depthWrite !== undefined ) material.depthWrite = json.depthWrite; if ( json.colorWrite !== undefined ) material.colorWrite = json.colorWrite; if ( json.wireframe !== undefined ) material.wireframe = json.wireframe; if ( json.wireframeLinewidth !== undefined ) material.wireframeLinewidth = json.wireframeLinewidth; if ( json.wireframeLinecap !== undefined ) material.wireframeLinecap = json.wireframeLinecap; if ( json.wireframeLinejoin !== undefined ) material.wireframeLinejoin = json.wireframeLinejoin; if ( json.rotation !== undefined ) material.rotation = json.rotation; if ( json.linewidth !== 1 ) material.linewidth = json.linewidth; if ( json.dashSize !== undefined ) material.dashSize = json.dashSize; if ( json.gapSize !== undefined ) material.gapSize = json.gapSize; if ( json.scale !== undefined ) material.scale = json.scale; if ( json.polygonOffset !== undefined ) material.polygonOffset = json.polygonOffset; if ( json.polygonOffsetFactor !== undefined ) material.polygonOffsetFactor = json.polygonOffsetFactor; if ( json.polygonOffsetUnits !== undefined ) material.polygonOffsetUnits = json.polygonOffsetUnits; if ( json.skinning !== undefined ) material.skinning = json.skinning; if ( json.morphTargets !== undefined ) material.morphTargets = json.morphTargets; if ( json.dithering !== undefined ) material.dithering = json.dithering; if ( json.visible !== undefined ) material.visible = json.visible; if ( json.userData !== undefined ) material.userData = json.userData; // Shader Material if ( json.uniforms !== undefined ) { for ( var name in json.uniforms ) { var uniform = json.uniforms[ name ]; material.uniforms[ name ] = {}; switch ( uniform.type ) { case 't': material.uniforms[ name ].value = getTexture( uniform.value ); break; case 'c': material.uniforms[ name ].value = new Color().setHex( uniform.value ); break; case 'v2': material.uniforms[ name ].value = new Vector2().fromArray( uniform.value ); break; case 'v3': material.uniforms[ name ].value = new Vector3().fromArray( uniform.value ); break; case 'v4': material.uniforms[ name ].value = new Vector4().fromArray( uniform.value ); break; case 'm3': material.uniforms[ name ].value = new Matrix3().fromArray( uniform.value ); case 'm4': material.uniforms[ name ].value = new Matrix4().fromArray( uniform.value ); break; default: material.uniforms[ name ].value = uniform.value; } } } if ( json.defines !== undefined ) material.defines = json.defines; if ( json.vertexShader !== undefined ) material.vertexShader = json.vertexShader; if ( json.fragmentShader !== undefined ) material.fragmentShader = json.fragmentShader; if ( json.extensions !== undefined ) { for ( var key in json.extensions ) { material.extensions[ key ] = json.extensions[ key ]; } } // Deprecated if ( json.shading !== undefined ) material.flatShading = json.shading === 1; // THREE.FlatShading // for PointsMaterial if ( json.size !== undefined ) material.size = json.size; if ( json.sizeAttenuation !== undefined ) material.sizeAttenuation = json.sizeAttenuation; // maps if ( json.map !== undefined ) material.map = getTexture( json.map ); if ( json.alphaMap !== undefined ) { material.alphaMap = getTexture( json.alphaMap ); material.transparent = true; } if ( json.bumpMap !== undefined ) material.bumpMap = getTexture( json.bumpMap ); if ( json.bumpScale !== undefined ) material.bumpScale = json.bumpScale; if ( json.normalMap !== undefined ) material.normalMap = getTexture( json.normalMap ); if ( json.normalMapType !== undefined ) material.normalMapType = json.normalMapType; if ( json.normalScale !== undefined ) { var normalScale = json.normalScale; if ( Array.isArray( normalScale ) === false ) { // Blender exporter used to export a scalar. See #7459 normalScale = [ normalScale, normalScale ]; } material.normalScale = new Vector2().fromArray( normalScale ); } if ( json.displacementMap !== undefined ) material.displacementMap = getTexture( json.displacementMap ); if ( json.displacementScale !== undefined ) material.displacementScale = json.displacementScale; if ( json.displacementBias !== undefined ) material.displacementBias = json.displacementBias; if ( json.roughnessMap !== undefined ) material.roughnessMap = getTexture( json.roughnessMap ); if ( json.metalnessMap !== undefined ) material.metalnessMap = getTexture( json.metalnessMap ); if ( json.emissiveMap !== undefined ) material.emissiveMap = getTexture( json.emissiveMap ); if ( json.emissiveIntensity !== undefined ) material.emissiveIntensity = json.emissiveIntensity; if ( json.specularMap !== undefined ) material.specularMap = getTexture( json.specularMap ); if ( json.envMap !== undefined ) material.envMap = getTexture( json.envMap ); if ( json.envMapIntensity !== undefined ) material.envMapIntensity = json.envMapIntensity; if ( json.reflectivity !== undefined ) material.reflectivity = json.reflectivity; if ( json.lightMap !== undefined ) material.lightMap = getTexture( json.lightMap ); if ( json.lightMapIntensity !== undefined ) material.lightMapIntensity = json.lightMapIntensity; if ( json.aoMap !== undefined ) material.aoMap = getTexture( json.aoMap ); if ( json.aoMapIntensity !== undefined ) material.aoMapIntensity = json.aoMapIntensity; if ( json.gradientMap !== undefined ) material.gradientMap = getTexture( json.gradientMap ); return material; }, setPath: function ( value ) { this.path = value; return this; }, setTextures: function ( value ) { this.textures = value; return this; } } ); /** * @author Don McCurdy / https://www.donmccurdy.com */ var LoaderUtils = { decodeText: function ( array ) { if ( typeof TextDecoder !== 'undefined' ) { return new TextDecoder().decode( array ); } // Avoid the String.fromCharCode.apply(null, array) shortcut, which // throws a \"maximum call stack size exceeded\" error for large arrays. var s = ''; for ( var i = 0, il = array.length; i < il; i ++ ) { // Implicitly assumes little-endian. s += String.fromCharCode( array[ i ] ); } // Merges multi-byte utf-8 characters. return decodeURIComponent( escape( s ) ); }, extractUrlBase: function ( url ) { var index = url.lastIndexOf( '/' ); if ( index === - 1 ) return './'; return url.substr( 0, index + 1 ); } }; /** * @author mrdoob / http://mrdoob.com/ */ function BufferGeometryLoader( manager ) { this.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager; } Object.assign( BufferGeometryLoader.prototype, { load: function ( url, onLoad, onProgress, onError ) { var scope = this; var loader = new FileLoader( scope.manager ); loader.setPath( scope.path ); loader.load( url, function ( text ) { onLoad( scope.parse( JSON.parse( text ) ) ); }, onProgress, onError ); }, parse: function ( json ) { var geometry = new BufferGeometry(); var index = json.data.index; if ( index !== undefined ) { var typedArray = new TYPED_ARRAYS[ index.type ]( index.array ); geometry.setIndex( new BufferAttribute( typedArray, 1 ) ); } var attributes = json.data.attributes; for ( var key in attributes ) { var attribute = attributes[ key ]; var typedArray = new TYPED_ARRAYS[ attribute.type ]( attribute.array ); geometry.addAttribute( key, new BufferAttribute( typedArray, attribute.itemSize, attribute.normalized ) ); } var groups = json.data.groups || json.data.drawcalls || json.data.offsets; if ( groups !== undefined ) { for ( var i = 0, n = groups.length; i !== n; ++ i ) { var group = groups[ i ]; geometry.addGroup( group.start, group.count, group.materialIndex ); } } var boundingSphere = json.data.boundingSphere; if ( boundingSphere !== undefined ) { var center = new Vector3(); if ( boundingSphere.center !== undefined ) { center.fromArray( boundingSphere.center ); } geometry.boundingSphere = new Sphere( center, boundingSphere.radius ); } if ( json.name ) geometry.name = json.name; if ( json.userData ) geometry.userData = json.userData; return geometry; }, setPath: function ( value ) { this.path = value; return this; } } ); var TYPED_ARRAYS = { Int8Array: Int8Array, Uint8Array: Uint8Array, // Workaround for IE11 pre KB2929437. See #11440 Uint8ClampedArray: typeof Uint8ClampedArray !== 'undefined' ? Uint8ClampedArray : Uint8Array, Int16Array: Int16Array, Uint16Array: Uint16Array, Int32Array: Int32Array, Uint32Array: Uint32Array, Float32Array: Float32Array, Float64Array: Float64Array }; /** * @author mrdoob / http://mrdoob.com/ */ function ObjectLoader( manager ) { this.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager; this.resourcePath = ''; } Object.assign( ObjectLoader.prototype, { crossOrigin: 'anonymous', load: function ( url, onLoad, onProgress, onError ) { var scope = this; var path = ( this.path === undefined ) ? LoaderUtils.extractUrlBase( url ) : this.path; this.resourcePath = this.resourcePath || path; var loader = new FileLoader( scope.manager ); loader.setPath( this.path ); loader.load( url, function ( text ) { var json = null; try { json = JSON.parse( text ); } catch ( error ) { if ( onError !== undefined ) onError( error ); console.error( 'THREE:ObjectLoader: Can\\'t parse ' + url + '.', error.message ); return; } var metadata = json.metadata; if ( metadata === undefined || metadata.type === undefined || metadata.type.toLowerCase() === 'geometry' ) { console.error( 'THREE.ObjectLoader: Can\\'t load ' + url ); return; } scope.parse( json, onLoad ); }, onProgress, onError ); }, setPath: function ( value ) { this.path = value; return this; }, setResourcePath: function ( value ) { this.resourcePath = value; return this; }, setCrossOrigin: function ( value ) { this.crossOrigin = value; return this; }, parse: function ( json, onLoad ) { var shapes = this.parseShape( json.shapes ); var geometries = this.parseGeometries( json.geometries, shapes ); var images = this.parseImages( json.images, function () { if ( onLoad !== undefined ) onLoad( object ); } ); var textures = this.parseTextures( json.textures, images ); var materials = this.parseMaterials( json.materials, textures ); var object = this.parseObject( json.object, geometries, materials ); if ( json.animations ) { object.animations = this.parseAnimations( json.animations ); } if ( json.images === undefined || json.images.length === 0 ) { if ( onLoad !== undefined ) onLoad( object ); } return object; }, parseShape: function ( json ) { var shapes = {}; if ( json !== undefined ) { for ( var i = 0, l = json.length; i < l; i ++ ) { var shape = new Shape().fromJSON( json[ i ] ); shapes[ shape.uuid ] = shape; } } return shapes; }, parseGeometries: function ( json, shapes ) { var geometries = {}; if ( json !== undefined ) { var bufferGeometryLoader = new BufferGeometryLoader(); for ( var i = 0, l = json.length; i < l; i ++ ) { var geometry; var data = json[ i ]; switch ( data.type ) { case 'PlaneGeometry': case 'PlaneBufferGeometry': geometry = new Geometries[ data.type ]( data.width, data.height, data.widthSegments, data.heightSegments ); break; case 'BoxGeometry': case 'BoxBufferGeometry': case 'CubeGeometry': // backwards compatible geometry = new Geometries[ data.type ]( data.width, data.height, data.depth, data.widthSegments, data.heightSegments, data.depthSegments ); break; case 'CircleGeometry': case 'CircleBufferGeometry': geometry = new Geometries[ data.type ]( data.radius, data.segments, data.thetaStart, data.thetaLength ); break; case 'CylinderGeometry': case 'CylinderBufferGeometry': geometry = new Geometries[ data.type ]( data.radiusTop, data.radiusBottom, data.height, data.radialSegments, data.heightSegments, data.openEnded, data.thetaStart, data.thetaLength ); break; case 'ConeGeometry': case 'ConeBufferGeometry': geometry = new Geometries[ data.type ]( data.radius, data.height, data.radialSegments, data.heightSegments, data.openEnded, data.thetaStart, data.thetaLength ); break; case 'SphereGeometry': case 'SphereBufferGeometry': geometry = new Geometries[ data.type ]( data.radius, data.widthSegments, data.heightSegments, data.phiStart, data.phiLength, data.thetaStart, data.thetaLength ); break; case 'DodecahedronGeometry': case 'DodecahedronBufferGeometry': case 'IcosahedronGeometry': case 'IcosahedronBufferGeometry': case 'OctahedronGeometry': case 'OctahedronBufferGeometry': case 'TetrahedronGeometry': case 'TetrahedronBufferGeometry': geometry = new Geometries[ data.type ]( data.radius, data.detail ); break; case 'RingGeometry': case 'RingBufferGeometry': geometry = new Geometries[ data.type ]( data.innerRadius, data.outerRadius, data.thetaSegments, data.phiSegments, data.thetaStart, data.thetaLength ); break; case 'TorusGeometry': case 'TorusBufferGeometry': geometry = new Geometries[ data.type ]( data.radius, data.tube, data.radialSegments, data.tubularSegments, data.arc ); break; case 'TorusKnotGeometry': case 'TorusKnotBufferGeometry': geometry = new Geometries[ data.type ]( data.radius, data.tube, data.tubularSegments, data.radialSegments, data.p, data.q ); break; case 'LatheGeometry': case 'LatheBufferGeometry': geometry = new Geometries[ data.type ]( data.points, data.segments, data.phiStart, data.phiLength ); break; case 'PolyhedronGeometry': case 'PolyhedronBufferGeometry': geometry = new Geometries[ data.type ]( data.vertices, data.indices, data.radius, data.details ); break; case 'ShapeGeometry': case 'ShapeBufferGeometry': var geometryShapes = []; for ( var j = 0, jl = data.shapes.length; j < jl; j ++ ) { var shape = shapes[ data.shapes[ j ] ]; geometryShapes.push( shape ); } geometry = new Geometries[ data.type ]( geometryShapes, data.curveSegments ); break; case 'ExtrudeGeometry': case 'ExtrudeBufferGeometry': var geometryShapes = []; for ( var j = 0, jl = data.shapes.length; j < jl; j ++ ) { var shape = shapes[ data.shapes[ j ] ]; geometryShapes.push( shape ); } var extrudePath = data.options.extrudePath; if ( extrudePath !== undefined ) { data.options.extrudePath = new Curves[ extrudePath.type ]().fromJSON( extrudePath ); } geometry = new Geometries[ data.type ]( geometryShapes, data.options ); break; case 'BufferGeometry': geometry = bufferGeometryLoader.parse( data ); break; case 'Geometry': if ( 'THREE' in window && 'LegacyJSONLoader' in THREE ) { var geometryLoader = new THREE.LegacyJSONLoader(); geometry = geometryLoader.parse( data, this.resourcePath ).geometry; } else { console.error( 'THREE.ObjectLoader: You have to import LegacyJSONLoader in order load geometry data of type \"Geometry\".' ); } break; default: console.warn( 'THREE.ObjectLoader: Unsupported geometry type \"' + data.type + '\"' ); continue; } geometry.uuid = data.uuid; if ( data.name !== undefined ) geometry.name = data.name; if ( geometry.isBufferGeometry === true && data.userData !== undefined ) geometry.userData = data.userData; geometries[ data.uuid ] = geometry; } } return geometries; }, parseMaterials: function ( json, textures ) { var cache = {}; // MultiMaterial var materials = {}; if ( json !== undefined ) { var loader = new MaterialLoader(); loader.setTextures( textures ); for ( var i = 0, l = json.length; i < l; i ++ ) { var data = json[ i ]; if ( data.type === 'MultiMaterial' ) { // Deprecated var array = []; for ( var j = 0; j < data.materials.length; j ++ ) { var material = data.materials[ j ]; if ( cache[ material.uuid ] === undefined ) { cache[ material.uuid ] = loader.parse( material ); } array.push( cache[ material.uuid ] ); } materials[ data.uuid ] = array; } else { if ( cache[ data.uuid ] === undefined ) { cache[ data.uuid ] = loader.parse( data ); } materials[ data.uuid ] = cache[ data.uuid ]; } } } return materials; }, parseAnimations: function ( json ) { var animations = []; for ( var i = 0; i < json.length; i ++ ) { var data = json[ i ]; var clip = AnimationClip.parse( data ); if ( data.uuid !== undefined ) clip.uuid = data.uuid; animations.push( clip ); } return animations; }, parseImages: function ( json, onLoad ) { var scope = this; var images = {}; function loadImage( url ) { scope.manager.itemStart( url ); return loader.load( url, function () { scope.manager.itemEnd( url ); }, undefined, function () { scope.manager.itemError( url ); scope.manager.itemEnd( url ); } ); } if ( json !== undefined && json.length > 0 ) { var manager = new LoadingManager( onLoad ); var loader = new ImageLoader( manager ); loader.setCrossOrigin( this.crossOrigin ); for ( var i = 0, il = json.length; i < il; i ++ ) { var image = json[ i ]; var url = image.url; if ( Array.isArray( url ) ) { // load array of images e.g CubeTexture images[ image.uuid ] = []; for ( var j = 0, jl = url.length; j < jl; j ++ ) { var currentUrl = url[ j ]; var path = /^(\\/\\/)|([a-z]+:(\\/\\/)?)/i.test( currentUrl ) ? currentUrl : scope.resourcePath + currentUrl; images[ image.uuid ].push( loadImage( path ) ); } } else { // load single image var path = /^(\\/\\/)|([a-z]+:(\\/\\/)?)/i.test( image.url ) ? image.url : scope.resourcePath + image.url; images[ image.uuid ] = loadImage( path ); } } } return images; }, parseTextures: function ( json, images ) { function parseConstant( value, type ) { if ( typeof value === 'number' ) return value; console.warn( 'THREE.ObjectLoader.parseTexture: Constant should be in numeric form.', value ); return type[ value ]; } var textures = {}; if ( json !== undefined ) { for ( var i = 0, l = json.length; i < l; i ++ ) { var data = json[ i ]; if ( data.image === undefined ) { console.warn( 'THREE.ObjectLoader: No \"image\" specified for', data.uuid ); } if ( images[ data.image ] === undefined ) { console.warn( 'THREE.ObjectLoader: Undefined image', data.image ); } var texture; if ( Array.isArray( images[ data.image ] ) ) { texture = new CubeTexture( images[ data.image ] ); } else { texture = new Texture( images[ data.image ] ); } texture.needsUpdate = true; texture.uuid = data.uuid; if ( data.name !== undefined ) texture.name = data.name; if ( data.mapping !== undefined ) texture.mapping = parseConstant( data.mapping, TEXTURE_MAPPING ); if ( data.offset !== undefined ) texture.offset.fromArray( data.offset ); if ( data.repeat !== undefined ) texture.repeat.fromArray( data.repeat ); if ( data.center !== undefined ) texture.center.fromArray( data.center ); if ( data.rotation !== undefined ) texture.rotation = data.rotation; if ( data.wrap !== undefined ) { texture.wrapS = parseConstant( data.wrap[ 0 ], TEXTURE_WRAPPING ); texture.wrapT = parseConstant( data.wrap[ 1 ], TEXTURE_WRAPPING ); } if ( data.format !== undefined ) texture.format = data.format; if ( data.type !== undefined ) texture.type = data.type; if ( data.encoding !== undefined ) texture.encoding = data.encoding; if ( data.minFilter !== undefined ) texture.minFilter = parseConstant( data.minFilter, TEXTURE_FILTER ); if ( data.magFilter !== undefined ) texture.magFilter = parseConstant( data.magFilter, TEXTURE_FILTER ); if ( data.anisotropy !== undefined ) texture.anisotropy = data.anisotropy; if ( data.flipY !== undefined ) texture.flipY = data.flipY; if ( data.premultiplyAlpha !== undefined ) texture.premultiplyAlpha = data.premultiplyAlpha; if ( data.unpackAlignment !== undefined ) texture.unpackAlignment = data.unpackAlignment; textures[ data.uuid ] = texture; } } return textures; }, parseObject: function ( data, geometries, materials ) { var object; function getGeometry( name ) { if ( geometries[ name ] === undefined ) { console.warn( 'THREE.ObjectLoader: Undefined geometry', name ); } return geometries[ name ]; } function getMaterial( name ) { if ( name === undefined ) return undefined; if ( Array.isArray( name ) ) { var array = []; for ( var i = 0, l = name.length; i < l; i ++ ) { var uuid = name[ i ]; if ( materials[ uuid ] === undefined ) { console.warn( 'THREE.ObjectLoader: Undefined material', uuid ); } array.push( materials[ uuid ] ); } return array; } if ( materials[ name ] === undefined ) { console.warn( 'THREE.ObjectLoader: Undefined material', name ); } return materials[ name ]; } switch ( data.type ) { case 'Scene': object = new Scene(); if ( data.background !== undefined ) { if ( Number.isInteger( data.background ) ) { object.background = new Color( data.background ); } } if ( data.fog !== undefined ) { if ( data.fog.type === 'Fog' ) { object.fog = new Fog( data.fog.color, data.fog.near, data.fog.far ); } else if ( data.fog.type === 'FogExp2' ) { object.fog = new FogExp2( data.fog.color, data.fog.density ); } } break; case 'PerspectiveCamera': object = new PerspectiveCamera( data.fov, data.aspect, data.near, data.far ); if ( data.focus !== undefined ) object.focus = data.focus; if ( data.zoom !== undefined ) object.zoom = data.zoom; if ( data.filmGauge !== undefined ) object.filmGauge = data.filmGauge; if ( data.filmOffset !== undefined ) object.filmOffset = data.filmOffset; if ( data.view !== undefined ) object.view = Object.assign( {}, data.view ); break; case 'OrthographicCamera': object = new OrthographicCamera( data.left, data.right, data.top, data.bottom, data.near, data.far ); if ( data.zoom !== undefined ) object.zoom = data.zoom; if ( data.view !== undefined ) object.view = Object.assign( {}, data.view ); break; case 'AmbientLight': object = new AmbientLight( data.color, data.intensity ); break; case 'DirectionalLight': object = new DirectionalLight( data.color, data.intensity ); break; case 'PointLight': object = new PointLight( data.color, data.intensity, data.distance, data.decay ); break; case 'RectAreaLight': object = new RectAreaLight( data.color, data.intensity, data.width, data.height ); break; case 'SpotLight': object = new SpotLight( data.color, data.intensity, data.distance, data.angle, data.penumbra, data.decay ); break; case 'HemisphereLight': object = new HemisphereLight( data.color, data.groundColor, data.intensity ); break; case 'SkinnedMesh': console.warn( 'THREE.ObjectLoader.parseObject() does not support SkinnedMesh yet.' ); case 'Mesh': var geometry = getGeometry( data.geometry ); var material = getMaterial( data.material ); if ( geometry.bones && geometry.bones.length > 0 ) { object = new SkinnedMesh( geometry, material ); } else { object = new Mesh( geometry, material ); } if ( data.drawMode !== undefined ) object.setDrawMode( data.drawMode ); break; case 'LOD': object = new LOD(); break; case 'Line': object = new Line( getGeometry( data.geometry ), getMaterial( data.material ), data.mode ); break; case 'LineLoop': object = new LineLoop( getGeometry( data.geometry ), getMaterial( data.material ) ); break; case 'LineSegments': object = new LineSegments( getGeometry( data.geometry ), getMaterial( data.material ) ); break; case 'PointCloud': case 'Points': object = new Points( getGeometry( data.geometry ), getMaterial( data.material ) ); break; case 'Sprite': object = new Sprite( getMaterial( data.material ) ); break; case 'Group': object = new Group(); break; default: object = new Object3D(); } object.uuid = data.uuid; if ( data.name !== undefined ) object.name = data.name; if ( data.matrix !== undefined ) { object.matrix.fromArray( data.matrix ); if ( data.matrixAutoUpdate !== undefined ) object.matrixAutoUpdate = data.matrixAutoUpdate; if ( object.matrixAutoUpdate ) object.matrix.decompose( object.position, object.quaternion, object.scale ); } else { if ( data.position !== undefined ) object.position.fromArray( data.position ); if ( data.rotation !== undefined ) object.rotation.fromArray( data.rotation ); if ( data.quaternion !== undefined ) object.quaternion.fromArray( data.quaternion ); if ( data.scale !== undefined ) object.scale.fromArray( data.scale ); } if ( data.castShadow !== undefined ) object.castShadow = data.castShadow; if ( data.receiveShadow !== undefined ) object.receiveShadow = data.receiveShadow; if ( data.shadow ) { if ( data.shadow.bias !== undefined ) object.shadow.bias = data.shadow.bias; if ( data.shadow.radius !== undefined ) object.shadow.radius = data.shadow.radius; if ( data.shadow.mapSize !== undefined ) object.shadow.mapSize.fromArray( data.shadow.mapSize ); if ( data.shadow.camera !== undefined ) object.shadow.camera = this.parseObject( data.shadow.camera ); } if ( data.visible !== undefined ) object.visible = data.visible; if ( data.frustumCulled !== undefined ) object.frustumCulled = data.frustumCulled; if ( data.renderOrder !== undefined ) object.renderOrder = data.renderOrder; if ( data.userData !== undefined ) object.userData = data.userData; if ( data.layers !== undefined ) object.layers.mask = data.layers; if ( data.children !== undefined ) { var children = data.children; for ( var i = 0; i < children.length; i ++ ) { object.add( this.parseObject( children[ i ], geometries, materials ) ); } } if ( data.type === 'LOD' ) { var levels = data.levels; for ( var l = 0; l < levels.length; l ++ ) { var level = levels[ l ]; var child = object.getObjectByProperty( 'uuid', level.object ); if ( child !== undefined ) { object.addLevel( child, level.distance ); } } } return object; } } ); var TEXTURE_MAPPING = { UVMapping: UVMapping, CubeReflectionMapping: CubeReflectionMapping, CubeRefractionMapping: CubeRefractionMapping, EquirectangularReflectionMapping: EquirectangularReflectionMapping, EquirectangularRefractionMapping: EquirectangularRefractionMapping, SphericalReflectionMapping: SphericalReflectionMapping, CubeUVReflectionMapping: CubeUVReflectionMapping, CubeUVRefractionMapping: CubeUVRefractionMapping }; var TEXTURE_WRAPPING = { RepeatWrapping: RepeatWrapping, ClampToEdgeWrapping: ClampToEdgeWrapping, MirroredRepeatWrapping: MirroredRepeatWrapping }; var TEXTURE_FILTER = { NearestFilter: NearestFilter, NearestMipMapNearestFilter: NearestMipMapNearestFilter, NearestMipMapLinearFilter: NearestMipMapLinearFilter, LinearFilter: LinearFilter, LinearMipMapNearestFilter: LinearMipMapNearestFilter, LinearMipMapLinearFilter: LinearMipMapLinearFilter }; /** * @author thespite / http://clicktorelease.com/ */ function ImageBitmapLoader( manager ) { if ( typeof createImageBitmap === 'undefined' ) { console.warn( 'THREE.ImageBitmapLoader: createImageBitmap() not supported.' ); } if ( typeof fetch === 'undefined' ) { console.warn( 'THREE.ImageBitmapLoader: fetch() not supported.' ); } this.manager = manager !== undefined ? manager : DefaultLoadingManager; this.options = undefined; } ImageBitmapLoader.prototype = { constructor: ImageBitmapLoader, setOptions: function setOptions( options ) { this.options = options; return this; }, load: function ( url, onLoad, onProgress, onError ) { if ( url === undefined ) url = ''; if ( this.path !== undefined ) url = this.path + url; url = this.manager.resolveURL( url ); var scope = this; var cached = Cache.get( url ); if ( cached !== undefined ) { scope.manager.itemStart( url ); setTimeout( function () { if ( onLoad ) onLoad( cached ); scope.manager.itemEnd( url ); }, 0 ); return cached; } fetch( url ).then( function ( res ) { return res.blob(); } ).then( function ( blob ) { return createImageBitmap( blob, scope.options ); } ).then( function ( imageBitmap ) { Cache.add( url, imageBitmap ); if ( onLoad ) onLoad( imageBitmap ); scope.manager.itemEnd( url ); } ).catch( function ( e ) { if ( onError ) onError( e ); scope.manager.itemError( url ); scope.manager.itemEnd( url ); } ); }, setCrossOrigin: function ( /* value */ ) { return this; }, setPath: function ( value ) { this.path = value; return this; } }; /** * @author zz85 / http://www.lab4games.net/zz85/blog * minimal class for proxing functions to Path. Replaces old \"extractSubpaths()\" **/ function ShapePath() { this.type = 'ShapePath'; this.color = new Color(); this.subPaths = []; this.currentPath = null; } Object.assign( ShapePath.prototype, { moveTo: function ( x, y ) { this.currentPath = new Path(); this.subPaths.push( this.currentPath ); this.currentPath.moveTo( x, y ); }, lineTo: function ( x, y ) { this.currentPath.lineTo( x, y ); }, quadraticCurveTo: function ( aCPx, aCPy, aX, aY ) { this.currentPath.quadraticCurveTo( aCPx, aCPy, aX, aY ); }, bezierCurveTo: function ( aCP1x, aCP1y, aCP2x, aCP2y, aX, aY ) { this.currentPath.bezierCurveTo( aCP1x, aCP1y, aCP2x, aCP2y, aX, aY ); }, splineThru: function ( pts ) { this.currentPath.splineThru( pts ); }, toShapes: function ( isCCW, noHoles ) { function toShapesNoHoles( inSubpaths ) { var shapes = []; for ( var i = 0, l = inSubpaths.length; i < l; i ++ ) { var tmpPath = inSubpaths[ i ]; var tmpShape = new Shape(); tmpShape.curves = tmpPath.curves; shapes.push( tmpShape ); } return shapes; } function isPointInsidePolygon( inPt, inPolygon ) { var polyLen = inPolygon.length; // inPt on polygon contour => immediate success or // toggling of inside/outside at every single! intersection point of an edge // with the horizontal line through inPt, left of inPt // not counting lowerY endpoints of edges and whole edges on that line var inside = false; for ( var p = polyLen - 1, q = 0; q < polyLen; p = q ++ ) { var edgeLowPt = inPolygon[ p ]; var edgeHighPt = inPolygon[ q ]; var edgeDx = edgeHighPt.x - edgeLowPt.x; var edgeDy = edgeHighPt.y - edgeLowPt.y; if ( Math.abs( edgeDy ) > Number.EPSILON ) { // not parallel if ( edgeDy < 0 ) { edgeLowPt = inPolygon[ q ]; edgeDx = - edgeDx; edgeHighPt = inPolygon[ p ]; edgeDy = - edgeDy; } if ( ( inPt.y < edgeLowPt.y ) || ( inPt.y > edgeHighPt.y ) ) continue; if ( inPt.y === edgeLowPt.y ) { if ( inPt.x === edgeLowPt.x ) return true; // inPt is on contour ? // continue; // no intersection or edgeLowPt => doesn't count !!! } else { var perpEdge = edgeDy * ( inPt.x - edgeLowPt.x ) - edgeDx * ( inPt.y - edgeLowPt.y ); if ( perpEdge === 0 ) return true; // inPt is on contour ? if ( perpEdge < 0 ) continue; inside = ! inside; // true intersection left of inPt } } else { // parallel or collinear if ( inPt.y !== edgeLowPt.y ) continue; // parallel // edge lies on the same horizontal line as inPt if ( ( ( edgeHighPt.x 1 ) { var ambiguous = false; var toChange = []; for ( var sIdx = 0, sLen = newShapes.length; sIdx < sLen; sIdx ++ ) { betterShapeHoles[ sIdx ] = []; } for ( var sIdx = 0, sLen = newShapes.length; sIdx < sLen; sIdx ++ ) { var sho = newShapeHoles[ sIdx ]; for ( var hIdx = 0; hIdx < sho.length; hIdx ++ ) { var ho = sho[ hIdx ]; var hole_unassigned = true; for ( var s2Idx = 0; s2Idx < newShapes.length; s2Idx ++ ) { if ( isPointInsidePolygon( ho.p, newShapes[ s2Idx ].p ) ) { if ( sIdx !== s2Idx ) toChange.push( { froms: sIdx, tos: s2Idx, hole: hIdx } ); if ( hole_unassigned ) { hole_unassigned = false; betterShapeHoles[ s2Idx ].push( ho ); } else { ambiguous = true; } } } if ( hole_unassigned ) { betterShapeHoles[ sIdx ].push( ho ); } } } // console.log(\"ambiguous: \", ambiguous); if ( toChange.length > 0 ) { // console.log(\"to change: \", toChange); if ( ! ambiguous ) newShapeHoles = betterShapeHoles; } } var tmpHoles; for ( var i = 0, il = newShapes.length; i < il; i ++ ) { tmpShape = newShapes[ i ].s; shapes.push( tmpShape ); tmpHoles = newShapeHoles[ i ]; for ( var j = 0, jl = tmpHoles.length; j < jl; j ++ ) { tmpShape.holes.push( tmpHoles[ j ].h ); } } //console.log(\"shape\", shapes); return shapes; } } ); /** * @author zz85 / http://www.lab4games.net/zz85/blog * @author mrdoob / http://mrdoob.com/ */ function Font( data ) { this.type = 'Font'; this.data = data; } Object.assign( Font.prototype, { isFont: true, generateShapes: function ( text, size ) { if ( size === undefined ) size = 100; var shapes = []; var paths = createPaths( text, size, this.data ); for ( var p = 0, pl = paths.length; p < pl; p ++ ) { Array.prototype.push.apply( shapes, paths[ p ].toShapes() ); } return shapes; } } ); function createPaths( text, size, data ) { var chars = Array.from ? Array.from( text ) : String( text ).split( '' ); // see #13988 var scale = size / data.resolution; var line_height = ( data.boundingBox.yMax - data.boundingBox.yMin + data.underlineThickness ) * scale; var paths = []; var offsetX = 0, offsetY = 0; for ( var i = 0; i < chars.length; i ++ ) { var char = chars[ i ]; if ( char === '\\n' ) { offsetX = 0; offsetY -= line_height; } else { var ret = createPath( char, scale, offsetX, offsetY, data ); offsetX += ret.offsetX; paths.push( ret.path ); } } return paths; } function createPath( char, scale, offsetX, offsetY, data ) { var glyph = data.glyphs[ char ] || data.glyphs[ '?' ]; if ( ! glyph ) return; var path = new ShapePath(); var x, y, cpx, cpy, cpx1, cpy1, cpx2, cpy2; if ( glyph.o ) { var outline = glyph._cachedOutline || ( glyph._cachedOutline = glyph.o.split( ' ' ) ); for ( var i = 0, l = outline.length; i < l; ) { var action = outline[ i ++ ]; switch ( action ) { case 'm': // moveTo x = outline[ i ++ ] * scale + offsetX; y = outline[ i ++ ] * scale + offsetY; path.moveTo( x, y ); break; case 'l': // lineTo x = outline[ i ++ ] * scale + offsetX; y = outline[ i ++ ] * scale + offsetY; path.lineTo( x, y ); break; case 'q': // quadraticCurveTo cpx = outline[ i ++ ] * scale + offsetX; cpy = outline[ i ++ ] * scale + offsetY; cpx1 = outline[ i ++ ] * scale + offsetX; cpy1 = outline[ i ++ ] * scale + offsetY; path.quadraticCurveTo( cpx1, cpy1, cpx, cpy ); break; case 'b': // bezierCurveTo cpx = outline[ i ++ ] * scale + offsetX; cpy = outline[ i ++ ] * scale + offsetY; cpx1 = outline[ i ++ ] * scale + offsetX; cpy1 = outline[ i ++ ] * scale + offsetY; cpx2 = outline[ i ++ ] * scale + offsetX; cpy2 = outline[ i ++ ] * scale + offsetY; path.bezierCurveTo( cpx1, cpy1, cpx2, cpy2, cpx, cpy ); break; } } } return { offsetX: glyph.ha * scale, path: path }; } /** * @author mrdoob / http://mrdoob.com/ */ function FontLoader( manager ) { this.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager; } Object.assign( FontLoader.prototype, { load: function ( url, onLoad, onProgress, onError ) { var scope = this; var loader = new FileLoader( this.manager ); loader.setPath( this.path ); loader.load( url, function ( text ) { var json; try { json = JSON.parse( text ); } catch ( e ) { console.warn( 'THREE.FontLoader: typeface.js support is being deprecated. Use typeface.json instead.' ); json = JSON.parse( text.substring( 65, text.length - 2 ) ); } var font = scope.parse( json ); if ( onLoad ) onLoad( font ); }, onProgress, onError ); }, parse: function ( json ) { return new Font( json ); }, setPath: function ( value ) { this.path = value; return this; } } ); /** * @author alteredq / http://alteredqualia.com/ */ function Loader() {} Loader.Handlers = { handlers: [], add: function ( regex, loader ) { this.handlers.push( regex, loader ); }, get: function ( file ) { var handlers = this.handlers; for ( var i = 0, l = handlers.length; i < l; i += 2 ) { var regex = handlers[ i ]; var loader = handlers[ i + 1 ]; if ( regex.test( file ) ) { return loader; } } return null; } }; Object.assign( Loader.prototype, { crossOrigin: 'anonymous', onLoadStart: function () {}, onLoadProgress: function () {}, onLoadComplete: function () {}, initMaterials: function ( materials, texturePath, crossOrigin ) { var array = []; for ( var i = 0; i < materials.length; ++ i ) { array[ i ] = this.createMaterial( materials[ i ], texturePath, crossOrigin ); } return array; }, createMaterial: ( function () { var BlendingMode = { NoBlending: NoBlending, NormalBlending: NormalBlending, AdditiveBlending: AdditiveBlending, SubtractiveBlending: SubtractiveBlending, MultiplyBlending: MultiplyBlending, CustomBlending: CustomBlending }; var color = new Color(); var textureLoader = new TextureLoader(); var materialLoader = new MaterialLoader(); return function createMaterial( m, texturePath, crossOrigin ) { // convert from old material format var textures = {}; function loadTexture( path, repeat, offset, wrap, anisotropy ) { var fullPath = texturePath + path; var loader = Loader.Handlers.get( fullPath ); var texture; if ( loader !== null ) { texture = loader.load( fullPath ); } else { textureLoader.setCrossOrigin( crossOrigin ); texture = textureLoader.load( fullPath ); } if ( repeat !== undefined ) { texture.repeat.fromArray( repeat ); if ( repeat[ 0 ] !== 1 ) texture.wrapS = RepeatWrapping; if ( repeat[ 1 ] !== 1 ) texture.wrapT = RepeatWrapping; } if ( offset !== undefined ) { texture.offset.fromArray( offset ); } if ( wrap !== undefined ) { if ( wrap[ 0 ] === 'repeat' ) texture.wrapS = RepeatWrapping; if ( wrap[ 0 ] === 'mirror' ) texture.wrapS = MirroredRepeatWrapping; if ( wrap[ 1 ] === 'repeat' ) texture.wrapT = RepeatWrapping; if ( wrap[ 1 ] === 'mirror' ) texture.wrapT = MirroredRepeatWrapping; } if ( anisotropy !== undefined ) { texture.anisotropy = anisotropy; } var uuid = _Math.generateUUID(); textures[ uuid ] = texture; return uuid; } // var json = { uuid: _Math.generateUUID(), type: 'MeshLambertMaterial' }; for ( var name in m ) { var value = m[ name ]; switch ( name ) { case 'DbgColor': case 'DbgIndex': case 'opticalDensity': case 'illumination': break; case 'DbgName': json.name = value; break; case 'blending': json.blending = BlendingMode[ value ]; break; case 'colorAmbient': case 'mapAmbient': console.warn( 'THREE.Loader.createMaterial:', name, 'is no longer supported.' ); break; case 'colorDiffuse': json.color = color.fromArray( value ).getHex(); break; case 'colorSpecular': json.specular = color.fromArray( value ).getHex(); break; case 'colorEmissive': json.emissive = color.fromArray( value ).getHex(); break; case 'specularCoef': json.shininess = value; break; case 'shading': if ( value.toLowerCase() === 'basic' ) json.type = 'MeshBasicMaterial'; if ( value.toLowerCase() === 'phong' ) json.type = 'MeshPhongMaterial'; if ( value.toLowerCase() === 'standard' ) json.type = 'MeshStandardMaterial'; break; case 'mapDiffuse': json.map = loadTexture( value, m.mapDiffuseRepeat, m.mapDiffuseOffset, m.mapDiffuseWrap, m.mapDiffuseAnisotropy ); break; case 'mapDiffuseRepeat': case 'mapDiffuseOffset': case 'mapDiffuseWrap': case 'mapDiffuseAnisotropy': break; case 'mapEmissive': json.emissiveMap = loadTexture( value, m.mapEmissiveRepeat, m.mapEmissiveOffset, m.mapEmissiveWrap, m.mapEmissiveAnisotropy ); break; case 'mapEmissiveRepeat': case 'mapEmissiveOffset': case 'mapEmissiveWrap': case 'mapEmissiveAnisotropy': break; case 'mapLight': json.lightMap = loadTexture( value, m.mapLightRepeat, m.mapLightOffset, m.mapLightWrap, m.mapLightAnisotropy ); break; case 'mapLightRepeat': case 'mapLightOffset': case 'mapLightWrap': case 'mapLightAnisotropy': break; case 'mapAO': json.aoMap = loadTexture( value, m.mapAORepeat, m.mapAOOffset, m.mapAOWrap, m.mapAOAnisotropy ); break; case 'mapAORepeat': case 'mapAOOffset': case 'mapAOWrap': case 'mapAOAnisotropy': break; case 'mapBump': json.bumpMap = loadTexture( value, m.mapBumpRepeat, m.mapBumpOffset, m.mapBumpWrap, m.mapBumpAnisotropy ); break; case 'mapBumpScale': json.bumpScale = value; break; case 'mapBumpRepeat': case 'mapBumpOffset': case 'mapBumpWrap': case 'mapBumpAnisotropy': break; case 'mapNormal': json.normalMap = loadTexture( value, m.mapNormalRepeat, m.mapNormalOffset, m.mapNormalWrap, m.mapNormalAnisotropy ); break; case 'mapNormalFactor': json.normalScale = value; break; case 'mapNormalRepeat': case 'mapNormalOffset': case 'mapNormalWrap': case 'mapNormalAnisotropy': break; case 'mapSpecular': json.specularMap = loadTexture( value, m.mapSpecularRepeat, m.mapSpecularOffset, m.mapSpecularWrap, m.mapSpecularAnisotropy ); break; case 'mapSpecularRepeat': case 'mapSpecularOffset': case 'mapSpecularWrap': case 'mapSpecularAnisotropy': break; case 'mapMetalness': json.metalnessMap = loadTexture( value, m.mapMetalnessRepeat, m.mapMetalnessOffset, m.mapMetalnessWrap, m.mapMetalnessAnisotropy ); break; case 'mapMetalnessRepeat': case 'mapMetalnessOffset': case 'mapMetalnessWrap': case 'mapMetalnessAnisotropy': break; case 'mapRoughness': json.roughnessMap = loadTexture( value, m.mapRoughnessRepeat, m.mapRoughnessOffset, m.mapRoughnessWrap, m.mapRoughnessAnisotropy ); break; case 'mapRoughnessRepeat': case 'mapRoughnessOffset': case 'mapRoughnessWrap': case 'mapRoughnessAnisotropy': break; case 'mapAlpha': json.alphaMap = loadTexture( value, m.mapAlphaRepeat, m.mapAlphaOffset, m.mapAlphaWrap, m.mapAlphaAnisotropy ); break; case 'mapAlphaRepeat': case 'mapAlphaOffset': case 'mapAlphaWrap': case 'mapAlphaAnisotropy': break; case 'flipSided': json.side = BackSide; break; case 'doubleSided': json.side = DoubleSide; break; case 'transparency': console.warn( 'THREE.Loader.createMaterial: transparency has been renamed to opacity' ); json.opacity = value; break; case 'depthTest': case 'depthWrite': case 'colorWrite': case 'opacity': case 'reflectivity': case 'transparent': case 'visible': case 'wireframe': json[ name ] = value; break; case 'vertexColors': if ( value === true ) json.vertexColors = VertexColors; if ( value === 'face' ) json.vertexColors = FaceColors; break; default: console.error( 'THREE.Loader.createMaterial: Unsupported', name, value ); break; } } if ( json.type === 'MeshBasicMaterial' ) delete json.emissive; if ( json.type !== 'MeshPhongMaterial' ) delete json.specular; if ( json.opacity < 1 ) json.transparent = true; materialLoader.setTextures( textures ); return materialLoader.parse( json ); }; } )() } ); /** * @author mrdoob / http://mrdoob.com/ */ var context; var AudioContext = { getContext: function () { if ( context === undefined ) { context = new ( window.AudioContext || window.webkitAudioContext )(); } return context; }, setContext: function ( value ) { context = value; } }; /** * @author Reece Aaron Lecrivain / http://reecenotes.com/ */ function AudioLoader( manager ) { this.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager; } Object.assign( AudioLoader.prototype, { load: function ( url, onLoad, onProgress, onError ) { var loader = new FileLoader( this.manager ); loader.setResponseType( 'arraybuffer' ); loader.setPath( this.path ); loader.load( url, function ( buffer ) { // Create a copy of the buffer. The `decodeAudioData` method // detaches the buffer when complete, preventing reuse. var bufferCopy = buffer.slice( 0 ); var context = AudioContext.getContext(); context.decodeAudioData( bufferCopy, function ( audioBuffer ) { onLoad( audioBuffer ); } ); }, onProgress, onError ); }, setPath: function ( value ) { this.path = value; return this; } } ); /** * @author mrdoob / http://mrdoob.com/ */ function StereoCamera() { this.type = 'StereoCamera'; this.aspect = 1; this.eyeSep = 0.064; this.cameraL = new PerspectiveCamera(); this.cameraL.layers.enable( 1 ); this.cameraL.matrixAutoUpdate = false; this.cameraR = new PerspectiveCamera(); this.cameraR.layers.enable( 2 ); this.cameraR.matrixAutoUpdate = false; } Object.assign( StereoCamera.prototype, { update: ( function () { var instance, focus, fov, aspect, near, far, zoom, eyeSep; var eyeRight = new Matrix4(); var eyeLeft = new Matrix4(); return function update( camera ) { var needsUpdate = instance !== this || focus !== camera.focus || fov !== camera.fov || aspect !== camera.aspect * this.aspect || near !== camera.near || far !== camera.far || zoom !== camera.zoom || eyeSep !== this.eyeSep; if ( needsUpdate ) { instance = this; focus = camera.focus; fov = camera.fov; aspect = camera.aspect * this.aspect; near = camera.near; far = camera.far; zoom = camera.zoom; // Off-axis stereoscopic effect based on // http://paulbourke.net/stereographics/stereorender/ var projectionMatrix = camera.projectionMatrix.clone(); eyeSep = this.eyeSep / 2; var eyeSepOnProjection = eyeSep * near / focus; var ymax = ( near * Math.tan( _Math.DEG2RAD * fov * 0.5 ) ) / zoom; var xmin, xmax; // translate xOffset eyeLeft.elements[ 12 ] = - eyeSep; eyeRight.elements[ 12 ] = eyeSep; // for left eye xmin = - ymax * aspect + eyeSepOnProjection; xmax = ymax * aspect + eyeSepOnProjection; projectionMatrix.elements[ 0 ] = 2 * near / ( xmax - xmin ); projectionMatrix.elements[ 8 ] = ( xmax + xmin ) / ( xmax - xmin ); this.cameraL.projectionMatrix.copy( projectionMatrix ); // for right eye xmin = - ymax * aspect - eyeSepOnProjection; xmax = ymax * aspect - eyeSepOnProjection; projectionMatrix.elements[ 0 ] = 2 * near / ( xmax - xmin ); projectionMatrix.elements[ 8 ] = ( xmax + xmin ) / ( xmax - xmin ); this.cameraR.projectionMatrix.copy( projectionMatrix ); } this.cameraL.matrixWorld.copy( camera.matrixWorld ).multiply( eyeLeft ); this.cameraR.matrixWorld.copy( camera.matrixWorld ).multiply( eyeRight ); }; } )() } ); /** * Camera for rendering cube maps * - renders scene into axis-aligned cube * * @author alteredq / http://alteredqualia.com/ */ function CubeCamera( near, far, cubeResolution, options ) { Object3D.call( this ); this.type = 'CubeCamera'; var fov = 90, aspect = 1; var cameraPX = new PerspectiveCamera( fov, aspect, near, far ); cameraPX.up.set( 0, - 1, 0 ); cameraPX.lookAt( new Vector3( 1, 0, 0 ) ); this.add( cameraPX ); var cameraNX = new PerspectiveCamera( fov, aspect, near, far ); cameraNX.up.set( 0, - 1, 0 ); cameraNX.lookAt( new Vector3( - 1, 0, 0 ) ); this.add( cameraNX ); var cameraPY = new PerspectiveCamera( fov, aspect, near, far ); cameraPY.up.set( 0, 0, 1 ); cameraPY.lookAt( new Vector3( 0, 1, 0 ) ); this.add( cameraPY ); var cameraNY = new PerspectiveCamera( fov, aspect, near, far ); cameraNY.up.set( 0, 0, - 1 ); cameraNY.lookAt( new Vector3( 0, - 1, 0 ) ); this.add( cameraNY ); var cameraPZ = new PerspectiveCamera( fov, aspect, near, far ); cameraPZ.up.set( 0, - 1, 0 ); cameraPZ.lookAt( new Vector3( 0, 0, 1 ) ); this.add( cameraPZ ); var cameraNZ = new PerspectiveCamera( fov, aspect, near, far ); cameraNZ.up.set( 0, - 1, 0 ); cameraNZ.lookAt( new Vector3( 0, 0, - 1 ) ); this.add( cameraNZ ); options = options || { format: RGBFormat, magFilter: LinearFilter, minFilter: LinearFilter }; this.renderTarget = new WebGLRenderTargetCube( cubeResolution, cubeResolution, options ); this.renderTarget.texture.name = \"CubeCamera\"; this.update = function ( renderer, scene ) { if ( this.parent === null ) this.updateMatrixWorld(); var currentRenderTarget = renderer.getRenderTarget(); var renderTarget = this.renderTarget; var generateMipmaps = renderTarget.texture.generateMipmaps; renderTarget.texture.generateMipmaps = false; renderTarget.activeCubeFace = 0; renderer.setRenderTarget( renderTarget ); renderer.render( scene, cameraPX ); renderTarget.activeCubeFace = 1; renderer.render( scene, cameraNX ); renderTarget.activeCubeFace = 2; renderer.render( scene, cameraPY ); renderTarget.activeCubeFace = 3; renderer.render( scene, cameraNY ); renderTarget.activeCubeFace = 4; renderer.render( scene, cameraPZ ); renderTarget.texture.generateMipmaps = generateMipmaps; renderTarget.activeCubeFace = 5; renderer.render( scene, cameraNZ ); renderer.setRenderTarget( currentRenderTarget ); }; this.clear = function ( renderer, color, depth, stencil ) { var currentRenderTarget = renderer.getRenderTarget(); var renderTarget = this.renderTarget; for ( var i = 0; i < 6; i ++ ) { renderTarget.activeCubeFace = i; renderer.setRenderTarget( renderTarget ); renderer.clear( color, depth, stencil ); } renderer.setRenderTarget( currentRenderTarget ); }; } CubeCamera.prototype = Object.create( Object3D.prototype ); CubeCamera.prototype.constructor = CubeCamera; /** * @author alteredq / http://alteredqualia.com/ */ function Clock( autoStart ) { this.autoStart = ( autoStart !== undefined ) ? autoStart : true; this.startTime = 0; this.oldTime = 0; this.elapsedTime = 0; this.running = false; } Object.assign( Clock.prototype, { start: function () { this.startTime = ( typeof performance === 'undefined' ? Date : performance ).now(); // see #10732 this.oldTime = this.startTime; this.elapsedTime = 0; this.running = true; }, stop: function () { this.getElapsedTime(); this.running = false; this.autoStart = false; }, getElapsedTime: function () { this.getDelta(); return this.elapsedTime; }, getDelta: function () { var diff = 0; if ( this.autoStart && ! this.running ) { this.start(); return 0; } if ( this.running ) { var newTime = ( typeof performance === 'undefined' ? Date : performance ).now(); diff = ( newTime - this.oldTime ) / 1000; this.oldTime = newTime; this.elapsedTime += diff; } return diff; } } ); /** * @author mrdoob / http://mrdoob.com/ */ function AudioListener() { Object3D.call( this ); this.type = 'AudioListener'; this.context = AudioContext.getContext(); this.gain = this.context.createGain(); this.gain.connect( this.context.destination ); this.filter = null; this.timeDelta = 0; } AudioListener.prototype = Object.assign( Object.create( Object3D.prototype ), { constructor: AudioListener, getInput: function () { return this.gain; }, removeFilter: function ( ) { if ( this.filter !== null ) { this.gain.disconnect( this.filter ); this.filter.disconnect( this.context.destination ); this.gain.connect( this.context.destination ); this.filter = null; } return this; }, getFilter: function () { return this.filter; }, setFilter: function ( value ) { if ( this.filter !== null ) { this.gain.disconnect( this.filter ); this.filter.disconnect( this.context.destination ); } else { this.gain.disconnect( this.context.destination ); } this.filter = value; this.gain.connect( this.filter ); this.filter.connect( this.context.destination ); return this; }, getMasterVolume: function () { return this.gain.gain.value; }, setMasterVolume: function ( value ) { this.gain.gain.setTargetAtTime( value, this.context.currentTime, 0.01 ); return this; }, updateMatrixWorld: ( function () { var position = new Vector3(); var quaternion = new Quaternion(); var scale = new Vector3(); var orientation = new Vector3(); var clock = new Clock(); return function updateMatrixWorld( force ) { Object3D.prototype.updateMatrixWorld.call( this, force ); var listener = this.context.listener; var up = this.up; this.timeDelta = clock.getDelta(); this.matrixWorld.decompose( position, quaternion, scale ); orientation.set( 0, 0, - 1 ).applyQuaternion( quaternion ); if ( listener.positionX ) { // code path for Chrome (see #14393) var endTime = this.context.currentTime + this.timeDelta; listener.positionX.linearRampToValueAtTime( position.x, endTime ); listener.positionY.linearRampToValueAtTime( position.y, endTime ); listener.positionZ.linearRampToValueAtTime( position.z, endTime ); listener.forwardX.linearRampToValueAtTime( orientation.x, endTime ); listener.forwardY.linearRampToValueAtTime( orientation.y, endTime ); listener.forwardZ.linearRampToValueAtTime( orientation.z, endTime ); listener.upX.linearRampToValueAtTime( up.x, endTime ); listener.upY.linearRampToValueAtTime( up.y, endTime ); listener.upZ.linearRampToValueAtTime( up.z, endTime ); } else { listener.setPosition( position.x, position.y, position.z ); listener.setOrientation( orientation.x, orientation.y, orientation.z, up.x, up.y, up.z ); } }; } )() } ); /** * @author mrdoob / http://mrdoob.com/ * @author Reece Aaron Lecrivain / http://reecenotes.com/ */ function Audio( listener ) { Object3D.call( this ); this.type = 'Audio'; this.listener = listener; this.context = listener.context; this.gain = this.context.createGain(); this.gain.connect( listener.getInput() ); this.autoplay = false; this.buffer = null; this.detune = 0; this.loop = false; this.startTime = 0; this.offset = 0; this.playbackRate = 1; this.isPlaying = false; this.hasPlaybackControl = true; this.sourceType = 'empty'; this.filters = []; } Audio.prototype = Object.assign( Object.create( Object3D.prototype ), { constructor: Audio, getOutput: function () { return this.gain; }, setNodeSource: function ( audioNode ) { this.hasPlaybackControl = false; this.sourceType = 'audioNode'; this.source = audioNode; this.connect(); return this; }, setMediaElementSource: function ( mediaElement ) { this.hasPlaybackControl = false; this.sourceType = 'mediaNode'; this.source = this.context.createMediaElementSource( mediaElement ); this.connect(); return this; }, setBuffer: function ( audioBuffer ) { this.buffer = audioBuffer; this.sourceType = 'buffer'; if ( this.autoplay ) this.play(); return this; }, play: function () { if ( this.isPlaying === true ) { console.warn( 'THREE.Audio: Audio is already playing.' ); return; } if ( this.hasPlaybackControl === false ) { console.warn( 'THREE.Audio: this Audio has no playback control.' ); return; } var source = this.context.createBufferSource(); source.buffer = this.buffer; source.loop = this.loop; source.onended = this.onEnded.bind( this ); this.startTime = this.context.currentTime; source.start( this.startTime, this.offset ); this.isPlaying = true; this.source = source; this.setDetune( this.detune ); this.setPlaybackRate( this.playbackRate ); return this.connect(); }, pause: function () { if ( this.hasPlaybackControl === false ) { console.warn( 'THREE.Audio: this Audio has no playback control.' ); return; } if ( this.isPlaying === true ) { this.source.stop(); this.source.onended = null; this.offset += ( this.context.currentTime - this.startTime ) * this.playbackRate; this.isPlaying = false; } return this; }, stop: function () { if ( this.hasPlaybackControl === false ) { console.warn( 'THREE.Audio: this Audio has no playback control.' ); return; } this.source.stop(); this.source.onended = null; this.offset = 0; this.isPlaying = false; return this; }, connect: function () { if ( this.filters.length > 0 ) { this.source.connect( this.filters[ 0 ] ); for ( var i = 1, l = this.filters.length; i < l; i ++ ) { this.filters[ i - 1 ].connect( this.filters[ i ] ); } this.filters[ this.filters.length - 1 ].connect( this.getOutput() ); } else { this.source.connect( this.getOutput() ); } return this; }, disconnect: function () { if ( this.filters.length > 0 ) { this.source.disconnect( this.filters[ 0 ] ); for ( var i = 1, l = this.filters.length; i < l; i ++ ) { this.filters[ i - 1 ].disconnect( this.filters[ i ] ); } this.filters[ this.filters.length - 1 ].disconnect( this.getOutput() ); } else { this.source.disconnect( this.getOutput() ); } return this; }, getFilters: function () { return this.filters; }, setFilters: function ( value ) { if ( ! value ) value = []; if ( this.isPlaying === true ) { this.disconnect(); this.filters = value; this.connect(); } else { this.filters = value; } return this; }, setDetune: function ( value ) { this.detune = value; if ( this.source.detune === undefined ) return; // only set detune when available if ( this.isPlaying === true ) { this.source.detune.setTargetAtTime( this.detune, this.context.currentTime, 0.01 ); } return this; }, getDetune: function () { return this.detune; }, getFilter: function () { return this.getFilters()[ 0 ]; }, setFilter: function ( filter ) { return this.setFilters( filter ? [ filter ] : [] ); }, setPlaybackRate: function ( value ) { if ( this.hasPlaybackControl === false ) { console.warn( 'THREE.Audio: this Audio has no playback control.' ); return; } this.playbackRate = value; if ( this.isPlaying === true ) { this.source.playbackRate.setTargetAtTime( this.playbackRate, this.context.currentTime, 0.01 ); } return this; }, getPlaybackRate: function () { return this.playbackRate; }, onEnded: function () { this.isPlaying = false; }, getLoop: function () { if ( this.hasPlaybackControl === false ) { console.warn( 'THREE.Audio: this Audio has no playback control.' ); return false; } return this.loop; }, setLoop: function ( value ) { if ( this.hasPlaybackControl === false ) { console.warn( 'THREE.Audio: this Audio has no playback control.' ); return; } this.loop = value; if ( this.isPlaying === true ) { this.source.loop = this.loop; } return this; }, getVolume: function () { return this.gain.gain.value; }, setVolume: function ( value ) { this.gain.gain.setTargetAtTime( value, this.context.currentTime, 0.01 ); return this; } } ); /** * @author mrdoob / http://mrdoob.com/ */ function PositionalAudio( listener ) { Audio.call( this, listener ); this.panner = this.context.createPanner(); this.panner.connect( this.gain ); } PositionalAudio.prototype = Object.assign( Object.create( Audio.prototype ), { constructor: PositionalAudio, getOutput: function () { return this.panner; }, getRefDistance: function () { return this.panner.refDistance; }, setRefDistance: function ( value ) { this.panner.refDistance = value; return this; }, getRolloffFactor: function () { return this.panner.rolloffFactor; }, setRolloffFactor: function ( value ) { this.panner.rolloffFactor = value; return this; }, getDistanceModel: function () { return this.panner.distanceModel; }, setDistanceModel: function ( value ) { this.panner.distanceModel = value; return this; }, getMaxDistance: function () { return this.panner.maxDistance; }, setMaxDistance: function ( value ) { this.panner.maxDistance = value; return this; }, setDirectionalCone: function ( coneInnerAngle, coneOuterAngle, coneOuterGain ) { this.panner.coneInnerAngle = coneInnerAngle; this.panner.coneOuterAngle = coneOuterAngle; this.panner.coneOuterGain = coneOuterGain; return this; }, updateMatrixWorld: ( function () { var position = new Vector3(); var quaternion = new Quaternion(); var scale = new Vector3(); var orientation = new Vector3(); return function updateMatrixWorld( force ) { Object3D.prototype.updateMatrixWorld.call( this, force ); if ( this.hasPlaybackControl === true && this.isPlaying === false ) return; this.matrixWorld.decompose( position, quaternion, scale ); orientation.set( 0, 0, 1 ).applyQuaternion( quaternion ); var panner = this.panner; if ( panner.positionX ) { // code path for Chrome and Firefox (see #14393) var endTime = this.context.currentTime + this.listener.timeDelta; panner.positionX.linearRampToValueAtTime( position.x, endTime ); panner.positionY.linearRampToValueAtTime( position.y, endTime ); panner.positionZ.linearRampToValueAtTime( position.z, endTime ); panner.orientationX.linearRampToValueAtTime( orientation.x, endTime ); panner.orientationY.linearRampToValueAtTime( orientation.y, endTime ); panner.orientationZ.linearRampToValueAtTime( orientation.z, endTime ); } else { panner.setPosition( position.x, position.y, position.z ); panner.setOrientation( orientation.x, orientation.y, orientation.z ); } }; } )() } ); /** * @author mrdoob / http://mrdoob.com/ */ function AudioAnalyser( audio, fftSize ) { this.analyser = audio.context.createAnalyser(); this.analyser.fftSize = fftSize !== undefined ? fftSize : 2048; this.data = new Uint8Array( this.analyser.frequencyBinCount ); audio.getOutput().connect( this.analyser ); } Object.assign( AudioAnalyser.prototype, { getFrequencyData: function () { this.analyser.getByteFrequencyData( this.data ); return this.data; }, getAverageFrequency: function () { var value = 0, data = this.getFrequencyData(); for ( var i = 0; i < data.length; i ++ ) { value += data[ i ]; } return value / data.length; } } ); /** * * Buffered scene graph property that allows weighted accumulation. * * * @author Ben Houston / http://clara.io/ * @author David Sarno / http://lighthaus.us/ * @author tschw */ function PropertyMixer( binding, typeName, valueSize ) { this.binding = binding; this.valueSize = valueSize; var bufferType = Float64Array, mixFunction; switch ( typeName ) { case 'quaternion': mixFunction = this._slerp; break; case 'string': case 'bool': bufferType = Array; mixFunction = this._select; break; default: mixFunction = this._lerp; } this.buffer = new bufferType( valueSize * 4 ); // layout: [ incoming | accu0 | accu1 | orig ] // // interpolators can use .buffer as their .result // the data then goes to 'incoming' // // 'accu0' and 'accu1' are used frame-interleaved for // the cumulative result and are compared to detect // changes // // 'orig' stores the original state of the property this._mixBufferRegion = mixFunction; this.cumulativeWeight = 0; this.useCount = 0; this.referenceCount = 0; } Object.assign( PropertyMixer.prototype, { // accumulate data in the 'incoming' region into 'accu' accumulate: function ( accuIndex, weight ) { // note: happily accumulating nothing when weight = 0, the caller knows // the weight and shouldn't have made the call in the first place var buffer = this.buffer, stride = this.valueSize, offset = accuIndex * stride + stride, currentWeight = this.cumulativeWeight; if ( currentWeight === 0 ) { // accuN := incoming * weight for ( var i = 0; i !== stride; ++ i ) { buffer[ offset + i ] = buffer[ i ]; } currentWeight = weight; } else { // accuN := accuN + incoming * weight currentWeight += weight; var mix = weight / currentWeight; this._mixBufferRegion( buffer, offset, 0, mix, stride ); } this.cumulativeWeight = currentWeight; }, // apply the state of 'accu' to the binding when accus differ apply: function ( accuIndex ) { var stride = this.valueSize, buffer = this.buffer, offset = accuIndex * stride + stride, weight = this.cumulativeWeight, binding = this.binding; this.cumulativeWeight = 0; if ( weight < 1 ) { // accuN := accuN + original * ( 1 - cumulativeWeight ) var originalValueOffset = stride * 3; this._mixBufferRegion( buffer, offset, originalValueOffset, 1 - weight, stride ); } for ( var i = stride, e = stride + stride; i !== e; ++ i ) { if ( buffer[ i ] !== buffer[ i + stride ] ) { // value has changed -> update scene graph binding.setValue( buffer, offset ); break; } } }, // remember the state of the bound property and copy it to both accus saveOriginalState: function () { var binding = this.binding; var buffer = this.buffer, stride = this.valueSize, originalValueOffset = stride * 3; binding.getValue( buffer, originalValueOffset ); // accu[0..1] := orig -- initially detect changes against the original for ( var i = stride, e = originalValueOffset; i !== e; ++ i ) { buffer[ i ] = buffer[ originalValueOffset + ( i % stride ) ]; } this.cumulativeWeight = 0; }, // apply the state previously taken via 'saveOriginalState' to the binding restoreOriginalState: function () { var originalValueOffset = this.valueSize * 3; this.binding.setValue( this.buffer, originalValueOffset ); }, // mix functions _select: function ( buffer, dstOffset, srcOffset, t, stride ) { if ( t >= 0.5 ) { for ( var i = 0; i !== stride; ++ i ) { buffer[ dstOffset + i ] = buffer[ srcOffset + i ]; } } }, _slerp: function ( buffer, dstOffset, srcOffset, t ) { Quaternion.slerpFlat( buffer, dstOffset, buffer, dstOffset, buffer, srcOffset, t ); }, _lerp: function ( buffer, dstOffset, srcOffset, t, stride ) { var s = 1 - t; for ( var i = 0; i !== stride; ++ i ) { var j = dstOffset + i; buffer[ j ] = buffer[ j ] * s + buffer[ srcOffset + i ] * t; } } } ); /** * * A reference to a real property in the scene graph. * * * @author Ben Houston / http://clara.io/ * @author David Sarno / http://lighthaus.us/ * @author tschw */ // Characters [].:/ are reserved for track binding syntax. var RESERVED_CHARS_RE = '\\\\[\\\\]\\\\.:\\\\/'; function Composite( targetGroup, path, optionalParsedPath ) { var parsedPath = optionalParsedPath || PropertyBinding.parseTrackName( path ); this._targetGroup = targetGroup; this._bindings = targetGroup.subscribe_( path, parsedPath ); } Object.assign( Composite.prototype, { getValue: function ( array, offset ) { this.bind(); // bind all binding var firstValidIndex = this._targetGroup.nCachedObjects_, binding = this._bindings[ firstValidIndex ]; // and only call .getValue on the first if ( binding !== undefined ) binding.getValue( array, offset ); }, setValue: function ( array, offset ) { var bindings = this._bindings; for ( var i = this._targetGroup.nCachedObjects_, n = bindings.length; i !== n; ++ i ) { bindings[ i ].setValue( array, offset ); } }, bind: function () { var bindings = this._bindings; for ( var i = this._targetGroup.nCachedObjects_, n = bindings.length; i !== n; ++ i ) { bindings[ i ].bind(); } }, unbind: function () { var bindings = this._bindings; for ( var i = this._targetGroup.nCachedObjects_, n = bindings.length; i !== n; ++ i ) { bindings[ i ].unbind(); } } } ); function PropertyBinding( rootNode, path, parsedPath ) { this.path = path; this.parsedPath = parsedPath || PropertyBinding.parseTrackName( path ); this.node = PropertyBinding.findNode( rootNode, this.parsedPath.nodeName ) || rootNode; this.rootNode = rootNode; } Object.assign( PropertyBinding, { Composite: Composite, create: function ( root, path, parsedPath ) { if ( ! ( root && root.isAnimationObjectGroup ) ) { return new PropertyBinding( root, path, parsedPath ); } else { return new PropertyBinding.Composite( root, path, parsedPath ); } }, /** * Replaces spaces with underscores and removes unsupported characters from * node names, to ensure compatibility with parseTrackName(). * * @param {string} name Node name to be sanitized. * @return {string} */ sanitizeNodeName: ( function () { var reservedRe = new RegExp( '[' + RESERVED_CHARS_RE + ']', 'g' ); return function sanitizeNodeName( name ) { return name.replace( /\\s/g, '_' ).replace( reservedRe, '' ); }; }() ), parseTrackName: function () { // Attempts to allow node names from any language. ES5's `\\w` regexp matches // only latin characters, and the unicode \\p{L} is not yet supported. So // instead, we exclude reserved characters and match everything else. var wordChar = '[^' + RESERVED_CHARS_RE + ']'; var wordCharOrDot = '[^' + RESERVED_CHARS_RE.replace( '\\\\.', '' ) + ']'; // Parent directories, delimited by '/' or ':'. Currently unused, but must // be matched to parse the rest of the track name. var directoryRe = /((?:WC+[\\/:])*)/.source.replace( 'WC', wordChar ); // Target node. May contain word characters (a-zA-Z0-9_) and '.' or '-'. var nodeRe = /(WCOD+)?/.source.replace( 'WCOD', wordCharOrDot ); // Object on target node, and accessor. May not contain reserved // characters. Accessor may contain any character except closing bracket. var objectRe = /(?:\\.(WC+)(?:\\[(.+)\\])?)?/.source.replace( 'WC', wordChar ); // Property and accessor. May not contain reserved characters. Accessor may // contain any non-bracket characters. var propertyRe = /\\.(WC+)(?:\\[(.+)\\])?/.source.replace( 'WC', wordChar ); var trackRe = new RegExp( '' + '^' + directoryRe + nodeRe + objectRe + propertyRe + '$' ); var supportedObjectNames = [ 'material', 'materials', 'bones' ]; return function parseTrackName( trackName ) { var matches = trackRe.exec( trackName ); if ( ! matches ) { throw new Error( 'PropertyBinding: Cannot parse trackName: ' + trackName ); } var results = { // directoryName: matches[ 1 ], // (tschw) currently unused nodeName: matches[ 2 ], objectName: matches[ 3 ], objectIndex: matches[ 4 ], propertyName: matches[ 5 ], // required propertyIndex: matches[ 6 ] }; var lastDot = results.nodeName && results.nodeName.lastIndexOf( '.' ); if ( lastDot !== undefined && lastDot !== - 1 ) { var objectName = results.nodeName.substring( lastDot + 1 ); // Object names must be checked against a whitelist. Otherwise, there // is no way to parse 'foo.bar.baz': 'baz' must be a property, but // 'bar' could be the objectName, or part of a nodeName (which can // include '.' characters). if ( supportedObjectNames.indexOf( objectName ) !== - 1 ) { results.nodeName = results.nodeName.substring( 0, lastDot ); results.objectName = objectName; } } if ( results.propertyName === null || results.propertyName.length === 0 ) { throw new Error( 'PropertyBinding: can not parse propertyName from trackName: ' + trackName ); } return results; }; }(), findNode: function ( root, nodeName ) { if ( ! nodeName || nodeName === \"\" || nodeName === \"root\" || nodeName === \".\" || nodeName === - 1 || nodeName === root.name || nodeName === root.uuid ) { return root; } // search into skeleton bones. if ( root.skeleton ) { var bone = root.skeleton.getBoneByName( nodeName ); if ( bone !== undefined ) { return bone; } } // search into node subtree. if ( root.children ) { var searchNodeSubtree = function ( children ) { for ( var i = 0; i < children.length; i ++ ) { var childNode = children[ i ]; if ( childNode.name === nodeName || childNode.uuid === nodeName ) { return childNode; } var result = searchNodeSubtree( childNode.children ); if ( result ) return result; } return null; }; var subTreeNode = searchNodeSubtree( root.children ); if ( subTreeNode ) { return subTreeNode; } } return null; } } ); Object.assign( PropertyBinding.prototype, { // prototype, continued // these are used to \"bind\" a nonexistent property _getValue_unavailable: function () {}, _setValue_unavailable: function () {}, BindingType: { Direct: 0, EntireArray: 1, ArrayElement: 2, HasFromToArray: 3 }, Versioning: { None: 0, NeedsUpdate: 1, MatrixWorldNeedsUpdate: 2 }, GetterByBindingType: [ function getValue_direct( buffer, offset ) { buffer[ offset ] = this.node[ this.propertyName ]; }, function getValue_array( buffer, offset ) { var source = this.resolvedProperty; for ( var i = 0, n = source.length; i !== n; ++ i ) { buffer[ offset ++ ] = source[ i ]; } }, function getValue_arrayElement( buffer, offset ) { buffer[ offset ] = this.resolvedProperty[ this.propertyIndex ]; }, function getValue_toArray( buffer, offset ) { this.resolvedProperty.toArray( buffer, offset ); } ], SetterByBindingTypeAndVersioning: [ [ // Direct function setValue_direct( buffer, offset ) { this.targetObject[ this.propertyName ] = buffer[ offset ]; }, function setValue_direct_setNeedsUpdate( buffer, offset ) { this.targetObject[ this.propertyName ] = buffer[ offset ]; this.targetObject.needsUpdate = true; }, function setValue_direct_setMatrixWorldNeedsUpdate( buffer, offset ) { this.targetObject[ this.propertyName ] = buffer[ offset ]; this.targetObject.matrixWorldNeedsUpdate = true; } ], [ // EntireArray function setValue_array( buffer, offset ) { var dest = this.resolvedProperty; for ( var i = 0, n = dest.length; i !== n; ++ i ) { dest[ i ] = buffer[ offset ++ ]; } }, function setValue_array_setNeedsUpdate( buffer, offset ) { var dest = this.resolvedProperty; for ( var i = 0, n = dest.length; i !== n; ++ i ) { dest[ i ] = buffer[ offset ++ ]; } this.targetObject.needsUpdate = true; }, function setValue_array_setMatrixWorldNeedsUpdate( buffer, offset ) { var dest = this.resolvedProperty; for ( var i = 0, n = dest.length; i !== n; ++ i ) { dest[ i ] = buffer[ offset ++ ]; } this.targetObject.matrixWorldNeedsUpdate = true; } ], [ // ArrayElement function setValue_arrayElement( buffer, offset ) { this.resolvedProperty[ this.propertyIndex ] = buffer[ offset ]; }, function setValue_arrayElement_setNeedsUpdate( buffer, offset ) { this.resolvedProperty[ this.propertyIndex ] = buffer[ offset ]; this.targetObject.needsUpdate = true; }, function setValue_arrayElement_setMatrixWorldNeedsUpdate( buffer, offset ) { this.resolvedProperty[ this.propertyIndex ] = buffer[ offset ]; this.targetObject.matrixWorldNeedsUpdate = true; } ], [ // HasToFromArray function setValue_fromArray( buffer, offset ) { this.resolvedProperty.fromArray( buffer, offset ); }, function setValue_fromArray_setNeedsUpdate( buffer, offset ) { this.resolvedProperty.fromArray( buffer, offset ); this.targetObject.needsUpdate = true; }, function setValue_fromArray_setMatrixWorldNeedsUpdate( buffer, offset ) { this.resolvedProperty.fromArray( buffer, offset ); this.targetObject.matrixWorldNeedsUpdate = true; } ] ], getValue: function getValue_unbound( targetArray, offset ) { this.bind(); this.getValue( targetArray, offset ); // Note: This class uses a State pattern on a per-method basis: // 'bind' sets 'this.getValue' / 'setValue' and shadows the // prototype version of these methods with one that represents // the bound state. When the property is not found, the methods // become no-ops. }, setValue: function getValue_unbound( sourceArray, offset ) { this.bind(); this.setValue( sourceArray, offset ); }, // create getter / setter pair for a property in the scene graph bind: function () { var targetObject = this.node, parsedPath = this.parsedPath, objectName = parsedPath.objectName, propertyName = parsedPath.propertyName, propertyIndex = parsedPath.propertyIndex; if ( ! targetObject ) { targetObject = PropertyBinding.findNode( this.rootNode, parsedPath.nodeName ) || this.rootNode; this.node = targetObject; } // set fail state so we can just 'return' on error this.getValue = this._getValue_unavailable; this.setValue = this._setValue_unavailable; // ensure there is a value node if ( ! targetObject ) { console.error( 'THREE.PropertyBinding: Trying to update node for track: ' + this.path + ' but it wasn\\'t found.' ); return; } if ( objectName ) { var objectIndex = parsedPath.objectIndex; // special cases were we need to reach deeper into the hierarchy to get the face materials.... switch ( objectName ) { case 'materials': if ( ! targetObject.material ) { console.error( 'THREE.PropertyBinding: Can not bind to material as node does not have a material.', this ); return; } if ( ! targetObject.material.materials ) { console.error( 'THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.', this ); return; } targetObject = targetObject.material.materials; break; case 'bones': if ( ! targetObject.skeleton ) { console.error( 'THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.', this ); return; } // potential future optimization: skip this if propertyIndex is already an integer // and convert the integer string to a true integer. targetObject = targetObject.skeleton.bones; // support resolving morphTarget names into indices. for ( var i = 0; i < targetObject.length; i ++ ) { if ( targetObject[ i ].name === objectIndex ) { objectIndex = i; break; } } break; default: if ( targetObject[ objectName ] === undefined ) { console.error( 'THREE.PropertyBinding: Can not bind to objectName of node undefined.', this ); return; } targetObject = targetObject[ objectName ]; } if ( objectIndex !== undefined ) { if ( targetObject[ objectIndex ] === undefined ) { console.error( 'THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.', this, targetObject ); return; } targetObject = targetObject[ objectIndex ]; } } // resolve property var nodeProperty = targetObject[ propertyName ]; if ( nodeProperty === undefined ) { var nodeName = parsedPath.nodeName; console.error( 'THREE.PropertyBinding: Trying to update property for track: ' + nodeName + '.' + propertyName + ' but it wasn\\'t found.', targetObject ); return; } // determine versioning scheme var versioning = this.Versioning.None; this.targetObject = targetObject; if ( targetObject.needsUpdate !== undefined ) { // material versioning = this.Versioning.NeedsUpdate; } else if ( targetObject.matrixWorldNeedsUpdate !== undefined ) { // node transform versioning = this.Versioning.MatrixWorldNeedsUpdate; } // determine how the property gets bound var bindingType = this.BindingType.Direct; if ( propertyIndex !== undefined ) { // access a sub element of the property array (only primitives are supported right now) if ( propertyName === \"morphTargetInfluences\" ) { // potential optimization, skip this if propertyIndex is already an integer, and convert the integer string to a true integer. // support resolving morphTarget names into indices. if ( ! targetObject.geometry ) { console.error( 'THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.', this ); return; } if ( targetObject.geometry.isBufferGeometry ) { if ( ! targetObject.geometry.morphAttributes ) { console.error( 'THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.', this ); return; } for ( var i = 0; i < this.node.geometry.morphAttributes.position.length; i ++ ) { if ( targetObject.geometry.morphAttributes.position[ i ].name === propertyIndex ) { propertyIndex = i; break; } } } else { if ( ! targetObject.geometry.morphTargets ) { console.error( 'THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphTargets.', this ); return; } for ( var i = 0; i < this.node.geometry.morphTargets.length; i ++ ) { if ( targetObject.geometry.morphTargets[ i ].name === propertyIndex ) { propertyIndex = i; break; } } } } bindingType = this.BindingType.ArrayElement; this.resolvedProperty = nodeProperty; this.propertyIndex = propertyIndex; } else if ( nodeProperty.fromArray !== undefined && nodeProperty.toArray !== undefined ) { // must use copy for Object3D.Euler/Quaternion bindingType = this.BindingType.HasFromToArray; this.resolvedProperty = nodeProperty; } else if ( Array.isArray( nodeProperty ) ) { bindingType = this.BindingType.EntireArray; this.resolvedProperty = nodeProperty; } else { this.propertyName = propertyName; } // select getter / setter this.getValue = this.GetterByBindingType[ bindingType ]; this.setValue = this.SetterByBindingTypeAndVersioning[ bindingType ][ versioning ]; }, unbind: function () { this.node = null; // back to the prototype version of getValue / setValue // note: avoiding to mutate the shape of 'this' via 'delete' this.getValue = this._getValue_unbound; this.setValue = this._setValue_unbound; } } ); //!\\ DECLARE ALIAS AFTER assign prototype ! Object.assign( PropertyBinding.prototype, { // initial state of these methods that calls 'bind' _getValue_unbound: PropertyBinding.prototype.getValue, _setValue_unbound: PropertyBinding.prototype.setValue, } ); /** * * A group of objects that receives a shared animation state. * * Usage: * * - Add objects you would otherwise pass as 'root' to the * constructor or the .clipAction method of AnimationMixer. * * - Instead pass this object as 'root'. * * - You can also add and remove objects later when the mixer * is running. * * Note: * * Objects of this class appear as one object to the mixer, * so cache control of the individual objects must be done * on the group. * * Limitation: * * - The animated properties must be compatible among the * all objects in the group. * * - A single property can either be controlled through a * target group or directly, but not both. * * @author tschw */ function AnimationObjectGroup() { this.uuid = _Math.generateUUID(); // cached objects followed by the active ones this._objects = Array.prototype.slice.call( arguments ); this.nCachedObjects_ = 0; // threshold // note: read by PropertyBinding.Composite var indices = {}; this._indicesByUUID = indices; // for bookkeeping for ( var i = 0, n = arguments.length; i !== n; ++ i ) { indices[ arguments[ i ].uuid ] = i; } this._paths = []; // inside: string this._parsedPaths = []; // inside: { we don't care, here } this._bindings = []; // inside: Array< PropertyBinding > this._bindingsIndicesByPath = {}; // inside: indices in these arrays var scope = this; this.stats = { objects: { get total() { return scope._objects.length; }, get inUse() { return this.total - scope.nCachedObjects_; } }, get bindingsPerObject() { return scope._bindings.length; } }; } Object.assign( AnimationObjectGroup.prototype, { isAnimationObjectGroup: true, add: function () { var objects = this._objects, nObjects = objects.length, nCachedObjects = this.nCachedObjects_, indicesByUUID = this._indicesByUUID, paths = this._paths, parsedPaths = this._parsedPaths, bindings = this._bindings, nBindings = bindings.length, knownObject = undefined; for ( var i = 0, n = arguments.length; i !== n; ++ i ) { var object = arguments[ i ], uuid = object.uuid, index = indicesByUUID[ uuid ]; if ( index === undefined ) { // unknown object -> add it to the ACTIVE region index = nObjects ++; indicesByUUID[ uuid ] = index; objects.push( object ); // accounting is done, now do the same for all bindings for ( var j = 0, m = nBindings; j !== m; ++ j ) { bindings[ j ].push( new PropertyBinding( object, paths[ j ], parsedPaths[ j ] ) ); } } else if ( index < nCachedObjects ) { knownObject = objects[ index ]; // move existing object to the ACTIVE region var firstActiveIndex = -- nCachedObjects, lastCachedObject = objects[ firstActiveIndex ]; indicesByUUID[ lastCachedObject.uuid ] = index; objects[ index ] = lastCachedObject; indicesByUUID[ uuid ] = firstActiveIndex; objects[ firstActiveIndex ] = object; // accounting is done, now do the same for all bindings for ( var j = 0, m = nBindings; j !== m; ++ j ) { var bindingsForPath = bindings[ j ], lastCached = bindingsForPath[ firstActiveIndex ], binding = bindingsForPath[ index ]; bindingsForPath[ index ] = lastCached; if ( binding === undefined ) { // since we do not bother to create new bindings // for objects that are cached, the binding may // or may not exist binding = new PropertyBinding( object, paths[ j ], parsedPaths[ j ] ); } bindingsForPath[ firstActiveIndex ] = binding; } } else if ( objects[ index ] !== knownObject ) { console.error( 'THREE.AnimationObjectGroup: Different objects with the same UUID ' + 'detected. Clean the caches or recreate your infrastructure when reloading scenes.' ); } // else the object is already where we want it to be } // for arguments this.nCachedObjects_ = nCachedObjects; }, remove: function () { var objects = this._objects, nCachedObjects = this.nCachedObjects_, indicesByUUID = this._indicesByUUID, bindings = this._bindings, nBindings = bindings.length; for ( var i = 0, n = arguments.length; i !== n; ++ i ) { var object = arguments[ i ], uuid = object.uuid, index = indicesByUUID[ uuid ]; if ( index !== undefined && index >= nCachedObjects ) { // move existing object into the CACHED region var lastCachedIndex = nCachedObjects ++, firstActiveObject = objects[ lastCachedIndex ]; indicesByUUID[ firstActiveObject.uuid ] = index; objects[ index ] = firstActiveObject; indicesByUUID[ uuid ] = lastCachedIndex; objects[ lastCachedIndex ] = object; // accounting is done, now do the same for all bindings for ( var j = 0, m = nBindings; j !== m; ++ j ) { var bindingsForPath = bindings[ j ], firstActive = bindingsForPath[ lastCachedIndex ], binding = bindingsForPath[ index ]; bindingsForPath[ index ] = firstActive; bindingsForPath[ lastCachedIndex ] = binding; } } } // for arguments this.nCachedObjects_ = nCachedObjects; }, // remove & forget uncache: function () { var objects = this._objects, nObjects = objects.length, nCachedObjects = this.nCachedObjects_, indicesByUUID = this._indicesByUUID, bindings = this._bindings, nBindings = bindings.length; for ( var i = 0, n = arguments.length; i !== n; ++ i ) { var object = arguments[ i ], uuid = object.uuid, index = indicesByUUID[ uuid ]; if ( index !== undefined ) { delete indicesByUUID[ uuid ]; if ( index < nCachedObjects ) { // object is cached, shrink the CACHED region var firstActiveIndex = -- nCachedObjects, lastCachedObject = objects[ firstActiveIndex ], lastIndex = -- nObjects, lastObject = objects[ lastIndex ]; // last cached object takes this object's place indicesByUUID[ lastCachedObject.uuid ] = index; objects[ index ] = lastCachedObject; // last object goes to the activated slot and pop indicesByUUID[ lastObject.uuid ] = firstActiveIndex; objects[ firstActiveIndex ] = lastObject; objects.pop(); // accounting is done, now do the same for all bindings for ( var j = 0, m = nBindings; j !== m; ++ j ) { var bindingsForPath = bindings[ j ], lastCached = bindingsForPath[ firstActiveIndex ], last = bindingsForPath[ lastIndex ]; bindingsForPath[ index ] = lastCached; bindingsForPath[ firstActiveIndex ] = last; bindingsForPath.pop(); } } else { // object is active, just swap with the last and pop var lastIndex = -- nObjects, lastObject = objects[ lastIndex ]; indicesByUUID[ lastObject.uuid ] = index; objects[ index ] = lastObject; objects.pop(); // accounting is done, now do the same for all bindings for ( var j = 0, m = nBindings; j !== m; ++ j ) { var bindingsForPath = bindings[ j ]; bindingsForPath[ index ] = bindingsForPath[ lastIndex ]; bindingsForPath.pop(); } } // cached or active } // if object is known } // for arguments this.nCachedObjects_ = nCachedObjects; }, // Internal interface used by befriended PropertyBinding.Composite: subscribe_: function ( path, parsedPath ) { // returns an array of bindings for the given path that is changed // according to the contained objects in the group var indicesByPath = this._bindingsIndicesByPath, index = indicesByPath[ path ], bindings = this._bindings; if ( index !== undefined ) return bindings[ index ]; var paths = this._paths, parsedPaths = this._parsedPaths, objects = this._objects, nObjects = objects.length, nCachedObjects = this.nCachedObjects_, bindingsForPath = new Array( nObjects ); index = bindings.length; indicesByPath[ path ] = index; paths.push( path ); parsedPaths.push( parsedPath ); bindings.push( bindingsForPath ); for ( var i = nCachedObjects, n = objects.length; i !== n; ++ i ) { var object = objects[ i ]; bindingsForPath[ i ] = new PropertyBinding( object, path, parsedPath ); } return bindingsForPath; }, unsubscribe_: function ( path ) { // tells the group to forget about a property path and no longer // update the array previously obtained with 'subscribe_' var indicesByPath = this._bindingsIndicesByPath, index = indicesByPath[ path ]; if ( index !== undefined ) { var paths = this._paths, parsedPaths = this._parsedPaths, bindings = this._bindings, lastBindingsIndex = bindings.length - 1, lastBindings = bindings[ lastBindingsIndex ], lastBindingsPath = path[ lastBindingsIndex ]; indicesByPath[ lastBindingsPath ] = index; bindings[ index ] = lastBindings; bindings.pop(); parsedPaths[ index ] = parsedPaths[ lastBindingsIndex ]; parsedPaths.pop(); paths[ index ] = paths[ lastBindingsIndex ]; paths.pop(); } } } ); /** * * Action provided by AnimationMixer for scheduling clip playback on specific * objects. * * @author Ben Houston / http://clara.io/ * @author David Sarno / http://lighthaus.us/ * @author tschw * */ function AnimationAction( mixer, clip, localRoot ) { this._mixer = mixer; this._clip = clip; this._localRoot = localRoot || null; var tracks = clip.tracks, nTracks = tracks.length, interpolants = new Array( nTracks ); var interpolantSettings = { endingStart: ZeroCurvatureEnding, endingEnd: ZeroCurvatureEnding }; for ( var i = 0; i !== nTracks; ++ i ) { var interpolant = tracks[ i ].createInterpolant( null ); interpolants[ i ] = interpolant; interpolant.settings = interpolantSettings; } this._interpolantSettings = interpolantSettings; this._interpolants = interpolants; // bound by the mixer // inside: PropertyMixer (managed by the mixer) this._propertyBindings = new Array( nTracks ); this._cacheIndex = null; // for the memory manager this._byClipCacheIndex = null; // for the memory manager this._timeScaleInterpolant = null; this._weightInterpolant = null; this.loop = LoopRepeat; this._loopCount = - 1; // global mixer time when the action is to be started // it's set back to 'null' upon start of the action this._startTime = null; // scaled local time of the action // gets clamped or wrapped to 0..clip.duration according to loop this.time = 0; this.timeScale = 1; this._effectiveTimeScale = 1; this.weight = 1; this._effectiveWeight = 1; this.repetitions = Infinity; // no. of repetitions when looping this.paused = false; // true -> zero effective time scale this.enabled = true; // false -> zero effective weight this.clampWhenFinished = false;// keep feeding the last frame? this.zeroSlopeAtStart = true;// for smooth interpolation w/o separate this.zeroSlopeAtEnd = true;// clips for start, loop and end } Object.assign( AnimationAction.prototype, { // State & Scheduling play: function () { this._mixer._activateAction( this ); return this; }, stop: function () { this._mixer._deactivateAction( this ); return this.reset(); }, reset: function () { this.paused = false; this.enabled = true; this.time = 0; // restart clip this._loopCount = - 1;// forget previous loops this._startTime = null;// forget scheduling return this.stopFading().stopWarping(); }, isRunning: function () { return this.enabled && ! this.paused && this.timeScale !== 0 && this._startTime === null && this._mixer._isActiveAction( this ); }, // return true when play has been called isScheduled: function () { return this._mixer._isActiveAction( this ); }, startAt: function ( time ) { this._startTime = time; return this; }, setLoop: function ( mode, repetitions ) { this.loop = mode; this.repetitions = repetitions; return this; }, // Weight // set the weight stopping any scheduled fading // although .enabled = false yields an effective weight of zero, this // method does *not* change .enabled, because it would be confusing setEffectiveWeight: function ( weight ) { this.weight = weight; // note: same logic as when updated at runtime this._effectiveWeight = this.enabled ? weight : 0; return this.stopFading(); }, // return the weight considering fading and .enabled getEffectiveWeight: function () { return this._effectiveWeight; }, fadeIn: function ( duration ) { return this._scheduleFading( duration, 0, 1 ); }, fadeOut: function ( duration ) { return this._scheduleFading( duration, 1, 0 ); }, crossFadeFrom: function ( fadeOutAction, duration, warp ) { fadeOutAction.fadeOut( duration ); this.fadeIn( duration ); if ( warp ) { var fadeInDuration = this._clip.duration, fadeOutDuration = fadeOutAction._clip.duration, startEndRatio = fadeOutDuration / fadeInDuration, endStartRatio = fadeInDuration / fadeOutDuration; fadeOutAction.warp( 1.0, startEndRatio, duration ); this.warp( endStartRatio, 1.0, duration ); } return this; }, crossFadeTo: function ( fadeInAction, duration, warp ) { return fadeInAction.crossFadeFrom( this, duration, warp ); }, stopFading: function () { var weightInterpolant = this._weightInterpolant; if ( weightInterpolant !== null ) { this._weightInterpolant = null; this._mixer._takeBackControlInterpolant( weightInterpolant ); } return this; }, // Time Scale Control // set the time scale stopping any scheduled warping // although .paused = true yields an effective time scale of zero, this // method does *not* change .paused, because it would be confusing setEffectiveTimeScale: function ( timeScale ) { this.timeScale = timeScale; this._effectiveTimeScale = this.paused ? 0 : timeScale; return this.stopWarping(); }, // return the time scale considering warping and .paused getEffectiveTimeScale: function () { return this._effectiveTimeScale; }, setDuration: function ( duration ) { this.timeScale = this._clip.duration / duration; return this.stopWarping(); }, syncWith: function ( action ) { this.time = action.time; this.timeScale = action.timeScale; return this.stopWarping(); }, halt: function ( duration ) { return this.warp( this._effectiveTimeScale, 0, duration ); }, warp: function ( startTimeScale, endTimeScale, duration ) { var mixer = this._mixer, now = mixer.time, interpolant = this._timeScaleInterpolant, timeScale = this.timeScale; if ( interpolant === null ) { interpolant = mixer._lendControlInterpolant(); this._timeScaleInterpolant = interpolant; } var times = interpolant.parameterPositions, values = interpolant.sampleValues; times[ 0 ] = now; times[ 1 ] = now + duration; values[ 0 ] = startTimeScale / timeScale; values[ 1 ] = endTimeScale / timeScale; return this; }, stopWarping: function () { var timeScaleInterpolant = this._timeScaleInterpolant; if ( timeScaleInterpolant !== null ) { this._timeScaleInterpolant = null; this._mixer._takeBackControlInterpolant( timeScaleInterpolant ); } return this; }, // Object Accessors getMixer: function () { return this._mixer; }, getClip: function () { return this._clip; }, getRoot: function () { return this._localRoot || this._mixer._root; }, // Interna _update: function ( time, deltaTime, timeDirection, accuIndex ) { // called by the mixer if ( ! this.enabled ) { // call ._updateWeight() to update ._effectiveWeight this._updateWeight( time ); return; } var startTime = this._startTime; if ( startTime !== null ) { // check for scheduled start of action var timeRunning = ( time - startTime ) * timeDirection; if ( timeRunning < 0 || timeDirection === 0 ) { return; // yet to come / don't decide when delta = 0 } // start this._startTime = null; // unschedule deltaTime = timeDirection * timeRunning; } // apply time scale and advance time deltaTime *= this._updateTimeScale( time ); var clipTime = this._updateTime( deltaTime ); // note: _updateTime may disable the action resulting in // an effective weight of 0 var weight = this._updateWeight( time ); if ( weight > 0 ) { var interpolants = this._interpolants; var propertyMixers = this._propertyBindings; for ( var j = 0, m = interpolants.length; j !== m; ++ j ) { interpolants[ j ].evaluate( clipTime ); propertyMixers[ j ].accumulate( accuIndex, weight ); } } }, _updateWeight: function ( time ) { var weight = 0; if ( this.enabled ) { weight = this.weight; var interpolant = this._weightInterpolant; if ( interpolant !== null ) { var interpolantValue = interpolant.evaluate( time )[ 0 ]; weight *= interpolantValue; if ( time > interpolant.parameterPositions[ 1 ] ) { this.stopFading(); if ( interpolantValue === 0 ) { // faded out, disable this.enabled = false; } } } } this._effectiveWeight = weight; return weight; }, _updateTimeScale: function ( time ) { var timeScale = 0; if ( ! this.paused ) { timeScale = this.timeScale; var interpolant = this._timeScaleInterpolant; if ( interpolant !== null ) { var interpolantValue = interpolant.evaluate( time )[ 0 ]; timeScale *= interpolantValue; if ( time > interpolant.parameterPositions[ 1 ] ) { this.stopWarping(); if ( timeScale === 0 ) { // motion has halted, pause this.paused = true; } else { // warp done - apply final time scale this.timeScale = timeScale; } } } } this._effectiveTimeScale = timeScale; return timeScale; }, _updateTime: function ( deltaTime ) { var time = this.time + deltaTime; var duration = this._clip.duration; var loop = this.loop; var loopCount = this._loopCount; var pingPong = ( loop === LoopPingPong ); if ( deltaTime === 0 ) { if ( loopCount === - 1 ) return time; return ( pingPong && ( loopCount & 1 ) === 1 ) ? duration - time : time; } if ( loop === LoopOnce ) { if ( loopCount === - 1 ) { // just started this._loopCount = 0; this._setEndings( true, true, false ); } handle_stop: { if ( time >= duration ) { time = duration; } else if ( time < 0 ) { time = 0; } else break handle_stop; if ( this.clampWhenFinished ) this.paused = true; else this.enabled = false; this._mixer.dispatchEvent( { type: 'finished', action: this, direction: deltaTime < 0 ? - 1 : 1 } ); } } else { // repetitive Repeat or PingPong if ( loopCount === - 1 ) { // just started if ( deltaTime >= 0 ) { loopCount = 0; this._setEndings( true, this.repetitions === 0, pingPong ); } else { // when looping in reverse direction, the initial // transition through zero counts as a repetition, // so leave loopCount at -1 this._setEndings( this.repetitions === 0, true, pingPong ); } } if ( time >= duration || time < 0 ) { // wrap around var loopDelta = Math.floor( time / duration ); // signed time -= duration * loopDelta; loopCount += Math.abs( loopDelta ); var pending = this.repetitions - loopCount; if ( pending 0 ? duration : 0; this._mixer.dispatchEvent( { type: 'finished', action: this, direction: deltaTime > 0 ? 1 : - 1 } ); } else { // keep running if ( pending === 1 ) { // entering the last round var atStart = deltaTime < 0; this._setEndings( atStart, ! atStart, pingPong ); } else { this._setEndings( false, false, pingPong ); } this._loopCount = loopCount; this._mixer.dispatchEvent( { type: 'loop', action: this, loopDelta: loopDelta } ); } } if ( pingPong && ( loopCount & 1 ) === 1 ) { // invert time for the \"pong round\" this.time = time; return duration - time; } } this.time = time; return time; }, _setEndings: function ( atStart, atEnd, pingPong ) { var settings = this._interpolantSettings; if ( pingPong ) { settings.endingStart = ZeroSlopeEnding; settings.endingEnd = ZeroSlopeEnding; } else { // assuming for LoopOnce atStart == atEnd == true if ( atStart ) { settings.endingStart = this.zeroSlopeAtStart ? ZeroSlopeEnding : ZeroCurvatureEnding; } else { settings.endingStart = WrapAroundEnding; } if ( atEnd ) { settings.endingEnd = this.zeroSlopeAtEnd ? ZeroSlopeEnding : ZeroCurvatureEnding; } else { settings.endingEnd = WrapAroundEnding; } } }, _scheduleFading: function ( duration, weightNow, weightThen ) { var mixer = this._mixer, now = mixer.time, interpolant = this._weightInterpolant; if ( interpolant === null ) { interpolant = mixer._lendControlInterpolant(); this._weightInterpolant = interpolant; } var times = interpolant.parameterPositions, values = interpolant.sampleValues; times[ 0 ] = now; values[ 0 ] = weightNow; times[ 1 ] = now + duration; values[ 1 ] = weightThen; return this; } } ); /** * * Player for AnimationClips. * * * @author Ben Houston / http://clara.io/ * @author David Sarno / http://lighthaus.us/ * @author tschw */ function AnimationMixer( root ) { this._root = root; this._initMemoryManager(); this._accuIndex = 0; this.time = 0; this.timeScale = 1.0; } AnimationMixer.prototype = Object.assign( Object.create( EventDispatcher.prototype ), { constructor: AnimationMixer, _bindAction: function ( action, prototypeAction ) { var root = action._localRoot || this._root, tracks = action._clip.tracks, nTracks = tracks.length, bindings = action._propertyBindings, interpolants = action._interpolants, rootUuid = root.uuid, bindingsByRoot = this._bindingsByRootAndName, bindingsByName = bindingsByRoot[ rootUuid ]; if ( bindingsByName === undefined ) { bindingsByName = {}; bindingsByRoot[ rootUuid ] = bindingsByName; } for ( var i = 0; i !== nTracks; ++ i ) { var track = tracks[ i ], trackName = track.name, binding = bindingsByName[ trackName ]; if ( binding !== undefined ) { bindings[ i ] = binding; } else { binding = bindings[ i ]; if ( binding !== undefined ) { // existing binding, make sure the cache knows if ( binding._cacheIndex === null ) { ++ binding.referenceCount; this._addInactiveBinding( binding, rootUuid, trackName ); } continue; } var path = prototypeAction && prototypeAction. _propertyBindings[ i ].binding.parsedPath; binding = new PropertyMixer( PropertyBinding.create( root, trackName, path ), track.ValueTypeName, track.getValueSize() ); ++ binding.referenceCount; this._addInactiveBinding( binding, rootUuid, trackName ); bindings[ i ] = binding; } interpolants[ i ].resultBuffer = binding.buffer; } }, _activateAction: function ( action ) { if ( ! this._isActiveAction( action ) ) { if ( action._cacheIndex === null ) { // this action has been forgotten by the cache, but the user // appears to be still using it -> rebind var rootUuid = ( action._localRoot || this._root ).uuid, clipUuid = action._clip.uuid, actionsForClip = this._actionsByClip[ clipUuid ]; this._bindAction( action, actionsForClip && actionsForClip.knownActions[ 0 ] ); this._addInactiveAction( action, clipUuid, rootUuid ); } var bindings = action._propertyBindings; // increment reference counts / sort out state for ( var i = 0, n = bindings.length; i !== n; ++ i ) { var binding = bindings[ i ]; if ( binding.useCount ++ === 0 ) { this._lendBinding( binding ); binding.saveOriginalState(); } } this._lendAction( action ); } }, _deactivateAction: function ( action ) { if ( this._isActiveAction( action ) ) { var bindings = action._propertyBindings; // decrement reference counts / sort out state for ( var i = 0, n = bindings.length; i !== n; ++ i ) { var binding = bindings[ i ]; if ( -- binding.useCount === 0 ) { binding.restoreOriginalState(); this._takeBackBinding( binding ); } } this._takeBackAction( action ); } }, // Memory manager _initMemoryManager: function () { this._actions = []; // 'nActiveActions' followed by inactive ones this._nActiveActions = 0; this._actionsByClip = {}; // inside: // { // knownActions: Array< AnimationAction > - used as prototypes // actionByRoot: AnimationAction - lookup // } this._bindings = []; // 'nActiveBindings' followed by inactive ones this._nActiveBindings = 0; this._bindingsByRootAndName = {}; // inside: Map< name, PropertyMixer > this._controlInterpolants = []; // same game as above this._nActiveControlInterpolants = 0; var scope = this; this.stats = { actions: { get total() { return scope._actions.length; }, get inUse() { return scope._nActiveActions; } }, bindings: { get total() { return scope._bindings.length; }, get inUse() { return scope._nActiveBindings; } }, controlInterpolants: { get total() { return scope._controlInterpolants.length; }, get inUse() { return scope._nActiveControlInterpolants; } } }; }, // Memory management for AnimationAction objects _isActiveAction: function ( action ) { var index = action._cacheIndex; return index !== null && index < this._nActiveActions; }, _addInactiveAction: function ( action, clipUuid, rootUuid ) { var actions = this._actions, actionsByClip = this._actionsByClip, actionsForClip = actionsByClip[ clipUuid ]; if ( actionsForClip === undefined ) { actionsForClip = { knownActions: [ action ], actionByRoot: {} }; action._byClipCacheIndex = 0; actionsByClip[ clipUuid ] = actionsForClip; } else { var knownActions = actionsForClip.knownActions; action._byClipCacheIndex = knownActions.length; knownActions.push( action ); } action._cacheIndex = actions.length; actions.push( action ); actionsForClip.actionByRoot[ rootUuid ] = action; }, _removeInactiveAction: function ( action ) { var actions = this._actions, lastInactiveAction = actions[ actions.length - 1 ], cacheIndex = action._cacheIndex; lastInactiveAction._cacheIndex = cacheIndex; actions[ cacheIndex ] = lastInactiveAction; actions.pop(); action._cacheIndex = null; var clipUuid = action._clip.uuid, actionsByClip = this._actionsByClip, actionsForClip = actionsByClip[ clipUuid ], knownActionsForClip = actionsForClip.knownActions, lastKnownAction = knownActionsForClip[ knownActionsForClip.length - 1 ], byClipCacheIndex = action._byClipCacheIndex; lastKnownAction._byClipCacheIndex = byClipCacheIndex; knownActionsForClip[ byClipCacheIndex ] = lastKnownAction; knownActionsForClip.pop(); action._byClipCacheIndex = null; var actionByRoot = actionsForClip.actionByRoot, rootUuid = ( action._localRoot || this._root ).uuid; delete actionByRoot[ rootUuid ]; if ( knownActionsForClip.length === 0 ) { delete actionsByClip[ clipUuid ]; } this._removeInactiveBindingsForAction( action ); }, _removeInactiveBindingsForAction: function ( action ) { var bindings = action._propertyBindings; for ( var i = 0, n = bindings.length; i !== n; ++ i ) { var binding = bindings[ i ]; if ( -- binding.referenceCount === 0 ) { this._removeInactiveBinding( binding ); } } }, _lendAction: function ( action ) { // [ active actions | inactive actions ] // [ active actions >| inactive actions ] // s a // // a s var actions = this._actions, prevIndex = action._cacheIndex, lastActiveIndex = this._nActiveActions ++, firstInactiveAction = actions[ lastActiveIndex ]; action._cacheIndex = lastActiveIndex; actions[ lastActiveIndex ] = action; firstInactiveAction._cacheIndex = prevIndex; actions[ prevIndex ] = firstInactiveAction; }, _takeBackAction: function ( action ) { // [ active actions | inactive actions ] // [ active actions |< inactive actions ] // a s // // s a var actions = this._actions, prevIndex = action._cacheIndex, firstInactiveIndex = -- this._nActiveActions, lastActiveAction = actions[ firstInactiveIndex ]; action._cacheIndex = firstInactiveIndex; actions[ firstInactiveIndex ] = action; lastActiveAction._cacheIndex = prevIndex; actions[ prevIndex ] = lastActiveAction; }, // Memory management for PropertyMixer objects _addInactiveBinding: function ( binding, rootUuid, trackName ) { var bindingsByRoot = this._bindingsByRootAndName, bindingByName = bindingsByRoot[ rootUuid ], bindings = this._bindings; if ( bindingByName === undefined ) { bindingByName = {}; bindingsByRoot[ rootUuid ] = bindingByName; } bindingByName[ trackName ] = binding; binding._cacheIndex = bindings.length; bindings.push( binding ); }, _removeInactiveBinding: function ( binding ) { var bindings = this._bindings, propBinding = binding.binding, rootUuid = propBinding.rootNode.uuid, trackName = propBinding.path, bindingsByRoot = this._bindingsByRootAndName, bindingByName = bindingsByRoot[ rootUuid ], lastInactiveBinding = bindings[ bindings.length - 1 ], cacheIndex = binding._cacheIndex; lastInactiveBinding._cacheIndex = cacheIndex; bindings[ cacheIndex ] = lastInactiveBinding; bindings.pop(); delete bindingByName[ trackName ]; remove_empty_map: { for ( var _ in bindingByName ) break remove_empty_map; // eslint-disable-line no-unused-vars delete bindingsByRoot[ rootUuid ]; } }, _lendBinding: function ( binding ) { var bindings = this._bindings, prevIndex = binding._cacheIndex, lastActiveIndex = this._nActiveBindings ++, firstInactiveBinding = bindings[ lastActiveIndex ]; binding._cacheIndex = lastActiveIndex; bindings[ lastActiveIndex ] = binding; firstInactiveBinding._cacheIndex = prevIndex; bindings[ prevIndex ] = firstInactiveBinding; }, _takeBackBinding: function ( binding ) { var bindings = this._bindings, prevIndex = binding._cacheIndex, firstInactiveIndex = -- this._nActiveBindings, lastActiveBinding = bindings[ firstInactiveIndex ]; binding._cacheIndex = firstInactiveIndex; bindings[ firstInactiveIndex ] = binding; lastActiveBinding._cacheIndex = prevIndex; bindings[ prevIndex ] = lastActiveBinding; }, // Memory management of Interpolants for weight and time scale _lendControlInterpolant: function () { var interpolants = this._controlInterpolants, lastActiveIndex = this._nActiveControlInterpolants ++, interpolant = interpolants[ lastActiveIndex ]; if ( interpolant === undefined ) { interpolant = new LinearInterpolant( new Float32Array( 2 ), new Float32Array( 2 ), 1, this._controlInterpolantsResultBuffer ); interpolant.__cacheIndex = lastActiveIndex; interpolants[ lastActiveIndex ] = interpolant; } return interpolant; }, _takeBackControlInterpolant: function ( interpolant ) { var interpolants = this._controlInterpolants, prevIndex = interpolant.__cacheIndex, firstInactiveIndex = -- this._nActiveControlInterpolants, lastActiveInterpolant = interpolants[ firstInactiveIndex ]; interpolant.__cacheIndex = firstInactiveIndex; interpolants[ firstInactiveIndex ] = interpolant; lastActiveInterpolant.__cacheIndex = prevIndex; interpolants[ prevIndex ] = lastActiveInterpolant; }, _controlInterpolantsResultBuffer: new Float32Array( 1 ), // return an action for a clip optionally using a custom root target // object (this method allocates a lot of dynamic memory in case a // previously unknown clip/root combination is specified) clipAction: function ( clip, optionalRoot ) { var root = optionalRoot || this._root, rootUuid = root.uuid, clipObject = typeof clip === 'string' ? AnimationClip.findByName( root, clip ) : clip, clipUuid = clipObject !== null ? clipObject.uuid : clip, actionsForClip = this._actionsByClip[ clipUuid ], prototypeAction = null; if ( actionsForClip !== undefined ) { var existingAction = actionsForClip.actionByRoot[ rootUuid ]; if ( existingAction !== undefined ) { return existingAction; } // we know the clip, so we don't have to parse all // the bindings again but can just copy prototypeAction = actionsForClip.knownActions[ 0 ]; // also, take the clip from the prototype action if ( clipObject === null ) clipObject = prototypeAction._clip; } // clip must be known when specified via string if ( clipObject === null ) return null; // allocate all resources required to run it var newAction = new AnimationAction( this, clipObject, optionalRoot ); this._bindAction( newAction, prototypeAction ); // and make the action known to the memory manager this._addInactiveAction( newAction, clipUuid, rootUuid ); return newAction; }, // get an existing action existingAction: function ( clip, optionalRoot ) { var root = optionalRoot || this._root, rootUuid = root.uuid, clipObject = typeof clip === 'string' ? AnimationClip.findByName( root, clip ) : clip, clipUuid = clipObject ? clipObject.uuid : clip, actionsForClip = this._actionsByClip[ clipUuid ]; if ( actionsForClip !== undefined ) { return actionsForClip.actionByRoot[ rootUuid ] || null; } return null; }, // deactivates all previously scheduled actions stopAllAction: function () { var actions = this._actions, nActions = this._nActiveActions, bindings = this._bindings, nBindings = this._nActiveBindings; this._nActiveActions = 0; this._nActiveBindings = 0; for ( var i = 0; i !== nActions; ++ i ) { actions[ i ].reset(); } for ( var i = 0; i !== nBindings; ++ i ) { bindings[ i ].useCount = 0; } return this; }, // advance the time and update apply the animation update: function ( deltaTime ) { deltaTime *= this.timeScale; var actions = this._actions, nActions = this._nActiveActions, time = this.time += deltaTime, timeDirection = Math.sign( deltaTime ), accuIndex = this._accuIndex ^= 1; // run active actions for ( var i = 0; i !== nActions; ++ i ) { var action = actions[ i ]; action._update( time, deltaTime, timeDirection, accuIndex ); } // update scene graph var bindings = this._bindings, nBindings = this._nActiveBindings; for ( var i = 0; i !== nBindings; ++ i ) { bindings[ i ].apply( accuIndex ); } return this; }, // return this mixer's root target object getRoot: function () { return this._root; }, // free all resources specific to a particular clip uncacheClip: function ( clip ) { var actions = this._actions, clipUuid = clip.uuid, actionsByClip = this._actionsByClip, actionsForClip = actionsByClip[ clipUuid ]; if ( actionsForClip !== undefined ) { // note: just calling _removeInactiveAction would mess up the // iteration state and also require updating the state we can // just throw away var actionsToRemove = actionsForClip.knownActions; for ( var i = 0, n = actionsToRemove.length; i !== n; ++ i ) { var action = actionsToRemove[ i ]; this._deactivateAction( action ); var cacheIndex = action._cacheIndex, lastInactiveAction = actions[ actions.length - 1 ]; action._cacheIndex = null; action._byClipCacheIndex = null; lastInactiveAction._cacheIndex = cacheIndex; actions[ cacheIndex ] = lastInactiveAction; actions.pop(); this._removeInactiveBindingsForAction( action ); } delete actionsByClip[ clipUuid ]; } }, // free all resources specific to a particular root target object uncacheRoot: function ( root ) { var rootUuid = root.uuid, actionsByClip = this._actionsByClip; for ( var clipUuid in actionsByClip ) { var actionByRoot = actionsByClip[ clipUuid ].actionByRoot, action = actionByRoot[ rootUuid ]; if ( action !== undefined ) { this._deactivateAction( action ); this._removeInactiveAction( action ); } } var bindingsByRoot = this._bindingsByRootAndName, bindingByName = bindingsByRoot[ rootUuid ]; if ( bindingByName !== undefined ) { for ( var trackName in bindingByName ) { var binding = bindingByName[ trackName ]; binding.restoreOriginalState(); this._removeInactiveBinding( binding ); } } }, // remove a targeted clip from the cache uncacheAction: function ( clip, optionalRoot ) { var action = this.existingAction( clip, optionalRoot ); if ( action !== null ) { this._deactivateAction( action ); this._removeInactiveAction( action ); } } } ); /** * @author mrdoob / http://mrdoob.com/ */ function Uniform( value ) { if ( typeof value === 'string' ) { console.warn( 'THREE.Uniform: Type parameter is no longer needed.' ); value = arguments[ 1 ]; } this.value = value; } Uniform.prototype.clone = function () { return new Uniform( this.value.clone === undefined ? this.value : this.value.clone() ); }; /** * @author benaadams / https://twitter.com/ben_a_adams */ function InstancedBufferGeometry() { BufferGeometry.call( this ); this.type = 'InstancedBufferGeometry'; this.maxInstancedCount = undefined; } InstancedBufferGeometry.prototype = Object.assign( Object.create( BufferGeometry.prototype ), { constructor: InstancedBufferGeometry, isInstancedBufferGeometry: true, copy: function ( source ) { BufferGeometry.prototype.copy.call( this, source ); this.maxInstancedCount = source.maxInstancedCount; return this; }, clone: function () { return new this.constructor().copy( this ); } } ); /** * @author benaadams / https://twitter.com/ben_a_adams */ function InstancedInterleavedBuffer( array, stride, meshPerAttribute ) { InterleavedBuffer.call( this, array, stride ); this.meshPerAttribute = meshPerAttribute || 1; } InstancedInterleavedBuffer.prototype = Object.assign( Object.create( InterleavedBuffer.prototype ), { constructor: InstancedInterleavedBuffer, isInstancedInterleavedBuffer: true, copy: function ( source ) { InterleavedBuffer.prototype.copy.call( this, source ); this.meshPerAttribute = source.meshPerAttribute; return this; } } ); /** * @author benaadams / https://twitter.com/ben_a_adams */ function InstancedBufferAttribute( array, itemSize, normalized, meshPerAttribute ) { if ( typeof ( normalized ) === 'number' ) { meshPerAttribute = normalized; normalized = false; console.error( 'THREE.InstancedBufferAttribute: The constructor now expects normalized as the third argument.' ); } BufferAttribute.call( this, array, itemSize, normalized ); this.meshPerAttribute = meshPerAttribute || 1; } InstancedBufferAttribute.prototype = Object.assign( Object.create( BufferAttribute.prototype ), { constructor: InstancedBufferAttribute, isInstancedBufferAttribute: true, copy: function ( source ) { BufferAttribute.prototype.copy.call( this, source ); this.meshPerAttribute = source.meshPerAttribute; return this; } } ); /** * @author mrdoob / http://mrdoob.com/ * @author bhouston / http://clara.io/ * @author stephomi / http://stephaneginier.com/ */ function Raycaster( origin, direction, near, far ) { this.ray = new Ray( origin, direction ); // direction is assumed to be normalized (for accurate distance calculations) this.near = near || 0; this.far = far || Infinity; this.params = { Mesh: {}, Line: {}, LOD: {}, Points: { threshold: 1 }, Sprite: {} }; Object.defineProperties( this.params, { PointCloud: { get: function () { console.warn( 'THREE.Raycaster: params.PointCloud has been renamed to params.Points.' ); return this.Points; } } } ); } function ascSort( a, b ) { return a.distance - b.distance; } function intersectObject( object, raycaster, intersects, recursive ) { if ( object.visible === false ) return; object.raycast( raycaster, intersects ); if ( recursive === true ) { var children = object.children; for ( var i = 0, l = children.length; i < l; i ++ ) { intersectObject( children[ i ], raycaster, intersects, true ); } } } Object.assign( Raycaster.prototype, { linePrecision: 1, set: function ( origin, direction ) { // direction is assumed to be normalized (for accurate distance calculations) this.ray.set( origin, direction ); }, setFromCamera: function ( coords, camera ) { if ( ( camera && camera.isPerspectiveCamera ) ) { this.ray.origin.setFromMatrixPosition( camera.matrixWorld ); this.ray.direction.set( coords.x, coords.y, 0.5 ).unproject( camera ).sub( this.ray.origin ).normalize(); } else if ( ( camera && camera.isOrthographicCamera ) ) { this.ray.origin.set( coords.x, coords.y, ( camera.near + camera.far ) / ( camera.near - camera.far ) ).unproject( camera ); // set origin in plane of camera this.ray.direction.set( 0, 0, - 1 ).transformDirection( camera.matrixWorld ); } else { console.error( 'THREE.Raycaster: Unsupported camera type.' ); } }, intersectObject: function ( object, recursive, optionalTarget ) { var intersects = optionalTarget || []; intersectObject( object, this, intersects, recursive ); intersects.sort( ascSort ); return intersects; }, intersectObjects: function ( objects, recursive, optionalTarget ) { var intersects = optionalTarget || []; if ( Array.isArray( objects ) === false ) { console.warn( 'THREE.Raycaster.intersectObjects: objects is not an Array.' ); return intersects; } for ( var i = 0, l = objects.length; i < l; i ++ ) { intersectObject( objects[ i ], this, intersects, recursive ); } intersects.sort( ascSort ); return intersects; } } ); /** * @author bhouston / http://clara.io * @author WestLangley / http://github.com/WestLangley * * Ref: https://en.wikipedia.org/wiki/Spherical_coordinate_system * * The polar angle (phi) is measured from the positive y-axis. The positive y-axis is up. * The azimuthal angle (theta) is measured from the positive z-axiz. */ function Spherical( radius, phi, theta ) { this.radius = ( radius !== undefined ) ? radius : 1.0; this.phi = ( phi !== undefined ) ? phi : 0; // polar angle this.theta = ( theta !== undefined ) ? theta : 0; // azimuthal angle return this; } Object.assign( Spherical.prototype, { set: function ( radius, phi, theta ) { this.radius = radius; this.phi = phi; this.theta = theta; return this; }, clone: function () { return new this.constructor().copy( this ); }, copy: function ( other ) { this.radius = other.radius; this.phi = other.phi; this.theta = other.theta; return this; }, // restrict phi to be betwee EPS and PI-EPS makeSafe: function () { var EPS = 0.000001; this.phi = Math.max( EPS, Math.min( Math.PI - EPS, this.phi ) ); return this; }, setFromVector3: function ( v ) { return this.setFromCartesianCoords( v.x, v.y, v.z ); }, setFromCartesianCoords: function ( x, y, z ) { this.radius = Math.sqrt( x * x + y * y + z * z ); if ( this.radius === 0 ) { this.theta = 0; this.phi = 0; } else { this.theta = Math.atan2( x, z ); this.phi = Math.acos( _Math.clamp( y / this.radius, - 1, 1 ) ); } return this; } } ); /** * @author Mugen87 / https://github.com/Mugen87 * * Ref: https://en.wikipedia.org/wiki/Cylindrical_coordinate_system * */ function Cylindrical( radius, theta, y ) { this.radius = ( radius !== undefined ) ? radius : 1.0; // distance from the origin to a point in the x-z plane this.theta = ( theta !== undefined ) ? theta : 0; // counterclockwise angle in the x-z plane measured in radians from the positive z-axis this.y = ( y !== undefined ) ? y : 0; // height above the x-z plane return this; } Object.assign( Cylindrical.prototype, { set: function ( radius, theta, y ) { this.radius = radius; this.theta = theta; this.y = y; return this; }, clone: function () { return new this.constructor().copy( this ); }, copy: function ( other ) { this.radius = other.radius; this.theta = other.theta; this.y = other.y; return this; }, setFromVector3: function ( v ) { return this.setFromCartesianCoords( v.x, v.y, v.z ); }, setFromCartesianCoords: function ( x, y, z ) { this.radius = Math.sqrt( x * x + z * z ); this.theta = Math.atan2( x, z ); this.y = y; return this; } } ); /** * @author bhouston / http://clara.io */ function Box2( min, max ) { this.min = ( min !== undefined ) ? min : new Vector2( + Infinity, + Infinity ); this.max = ( max !== undefined ) ? max : new Vector2( - Infinity, - Infinity ); } Object.assign( Box2.prototype, { set: function ( min, max ) { this.min.copy( min ); this.max.copy( max ); return this; }, setFromPoints: function ( points ) { this.makeEmpty(); for ( var i = 0, il = points.length; i < il; i ++ ) { this.expandByPoint( points[ i ] ); } return this; }, setFromCenterAndSize: function () { var v1 = new Vector2(); return function setFromCenterAndSize( center, size ) { var halfSize = v1.copy( size ).multiplyScalar( 0.5 ); this.min.copy( center ).sub( halfSize ); this.max.copy( center ).add( halfSize ); return this; }; }(), clone: function () { return new this.constructor().copy( this ); }, copy: function ( box ) { this.min.copy( box.min ); this.max.copy( box.max ); return this; }, makeEmpty: function () { this.min.x = this.min.y = + Infinity; this.max.x = this.max.y = - Infinity; return this; }, isEmpty: function () { // this is a more robust check for empty than ( volume this.max.y ? false : true; }, containsBox: function ( box ) { return this.min.x this.max.y ? false : true; }, clampPoint: function ( point, target ) { if ( target === undefined ) { console.warn( 'THREE.Box2: .clampPoint() target is now required' ); target = new Vector2(); } return target.copy( point ).clamp( this.min, this.max ); }, distanceToPoint: function () { var v1 = new Vector2(); return function distanceToPoint( point ) { var clampedPoint = v1.copy( point ).clamp( this.min, this.max ); return clampedPoint.sub( point ).length(); }; }(), intersect: function ( box ) { this.min.max( box.min ); this.max.min( box.max ); return this; }, union: function ( box ) { this.min.min( box.min ); this.max.max( box.max ); return this; }, translate: function ( offset ) { this.min.add( offset ); this.max.add( offset ); return this; }, equals: function ( box ) { return box.min.equals( this.min ) && box.max.equals( this.max ); } } ); /** * @author bhouston / http://clara.io */ function Line3( start, end ) { this.start = ( start !== undefined ) ? start : new Vector3(); this.end = ( end !== undefined ) ? end : new Vector3(); } Object.assign( Line3.prototype, { set: function ( start, end ) { this.start.copy( start ); this.end.copy( end ); return this; }, clone: function () { return new this.constructor().copy( this ); }, copy: function ( line ) { this.start.copy( line.start ); this.end.copy( line.end ); return this; }, getCenter: function ( target ) { if ( target === undefined ) { console.warn( 'THREE.Line3: .getCenter() target is now required' ); target = new Vector3(); } return target.addVectors( this.start, this.end ).multiplyScalar( 0.5 ); }, delta: function ( target ) { if ( target === undefined ) { console.warn( 'THREE.Line3: .delta() target is now required' ); target = new Vector3(); } return target.subVectors( this.end, this.start ); }, distanceSq: function () { return this.start.distanceToSquared( this.end ); }, distance: function () { return this.start.distanceTo( this.end ); }, at: function ( t, target ) { if ( target === undefined ) { console.warn( 'THREE.Line3: .at() target is now required' ); target = new Vector3(); } return this.delta( target ).multiplyScalar( t ).add( this.start ); }, closestPointToPointParameter: function () { var startP = new Vector3(); var startEnd = new Vector3(); return function closestPointToPointParameter( point, clampToLine ) { startP.subVectors( point, this.start ); startEnd.subVectors( this.end, this.start ); var startEnd2 = startEnd.dot( startEnd ); var startEnd_startP = startEnd.dot( startP ); var t = startEnd_startP / startEnd2; if ( clampToLine ) { t = _Math.clamp( t, 0, 1 ); } return t; }; }(), closestPointToPoint: function ( point, clampToLine, target ) { var t = this.closestPointToPointParameter( point, clampToLine ); if ( target === undefined ) { console.warn( 'THREE.Line3: .closestPointToPoint() target is now required' ); target = new Vector3(); } return this.delta( target ).multiplyScalar( t ).add( this.start ); }, applyMatrix4: function ( matrix ) { this.start.applyMatrix4( matrix ); this.end.applyMatrix4( matrix ); return this; }, equals: function ( line ) { return line.start.equals( this.start ) && line.end.equals( this.end ); } } ); /** * @author alteredq / http://alteredqualia.com/ */ function ImmediateRenderObject( material ) { Object3D.call( this ); this.material = material; this.render = function ( /* renderCallback */ ) {}; } ImmediateRenderObject.prototype = Object.create( Object3D.prototype ); ImmediateRenderObject.prototype.constructor = ImmediateRenderObject; ImmediateRenderObject.prototype.isImmediateRenderObject = true; /** * @author mrdoob / http://mrdoob.com/ * @author WestLangley / http://github.com/WestLangley */ function VertexNormalsHelper( object, size, hex, linewidth ) { this.object = object; this.size = ( size !== undefined ) ? size : 1; var color = ( hex !== undefined ) ? hex : 0xff0000; var width = ( linewidth !== undefined ) ? linewidth : 1; // var nNormals = 0; var objGeometry = this.object.geometry; if ( objGeometry && objGeometry.isGeometry ) { nNormals = objGeometry.faces.length * 3; } else if ( objGeometry && objGeometry.isBufferGeometry ) { nNormals = objGeometry.attributes.normal.count; } // var geometry = new BufferGeometry(); var positions = new Float32BufferAttribute( nNormals * 2 * 3, 3 ); geometry.addAttribute( 'position', positions ); LineSegments.call( this, geometry, new LineBasicMaterial( { color: color, linewidth: width } ) ); // this.matrixAutoUpdate = false; this.update(); } VertexNormalsHelper.prototype = Object.create( LineSegments.prototype ); VertexNormalsHelper.prototype.constructor = VertexNormalsHelper; VertexNormalsHelper.prototype.update = ( function () { var v1 = new Vector3(); var v2 = new Vector3(); var normalMatrix = new Matrix3(); return function update() { var keys = [ 'a', 'b', 'c' ]; this.object.updateMatrixWorld( true ); normalMatrix.getNormalMatrix( this.object.matrixWorld ); var matrixWorld = this.object.matrixWorld; var position = this.geometry.attributes.position; // var objGeometry = this.object.geometry; if ( objGeometry && objGeometry.isGeometry ) { var vertices = objGeometry.vertices; var faces = objGeometry.faces; var idx = 0; for ( var i = 0, l = faces.length; i < l; i ++ ) { var face = faces[ i ]; for ( var j = 0, jl = face.vertexNormals.length; j < jl; j ++ ) { var vertex = vertices[ face[ keys[ j ] ] ]; var normal = face.vertexNormals[ j ]; v1.copy( vertex ).applyMatrix4( matrixWorld ); v2.copy( normal ).applyMatrix3( normalMatrix ).normalize().multiplyScalar( this.size ).add( v1 ); position.setXYZ( idx, v1.x, v1.y, v1.z ); idx = idx + 1; position.setXYZ( idx, v2.x, v2.y, v2.z ); idx = idx + 1; } } } else if ( objGeometry && objGeometry.isBufferGeometry ) { var objPos = objGeometry.attributes.position; var objNorm = objGeometry.attributes.normal; var idx = 0; // for simplicity, ignore index and drawcalls, and render every normal for ( var j = 0, jl = objPos.count; j < jl; j ++ ) { v1.set( objPos.getX( j ), objPos.getY( j ), objPos.getZ( j ) ).applyMatrix4( matrixWorld ); v2.set( objNorm.getX( j ), objNorm.getY( j ), objNorm.getZ( j ) ); v2.applyMatrix3( normalMatrix ).normalize().multiplyScalar( this.size ).add( v1 ); position.setXYZ( idx, v1.x, v1.y, v1.z ); idx = idx + 1; position.setXYZ( idx, v2.x, v2.y, v2.z ); idx = idx + 1; } } position.needsUpdate = true; }; }() ); /** * @author alteredq / http://alteredqualia.com/ * @author mrdoob / http://mrdoob.com/ * @author WestLangley / http://github.com/WestLangley */ function SpotLightHelper( light, color ) { Object3D.call( this ); this.light = light; this.light.updateMatrixWorld(); this.matrix = light.matrixWorld; this.matrixAutoUpdate = false; this.color = color; var geometry = new BufferGeometry(); var positions = [ 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, - 1, 0, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, - 1, 1 ]; for ( var i = 0, j = 1, l = 32; i < l; i ++, j ++ ) { var p1 = ( i / l ) * Math.PI * 2; var p2 = ( j / l ) * Math.PI * 2; positions.push( Math.cos( p1 ), Math.sin( p1 ), 1, Math.cos( p2 ), Math.sin( p2 ), 1 ); } geometry.addAttribute( 'position', new Float32BufferAttribute( positions, 3 ) ); var material = new LineBasicMaterial( { fog: false } ); this.cone = new LineSegments( geometry, material ); this.add( this.cone ); this.update(); } SpotLightHelper.prototype = Object.create( Object3D.prototype ); SpotLightHelper.prototype.constructor = SpotLightHelper; SpotLightHelper.prototype.dispose = function () { this.cone.geometry.dispose(); this.cone.material.dispose(); }; SpotLightHelper.prototype.update = function () { var vector = new Vector3(); return function update() { this.light.updateMatrixWorld(); var coneLength = this.light.distance ? this.light.distance : 1000; var coneWidth = coneLength * Math.tan( this.light.angle ); this.cone.scale.set( coneWidth, coneWidth, coneLength ); vector.setFromMatrixPosition( this.light.target.matrixWorld ); this.cone.lookAt( vector ); if ( this.color !== undefined ) { this.cone.material.color.set( this.color ); } else { this.cone.material.color.copy( this.light.color ); } }; }(); /** * @author Sean Griffin / http://twitter.com/sgrif * @author Michael Guerrero / http://realitymeltdown.com * @author mrdoob / http://mrdoob.com/ * @author ikerr / http://verold.com * @author Mugen87 / https://github.com/Mugen87 */ function getBoneList( object ) { var boneList = []; if ( object && object.isBone ) { boneList.push( object ); } for ( var i = 0; i < object.children.length; i ++ ) { boneList.push.apply( boneList, getBoneList( object.children[ i ] ) ); } return boneList; } function SkeletonHelper( object ) { var bones = getBoneList( object ); var geometry = new BufferGeometry(); var vertices = []; var colors = []; var color1 = new Color( 0, 0, 1 ); var color2 = new Color( 0, 1, 0 ); for ( var i = 0; i < bones.length; i ++ ) { var bone = bones[ i ]; if ( bone.parent && bone.parent.isBone ) { vertices.push( 0, 0, 0 ); vertices.push( 0, 0, 0 ); colors.push( color1.r, color1.g, color1.b ); colors.push( color2.r, color2.g, color2.b ); } } geometry.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) ); geometry.addAttribute( 'color', new Float32BufferAttribute( colors, 3 ) ); var material = new LineBasicMaterial( { vertexColors: VertexColors, depthTest: false, depthWrite: false, transparent: true } ); LineSegments.call( this, geometry, material ); this.root = object; this.bones = bones; this.matrix = object.matrixWorld; this.matrixAutoUpdate = false; } SkeletonHelper.prototype = Object.create( LineSegments.prototype ); SkeletonHelper.prototype.constructor = SkeletonHelper; SkeletonHelper.prototype.updateMatrixWorld = function () { var vector = new Vector3(); var boneMatrix = new Matrix4(); var matrixWorldInv = new Matrix4(); return function updateMatrixWorld( force ) { var bones = this.bones; var geometry = this.geometry; var position = geometry.getAttribute( 'position' ); matrixWorldInv.getInverse( this.root.matrixWorld ); for ( var i = 0, j = 0; i < bones.length; i ++ ) { var bone = bones[ i ]; if ( bone.parent && bone.parent.isBone ) { boneMatrix.multiplyMatrices( matrixWorldInv, bone.matrixWorld ); vector.setFromMatrixPosition( boneMatrix ); position.setXYZ( j, vector.x, vector.y, vector.z ); boneMatrix.multiplyMatrices( matrixWorldInv, bone.parent.matrixWorld ); vector.setFromMatrixPosition( boneMatrix ); position.setXYZ( j + 1, vector.x, vector.y, vector.z ); j += 2; } } geometry.getAttribute( 'position' ).needsUpdate = true; Object3D.prototype.updateMatrixWorld.call( this, force ); }; }(); /** * @author alteredq / http://alteredqualia.com/ * @author mrdoob / http://mrdoob.com/ */ function PointLightHelper( light, sphereSize, color ) { this.light = light; this.light.updateMatrixWorld(); this.color = color; var geometry = new SphereBufferGeometry( sphereSize, 4, 2 ); var material = new MeshBasicMaterial( { wireframe: true, fog: false } ); Mesh.call( this, geometry, material ); this.matrix = this.light.matrixWorld; this.matrixAutoUpdate = false; this.update(); /* var distanceGeometry = new THREE.IcosahedronBufferGeometry( 1, 2 ); var distanceMaterial = new THREE.MeshBasicMaterial( { color: hexColor, fog: false, wireframe: true, opacity: 0.1, transparent: true } ); this.lightSphere = new THREE.Mesh( bulbGeometry, bulbMaterial ); this.lightDistance = new THREE.Mesh( distanceGeometry, distanceMaterial ); var d = light.distance; if ( d === 0.0 ) { this.lightDistance.visible = false; } else { this.lightDistance.scale.set( d, d, d ); } this.add( this.lightDistance ); */ } PointLightHelper.prototype = Object.create( Mesh.prototype ); PointLightHelper.prototype.constructor = PointLightHelper; PointLightHelper.prototype.dispose = function () { this.geometry.dispose(); this.material.dispose(); }; PointLightHelper.prototype.update = function () { if ( this.color !== undefined ) { this.material.color.set( this.color ); } else { this.material.color.copy( this.light.color ); } /* var d = this.light.distance; if ( d === 0.0 ) { this.lightDistance.visible = false; } else { this.lightDistance.visible = true; this.lightDistance.scale.set( d, d, d ); } */ }; /** * @author abelnation / http://github.com/abelnation * @author Mugen87 / http://github.com/Mugen87 * @author WestLangley / http://github.com/WestLangley * * This helper must be added as a child of the light */ function RectAreaLightHelper( light, color ) { this.type = 'RectAreaLightHelper'; this.light = light; this.color = color; // optional hardwired color for the helper var positions = [ 1, 1, 0, - 1, 1, 0, - 1, - 1, 0, 1, - 1, 0, 1, 1, 0 ]; var geometry = new BufferGeometry(); geometry.addAttribute( 'position', new Float32BufferAttribute( positions, 3 ) ); geometry.computeBoundingSphere(); var material = new LineBasicMaterial( { fog: false } ); Line.call( this, geometry, material ); // var positions2 = [ 1, 1, 0, - 1, 1, 0, - 1, - 1, 0, 1, 1, 0, - 1, - 1, 0, 1, - 1, 0 ]; var geometry2 = new BufferGeometry(); geometry2.addAttribute( 'position', new Float32BufferAttribute( positions2, 3 ) ); geometry2.computeBoundingSphere(); this.add( new Mesh( geometry2, new MeshBasicMaterial( { side: BackSide, fog: false } ) ) ); this.update(); } RectAreaLightHelper.prototype = Object.create( Line.prototype ); RectAreaLightHelper.prototype.constructor = RectAreaLightHelper; RectAreaLightHelper.prototype.update = function () { this.scale.set( 0.5 * this.light.width, 0.5 * this.light.height, 1 ); if ( this.color !== undefined ) { this.material.color.set( this.color ); this.children[ 0 ].material.color.set( this.color ); } else { this.material.color.copy( this.light.color ).multiplyScalar( this.light.intensity ); // prevent hue shift var c = this.material.color; var max = Math.max( c.r, c.g, c.b ); if ( max > 1 ) c.multiplyScalar( 1 / max ); this.children[ 0 ].material.color.copy( this.material.color ); } }; RectAreaLightHelper.prototype.dispose = function () { this.geometry.dispose(); this.material.dispose(); this.children[ 0 ].geometry.dispose(); this.children[ 0 ].material.dispose(); }; /** * @author alteredq / http://alteredqualia.com/ * @author mrdoob / http://mrdoob.com/ * @author Mugen87 / https://github.com/Mugen87 */ function HemisphereLightHelper( light, size, color ) { Object3D.call( this ); this.light = light; this.light.updateMatrixWorld(); this.matrix = light.matrixWorld; this.matrixAutoUpdate = false; this.color = color; var geometry = new OctahedronBufferGeometry( size ); geometry.rotateY( Math.PI * 0.5 ); this.material = new MeshBasicMaterial( { wireframe: true, fog: false } ); if ( this.color === undefined ) this.material.vertexColors = VertexColors; var position = geometry.getAttribute( 'position' ); var colors = new Float32Array( position.count * 3 ); geometry.addAttribute( 'color', new BufferAttribute( colors, 3 ) ); this.add( new Mesh( geometry, this.material ) ); this.update(); } HemisphereLightHelper.prototype = Object.create( Object3D.prototype ); HemisphereLightHelper.prototype.constructor = HemisphereLightHelper; HemisphereLightHelper.prototype.dispose = function () { this.children[ 0 ].geometry.dispose(); this.children[ 0 ].material.dispose(); }; HemisphereLightHelper.prototype.update = function () { var vector = new Vector3(); var color1 = new Color(); var color2 = new Color(); return function update() { var mesh = this.children[ 0 ]; if ( this.color !== undefined ) { this.material.color.set( this.color ); } else { var colors = mesh.geometry.getAttribute( 'color' ); color1.copy( this.light.color ); color2.copy( this.light.groundColor ); for ( var i = 0, l = colors.count; i < l; i ++ ) { var color = ( i < ( l / 2 ) ) ? color1 : color2; colors.setXYZ( i, color.r, color.g, color.b ); } colors.needsUpdate = true; } mesh.lookAt( vector.setFromMatrixPosition( this.light.matrixWorld ).negate() ); }; }(); /** * @author mrdoob / http://mrdoob.com/ */ function GridHelper( size, divisions, color1, color2 ) { size = size || 10; divisions = divisions || 10; color1 = new Color( color1 !== undefined ? color1 : 0x444444 ); color2 = new Color( color2 !== undefined ? color2 : 0x888888 ); var center = divisions / 2; var step = size / divisions; var halfSize = size / 2; var vertices = [], colors = []; for ( var i = 0, j = 0, k = - halfSize; i"}],"posts":[{"title":"Three.js移动DecalGeometry","slug":"Three.js移动DecalGeometry","date":"2019-03-17T14:03:27.772Z","updated":"2019-03-17T14:03:27.772Z","comments":true,"path":"2019/03/17/cjtcra7gx0000h1l3u7zhsy7d/","link":"","permalink":"http://www.zcating.tk/2019/03/17/cjtcra7gx0000h1l3u7zhsy7d/","excerpt":"遇到了一个需求是，使得DecalGeometry可以移动，先上个demo","text":"遇到了一个需求是，使得DecalGeometry可以移动，先上个demo #three-container { position: relative; width: 100%; height: 500px; } var container = document.getElementById( 'three-container' ); var renderer; var scene; var camera; var humanModel; var humanModels = []; var raycaster; var line; var intersection = { intersects: false, point: new THREE.Vector3(), normal: new THREE.Vector3() }; var mouse = new THREE.Vector2(); var textureLoader = new THREE.TextureLoader(); var decalDiffuse = textureLoader.load( 'textures/decal-diffuse.png' ); var decalNormal = textureLoader.load( 'textures/decal-normal.jpg' ); var decalMaterial = new THREE.MeshPhongMaterial( { specular: 0x444444, map: decalDiffuse, normalMap: decalNormal, normalScale: new THREE.Vector2( 1, 1 ), shininess: 30, transparent: true, depthTest: true, depthWrite: false, polygonOffset: true, polygonOffsetFactor: - 4, wireframe: false }); var decals = []; var mouseHelper; var position = new THREE.Vector3(); var orientation = new THREE.Euler(); var size = new THREE.Vector3( 10, 10, 10 ); var params = { minScale: 10, maxScale: 20, rotate: true, clear: function () { removeDecals(); } }; var focusDecalObject = { model: null, moving: false } window.addEventListener( 'load', init ); function init() { renderer = new THREE.WebGLRenderer( { antialias: true } ); renderer.setPixelRatio( window.devicePixelRatio ); renderer.setSize( container.offsetWidth, container.offsetHeight ); container.appendChild( renderer.domElement ); scene = new THREE.Scene(); camera = new THREE.PerspectiveCamera( 45, container.offsetWidth / container.offsetHeight, 1, 1000 ); camera.position.z = 120; camera.target = new THREE.Vector3(); var controls = new THREE.OrbitControls( camera, renderer.domElement ); controls.minDistance = 50; controls.maxDistance = 200; scene.add( new THREE.AmbientLight( 0x443333 ) ); var light = new THREE.DirectionalLight( 0xffddcc, 1 ); light.position.set( 1, 0.75, 0.5 ); scene.add( light ); var light = new THREE.DirectionalLight( 0xccccff, 1 ); light.position.set( - 1, 0.75, - 0.5 ); scene.add( light ); var geometry = new THREE.BufferGeometry(); geometry.setFromPoints( [ new THREE.Vector3(), new THREE.Vector3() ] ); line = new THREE.Line( geometry, new THREE.LineBasicMaterial() ); scene.add( line ); loadLeePerrySmith(); raycaster = new THREE.Raycaster(); mouseHelper = new THREE.Mesh(new THREE.BoxBufferGeometry( 1, 1, 10 ), new THREE.MeshNormalMaterial()); mouseHelper.visible = false; scene.add( mouseHelper ); window.addEventListener('resize', onWindowResize, false); controls.addEventListener( 'change', function () { renderer.render( scene, camera ); } ); window.addEventListener( 'mousedown', function (event) { event.preventDefault(); getMousePoint(event); raycaster.setFromCamera(mouse, camera); var intersects = raycaster.intersectObjects(decals); if (intersects.length > 0) { focusDecalObject.moving = true; focusDecalObject.model = intersects[0].object; controls.enabled = false; } else { focusDecalObject.moving = false; controls.enabled = true; } }, false ); window.addEventListener( 'mouseup', function () { event.preventDefault(); if ( !focusDecalObject.moving && intersection.intersects ) { shoot(); } controls.enabled = true; focusDecalObject.moving = false; } ); window.addEventListener( 'mousemove', onTouchMove ); window.addEventListener( 'touchmove', onTouchMove ); function onTouchMove( event ) { getMousePoint(event); event.preventDefault(); if(focusDecalObject.moving) { raycaster.setFromCamera(mouse, camera); var intersects = raycaster.intersectObjects(humanModels); if (intersects.length > 0) { var model = intersects[0].object; var point = intersects[0].point; mouseHelper.position.copy(point); var normal = intersects[0].face.normal.clone(); normal.multiplyScalar(10); normal.add(intersects[0].point); mouseHelper.lookAt(normal); var rotation = mouseHelper.rotation; focusDecalObject.model.geometry.dispose(); focusDecalObject.model.geometry = new THREE.DecalGeometry(model, point, rotation, size); } } checkIntersection(); renderer.render( scene, camera ); } function getMousePoint(event) { mouse.x = (event.offsetX / container.offsetWidth) * 2 - 1; mouse.y = -(event.offsetY / container.offsetHeight) * 2 + 1; } function checkIntersection() { if ( ! humanModel ) { return; } raycaster.setFromCamera( mouse, camera ); var intersects = raycaster.intersectObjects( humanModels ); if ( intersects.length > 0 ) { var point = intersects[ 0 ].point; mouseHelper.position.copy( point ); intersection.point.copy( point ); var normal = intersects[ 0 ].face.normal.clone(); normal.transformDirection( humanModel.matrixWorld ); normal.multiplyScalar( 10 ); normal.add( intersects[ 0 ].point ); intersection.normal.copy( intersects[ 0 ].face.normal ); mouseHelper.lookAt( normal ); var positions = line.geometry.attributes.position; positions.setXYZ( 0, point.x, point.y, point.z ); positions.setXYZ( 1, normal.x, normal.y, normal.z ); positions.needsUpdate = true; intersection.intersects = true; } else { intersection.intersects = false; } } onWindowResize(); } function loadLeePerrySmith() { var loader = new THREE.GLTFLoader(); loader.load( 'LeePerrySmith/LeePerrySmith.glb', function ( gltf ) { humanModel = gltf.scene.children[ 0 ]; humanModel.material = new THREE.MeshPhongMaterial({ specular: 0x111111, map: textureLoader.load( 'LeePerrySmith/Map-COL.jpg' ), specularMap: textureLoader.load( 'LeePerrySmith/Map-SPEC.jpg' ), normalMap: textureLoader.load( 'LeePerrySmith/Infinite-Level_02_Tangent_SmoothUV.jpg' ), shininess: 25 }); scene.add( humanModel ); humanModel.scale.set( 10, 10, 10 ); humanModels.push(humanModel); } ); } function shoot() { position.copy( intersection.point ); orientation.copy( mouseHelper.rotation ); var scale = 10; var material = decalMaterial.clone(); material.color.setHex( Math.random() * 0xffffff ); var decalMesh = new THREE.Mesh( new THREE.DecalGeometry( humanModel, position, orientation, size ), material ); decals.push( decalMesh ); scene.add( decalMesh ); } function onWindowResize() { camera.aspect = container.offsetWidth / container.offsetHeight; camera.updateProjectionMatrix(); renderer.setSize( container.offsetWidth, container.offsetHeight ); } 代码分析主要分为以下几个步骤： 点击鼠标，然后在生成decal。 点住decal的时候可以拖动decal。 首先要计算鼠标的具体位置，我们可以通过监听鼠标的事件来计算： 12345// container 是 document 对象function getMousePoint(event) &#123; mouse.x = (event.offsetX / container.offsetWidth) * 2 - 1; mouse.y = -(event.offsetY / container.offsetHeight) * 2 + 1;&#125; 通过监听点击事件，在模型上生成decal： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849// 鼠标松开会触发window.addEventListener('mouseup', function () &#123; event.preventDefault(); checkIntersection(); if ( !focusDecalObject.moving &amp;&amp; intersection.intersects ) &#123; // 在模型上进行decal shoot(); &#125; // 松开的时候轨道控制器允许运行 controls.enabled = true; focusDecalObject.moving = false;&#125;);// 鼠标点下会触发window.addEventListener('mousedown', function (event) &#123; event.preventDefault(); // 计算鼠标所在的点在三维中位置 getMousePoint(event); raycaster.setFromCamera(mouse, camera); // 用于判断我们的点是否落在decal上 var intersects = raycaster.intersectObjects(decals); // 如果落在decal上，focusDecalObject将获取点击所在的第一个decal， // 第一个decal意味着这个decal是覆盖在其他decal之上。 if (intersects.length &gt; 0) &#123; focusDecalObject.moving = true; focusDecalObject.model = intersects[0].object; controls.enabled = false; &#125; else &#123; focusDecalObject.moving = false; controls.enabled = true; &#125;&#125;, false );// 具体的将decal展示在模型上function shoot() &#123; position.copy( intersection.point ); orientation.copy( mouseHelper.rotation ); var scale = 10; var material = decalMaterial.clone(); material.color.setHex( Math.random() * 0xffffff ); var decalMesh = new THREE.Mesh( new THREE.DecalGeometry( humanModel, position, orientation, size ), material ); decals.push( decalMesh ); scene.add( decalMesh );&#125; 监听鼠标移动事件需要注意的是，要记录点下鼠标的动作，如果允许移动decal，那么就移动它，如果不，那就忽略，然后使轨道控制器运行。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566// 鼠标移动事件window.addEventListener( 'mousemove', function ( event ) &#123; getMousePoint(); event.preventDefault(); if(focusDecalObject.moving) &#123; // 还是通过raycaster计算鼠标点在3D中的位置。 raycaster.setFromCamera(mouse, camera); var intersects = this.raycaster.intersectObjects(humanModels); // 如果点在模型上，那么允许移动。 if (intersects.length &gt; 0) &#123; // var model = intersects[0].object; var point = intersects[0].point; mouseHelper.position.copy(point); // 这里的目的主要是为了改变 var normal = intersects[0].face.normal.clone(); normal.multiplyScalar(10); normal.add(intersects[0].point); mouseHelper.lookAt(normal); var rotation = mouseHelper.rotation; // 这里最重要，我们使原来的几何结构失效，并重新生成新的几何结构 focusDecalObject.model.dispose(); focusDecalObject.model.geometry = new THREE.DecalGeometry(model, position, rotation, size); &#125; &#125; // 显示点在模型上所在的平面的法线 checkIntersection();&#125;, false);function checkIntersection() &#123; if ( ! humanModel ) &#123; return; &#125; // 我们需要计算鼠标所在的点在三维中位置 raycaster.setFromCamera( mouse, camera ); // 去计算这个点是否在模型上 var intersects = raycaster.intersectObjects( humanModels ); if ( intersects.length &gt; 0 ) &#123; // 这个点在三维中的坐标 var point = intersects[ 0 ].point; mouseHelper.position.copy( point ); intersection.point.copy( point ); // 然后我们找到这个点所在平面的法线 var normal = intersects[ 0 ].face.normal.clone(); normal.transformDirection( humanModel.matrixWorld ); normal.multiplyScalar( 10 ); normal.add( intersects[ 0 ].point ); intersection.normal.copy( intersects[ 0 ].face.normal ); // 调整mouseHelper的角度，使其跟这个平面共面 mouseHelper.lookAt( normal ); // 当我们在模型上移动的时候，会显示该鼠标点上模型所在平面的法线。 var positions = line.geometry.attributes.position; positions.setXYZ( 0, point.x, point.y, point.z ); positions.setXYZ( 1, normal.x, normal.y, normal.z ); positions.needsUpdate = true; intersection.intersects = true; &#125; else &#123; intersection.intersects = false; &#125;&#125;","categories":[{"name":"-JavaScript","slug":"JavaScript","permalink":"http://www.zcating.tk/categories/JavaScript/"}],"tags":[]},{"title":"","slug":"Three.js移动DecalGeometry/three","date":"2019-03-17T10:06:35.723Z","updated":"2019-03-17T10:06:35.723Z","comments":true,"path":"2019/03/17/cjtcra7kn000gh1l34jljij1z/","link":"","permalink":"http://www.zcating.tk/2019/03/17/cjtcra7kn000gh1l34jljij1z/","excerpt":"","text":"(function (global, factory) { typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) : typeof define === 'function' && define.amd ? define(['exports'], factory) : (global = global || self, factory(global.THREE = {})); }(this, function (exports) { 'use strict'; // Polyfills if ( Number.EPSILON === undefined ) { Number.EPSILON = Math.pow( 2, - 52 ); } if ( Number.isInteger === undefined ) { // Missing in IE // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/isInteger Number.isInteger = function ( value ) { return typeof value === 'number' && isFinite( value ) && Math.floor( value ) === value; }; } // if ( Math.sign === undefined ) { // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/sign Math.sign = function ( x ) { return ( x < 0 ) ? - 1 : ( x > 0 ) ? 1 : + x; }; } if ( 'name' in Function.prototype === false ) { // Missing in IE // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/name Object.defineProperty( Function.prototype, 'name', { get: function () { return this.toString().match( /^\\s*function\\s*([^\\(\\s]*)/ )[ 1 ]; } } ); } if ( Object.assign === undefined ) { // Missing in IE // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/assign ( function () { Object.assign = function ( target ) { if ( target === undefined || target === null ) { throw new TypeError( 'Cannot convert undefined or null to object' ); } var output = Object( target ); for ( var index = 1; index < arguments.length; index ++ ) { var source = arguments[ index ]; if ( source !== undefined && source !== null ) { for ( var nextKey in source ) { if ( Object.prototype.hasOwnProperty.call( source, nextKey ) ) { output[ nextKey ] = source[ nextKey ]; } } } } return output; }; } )(); } /** * https://github.com/mrdoob/eventdispatcher.js/ */ function EventDispatcher() {} Object.assign( EventDispatcher.prototype, { addEventListener: function ( type, listener ) { if ( this._listeners === undefined ) this._listeners = {}; var listeners = this._listeners; if ( listeners[ type ] === undefined ) { listeners[ type ] = []; } if ( listeners[ type ].indexOf( listener ) === - 1 ) { listeners[ type ].push( listener ); } }, hasEventListener: function ( type, listener ) { if ( this._listeners === undefined ) return false; var listeners = this._listeners; return listeners[ type ] !== undefined && listeners[ type ].indexOf( listener ) !== - 1; }, removeEventListener: function ( type, listener ) { if ( this._listeners === undefined ) return; var listeners = this._listeners; var listenerArray = listeners[ type ]; if ( listenerArray !== undefined ) { var index = listenerArray.indexOf( listener ); if ( index !== - 1 ) { listenerArray.splice( index, 1 ); } } }, dispatchEvent: function ( event ) { if ( this._listeners === undefined ) return; var listeners = this._listeners; var listenerArray = listeners[ event.type ]; if ( listenerArray !== undefined ) { event.target = this; var array = listenerArray.slice( 0 ); for ( var i = 0, l = array.length; i < l; i ++ ) { array[ i ].call( this, event ); } } } } ); var REVISION = '102dev'; var MOUSE = { LEFT: 0, MIDDLE: 1, RIGHT: 2 }; var CullFaceNone = 0; var CullFaceBack = 1; var CullFaceFront = 2; var CullFaceFrontBack = 3; var FrontFaceDirectionCW = 0; var FrontFaceDirectionCCW = 1; var BasicShadowMap = 0; var PCFShadowMap = 1; var PCFSoftShadowMap = 2; var FrontSide = 0; var BackSide = 1; var DoubleSide = 2; var FlatShading = 1; var SmoothShading = 2; var NoColors = 0; var FaceColors = 1; var VertexColors = 2; var NoBlending = 0; var NormalBlending = 1; var AdditiveBlending = 2; var SubtractiveBlending = 3; var MultiplyBlending = 4; var CustomBlending = 5; var AddEquation = 100; var SubtractEquation = 101; var ReverseSubtractEquation = 102; var MinEquation = 103; var MaxEquation = 104; var ZeroFactor = 200; var OneFactor = 201; var SrcColorFactor = 202; var OneMinusSrcColorFactor = 203; var SrcAlphaFactor = 204; var OneMinusSrcAlphaFactor = 205; var DstAlphaFactor = 206; var OneMinusDstAlphaFactor = 207; var DstColorFactor = 208; var OneMinusDstColorFactor = 209; var SrcAlphaSaturateFactor = 210; var NeverDepth = 0; var AlwaysDepth = 1; var LessDepth = 2; var LessEqualDepth = 3; var EqualDepth = 4; var GreaterEqualDepth = 5; var GreaterDepth = 6; var NotEqualDepth = 7; var MultiplyOperation = 0; var MixOperation = 1; var AddOperation = 2; var NoToneMapping = 0; var LinearToneMapping = 1; var ReinhardToneMapping = 2; var Uncharted2ToneMapping = 3; var CineonToneMapping = 4; var ACESFilmicToneMapping = 5; var UVMapping = 300; var CubeReflectionMapping = 301; var CubeRefractionMapping = 302; var EquirectangularReflectionMapping = 303; var EquirectangularRefractionMapping = 304; var SphericalReflectionMapping = 305; var CubeUVReflectionMapping = 306; var CubeUVRefractionMapping = 307; var RepeatWrapping = 1000; var ClampToEdgeWrapping = 1001; var MirroredRepeatWrapping = 1002; var NearestFilter = 1003; var NearestMipMapNearestFilter = 1004; var NearestMipMapLinearFilter = 1005; var LinearFilter = 1006; var LinearMipMapNearestFilter = 1007; var LinearMipMapLinearFilter = 1008; var UnsignedByteType = 1009; var ByteType = 1010; var ShortType = 1011; var UnsignedShortType = 1012; var IntType = 1013; var UnsignedIntType = 1014; var FloatType = 1015; var HalfFloatType = 1016; var UnsignedShort4444Type = 1017; var UnsignedShort5551Type = 1018; var UnsignedShort565Type = 1019; var UnsignedInt248Type = 1020; var AlphaFormat = 1021; var RGBFormat = 1022; var RGBAFormat = 1023; var LuminanceFormat = 1024; var LuminanceAlphaFormat = 1025; var RGBEFormat = RGBAFormat; var DepthFormat = 1026; var DepthStencilFormat = 1027; var RedFormat = 1028; var RGB_S3TC_DXT1_Format = 33776; var RGBA_S3TC_DXT1_Format = 33777; var RGBA_S3TC_DXT3_Format = 33778; var RGBA_S3TC_DXT5_Format = 33779; var RGB_PVRTC_4BPPV1_Format = 35840; var RGB_PVRTC_2BPPV1_Format = 35841; var RGBA_PVRTC_4BPPV1_Format = 35842; var RGBA_PVRTC_2BPPV1_Format = 35843; var RGB_ETC1_Format = 36196; var RGBA_ASTC_4x4_Format = 37808; var RGBA_ASTC_5x4_Format = 37809; var RGBA_ASTC_5x5_Format = 37810; var RGBA_ASTC_6x5_Format = 37811; var RGBA_ASTC_6x6_Format = 37812; var RGBA_ASTC_8x5_Format = 37813; var RGBA_ASTC_8x6_Format = 37814; var RGBA_ASTC_8x8_Format = 37815; var RGBA_ASTC_10x5_Format = 37816; var RGBA_ASTC_10x6_Format = 37817; var RGBA_ASTC_10x8_Format = 37818; var RGBA_ASTC_10x10_Format = 37819; var RGBA_ASTC_12x10_Format = 37820; var RGBA_ASTC_12x12_Format = 37821; var LoopOnce = 2200; var LoopRepeat = 2201; var LoopPingPong = 2202; var InterpolateDiscrete = 2300; var InterpolateLinear = 2301; var InterpolateSmooth = 2302; var ZeroCurvatureEnding = 2400; var ZeroSlopeEnding = 2401; var WrapAroundEnding = 2402; var TrianglesDrawMode = 0; var TriangleStripDrawMode = 1; var TriangleFanDrawMode = 2; var LinearEncoding = 3000; var sRGBEncoding = 3001; var GammaEncoding = 3007; var RGBEEncoding = 3002; var LogLuvEncoding = 3003; var RGBM7Encoding = 3004; var RGBM16Encoding = 3005; var RGBDEncoding = 3006; var BasicDepthPacking = 3200; var RGBADepthPacking = 3201; var TangentSpaceNormalMap = 0; var ObjectSpaceNormalMap = 1; /** * @author alteredq / http://alteredqualia.com/ * @author mrdoob / http://mrdoob.com/ */ var _Math = { DEG2RAD: Math.PI / 180, RAD2DEG: 180 / Math.PI, generateUUID: ( function () { // http://stackoverflow.com/questions/105034/how-to-create-a-guid-uuid-in-javascript/21963136#21963136 var lut = []; for ( var i = 0; i < 256; i ++ ) { lut[ i ] = ( i < 16 ? '0' : '' ) + ( i ).toString( 16 ); } return function generateUUID() { var d0 = Math.random() * 0xffffffff | 0; var d1 = Math.random() * 0xffffffff | 0; var d2 = Math.random() * 0xffffffff | 0; var d3 = Math.random() * 0xffffffff | 0; var uuid = lut[ d0 & 0xff ] + lut[ d0 >> 8 & 0xff ] + lut[ d0 >> 16 & 0xff ] + lut[ d0 >> 24 & 0xff ] + '-' + lut[ d1 & 0xff ] + lut[ d1 >> 8 & 0xff ] + '-' + lut[ d1 >> 16 & 0x0f | 0x40 ] + lut[ d1 >> 24 & 0xff ] + '-' + lut[ d2 & 0x3f | 0x80 ] + lut[ d2 >> 8 & 0xff ] + '-' + lut[ d2 >> 16 & 0xff ] + lut[ d2 >> 24 & 0xff ] + lut[ d3 & 0xff ] + lut[ d3 >> 8 & 0xff ] + lut[ d3 >> 16 & 0xff ] + lut[ d3 >> 24 & 0xff ]; // .toUpperCase() here flattens concatenated strings to save heap memory space. return uuid.toUpperCase(); }; } )(), clamp: function ( value, min, max ) { return Math.max( min, Math.min( max, value ) ); }, // compute euclidian modulo of m % n // https://en.wikipedia.org/wiki/Modulo_operation euclideanModulo: function ( n, m ) { return ( ( n % m ) + m ) % m; }, // Linear mapping from range to range mapLinear: function ( x, a1, a2, b1, b2 ) { return b1 + ( x - a1 ) * ( b2 - b1 ) / ( a2 - a1 ); }, // https://en.wikipedia.org/wiki/Linear_interpolation lerp: function ( x, y, t ) { return ( 1 - t ) * x + t * y; }, // http://en.wikipedia.org/wiki/Smoothstep smoothstep: function ( x, min, max ) { if ( x = max ) return 1; x = ( x - min ) / ( max - min ); return x * x * ( 3 - 2 * x ); }, smootherstep: function ( x, min, max ) { if ( x = max ) return 1; x = ( x - min ) / ( max - min ); return x * x * x * ( x * ( x * 6 - 15 ) + 10 ); }, // Random integer from interval randInt: function ( low, high ) { return low + Math.floor( Math.random() * ( high - low + 1 ) ); }, // Random float from interval randFloat: function ( low, high ) { return low + Math.random() * ( high - low ); }, // Random float from interval randFloatSpread: function ( range ) { return range * ( 0.5 - Math.random() ); }, degToRad: function ( degrees ) { return degrees * _Math.DEG2RAD; }, radToDeg: function ( radians ) { return radians * _Math.RAD2DEG; }, isPowerOfTwo: function ( value ) { return ( value & ( value - 1 ) ) === 0 && value !== 0; }, ceilPowerOfTwo: function ( value ) { return Math.pow( 2, Math.ceil( Math.log( value ) / Math.LN2 ) ); }, floorPowerOfTwo: function ( value ) { return Math.pow( 2, Math.floor( Math.log( value ) / Math.LN2 ) ); } }; /** * @author mrdoob / http://mrdoob.com/ * @author philogb / http://blog.thejit.org/ * @author egraether / http://egraether.com/ * @author zz85 / http://www.lab4games.net/zz85/blog */ function Vector2( x, y ) { this.x = x || 0; this.y = y || 0; } Object.defineProperties( Vector2.prototype, { \"width\": { get: function () { return this.x; }, set: function ( value ) { this.x = value; } }, \"height\": { get: function () { return this.y; }, set: function ( value ) { this.y = value; } } } ); Object.assign( Vector2.prototype, { isVector2: true, set: function ( x, y ) { this.x = x; this.y = y; return this; }, setScalar: function ( scalar ) { this.x = scalar; this.y = scalar; return this; }, setX: function ( x ) { this.x = x; return this; }, setY: function ( y ) { this.y = y; return this; }, setComponent: function ( index, value ) { switch ( index ) { case 0: this.x = value; break; case 1: this.y = value; break; default: throw new Error( 'index is out of range: ' + index ); } return this; }, getComponent: function ( index ) { switch ( index ) { case 0: return this.x; case 1: return this.y; default: throw new Error( 'index is out of range: ' + index ); } }, clone: function () { return new this.constructor( this.x, this.y ); }, copy: function ( v ) { this.x = v.x; this.y = v.y; return this; }, add: function ( v, w ) { if ( w !== undefined ) { console.warn( 'THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead.' ); return this.addVectors( v, w ); } this.x += v.x; this.y += v.y; return this; }, addScalar: function ( s ) { this.x += s; this.y += s; return this; }, addVectors: function ( a, b ) { this.x = a.x + b.x; this.y = a.y + b.y; return this; }, addScaledVector: function ( v, s ) { this.x += v.x * s; this.y += v.y * s; return this; }, sub: function ( v, w ) { if ( w !== undefined ) { console.warn( 'THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.' ); return this.subVectors( v, w ); } this.x -= v.x; this.y -= v.y; return this; }, subScalar: function ( s ) { this.x -= s; this.y -= s; return this; }, subVectors: function ( a, b ) { this.x = a.x - b.x; this.y = a.y - b.y; return this; }, multiply: function ( v ) { this.x *= v.x; this.y *= v.y; return this; }, multiplyScalar: function ( scalar ) { this.x *= scalar; this.y *= scalar; return this; }, divide: function ( v ) { this.x /= v.x; this.y /= v.y; return this; }, divideScalar: function ( scalar ) { return this.multiplyScalar( 1 / scalar ); }, applyMatrix3: function ( m ) { var x = this.x, y = this.y; var e = m.elements; this.x = e[ 0 ] * x + e[ 3 ] * y + e[ 6 ]; this.y = e[ 1 ] * x + e[ 4 ] * y + e[ 7 ]; return this; }, min: function ( v ) { this.x = Math.min( this.x, v.x ); this.y = Math.min( this.y, v.y ); return this; }, max: function ( v ) { this.x = Math.max( this.x, v.x ); this.y = Math.max( this.y, v.y ); return this; }, clamp: function ( min, max ) { // assumes min < max, componentwise this.x = Math.max( min.x, Math.min( max.x, this.x ) ); this.y = Math.max( min.y, Math.min( max.y, this.y ) ); return this; }, clampScalar: function () { var min = new Vector2(); var max = new Vector2(); return function clampScalar( minVal, maxVal ) { min.set( minVal, minVal ); max.set( maxVal, maxVal ); return this.clamp( min, max ); }; }(), clampLength: function ( min, max ) { var length = this.length(); return this.divideScalar( length || 1 ).multiplyScalar( Math.max( min, Math.min( max, length ) ) ); }, floor: function () { this.x = Math.floor( this.x ); this.y = Math.floor( this.y ); return this; }, ceil: function () { this.x = Math.ceil( this.x ); this.y = Math.ceil( this.y ); return this; }, round: function () { this.x = Math.round( this.x ); this.y = Math.round( this.y ); return this; }, roundToZero: function () { this.x = ( this.x < 0 ) ? Math.ceil( this.x ) : Math.floor( this.x ); this.y = ( this.y < 0 ) ? Math.ceil( this.y ) : Math.floor( this.y ); return this; }, negate: function () { this.x = - this.x; this.y = - this.y; return this; }, dot: function ( v ) { return this.x * v.x + this.y * v.y; }, cross: function ( v ) { return this.x * v.y - this.y * v.x; }, lengthSq: function () { return this.x * this.x + this.y * this.y; }, length: function () { return Math.sqrt( this.x * this.x + this.y * this.y ); }, manhattanLength: function () { return Math.abs( this.x ) + Math.abs( this.y ); }, normalize: function () { return this.divideScalar( this.length() || 1 ); }, angle: function () { // computes the angle in radians with respect to the positive x-axis var angle = Math.atan2( this.y, this.x ); if ( angle < 0 ) angle += 2 * Math.PI; return angle; }, distanceTo: function ( v ) { return Math.sqrt( this.distanceToSquared( v ) ); }, distanceToSquared: function ( v ) { var dx = this.x - v.x, dy = this.y - v.y; return dx * dx + dy * dy; }, manhattanDistanceTo: function ( v ) { return Math.abs( this.x - v.x ) + Math.abs( this.y - v.y ); }, setLength: function ( length ) { return this.normalize().multiplyScalar( length ); }, lerp: function ( v, alpha ) { this.x += ( v.x - this.x ) * alpha; this.y += ( v.y - this.y ) * alpha; return this; }, lerpVectors: function ( v1, v2, alpha ) { return this.subVectors( v2, v1 ).multiplyScalar( alpha ).add( v1 ); }, equals: function ( v ) { return ( ( v.x === this.x ) && ( v.y === this.y ) ); }, fromArray: function ( array, offset ) { if ( offset === undefined ) offset = 0; this.x = array[ offset ]; this.y = array[ offset + 1 ]; return this; }, toArray: function ( array, offset ) { if ( array === undefined ) array = []; if ( offset === undefined ) offset = 0; array[ offset ] = this.x; array[ offset + 1 ] = this.y; return array; }, fromBufferAttribute: function ( attribute, index, offset ) { if ( offset !== undefined ) { console.warn( 'THREE.Vector2: offset has been removed from .fromBufferAttribute().' ); } this.x = attribute.getX( index ); this.y = attribute.getY( index ); return this; }, rotateAround: function ( center, angle ) { var c = Math.cos( angle ), s = Math.sin( angle ); var x = this.x - center.x; var y = this.y - center.y; this.x = x * c - y * s + center.x; this.y = x * s + y * c + center.y; return this; } } ); /** * @author mrdoob / http://mrdoob.com/ * @author supereggbert / http://www.paulbrunt.co.uk/ * @author philogb / http://blog.thejit.org/ * @author jordi_ros / http://plattsoft.com * @author D1plo1d / http://github.com/D1plo1d * @author alteredq / http://alteredqualia.com/ * @author mikael emtinger / http://gomo.se/ * @author timknip / http://www.floorplanner.com/ * @author bhouston / http://clara.io * @author WestLangley / http://github.com/WestLangley */ function Matrix4() { this.elements = [ 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1 ]; if ( arguments.length > 0 ) { console.error( 'THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.' ); } } Object.assign( Matrix4.prototype, { isMatrix4: true, set: function ( n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44 ) { var te = this.elements; te[ 0 ] = n11; te[ 4 ] = n12; te[ 8 ] = n13; te[ 12 ] = n14; te[ 1 ] = n21; te[ 5 ] = n22; te[ 9 ] = n23; te[ 13 ] = n24; te[ 2 ] = n31; te[ 6 ] = n32; te[ 10 ] = n33; te[ 14 ] = n34; te[ 3 ] = n41; te[ 7 ] = n42; te[ 11 ] = n43; te[ 15 ] = n44; return this; }, identity: function () { this.set( 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1 ); return this; }, clone: function () { return new Matrix4().fromArray( this.elements ); }, copy: function ( m ) { var te = this.elements; var me = m.elements; te[ 0 ] = me[ 0 ]; te[ 1 ] = me[ 1 ]; te[ 2 ] = me[ 2 ]; te[ 3 ] = me[ 3 ]; te[ 4 ] = me[ 4 ]; te[ 5 ] = me[ 5 ]; te[ 6 ] = me[ 6 ]; te[ 7 ] = me[ 7 ]; te[ 8 ] = me[ 8 ]; te[ 9 ] = me[ 9 ]; te[ 10 ] = me[ 10 ]; te[ 11 ] = me[ 11 ]; te[ 12 ] = me[ 12 ]; te[ 13 ] = me[ 13 ]; te[ 14 ] = me[ 14 ]; te[ 15 ] = me[ 15 ]; return this; }, copyPosition: function ( m ) { var te = this.elements, me = m.elements; te[ 12 ] = me[ 12 ]; te[ 13 ] = me[ 13 ]; te[ 14 ] = me[ 14 ]; return this; }, extractBasis: function ( xAxis, yAxis, zAxis ) { xAxis.setFromMatrixColumn( this, 0 ); yAxis.setFromMatrixColumn( this, 1 ); zAxis.setFromMatrixColumn( this, 2 ); return this; }, makeBasis: function ( xAxis, yAxis, zAxis ) { this.set( xAxis.x, yAxis.x, zAxis.x, 0, xAxis.y, yAxis.y, zAxis.y, 0, xAxis.z, yAxis.z, zAxis.z, 0, 0, 0, 0, 1 ); return this; }, extractRotation: function () { var v1 = new Vector3(); return function extractRotation( m ) { // this method does not support reflection matrices var te = this.elements; var me = m.elements; var scaleX = 1 / v1.setFromMatrixColumn( m, 0 ).length(); var scaleY = 1 / v1.setFromMatrixColumn( m, 1 ).length(); var scaleZ = 1 / v1.setFromMatrixColumn( m, 2 ).length(); te[ 0 ] = me[ 0 ] * scaleX; te[ 1 ] = me[ 1 ] * scaleX; te[ 2 ] = me[ 2 ] * scaleX; te[ 3 ] = 0; te[ 4 ] = me[ 4 ] * scaleY; te[ 5 ] = me[ 5 ] * scaleY; te[ 6 ] = me[ 6 ] * scaleY; te[ 7 ] = 0; te[ 8 ] = me[ 8 ] * scaleZ; te[ 9 ] = me[ 9 ] * scaleZ; te[ 10 ] = me[ 10 ] * scaleZ; te[ 11 ] = 0; te[ 12 ] = 0; te[ 13 ] = 0; te[ 14 ] = 0; te[ 15 ] = 1; return this; }; }(), makeRotationFromEuler: function ( euler ) { if ( ! ( euler && euler.isEuler ) ) { console.error( 'THREE.Matrix4: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.' ); } var te = this.elements; var x = euler.x, y = euler.y, z = euler.z; var a = Math.cos( x ), b = Math.sin( x ); var c = Math.cos( y ), d = Math.sin( y ); var e = Math.cos( z ), f = Math.sin( z ); if ( euler.order === 'XYZ' ) { var ae = a * e, af = a * f, be = b * e, bf = b * f; te[ 0 ] = c * e; te[ 4 ] = - c * f; te[ 8 ] = d; te[ 1 ] = af + be * d; te[ 5 ] = ae - bf * d; te[ 9 ] = - b * c; te[ 2 ] = bf - ae * d; te[ 6 ] = be + af * d; te[ 10 ] = a * c; } else if ( euler.order === 'YXZ' ) { var ce = c * e, cf = c * f, de = d * e, df = d * f; te[ 0 ] = ce + df * b; te[ 4 ] = de * b - cf; te[ 8 ] = a * d; te[ 1 ] = a * f; te[ 5 ] = a * e; te[ 9 ] = - b; te[ 2 ] = cf * b - de; te[ 6 ] = df + ce * b; te[ 10 ] = a * c; } else if ( euler.order === 'ZXY' ) { var ce = c * e, cf = c * f, de = d * e, df = d * f; te[ 0 ] = ce - df * b; te[ 4 ] = - a * f; te[ 8 ] = de + cf * b; te[ 1 ] = cf + de * b; te[ 5 ] = a * e; te[ 9 ] = df - ce * b; te[ 2 ] = - a * d; te[ 6 ] = b; te[ 10 ] = a * c; } else if ( euler.order === 'ZYX' ) { var ae = a * e, af = a * f, be = b * e, bf = b * f; te[ 0 ] = c * e; te[ 4 ] = be * d - af; te[ 8 ] = ae * d + bf; te[ 1 ] = c * f; te[ 5 ] = bf * d + ae; te[ 9 ] = af * d - be; te[ 2 ] = - d; te[ 6 ] = b * c; te[ 10 ] = a * c; } else if ( euler.order === 'YZX' ) { var ac = a * c, ad = a * d, bc = b * c, bd = b * d; te[ 0 ] = c * e; te[ 4 ] = bd - ac * f; te[ 8 ] = bc * f + ad; te[ 1 ] = f; te[ 5 ] = a * e; te[ 9 ] = - b * e; te[ 2 ] = - d * e; te[ 6 ] = ad * f + bc; te[ 10 ] = ac - bd * f; } else if ( euler.order === 'XZY' ) { var ac = a * c, ad = a * d, bc = b * c, bd = b * d; te[ 0 ] = c * e; te[ 4 ] = - f; te[ 8 ] = d * e; te[ 1 ] = ac * f + bd; te[ 5 ] = a * e; te[ 9 ] = ad * f - bc; te[ 2 ] = bc * f - ad; te[ 6 ] = b * e; te[ 10 ] = bd * f + ac; } // bottom row te[ 3 ] = 0; te[ 7 ] = 0; te[ 11 ] = 0; // last column te[ 12 ] = 0; te[ 13 ] = 0; te[ 14 ] = 0; te[ 15 ] = 1; return this; }, makeRotationFromQuaternion: function () { var zero = new Vector3( 0, 0, 0 ); var one = new Vector3( 1, 1, 1 ); return function makeRotationFromQuaternion( q ) { return this.compose( zero, q, one ); }; }(), lookAt: function () { var x = new Vector3(); var y = new Vector3(); var z = new Vector3(); return function lookAt( eye, target, up ) { var te = this.elements; z.subVectors( eye, target ); if ( z.lengthSq() === 0 ) { // eye and target are in the same position z.z = 1; } z.normalize(); x.crossVectors( up, z ); if ( x.lengthSq() === 0 ) { // up and z are parallel if ( Math.abs( up.z ) === 1 ) { z.x += 0.0001; } else { z.z += 0.0001; } z.normalize(); x.crossVectors( up, z ); } x.normalize(); y.crossVectors( z, x ); te[ 0 ] = x.x; te[ 4 ] = y.x; te[ 8 ] = z.x; te[ 1 ] = x.y; te[ 5 ] = y.y; te[ 9 ] = z.y; te[ 2 ] = x.z; te[ 6 ] = y.z; te[ 10 ] = z.z; return this; }; }(), multiply: function ( m, n ) { if ( n !== undefined ) { console.warn( 'THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead.' ); return this.multiplyMatrices( m, n ); } return this.multiplyMatrices( this, m ); }, premultiply: function ( m ) { return this.multiplyMatrices( m, this ); }, multiplyMatrices: function ( a, b ) { var ae = a.elements; var be = b.elements; var te = this.elements; var a11 = ae[ 0 ], a12 = ae[ 4 ], a13 = ae[ 8 ], a14 = ae[ 12 ]; var a21 = ae[ 1 ], a22 = ae[ 5 ], a23 = ae[ 9 ], a24 = ae[ 13 ]; var a31 = ae[ 2 ], a32 = ae[ 6 ], a33 = ae[ 10 ], a34 = ae[ 14 ]; var a41 = ae[ 3 ], a42 = ae[ 7 ], a43 = ae[ 11 ], a44 = ae[ 15 ]; var b11 = be[ 0 ], b12 = be[ 4 ], b13 = be[ 8 ], b14 = be[ 12 ]; var b21 = be[ 1 ], b22 = be[ 5 ], b23 = be[ 9 ], b24 = be[ 13 ]; var b31 = be[ 2 ], b32 = be[ 6 ], b33 = be[ 10 ], b34 = be[ 14 ]; var b41 = be[ 3 ], b42 = be[ 7 ], b43 = be[ 11 ], b44 = be[ 15 ]; te[ 0 ] = a11 * b11 + a12 * b21 + a13 * b31 + a14 * b41; te[ 4 ] = a11 * b12 + a12 * b22 + a13 * b32 + a14 * b42; te[ 8 ] = a11 * b13 + a12 * b23 + a13 * b33 + a14 * b43; te[ 12 ] = a11 * b14 + a12 * b24 + a13 * b34 + a14 * b44; te[ 1 ] = a21 * b11 + a22 * b21 + a23 * b31 + a24 * b41; te[ 5 ] = a21 * b12 + a22 * b22 + a23 * b32 + a24 * b42; te[ 9 ] = a21 * b13 + a22 * b23 + a23 * b33 + a24 * b43; te[ 13 ] = a21 * b14 + a22 * b24 + a23 * b34 + a24 * b44; te[ 2 ] = a31 * b11 + a32 * b21 + a33 * b31 + a34 * b41; te[ 6 ] = a31 * b12 + a32 * b22 + a33 * b32 + a34 * b42; te[ 10 ] = a31 * b13 + a32 * b23 + a33 * b33 + a34 * b43; te[ 14 ] = a31 * b14 + a32 * b24 + a33 * b34 + a34 * b44; te[ 3 ] = a41 * b11 + a42 * b21 + a43 * b31 + a44 * b41; te[ 7 ] = a41 * b12 + a42 * b22 + a43 * b32 + a44 * b42; te[ 11 ] = a41 * b13 + a42 * b23 + a43 * b33 + a44 * b43; te[ 15 ] = a41 * b14 + a42 * b24 + a43 * b34 + a44 * b44; return this; }, multiplyScalar: function ( s ) { var te = this.elements; te[ 0 ] *= s; te[ 4 ] *= s; te[ 8 ] *= s; te[ 12 ] *= s; te[ 1 ] *= s; te[ 5 ] *= s; te[ 9 ] *= s; te[ 13 ] *= s; te[ 2 ] *= s; te[ 6 ] *= s; te[ 10 ] *= s; te[ 14 ] *= s; te[ 3 ] *= s; te[ 7 ] *= s; te[ 11 ] *= s; te[ 15 ] *= s; return this; }, applyToBufferAttribute: function () { var v1 = new Vector3(); return function applyToBufferAttribute( attribute ) { for ( var i = 0, l = attribute.count; i < l; i ++ ) { v1.x = attribute.getX( i ); v1.y = attribute.getY( i ); v1.z = attribute.getZ( i ); v1.applyMatrix4( this ); attribute.setXYZ( i, v1.x, v1.y, v1.z ); } return attribute; }; }(), determinant: function () { var te = this.elements; var n11 = te[ 0 ], n12 = te[ 4 ], n13 = te[ 8 ], n14 = te[ 12 ]; var n21 = te[ 1 ], n22 = te[ 5 ], n23 = te[ 9 ], n24 = te[ 13 ]; var n31 = te[ 2 ], n32 = te[ 6 ], n33 = te[ 10 ], n34 = te[ 14 ]; var n41 = te[ 3 ], n42 = te[ 7 ], n43 = te[ 11 ], n44 = te[ 15 ]; //TODO: make this more efficient //( based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm ) return ( n41 * ( + n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34 ) + n42 * ( + n11 * n23 * n34 - n11 * n24 * n33 + n14 * n21 * n33 - n13 * n21 * n34 + n13 * n24 * n31 - n14 * n23 * n31 ) + n43 * ( + n11 * n24 * n32 - n11 * n22 * n34 - n14 * n21 * n32 + n12 * n21 * n34 + n14 * n22 * n31 - n12 * n24 * n31 ) + n44 * ( - n13 * n22 * n31 - n11 * n23 * n32 + n11 * n22 * n33 + n13 * n21 * n32 - n12 * n21 * n33 + n12 * n23 * n31 ) ); }, transpose: function () { var te = this.elements; var tmp; tmp = te[ 1 ]; te[ 1 ] = te[ 4 ]; te[ 4 ] = tmp; tmp = te[ 2 ]; te[ 2 ] = te[ 8 ]; te[ 8 ] = tmp; tmp = te[ 6 ]; te[ 6 ] = te[ 9 ]; te[ 9 ] = tmp; tmp = te[ 3 ]; te[ 3 ] = te[ 12 ]; te[ 12 ] = tmp; tmp = te[ 7 ]; te[ 7 ] = te[ 13 ]; te[ 13 ] = tmp; tmp = te[ 11 ]; te[ 11 ] = te[ 14 ]; te[ 14 ] = tmp; return this; }, setPosition: function ( v ) { var te = this.elements; te[ 12 ] = v.x; te[ 13 ] = v.y; te[ 14 ] = v.z; return this; }, getInverse: function ( m, throwOnDegenerate ) { // based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm var te = this.elements, me = m.elements, n11 = me[ 0 ], n21 = me[ 1 ], n31 = me[ 2 ], n41 = me[ 3 ], n12 = me[ 4 ], n22 = me[ 5 ], n32 = me[ 6 ], n42 = me[ 7 ], n13 = me[ 8 ], n23 = me[ 9 ], n33 = me[ 10 ], n43 = me[ 11 ], n14 = me[ 12 ], n24 = me[ 13 ], n34 = me[ 14 ], n44 = me[ 15 ], t11 = n23 * n34 * n42 - n24 * n33 * n42 + n24 * n32 * n43 - n22 * n34 * n43 - n23 * n32 * n44 + n22 * n33 * n44, t12 = n14 * n33 * n42 - n13 * n34 * n42 - n14 * n32 * n43 + n12 * n34 * n43 + n13 * n32 * n44 - n12 * n33 * n44, t13 = n13 * n24 * n42 - n14 * n23 * n42 + n14 * n22 * n43 - n12 * n24 * n43 - n13 * n22 * n44 + n12 * n23 * n44, t14 = n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34; var det = n11 * t11 + n21 * t12 + n31 * t13 + n41 * t14; if ( det === 0 ) { var msg = \"THREE.Matrix4: .getInverse() can't invert matrix, determinant is 0\"; if ( throwOnDegenerate === true ) { throw new Error( msg ); } else { console.warn( msg ); } return this.identity(); } var detInv = 1 / det; te[ 0 ] = t11 * detInv; te[ 1 ] = ( n24 * n33 * n41 - n23 * n34 * n41 - n24 * n31 * n43 + n21 * n34 * n43 + n23 * n31 * n44 - n21 * n33 * n44 ) * detInv; te[ 2 ] = ( n22 * n34 * n41 - n24 * n32 * n41 + n24 * n31 * n42 - n21 * n34 * n42 - n22 * n31 * n44 + n21 * n32 * n44 ) * detInv; te[ 3 ] = ( n23 * n32 * n41 - n22 * n33 * n41 - n23 * n31 * n42 + n21 * n33 * n42 + n22 * n31 * n43 - n21 * n32 * n43 ) * detInv; te[ 4 ] = t12 * detInv; te[ 5 ] = ( n13 * n34 * n41 - n14 * n33 * n41 + n14 * n31 * n43 - n11 * n34 * n43 - n13 * n31 * n44 + n11 * n33 * n44 ) * detInv; te[ 6 ] = ( n14 * n32 * n41 - n12 * n34 * n41 - n14 * n31 * n42 + n11 * n34 * n42 + n12 * n31 * n44 - n11 * n32 * n44 ) * detInv; te[ 7 ] = ( n12 * n33 * n41 - n13 * n32 * n41 + n13 * n31 * n42 - n11 * n33 * n42 - n12 * n31 * n43 + n11 * n32 * n43 ) * detInv; te[ 8 ] = t13 * detInv; te[ 9 ] = ( n14 * n23 * n41 - n13 * n24 * n41 - n14 * n21 * n43 + n11 * n24 * n43 + n13 * n21 * n44 - n11 * n23 * n44 ) * detInv; te[ 10 ] = ( n12 * n24 * n41 - n14 * n22 * n41 + n14 * n21 * n42 - n11 * n24 * n42 - n12 * n21 * n44 + n11 * n22 * n44 ) * detInv; te[ 11 ] = ( n13 * n22 * n41 - n12 * n23 * n41 - n13 * n21 * n42 + n11 * n23 * n42 + n12 * n21 * n43 - n11 * n22 * n43 ) * detInv; te[ 12 ] = t14 * detInv; te[ 13 ] = ( n13 * n24 * n31 - n14 * n23 * n31 + n14 * n21 * n33 - n11 * n24 * n33 - n13 * n21 * n34 + n11 * n23 * n34 ) * detInv; te[ 14 ] = ( n14 * n22 * n31 - n12 * n24 * n31 - n14 * n21 * n32 + n11 * n24 * n32 + n12 * n21 * n34 - n11 * n22 * n34 ) * detInv; te[ 15 ] = ( n12 * n23 * n31 - n13 * n22 * n31 + n13 * n21 * n32 - n11 * n23 * n32 - n12 * n21 * n33 + n11 * n22 * n33 ) * detInv; return this; }, scale: function ( v ) { var te = this.elements; var x = v.x, y = v.y, z = v.z; te[ 0 ] *= x; te[ 4 ] *= y; te[ 8 ] *= z; te[ 1 ] *= x; te[ 5 ] *= y; te[ 9 ] *= z; te[ 2 ] *= x; te[ 6 ] *= y; te[ 10 ] *= z; te[ 3 ] *= x; te[ 7 ] *= y; te[ 11 ] *= z; return this; }, getMaxScaleOnAxis: function () { var te = this.elements; var scaleXSq = te[ 0 ] * te[ 0 ] + te[ 1 ] * te[ 1 ] + te[ 2 ] * te[ 2 ]; var scaleYSq = te[ 4 ] * te[ 4 ] + te[ 5 ] * te[ 5 ] + te[ 6 ] * te[ 6 ]; var scaleZSq = te[ 8 ] * te[ 8 ] + te[ 9 ] * te[ 9 ] + te[ 10 ] * te[ 10 ]; return Math.sqrt( Math.max( scaleXSq, scaleYSq, scaleZSq ) ); }, makeTranslation: function ( x, y, z ) { this.set( 1, 0, 0, x, 0, 1, 0, y, 0, 0, 1, z, 0, 0, 0, 1 ); return this; }, makeRotationX: function ( theta ) { var c = Math.cos( theta ), s = Math.sin( theta ); this.set( 1, 0, 0, 0, 0, c, - s, 0, 0, s, c, 0, 0, 0, 0, 1 ); return this; }, makeRotationY: function ( theta ) { var c = Math.cos( theta ), s = Math.sin( theta ); this.set( c, 0, s, 0, 0, 1, 0, 0, - s, 0, c, 0, 0, 0, 0, 1 ); return this; }, makeRotationZ: function ( theta ) { var c = Math.cos( theta ), s = Math.sin( theta ); this.set( c, - s, 0, 0, s, c, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1 ); return this; }, makeRotationAxis: function ( axis, angle ) { // Based on http://www.gamedev.net/reference/articles/article1199.asp var c = Math.cos( angle ); var s = Math.sin( angle ); var t = 1 - c; var x = axis.x, y = axis.y, z = axis.z; var tx = t * x, ty = t * y; this.set( tx * x + c, tx * y - s * z, tx * z + s * y, 0, tx * y + s * z, ty * y + c, ty * z - s * x, 0, tx * z - s * y, ty * z + s * x, t * z * z + c, 0, 0, 0, 0, 1 ); return this; }, makeScale: function ( x, y, z ) { this.set( x, 0, 0, 0, 0, y, 0, 0, 0, 0, z, 0, 0, 0, 0, 1 ); return this; }, makeShear: function ( x, y, z ) { this.set( 1, y, z, 0, x, 1, z, 0, x, y, 1, 0, 0, 0, 0, 1 ); return this; }, compose: function ( position, quaternion, scale ) { var te = this.elements; var x = quaternion._x, y = quaternion._y, z = quaternion._z, w = quaternion._w; var x2 = x + x, y2 = y + y, z2 = z + z; var xx = x * x2, xy = x * y2, xz = x * z2; var yy = y * y2, yz = y * z2, zz = z * z2; var wx = w * x2, wy = w * y2, wz = w * z2; var sx = scale.x, sy = scale.y, sz = scale.z; te[ 0 ] = ( 1 - ( yy + zz ) ) * sx; te[ 1 ] = ( xy + wz ) * sx; te[ 2 ] = ( xz - wy ) * sx; te[ 3 ] = 0; te[ 4 ] = ( xy - wz ) * sy; te[ 5 ] = ( 1 - ( xx + zz ) ) * sy; te[ 6 ] = ( yz + wx ) * sy; te[ 7 ] = 0; te[ 8 ] = ( xz + wy ) * sz; te[ 9 ] = ( yz - wx ) * sz; te[ 10 ] = ( 1 - ( xx + yy ) ) * sz; te[ 11 ] = 0; te[ 12 ] = position.x; te[ 13 ] = position.y; te[ 14 ] = position.z; te[ 15 ] = 1; return this; }, decompose: function () { var vector = new Vector3(); var matrix = new Matrix4(); return function decompose( position, quaternion, scale ) { var te = this.elements; var sx = vector.set( te[ 0 ], te[ 1 ], te[ 2 ] ).length(); var sy = vector.set( te[ 4 ], te[ 5 ], te[ 6 ] ).length(); var sz = vector.set( te[ 8 ], te[ 9 ], te[ 10 ] ).length(); // if determine is negative, we need to invert one scale var det = this.determinant(); if ( det < 0 ) sx = - sx; position.x = te[ 12 ]; position.y = te[ 13 ]; position.z = te[ 14 ]; // scale the rotation part matrix.copy( this ); var invSX = 1 / sx; var invSY = 1 / sy; var invSZ = 1 / sz; matrix.elements[ 0 ] *= invSX; matrix.elements[ 1 ] *= invSX; matrix.elements[ 2 ] *= invSX; matrix.elements[ 4 ] *= invSY; matrix.elements[ 5 ] *= invSY; matrix.elements[ 6 ] *= invSY; matrix.elements[ 8 ] *= invSZ; matrix.elements[ 9 ] *= invSZ; matrix.elements[ 10 ] *= invSZ; quaternion.setFromRotationMatrix( matrix ); scale.x = sx; scale.y = sy; scale.z = sz; return this; }; }(), makePerspective: function ( left, right, top, bottom, near, far ) { if ( far === undefined ) { console.warn( 'THREE.Matrix4: .makePerspective() has been redefined and has a new signature. Please check the docs.' ); } var te = this.elements; var x = 2 * near / ( right - left ); var y = 2 * near / ( top - bottom ); var a = ( right + left ) / ( right - left ); var b = ( top + bottom ) / ( top - bottom ); var c = - ( far + near ) / ( far - near ); var d = - 2 * far * near / ( far - near ); te[ 0 ] = x; te[ 4 ] = 0; te[ 8 ] = a; te[ 12 ] = 0; te[ 1 ] = 0; te[ 5 ] = y; te[ 9 ] = b; te[ 13 ] = 0; te[ 2 ] = 0; te[ 6 ] = 0; te[ 10 ] = c; te[ 14 ] = d; te[ 3 ] = 0; te[ 7 ] = 0; te[ 11 ] = - 1; te[ 15 ] = 0; return this; }, makeOrthographic: function ( left, right, top, bottom, near, far ) { var te = this.elements; var w = 1.0 / ( right - left ); var h = 1.0 / ( top - bottom ); var p = 1.0 / ( far - near ); var x = ( right + left ) * w; var y = ( top + bottom ) * h; var z = ( far + near ) * p; te[ 0 ] = 2 * w; te[ 4 ] = 0; te[ 8 ] = 0; te[ 12 ] = - x; te[ 1 ] = 0; te[ 5 ] = 2 * h; te[ 9 ] = 0; te[ 13 ] = - y; te[ 2 ] = 0; te[ 6 ] = 0; te[ 10 ] = - 2 * p; te[ 14 ] = - z; te[ 3 ] = 0; te[ 7 ] = 0; te[ 11 ] = 0; te[ 15 ] = 1; return this; }, equals: function ( matrix ) { var te = this.elements; var me = matrix.elements; for ( var i = 0; i < 16; i ++ ) { if ( te[ i ] !== me[ i ] ) return false; } return true; }, fromArray: function ( array, offset ) { if ( offset === undefined ) offset = 0; for ( var i = 0; i < 16; i ++ ) { this.elements[ i ] = array[ i + offset ]; } return this; }, toArray: function ( array, offset ) { if ( array === undefined ) array = []; if ( offset === undefined ) offset = 0; var te = this.elements; array[ offset ] = te[ 0 ]; array[ offset + 1 ] = te[ 1 ]; array[ offset + 2 ] = te[ 2 ]; array[ offset + 3 ] = te[ 3 ]; array[ offset + 4 ] = te[ 4 ]; array[ offset + 5 ] = te[ 5 ]; array[ offset + 6 ] = te[ 6 ]; array[ offset + 7 ] = te[ 7 ]; array[ offset + 8 ] = te[ 8 ]; array[ offset + 9 ] = te[ 9 ]; array[ offset + 10 ] = te[ 10 ]; array[ offset + 11 ] = te[ 11 ]; array[ offset + 12 ] = te[ 12 ]; array[ offset + 13 ] = te[ 13 ]; array[ offset + 14 ] = te[ 14 ]; array[ offset + 15 ] = te[ 15 ]; return array; } } ); /** * @author mikael emtinger / http://gomo.se/ * @author alteredq / http://alteredqualia.com/ * @author WestLangley / http://github.com/WestLangley * @author bhouston / http://clara.io */ function Quaternion( x, y, z, w ) { this._x = x || 0; this._y = y || 0; this._z = z || 0; this._w = ( w !== undefined ) ? w : 1; } Object.assign( Quaternion, { slerp: function ( qa, qb, qm, t ) { return qm.copy( qa ).slerp( qb, t ); }, slerpFlat: function ( dst, dstOffset, src0, srcOffset0, src1, srcOffset1, t ) { // fuzz-free, array-based Quaternion SLERP operation var x0 = src0[ srcOffset0 + 0 ], y0 = src0[ srcOffset0 + 1 ], z0 = src0[ srcOffset0 + 2 ], w0 = src0[ srcOffset0 + 3 ], x1 = src1[ srcOffset1 + 0 ], y1 = src1[ srcOffset1 + 1 ], z1 = src1[ srcOffset1 + 2 ], w1 = src1[ srcOffset1 + 3 ]; if ( w0 !== w1 || x0 !== x1 || y0 !== y1 || z0 !== z1 ) { var s = 1 - t, cos = x0 * x1 + y0 * y1 + z0 * z1 + w0 * w1, dir = ( cos >= 0 ? 1 : - 1 ), sqrSin = 1 - cos * cos; // Skip the Slerp for tiny steps to avoid numeric problems: if ( sqrSin > Number.EPSILON ) { var sin = Math.sqrt( sqrSin ), len = Math.atan2( sin, cos * dir ); s = Math.sin( s * len ) / sin; t = Math.sin( t * len ) / sin; } var tDir = t * dir; x0 = x0 * s + x1 * tDir; y0 = y0 * s + y1 * tDir; z0 = z0 * s + z1 * tDir; w0 = w0 * s + w1 * tDir; // Normalize in case we just did a lerp: if ( s === 1 - t ) { var f = 1 / Math.sqrt( x0 * x0 + y0 * y0 + z0 * z0 + w0 * w0 ); x0 *= f; y0 *= f; z0 *= f; w0 *= f; } } dst[ dstOffset ] = x0; dst[ dstOffset + 1 ] = y0; dst[ dstOffset + 2 ] = z0; dst[ dstOffset + 3 ] = w0; } } ); Object.defineProperties( Quaternion.prototype, { x: { get: function () { return this._x; }, set: function ( value ) { this._x = value; this.onChangeCallback(); } }, y: { get: function () { return this._y; }, set: function ( value ) { this._y = value; this.onChangeCallback(); } }, z: { get: function () { return this._z; }, set: function ( value ) { this._z = value; this.onChangeCallback(); } }, w: { get: function () { return this._w; }, set: function ( value ) { this._w = value; this.onChangeCallback(); } } } ); Object.assign( Quaternion.prototype, { isQuaternion: true, set: function ( x, y, z, w ) { this._x = x; this._y = y; this._z = z; this._w = w; this.onChangeCallback(); return this; }, clone: function () { return new this.constructor( this._x, this._y, this._z, this._w ); }, copy: function ( quaternion ) { this._x = quaternion.x; this._y = quaternion.y; this._z = quaternion.z; this._w = quaternion.w; this.onChangeCallback(); return this; }, setFromEuler: function ( euler, update ) { if ( ! ( euler && euler.isEuler ) ) { throw new Error( 'THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order.' ); } var x = euler._x, y = euler._y, z = euler._z, order = euler.order; // http://www.mathworks.com/matlabcentral/fileexchange/ // 20696-function-to-convert-between-dcm-euler-angles-quaternions-and-euler-vectors/ // content/SpinCalc.m var cos = Math.cos; var sin = Math.sin; var c1 = cos( x / 2 ); var c2 = cos( y / 2 ); var c3 = cos( z / 2 ); var s1 = sin( x / 2 ); var s2 = sin( y / 2 ); var s3 = sin( z / 2 ); if ( order === 'XYZ' ) { this._x = s1 * c2 * c3 + c1 * s2 * s3; this._y = c1 * s2 * c3 - s1 * c2 * s3; this._z = c1 * c2 * s3 + s1 * s2 * c3; this._w = c1 * c2 * c3 - s1 * s2 * s3; } else if ( order === 'YXZ' ) { this._x = s1 * c2 * c3 + c1 * s2 * s3; this._y = c1 * s2 * c3 - s1 * c2 * s3; this._z = c1 * c2 * s3 - s1 * s2 * c3; this._w = c1 * c2 * c3 + s1 * s2 * s3; } else if ( order === 'ZXY' ) { this._x = s1 * c2 * c3 - c1 * s2 * s3; this._y = c1 * s2 * c3 + s1 * c2 * s3; this._z = c1 * c2 * s3 + s1 * s2 * c3; this._w = c1 * c2 * c3 - s1 * s2 * s3; } else if ( order === 'ZYX' ) { this._x = s1 * c2 * c3 - c1 * s2 * s3; this._y = c1 * s2 * c3 + s1 * c2 * s3; this._z = c1 * c2 * s3 - s1 * s2 * c3; this._w = c1 * c2 * c3 + s1 * s2 * s3; } else if ( order === 'YZX' ) { this._x = s1 * c2 * c3 + c1 * s2 * s3; this._y = c1 * s2 * c3 + s1 * c2 * s3; this._z = c1 * c2 * s3 - s1 * s2 * c3; this._w = c1 * c2 * c3 - s1 * s2 * s3; } else if ( order === 'XZY' ) { this._x = s1 * c2 * c3 - c1 * s2 * s3; this._y = c1 * s2 * c3 - s1 * c2 * s3; this._z = c1 * c2 * s3 + s1 * s2 * c3; this._w = c1 * c2 * c3 + s1 * s2 * s3; } if ( update !== false ) this.onChangeCallback(); return this; }, setFromAxisAngle: function ( axis, angle ) { // http://www.euclideanspace.com/maths/geometry/rotations/conversions/angleToQuaternion/index.htm // assumes axis is normalized var halfAngle = angle / 2, s = Math.sin( halfAngle ); this._x = axis.x * s; this._y = axis.y * s; this._z = axis.z * s; this._w = Math.cos( halfAngle ); this.onChangeCallback(); return this; }, setFromRotationMatrix: function ( m ) { // http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToQuaternion/index.htm // assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled) var te = m.elements, m11 = te[ 0 ], m12 = te[ 4 ], m13 = te[ 8 ], m21 = te[ 1 ], m22 = te[ 5 ], m23 = te[ 9 ], m31 = te[ 2 ], m32 = te[ 6 ], m33 = te[ 10 ], trace = m11 + m22 + m33, s; if ( trace > 0 ) { s = 0.5 / Math.sqrt( trace + 1.0 ); this._w = 0.25 / s; this._x = ( m32 - m23 ) * s; this._y = ( m13 - m31 ) * s; this._z = ( m21 - m12 ) * s; } else if ( m11 > m22 && m11 > m33 ) { s = 2.0 * Math.sqrt( 1.0 + m11 - m22 - m33 ); this._w = ( m32 - m23 ) / s; this._x = 0.25 * s; this._y = ( m12 + m21 ) / s; this._z = ( m13 + m31 ) / s; } else if ( m22 > m33 ) { s = 2.0 * Math.sqrt( 1.0 + m22 - m11 - m33 ); this._w = ( m13 - m31 ) / s; this._x = ( m12 + m21 ) / s; this._y = 0.25 * s; this._z = ( m23 + m32 ) / s; } else { s = 2.0 * Math.sqrt( 1.0 + m33 - m11 - m22 ); this._w = ( m21 - m12 ) / s; this._x = ( m13 + m31 ) / s; this._y = ( m23 + m32 ) / s; this._z = 0.25 * s; } this.onChangeCallback(); return this; }, setFromUnitVectors: function () { // assumes direction vectors vFrom and vTo are normalized var v1 = new Vector3(); var r; var EPS = 0.000001; return function setFromUnitVectors( vFrom, vTo ) { if ( v1 === undefined ) v1 = new Vector3(); r = vFrom.dot( vTo ) + 1; if ( r < EPS ) { r = 0; if ( Math.abs( vFrom.x ) > Math.abs( vFrom.z ) ) { v1.set( - vFrom.y, vFrom.x, 0 ); } else { v1.set( 0, - vFrom.z, vFrom.y ); } } else { v1.crossVectors( vFrom, vTo ); } this._x = v1.x; this._y = v1.y; this._z = v1.z; this._w = r; return this.normalize(); }; }(), angleTo: function ( q ) { return 2 * Math.acos( Math.abs( _Math.clamp( this.dot( q ), - 1, 1 ) ) ); }, rotateTowards: function ( q, step ) { var angle = this.angleTo( q ); if ( angle === 0 ) return this; var t = Math.min( 1, step / angle ); this.slerp( q, t ); return this; }, inverse: function () { // quaternion is assumed to have unit length return this.conjugate(); }, conjugate: function () { this._x *= - 1; this._y *= - 1; this._z *= - 1; this.onChangeCallback(); return this; }, dot: function ( v ) { return this._x * v._x + this._y * v._y + this._z * v._z + this._w * v._w; }, lengthSq: function () { return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w; }, length: function () { return Math.sqrt( this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w ); }, normalize: function () { var l = this.length(); if ( l === 0 ) { this._x = 0; this._y = 0; this._z = 0; this._w = 1; } else { l = 1 / l; this._x = this._x * l; this._y = this._y * l; this._z = this._z * l; this._w = this._w * l; } this.onChangeCallback(); return this; }, multiply: function ( q, p ) { if ( p !== undefined ) { console.warn( 'THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead.' ); return this.multiplyQuaternions( q, p ); } return this.multiplyQuaternions( this, q ); }, premultiply: function ( q ) { return this.multiplyQuaternions( q, this ); }, multiplyQuaternions: function ( a, b ) { // from http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/code/index.htm var qax = a._x, qay = a._y, qaz = a._z, qaw = a._w; var qbx = b._x, qby = b._y, qbz = b._z, qbw = b._w; this._x = qax * qbw + qaw * qbx + qay * qbz - qaz * qby; this._y = qay * qbw + qaw * qby + qaz * qbx - qax * qbz; this._z = qaz * qbw + qaw * qbz + qax * qby - qay * qbx; this._w = qaw * qbw - qax * qbx - qay * qby - qaz * qbz; this.onChangeCallback(); return this; }, slerp: function ( qb, t ) { if ( t === 0 ) return this; if ( t === 1 ) return this.copy( qb ); var x = this._x, y = this._y, z = this._z, w = this._w; // http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/slerp/ var cosHalfTheta = w * qb._w + x * qb._x + y * qb._y + z * qb._z; if ( cosHalfTheta < 0 ) { this._w = - qb._w; this._x = - qb._x; this._y = - qb._y; this._z = - qb._z; cosHalfTheta = - cosHalfTheta; } else { this.copy( qb ); } if ( cosHalfTheta >= 1.0 ) { this._w = w; this._x = x; this._y = y; this._z = z; return this; } var sqrSinHalfTheta = 1.0 - cosHalfTheta * cosHalfTheta; if ( sqrSinHalfTheta 0 ) { console.error( 'THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.' ); } } Object.assign( Matrix3.prototype, { isMatrix3: true, set: function ( n11, n12, n13, n21, n22, n23, n31, n32, n33 ) { var te = this.elements; te[ 0 ] = n11; te[ 1 ] = n21; te[ 2 ] = n31; te[ 3 ] = n12; te[ 4 ] = n22; te[ 5 ] = n32; te[ 6 ] = n13; te[ 7 ] = n23; te[ 8 ] = n33; return this; }, identity: function () { this.set( 1, 0, 0, 0, 1, 0, 0, 0, 1 ); return this; }, clone: function () { return new this.constructor().fromArray( this.elements ); }, copy: function ( m ) { var te = this.elements; var me = m.elements; te[ 0 ] = me[ 0 ]; te[ 1 ] = me[ 1 ]; te[ 2 ] = me[ 2 ]; te[ 3 ] = me[ 3 ]; te[ 4 ] = me[ 4 ]; te[ 5 ] = me[ 5 ]; te[ 6 ] = me[ 6 ]; te[ 7 ] = me[ 7 ]; te[ 8 ] = me[ 8 ]; return this; }, setFromMatrix4: function ( m ) { var me = m.elements; this.set( me[ 0 ], me[ 4 ], me[ 8 ], me[ 1 ], me[ 5 ], me[ 9 ], me[ 2 ], me[ 6 ], me[ 10 ] ); return this; }, applyToBufferAttribute: function () { var v1 = new Vector3(); return function applyToBufferAttribute( attribute ) { for ( var i = 0, l = attribute.count; i < l; i ++ ) { v1.x = attribute.getX( i ); v1.y = attribute.getY( i ); v1.z = attribute.getZ( i ); v1.applyMatrix3( this ); attribute.setXYZ( i, v1.x, v1.y, v1.z ); } return attribute; }; }(), multiply: function ( m ) { return this.multiplyMatrices( this, m ); }, premultiply: function ( m ) { return this.multiplyMatrices( m, this ); }, multiplyMatrices: function ( a, b ) { var ae = a.elements; var be = b.elements; var te = this.elements; var a11 = ae[ 0 ], a12 = ae[ 3 ], a13 = ae[ 6 ]; var a21 = ae[ 1 ], a22 = ae[ 4 ], a23 = ae[ 7 ]; var a31 = ae[ 2 ], a32 = ae[ 5 ], a33 = ae[ 8 ]; var b11 = be[ 0 ], b12 = be[ 3 ], b13 = be[ 6 ]; var b21 = be[ 1 ], b22 = be[ 4 ], b23 = be[ 7 ]; var b31 = be[ 2 ], b32 = be[ 5 ], b33 = be[ 8 ]; te[ 0 ] = a11 * b11 + a12 * b21 + a13 * b31; te[ 3 ] = a11 * b12 + a12 * b22 + a13 * b32; te[ 6 ] = a11 * b13 + a12 * b23 + a13 * b33; te[ 1 ] = a21 * b11 + a22 * b21 + a23 * b31; te[ 4 ] = a21 * b12 + a22 * b22 + a23 * b32; te[ 7 ] = a21 * b13 + a22 * b23 + a23 * b33; te[ 2 ] = a31 * b11 + a32 * b21 + a33 * b31; te[ 5 ] = a31 * b12 + a32 * b22 + a33 * b32; te[ 8 ] = a31 * b13 + a32 * b23 + a33 * b33; return this; }, multiplyScalar: function ( s ) { var te = this.elements; te[ 0 ] *= s; te[ 3 ] *= s; te[ 6 ] *= s; te[ 1 ] *= s; te[ 4 ] *= s; te[ 7 ] *= s; te[ 2 ] *= s; te[ 5 ] *= s; te[ 8 ] *= s; return this; }, determinant: function () { var te = this.elements; var a = te[ 0 ], b = te[ 1 ], c = te[ 2 ], d = te[ 3 ], e = te[ 4 ], f = te[ 5 ], g = te[ 6 ], h = te[ 7 ], i = te[ 8 ]; return a * e * i - a * f * h - b * d * i + b * f * g + c * d * h - c * e * g; }, getInverse: function ( matrix, throwOnDegenerate ) { if ( matrix && matrix.isMatrix4 ) { console.error( \"THREE.Matrix3: .getInverse() no longer takes a Matrix4 argument.\" ); } var me = matrix.elements, te = this.elements, n11 = me[ 0 ], n21 = me[ 1 ], n31 = me[ 2 ], n12 = me[ 3 ], n22 = me[ 4 ], n32 = me[ 5 ], n13 = me[ 6 ], n23 = me[ 7 ], n33 = me[ 8 ], t11 = n33 * n22 - n32 * n23, t12 = n32 * n13 - n33 * n12, t13 = n23 * n12 - n22 * n13, det = n11 * t11 + n21 * t12 + n31 * t13; if ( det === 0 ) { var msg = \"THREE.Matrix3: .getInverse() can't invert matrix, determinant is 0\"; if ( throwOnDegenerate === true ) { throw new Error( msg ); } else { console.warn( msg ); } return this.identity(); } var detInv = 1 / det; te[ 0 ] = t11 * detInv; te[ 1 ] = ( n31 * n23 - n33 * n21 ) * detInv; te[ 2 ] = ( n32 * n21 - n31 * n22 ) * detInv; te[ 3 ] = t12 * detInv; te[ 4 ] = ( n33 * n11 - n31 * n13 ) * detInv; te[ 5 ] = ( n31 * n12 - n32 * n11 ) * detInv; te[ 6 ] = t13 * detInv; te[ 7 ] = ( n21 * n13 - n23 * n11 ) * detInv; te[ 8 ] = ( n22 * n11 - n21 * n12 ) * detInv; return this; }, transpose: function () { var tmp, m = this.elements; tmp = m[ 1 ]; m[ 1 ] = m[ 3 ]; m[ 3 ] = tmp; tmp = m[ 2 ]; m[ 2 ] = m[ 6 ]; m[ 6 ] = tmp; tmp = m[ 5 ]; m[ 5 ] = m[ 7 ]; m[ 7 ] = tmp; return this; }, getNormalMatrix: function ( matrix4 ) { return this.setFromMatrix4( matrix4 ).getInverse( this ).transpose(); }, transposeIntoArray: function ( r ) { var m = this.elements; r[ 0 ] = m[ 0 ]; r[ 1 ] = m[ 3 ]; r[ 2 ] = m[ 6 ]; r[ 3 ] = m[ 1 ]; r[ 4 ] = m[ 4 ]; r[ 5 ] = m[ 7 ]; r[ 6 ] = m[ 2 ]; r[ 7 ] = m[ 5 ]; r[ 8 ] = m[ 8 ]; return this; }, setUvTransform: function ( tx, ty, sx, sy, rotation, cx, cy ) { var c = Math.cos( rotation ); var s = Math.sin( rotation ); this.set( sx * c, sx * s, - sx * ( c * cx + s * cy ) + cx + tx, - sy * s, sy * c, - sy * ( - s * cx + c * cy ) + cy + ty, 0, 0, 1 ); }, scale: function ( sx, sy ) { var te = this.elements; te[ 0 ] *= sx; te[ 3 ] *= sx; te[ 6 ] *= sx; te[ 1 ] *= sy; te[ 4 ] *= sy; te[ 7 ] *= sy; return this; }, rotate: function ( theta ) { var c = Math.cos( theta ); var s = Math.sin( theta ); var te = this.elements; var a11 = te[ 0 ], a12 = te[ 3 ], a13 = te[ 6 ]; var a21 = te[ 1 ], a22 = te[ 4 ], a23 = te[ 7 ]; te[ 0 ] = c * a11 + s * a21; te[ 3 ] = c * a12 + s * a22; te[ 6 ] = c * a13 + s * a23; te[ 1 ] = - s * a11 + c * a21; te[ 4 ] = - s * a12 + c * a22; te[ 7 ] = - s * a13 + c * a23; return this; }, translate: function ( tx, ty ) { var te = this.elements; te[ 0 ] += tx * te[ 2 ]; te[ 3 ] += tx * te[ 5 ]; te[ 6 ] += tx * te[ 8 ]; te[ 1 ] += ty * te[ 2 ]; te[ 4 ] += ty * te[ 5 ]; te[ 7 ] += ty * te[ 8 ]; return this; }, equals: function ( matrix ) { var te = this.elements; var me = matrix.elements; for ( var i = 0; i < 9; i ++ ) { if ( te[ i ] !== me[ i ] ) return false; } return true; }, fromArray: function ( array, offset ) { if ( offset === undefined ) offset = 0; for ( var i = 0; i < 9; i ++ ) { this.elements[ i ] = array[ i + offset ]; } return this; }, toArray: function ( array, offset ) { if ( array === undefined ) array = []; if ( offset === undefined ) offset = 0; var te = this.elements; array[ offset ] = te[ 0 ]; array[ offset + 1 ] = te[ 1 ]; array[ offset + 2 ] = te[ 2 ]; array[ offset + 3 ] = te[ 3 ]; array[ offset + 4 ] = te[ 4 ]; array[ offset + 5 ] = te[ 5 ]; array[ offset + 6 ] = te[ 6 ]; array[ offset + 7 ] = te[ 7 ]; array[ offset + 8 ] = te[ 8 ]; return array; } } ); /** * @author mrdoob / http://mrdoob.com/ * @author alteredq / http://alteredqualia.com/ * @author szimek / https://github.com/szimek/ */ var _canvas; var ImageUtils = { getDataURL: function ( image ) { var canvas; if ( typeof HTMLCanvasElement == 'undefined' ) { return image.src; } else if ( image instanceof HTMLCanvasElement ) { canvas = image; } else { if ( _canvas === undefined ) _canvas = document.createElementNS( 'http://www.w3.org/1999/xhtml', 'canvas' ); _canvas.width = image.width; _canvas.height = image.height; var context = _canvas.getContext( '2d' ); if ( image instanceof ImageData ) { context.putImageData( image, 0, 0 ); } else { context.drawImage( image, 0, 0, image.width, image.height ); } canvas = _canvas; } if ( canvas.width > 2048 || canvas.height > 2048 ) { return canvas.toDataURL( 'image/jpeg', 0.6 ); } else { return canvas.toDataURL( 'image/png' ); } } }; /** * @author mrdoob / http://mrdoob.com/ * @author alteredq / http://alteredqualia.com/ * @author szimek / https://github.com/szimek/ */ var textureId = 0; function Texture( image, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding ) { Object.defineProperty( this, 'id', { value: textureId ++ } ); this.uuid = _Math.generateUUID(); this.name = ''; this.image = image !== undefined ? image : Texture.DEFAULT_IMAGE; this.mipmaps = []; this.mapping = mapping !== undefined ? mapping : Texture.DEFAULT_MAPPING; this.wrapS = wrapS !== undefined ? wrapS : ClampToEdgeWrapping; this.wrapT = wrapT !== undefined ? wrapT : ClampToEdgeWrapping; this.magFilter = magFilter !== undefined ? magFilter : LinearFilter; this.minFilter = minFilter !== undefined ? minFilter : LinearMipMapLinearFilter; this.anisotropy = anisotropy !== undefined ? anisotropy : 1; this.format = format !== undefined ? format : RGBAFormat; this.type = type !== undefined ? type : UnsignedByteType; this.offset = new Vector2( 0, 0 ); this.repeat = new Vector2( 1, 1 ); this.center = new Vector2( 0, 0 ); this.rotation = 0; this.matrixAutoUpdate = true; this.matrix = new Matrix3(); this.generateMipmaps = true; this.premultiplyAlpha = false; this.flipY = true; this.unpackAlignment = 4; // valid values: 1, 2, 4, 8 (see http://www.khronos.org/opengles/sdk/docs/man/xhtml/glPixelStorei.xml) // Values of encoding !== THREE.LinearEncoding only supported on map, envMap and emissiveMap. // // Also changing the encoding after already used by a Material will not automatically make the Material // update. You need to explicitly call Material.needsUpdate to trigger it to recompile. this.encoding = encoding !== undefined ? encoding : LinearEncoding; this.version = 0; this.onUpdate = null; } Texture.DEFAULT_IMAGE = undefined; Texture.DEFAULT_MAPPING = UVMapping; Texture.prototype = Object.assign( Object.create( EventDispatcher.prototype ), { constructor: Texture, isTexture: true, updateMatrix: function () { this.matrix.setUvTransform( this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y ); }, clone: function () { return new this.constructor().copy( this ); }, copy: function ( source ) { this.name = source.name; this.image = source.image; this.mipmaps = source.mipmaps.slice( 0 ); this.mapping = source.mapping; this.wrapS = source.wrapS; this.wrapT = source.wrapT; this.magFilter = source.magFilter; this.minFilter = source.minFilter; this.anisotropy = source.anisotropy; this.format = source.format; this.type = source.type; this.offset.copy( source.offset ); this.repeat.copy( source.repeat ); this.center.copy( source.center ); this.rotation = source.rotation; this.matrixAutoUpdate = source.matrixAutoUpdate; this.matrix.copy( source.matrix ); this.generateMipmaps = source.generateMipmaps; this.premultiplyAlpha = source.premultiplyAlpha; this.flipY = source.flipY; this.unpackAlignment = source.unpackAlignment; this.encoding = source.encoding; return this; }, toJSON: function ( meta ) { var isRootObject = ( meta === undefined || typeof meta === 'string' ); if ( ! isRootObject && meta.textures[ this.uuid ] !== undefined ) { return meta.textures[ this.uuid ]; } var output = { metadata: { version: 4.5, type: 'Texture', generator: 'Texture.toJSON' }, uuid: this.uuid, name: this.name, mapping: this.mapping, repeat: [ this.repeat.x, this.repeat.y ], offset: [ this.offset.x, this.offset.y ], center: [ this.center.x, this.center.y ], rotation: this.rotation, wrap: [ this.wrapS, this.wrapT ], format: this.format, type: this.type, encoding: this.encoding, minFilter: this.minFilter, magFilter: this.magFilter, anisotropy: this.anisotropy, flipY: this.flipY, premultiplyAlpha: this.premultiplyAlpha, unpackAlignment: this.unpackAlignment }; if ( this.image !== undefined ) { // TODO: Move to THREE.Image var image = this.image; if ( image.uuid === undefined ) { image.uuid = _Math.generateUUID(); // UGH } if ( ! isRootObject && meta.images[ image.uuid ] === undefined ) { var url; if ( Array.isArray( image ) ) { // process array of images e.g. CubeTexture url = []; for ( var i = 0, l = image.length; i < l; i ++ ) { url.push( ImageUtils.getDataURL( image[ i ] ) ); } } else { // process single image url = ImageUtils.getDataURL( image ); } meta.images[ image.uuid ] = { uuid: image.uuid, url: url }; } output.image = image.uuid; } if ( ! isRootObject ) { meta.textures[ this.uuid ] = output; } return output; }, dispose: function () { this.dispatchEvent( { type: 'dispose' } ); }, transformUv: function ( uv ) { if ( this.mapping !== UVMapping ) return uv; uv.applyMatrix3( this.matrix ); if ( uv.x < 0 || uv.x > 1 ) { switch ( this.wrapS ) { case RepeatWrapping: uv.x = uv.x - Math.floor( uv.x ); break; case ClampToEdgeWrapping: uv.x = uv.x < 0 ? 0 : 1; break; case MirroredRepeatWrapping: if ( Math.abs( Math.floor( uv.x ) % 2 ) === 1 ) { uv.x = Math.ceil( uv.x ) - uv.x; } else { uv.x = uv.x - Math.floor( uv.x ); } break; } } if ( uv.y < 0 || uv.y > 1 ) { switch ( this.wrapT ) { case RepeatWrapping: uv.y = uv.y - Math.floor( uv.y ); break; case ClampToEdgeWrapping: uv.y = uv.y < 0 ? 0 : 1; break; case MirroredRepeatWrapping: if ( Math.abs( Math.floor( uv.y ) % 2 ) === 1 ) { uv.y = Math.ceil( uv.y ) - uv.y; } else { uv.y = uv.y - Math.floor( uv.y ); } break; } } if ( this.flipY ) { uv.y = 1 - uv.y; } return uv; } } ); Object.defineProperty( Texture.prototype, \"needsUpdate\", { set: function ( value ) { if ( value === true ) this.version ++; } } ); /** * @author supereggbert / http://www.paulbrunt.co.uk/ * @author philogb / http://blog.thejit.org/ * @author mikael emtinger / http://gomo.se/ * @author egraether / http://egraether.com/ * @author WestLangley / http://github.com/WestLangley */ function Vector4( x, y, z, w ) { this.x = x || 0; this.y = y || 0; this.z = z || 0; this.w = ( w !== undefined ) ? w : 1; } Object.assign( Vector4.prototype, { isVector4: true, set: function ( x, y, z, w ) { this.x = x; this.y = y; this.z = z; this.w = w; return this; }, setScalar: function ( scalar ) { this.x = scalar; this.y = scalar; this.z = scalar; this.w = scalar; return this; }, setX: function ( x ) { this.x = x; return this; }, setY: function ( y ) { this.y = y; return this; }, setZ: function ( z ) { this.z = z; return this; }, setW: function ( w ) { this.w = w; return this; }, setComponent: function ( index, value ) { switch ( index ) { case 0: this.x = value; break; case 1: this.y = value; break; case 2: this.z = value; break; case 3: this.w = value; break; default: throw new Error( 'index is out of range: ' + index ); } return this; }, getComponent: function ( index ) { switch ( index ) { case 0: return this.x; case 1: return this.y; case 2: return this.z; case 3: return this.w; default: throw new Error( 'index is out of range: ' + index ); } }, clone: function () { return new this.constructor( this.x, this.y, this.z, this.w ); }, copy: function ( v ) { this.x = v.x; this.y = v.y; this.z = v.z; this.w = ( v.w !== undefined ) ? v.w : 1; return this; }, add: function ( v, w ) { if ( w !== undefined ) { console.warn( 'THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead.' ); return this.addVectors( v, w ); } this.x += v.x; this.y += v.y; this.z += v.z; this.w += v.w; return this; }, addScalar: function ( s ) { this.x += s; this.y += s; this.z += s; this.w += s; return this; }, addVectors: function ( a, b ) { this.x = a.x + b.x; this.y = a.y + b.y; this.z = a.z + b.z; this.w = a.w + b.w; return this; }, addScaledVector: function ( v, s ) { this.x += v.x * s; this.y += v.y * s; this.z += v.z * s; this.w += v.w * s; return this; }, sub: function ( v, w ) { if ( w !== undefined ) { console.warn( 'THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.' ); return this.subVectors( v, w ); } this.x -= v.x; this.y -= v.y; this.z -= v.z; this.w -= v.w; return this; }, subScalar: function ( s ) { this.x -= s; this.y -= s; this.z -= s; this.w -= s; return this; }, subVectors: function ( a, b ) { this.x = a.x - b.x; this.y = a.y - b.y; this.z = a.z - b.z; this.w = a.w - b.w; return this; }, multiplyScalar: function ( scalar ) { this.x *= scalar; this.y *= scalar; this.z *= scalar; this.w *= scalar; return this; }, applyMatrix4: function ( m ) { var x = this.x, y = this.y, z = this.z, w = this.w; var e = m.elements; this.x = e[ 0 ] * x + e[ 4 ] * y + e[ 8 ] * z + e[ 12 ] * w; this.y = e[ 1 ] * x + e[ 5 ] * y + e[ 9 ] * z + e[ 13 ] * w; this.z = e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z + e[ 14 ] * w; this.w = e[ 3 ] * x + e[ 7 ] * y + e[ 11 ] * z + e[ 15 ] * w; return this; }, divideScalar: function ( scalar ) { return this.multiplyScalar( 1 / scalar ); }, setAxisAngleFromQuaternion: function ( q ) { // http://www.euclideanspace.com/maths/geometry/rotations/conversions/quaternionToAngle/index.htm // q is assumed to be normalized this.w = 2 * Math.acos( q.w ); var s = Math.sqrt( 1 - q.w * q.w ); if ( s < 0.0001 ) { this.x = 1; this.y = 0; this.z = 0; } else { this.x = q.x / s; this.y = q.y / s; this.z = q.z / s; } return this; }, setAxisAngleFromRotationMatrix: function ( m ) { // http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToAngle/index.htm // assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled) var angle, x, y, z, // variables for result epsilon = 0.01, // margin to allow for rounding errors epsilon2 = 0.1, // margin to distinguish between 0 and 180 degrees te = m.elements, m11 = te[ 0 ], m12 = te[ 4 ], m13 = te[ 8 ], m21 = te[ 1 ], m22 = te[ 5 ], m23 = te[ 9 ], m31 = te[ 2 ], m32 = te[ 6 ], m33 = te[ 10 ]; if ( ( Math.abs( m12 - m21 ) < epsilon ) && ( Math.abs( m13 - m31 ) < epsilon ) && ( Math.abs( m23 - m32 ) < epsilon ) ) { // singularity found // first check for identity matrix which must have +1 for all terms // in leading diagonal and zero in other terms if ( ( Math.abs( m12 + m21 ) < epsilon2 ) && ( Math.abs( m13 + m31 ) < epsilon2 ) && ( Math.abs( m23 + m32 ) < epsilon2 ) && ( Math.abs( m11 + m22 + m33 - 3 ) < epsilon2 ) ) { // this singularity is identity matrix so angle = 0 this.set( 1, 0, 0, 0 ); return this; // zero angle, arbitrary axis } // otherwise this singularity is angle = 180 angle = Math.PI; var xx = ( m11 + 1 ) / 2; var yy = ( m22 + 1 ) / 2; var zz = ( m33 + 1 ) / 2; var xy = ( m12 + m21 ) / 4; var xz = ( m13 + m31 ) / 4; var yz = ( m23 + m32 ) / 4; if ( ( xx > yy ) && ( xx > zz ) ) { // m11 is the largest diagonal term if ( xx < epsilon ) { x = 0; y = 0.707106781; z = 0.707106781; } else { x = Math.sqrt( xx ); y = xy / x; z = xz / x; } } else if ( yy > zz ) { // m22 is the largest diagonal term if ( yy < epsilon ) { x = 0.707106781; y = 0; z = 0.707106781; } else { y = Math.sqrt( yy ); x = xy / y; z = yz / y; } } else { // m33 is the largest diagonal term so base result on this if ( zz < epsilon ) { x = 0.707106781; y = 0.707106781; z = 0; } else { z = Math.sqrt( zz ); x = xz / z; y = yz / z; } } this.set( x, y, z, angle ); return this; // return 180 deg rotation } // as we have reached here there are no singularities so we can handle normally var s = Math.sqrt( ( m32 - m23 ) * ( m32 - m23 ) + ( m13 - m31 ) * ( m13 - m31 ) + ( m21 - m12 ) * ( m21 - m12 ) ); // used to normalize if ( Math.abs( s ) < 0.001 ) s = 1; // prevent divide by zero, should not happen if matrix is orthogonal and should be // caught by singularity test above, but I've left it in just in case this.x = ( m32 - m23 ) / s; this.y = ( m13 - m31 ) / s; this.z = ( m21 - m12 ) / s; this.w = Math.acos( ( m11 + m22 + m33 - 1 ) / 2 ); return this; }, min: function ( v ) { this.x = Math.min( this.x, v.x ); this.y = Math.min( this.y, v.y ); this.z = Math.min( this.z, v.z ); this.w = Math.min( this.w, v.w ); return this; }, max: function ( v ) { this.x = Math.max( this.x, v.x ); this.y = Math.max( this.y, v.y ); this.z = Math.max( this.z, v.z ); this.w = Math.max( this.w, v.w ); return this; }, clamp: function ( min, max ) { // assumes min < max, componentwise this.x = Math.max( min.x, Math.min( max.x, this.x ) ); this.y = Math.max( min.y, Math.min( max.y, this.y ) ); this.z = Math.max( min.z, Math.min( max.z, this.z ) ); this.w = Math.max( min.w, Math.min( max.w, this.w ) ); return this; }, clampScalar: function () { var min, max; return function clampScalar( minVal, maxVal ) { if ( min === undefined ) { min = new Vector4(); max = new Vector4(); } min.set( minVal, minVal, minVal, minVal ); max.set( maxVal, maxVal, maxVal, maxVal ); return this.clamp( min, max ); }; }(), clampLength: function ( min, max ) { var length = this.length(); return this.divideScalar( length || 1 ).multiplyScalar( Math.max( min, Math.min( max, length ) ) ); }, floor: function () { this.x = Math.floor( this.x ); this.y = Math.floor( this.y ); this.z = Math.floor( this.z ); this.w = Math.floor( this.w ); return this; }, ceil: function () { this.x = Math.ceil( this.x ); this.y = Math.ceil( this.y ); this.z = Math.ceil( this.z ); this.w = Math.ceil( this.w ); return this; }, round: function () { this.x = Math.round( this.x ); this.y = Math.round( this.y ); this.z = Math.round( this.z ); this.w = Math.round( this.w ); return this; }, roundToZero: function () { this.x = ( this.x < 0 ) ? Math.ceil( this.x ) : Math.floor( this.x ); this.y = ( this.y < 0 ) ? Math.ceil( this.y ) : Math.floor( this.y ); this.z = ( this.z < 0 ) ? Math.ceil( this.z ) : Math.floor( this.z ); this.w = ( this.w < 0 ) ? Math.ceil( this.w ) : Math.floor( this.w ); return this; }, negate: function () { this.x = - this.x; this.y = - this.y; this.z = - this.z; this.w = - this.w; return this; }, dot: function ( v ) { return this.x * v.x + this.y * v.y + this.z * v.z + this.w * v.w; }, lengthSq: function () { return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w; }, length: function () { return Math.sqrt( this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w ); }, manhattanLength: function () { return Math.abs( this.x ) + Math.abs( this.y ) + Math.abs( this.z ) + Math.abs( this.w ); }, normalize: function () { return this.divideScalar( this.length() || 1 ); }, setLength: function ( length ) { return this.normalize().multiplyScalar( length ); }, lerp: function ( v, alpha ) { this.x += ( v.x - this.x ) * alpha; this.y += ( v.y - this.y ) * alpha; this.z += ( v.z - this.z ) * alpha; this.w += ( v.w - this.w ) * alpha; return this; }, lerpVectors: function ( v1, v2, alpha ) { return this.subVectors( v2, v1 ).multiplyScalar( alpha ).add( v1 ); }, equals: function ( v ) { return ( ( v.x === this.x ) && ( v.y === this.y ) && ( v.z === this.z ) && ( v.w === this.w ) ); }, fromArray: function ( array, offset ) { if ( offset === undefined ) offset = 0; this.x = array[ offset ]; this.y = array[ offset + 1 ]; this.z = array[ offset + 2 ]; this.w = array[ offset + 3 ]; return this; }, toArray: function ( array, offset ) { if ( array === undefined ) array = []; if ( offset === undefined ) offset = 0; array[ offset ] = this.x; array[ offset + 1 ] = this.y; array[ offset + 2 ] = this.z; array[ offset + 3 ] = this.w; return array; }, fromBufferAttribute: function ( attribute, index, offset ) { if ( offset !== undefined ) { console.warn( 'THREE.Vector4: offset has been removed from .fromBufferAttribute().' ); } this.x = attribute.getX( index ); this.y = attribute.getY( index ); this.z = attribute.getZ( index ); this.w = attribute.getW( index ); return this; } } ); /** * @author szimek / https://github.com/szimek/ * @author alteredq / http://alteredqualia.com/ * @author Marius Kintel / https://github.com/kintel */ /* In options, we can specify: * Texture parameters for an auto-generated target texture * depthBuffer/stencilBuffer: Booleans to indicate if we should generate these buffers */ function WebGLRenderTarget( width, height, options ) { this.width = width; this.height = height; this.scissor = new Vector4( 0, 0, width, height ); this.scissorTest = false; this.viewport = new Vector4( 0, 0, width, height ); options = options || {}; this.texture = new Texture( undefined, undefined, options.wrapS, options.wrapT, options.magFilter, options.minFilter, options.format, options.type, options.anisotropy, options.encoding ); this.texture.generateMipmaps = options.generateMipmaps !== undefined ? options.generateMipmaps : false; this.texture.minFilter = options.minFilter !== undefined ? options.minFilter : LinearFilter; this.depthBuffer = options.depthBuffer !== undefined ? options.depthBuffer : true; this.stencilBuffer = options.stencilBuffer !== undefined ? options.stencilBuffer : true; this.depthTexture = options.depthTexture !== undefined ? options.depthTexture : null; } WebGLRenderTarget.prototype = Object.assign( Object.create( EventDispatcher.prototype ), { constructor: WebGLRenderTarget, isWebGLRenderTarget: true, setSize: function ( width, height ) { if ( this.width !== width || this.height !== height ) { this.width = width; this.height = height; this.dispose(); } this.viewport.set( 0, 0, width, height ); this.scissor.set( 0, 0, width, height ); }, clone: function () { return new this.constructor().copy( this ); }, copy: function ( source ) { this.width = source.width; this.height = source.height; this.viewport.copy( source.viewport ); this.texture = source.texture.clone(); this.depthBuffer = source.depthBuffer; this.stencilBuffer = source.stencilBuffer; this.depthTexture = source.depthTexture; return this; }, dispose: function () { this.dispatchEvent( { type: 'dispose' } ); } } ); /** * @author Mugen87 / https://github.com/Mugen87 * @author Matt DesLauriers / @mattdesl */ function WebGLMultisampleRenderTarget( width, height, options ) { WebGLRenderTarget.call( this, width, height, options ); this.samples = 4; } WebGLMultisampleRenderTarget.prototype = Object.assign( Object.create( WebGLRenderTarget.prototype ), { constructor: WebGLMultisampleRenderTarget, isWebGLMultisampleRenderTarget: true, copy: function ( source ) { WebGLRenderTarget.prototype.copy.call( this, source ); this.samples = source.samples; return this; } } ); /** * @author alteredq / http://alteredqualia.com */ function WebGLRenderTargetCube( width, height, options ) { WebGLRenderTarget.call( this, width, height, options ); this.activeCubeFace = 0; // PX 0, NX 1, PY 2, NY 3, PZ 4, NZ 5 this.activeMipMapLevel = 0; } WebGLRenderTargetCube.prototype = Object.create( WebGLRenderTarget.prototype ); WebGLRenderTargetCube.prototype.constructor = WebGLRenderTargetCube; WebGLRenderTargetCube.prototype.isWebGLRenderTargetCube = true; /** * @author alteredq / http://alteredqualia.com/ */ function DataTexture( data, width, height, format, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, encoding ) { Texture.call( this, null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding ); this.image = { data: data, width: width, height: height }; this.magFilter = magFilter !== undefined ? magFilter : NearestFilter; this.minFilter = minFilter !== undefined ? minFilter : NearestFilter; this.generateMipmaps = false; this.flipY = false; this.unpackAlignment = 1; } DataTexture.prototype = Object.create( Texture.prototype ); DataTexture.prototype.constructor = DataTexture; DataTexture.prototype.isDataTexture = true; /** * @author bhouston / http://clara.io * @author WestLangley / http://github.com/WestLangley */ function Box3( min, max ) { this.min = ( min !== undefined ) ? min : new Vector3( + Infinity, + Infinity, + Infinity ); this.max = ( max !== undefined ) ? max : new Vector3( - Infinity, - Infinity, - Infinity ); } Object.assign( Box3.prototype, { isBox3: true, set: function ( min, max ) { this.min.copy( min ); this.max.copy( max ); return this; }, setFromArray: function ( array ) { var minX = + Infinity; var minY = + Infinity; var minZ = + Infinity; var maxX = - Infinity; var maxY = - Infinity; var maxZ = - Infinity; for ( var i = 0, l = array.length; i < l; i += 3 ) { var x = array[ i ]; var y = array[ i + 1 ]; var z = array[ i + 2 ]; if ( x < minX ) minX = x; if ( y < minY ) minY = y; if ( z < minZ ) minZ = z; if ( x > maxX ) maxX = x; if ( y > maxY ) maxY = y; if ( z > maxZ ) maxZ = z; } this.min.set( minX, minY, minZ ); this.max.set( maxX, maxY, maxZ ); return this; }, setFromBufferAttribute: function ( attribute ) { var minX = + Infinity; var minY = + Infinity; var minZ = + Infinity; var maxX = - Infinity; var maxY = - Infinity; var maxZ = - Infinity; for ( var i = 0, l = attribute.count; i < l; i ++ ) { var x = attribute.getX( i ); var y = attribute.getY( i ); var z = attribute.getZ( i ); if ( x < minX ) minX = x; if ( y < minY ) minY = y; if ( z < minZ ) minZ = z; if ( x > maxX ) maxX = x; if ( y > maxY ) maxY = y; if ( z > maxZ ) maxZ = z; } this.min.set( minX, minY, minZ ); this.max.set( maxX, maxY, maxZ ); return this; }, setFromPoints: function ( points ) { this.makeEmpty(); for ( var i = 0, il = points.length; i < il; i ++ ) { this.expandByPoint( points[ i ] ); } return this; }, setFromCenterAndSize: function () { var v1 = new Vector3(); return function setFromCenterAndSize( center, size ) { var halfSize = v1.copy( size ).multiplyScalar( 0.5 ); this.min.copy( center ).sub( halfSize ); this.max.copy( center ).add( halfSize ); return this; }; }(), setFromObject: function ( object ) { this.makeEmpty(); return this.expandByObject( object ); }, clone: function () { return new this.constructor().copy( this ); }, copy: function ( box ) { this.min.copy( box.min ); this.max.copy( box.max ); return this; }, makeEmpty: function () { this.min.x = this.min.y = this.min.z = + Infinity; this.max.x = this.max.y = this.max.z = - Infinity; return this; }, isEmpty: function () { // this is a more robust check for empty than ( volume this.max.y || point.z < this.min.z || point.z > this.max.z ? false : true; }, containsBox: function ( box ) { return this.min.x this.max.y || box.max.z < this.min.z || box.min.z > this.max.z ? false : true; }, intersectsSphere: ( function () { var closestPoint = new Vector3(); return function intersectsSphere( sphere ) { // Find the point on the AABB closest to the sphere center. this.clampPoint( sphere.center, closestPoint ); // If that point is inside the sphere, the AABB and sphere intersect. return closestPoint.distanceToSquared( sphere.center ) 0 ) { min = plane.normal.x * this.min.x; max = plane.normal.x * this.max.x; } else { min = plane.normal.x * this.max.x; max = plane.normal.x * this.min.x; } if ( plane.normal.y > 0 ) { min += plane.normal.y * this.min.y; max += plane.normal.y * this.max.y; } else { min += plane.normal.y * this.max.y; max += plane.normal.y * this.min.y; } if ( plane.normal.z > 0 ) { min += plane.normal.z * this.min.z; max += plane.normal.z * this.max.z; } else { min += plane.normal.z * this.max.z; max += plane.normal.z * this.min.z; } return ( min = - plane.constant ); }, intersectsTriangle: ( function () { // triangle centered vertices var v0 = new Vector3(); var v1 = new Vector3(); var v2 = new Vector3(); // triangle edge vectors var f0 = new Vector3(); var f1 = new Vector3(); var f2 = new Vector3(); var testAxis = new Vector3(); var center = new Vector3(); var extents = new Vector3(); var triangleNormal = new Vector3(); function satForAxes( axes ) { var i, j; for ( i = 0, j = axes.length - 3; i r ) { // points of the projected triangle are outside the projected half-length of the aabb // the axis is seperating and we can exit return false; } } return true; } return function intersectsTriangle( triangle ) { if ( this.isEmpty() ) { return false; } // compute box center and extents this.getCenter( center ); extents.subVectors( this.max, center ); // translate triangle to aabb origin v0.subVectors( triangle.a, center ); v1.subVectors( triangle.b, center ); v2.subVectors( triangle.c, center ); // compute edge vectors for triangle f0.subVectors( v1, v0 ); f1.subVectors( v2, v1 ); f2.subVectors( v0, v2 ); // test against axes that are given by cross product combinations of the edges of the triangle and the edges of the aabb // make an axis testing of each of the 3 sides of the aabb against each of the 3 sides of the triangle = 9 axis of separation // axis_ij = u_i x f_j (u0, u1, u2 = face normals of aabb = x,y,z axes vectors since aabb is axis aligned) var axes = [ 0, - f0.z, f0.y, 0, - f1.z, f1.y, 0, - f2.z, f2.y, f0.z, 0, - f0.x, f1.z, 0, - f1.x, f2.z, 0, - f2.x, - f0.y, f0.x, 0, - f1.y, f1.x, 0, - f2.y, f2.x, 0 ]; if ( ! satForAxes( axes ) ) { return false; } // test 3 face normals from the aabb axes = [ 1, 0, 0, 0, 1, 0, 0, 0, 1 ]; if ( ! satForAxes( axes ) ) { return false; } // finally testing the face normal of the triangle // use already existing triangle edge vectors here triangleNormal.crossVectors( f0, f1 ); axes = [ triangleNormal.x, triangleNormal.y, triangleNormal.z ]; return satForAxes( axes ); }; } )(), clampPoint: function ( point, target ) { if ( target === undefined ) { console.warn( 'THREE.Box3: .clampPoint() target is now required' ); target = new Vector3(); } return target.copy( point ).clamp( this.min, this.max ); }, distanceToPoint: function () { var v1 = new Vector3(); return function distanceToPoint( point ) { var clampedPoint = v1.copy( point ).clamp( this.min, this.max ); return clampedPoint.sub( point ).length(); }; }(), getBoundingSphere: function () { var v1 = new Vector3(); return function getBoundingSphere( target ) { if ( target === undefined ) { console.warn( 'THREE.Box3: .getBoundingSphere() target is now required' ); target = new Sphere(); } this.getCenter( target.center ); target.radius = this.getSize( v1 ).length() * 0.5; return target; }; }(), intersect: function ( box ) { this.min.max( box.min ); this.max.min( box.max ); // ensure that if there is no overlap, the result is fully empty, not slightly empty with non-inf/+inf values that will cause subsequence intersects to erroneously return valid values. if ( this.isEmpty() ) this.makeEmpty(); return this; }, union: function ( box ) { this.min.min( box.min ); this.max.max( box.max ); return this; }, applyMatrix4: function () { var points = [ new Vector3(), new Vector3(), new Vector3(), new Vector3(), new Vector3(), new Vector3(), new Vector3(), new Vector3() ]; return function applyMatrix4( matrix ) { // transform of empty box is an empty box. if ( this.isEmpty() ) return this; // NOTE: I am using a binary pattern to specify all 2^3 combinations below points[ 0 ].set( this.min.x, this.min.y, this.min.z ).applyMatrix4( matrix ); // 000 points[ 1 ].set( this.min.x, this.min.y, this.max.z ).applyMatrix4( matrix ); // 001 points[ 2 ].set( this.min.x, this.max.y, this.min.z ).applyMatrix4( matrix ); // 010 points[ 3 ].set( this.min.x, this.max.y, this.max.z ).applyMatrix4( matrix ); // 011 points[ 4 ].set( this.max.x, this.min.y, this.min.z ).applyMatrix4( matrix ); // 100 points[ 5 ].set( this.max.x, this.min.y, this.max.z ).applyMatrix4( matrix ); // 101 points[ 6 ].set( this.max.x, this.max.y, this.min.z ).applyMatrix4( matrix ); // 110 points[ 7 ].set( this.max.x, this.max.y, this.max.z ).applyMatrix4( matrix ); // 111 this.setFromPoints( points ); return this; }; }(), translate: function ( offset ) { this.min.add( offset ); this.max.add( offset ); return this; }, equals: function ( box ) { return box.min.equals( this.min ) && box.max.equals( this.max ); } } ); /** * @author bhouston / http://clara.io * @author mrdoob / http://mrdoob.com/ */ function Sphere( center, radius ) { this.center = ( center !== undefined ) ? center : new Vector3(); this.radius = ( radius !== undefined ) ? radius : 0; } Object.assign( Sphere.prototype, { set: function ( center, radius ) { this.center.copy( center ); this.radius = radius; return this; }, setFromPoints: function () { var box = new Box3(); return function setFromPoints( points, optionalCenter ) { var center = this.center; if ( optionalCenter !== undefined ) { center.copy( optionalCenter ); } else { box.setFromPoints( points ).getCenter( center ); } var maxRadiusSq = 0; for ( var i = 0, il = points.length; i < il; i ++ ) { maxRadiusSq = Math.max( maxRadiusSq, center.distanceToSquared( points[ i ] ) ); } this.radius = Math.sqrt( maxRadiusSq ); return this; }; }(), clone: function () { return new this.constructor().copy( this ); }, copy: function ( sphere ) { this.center.copy( sphere.center ); this.radius = sphere.radius; return this; }, empty: function () { return ( this.radius 1 ) { return undefined; } return target.copy( direction ).multiplyScalar( t ).add( line.start ); }; }(), intersectsLine: function ( line ) { // Note: this tests if a line intersects the plane, not whether it (or its end-points) are coplanar with it. var startSign = this.distanceToPoint( line.start ); var endSign = this.distanceToPoint( line.end ); return ( startSign < 0 && endSign > 0 ) || ( endSign < 0 && startSign > 0 ); }, intersectsBox: function ( box ) { return box.intersectsPlane( this ); }, intersectsSphere: function ( sphere ) { return sphere.intersectsPlane( this ); }, coplanarPoint: function ( target ) { if ( target === undefined ) { console.warn( 'THREE.Plane: .coplanarPoint() target is now required' ); target = new Vector3(); } return target.copy( this.normal ).multiplyScalar( - this.constant ); }, applyMatrix4: function () { var v1 = new Vector3(); var m1 = new Matrix3(); return function applyMatrix4( matrix, optionalNormalMatrix ) { var normalMatrix = optionalNormalMatrix || m1.getNormalMatrix( matrix ); var referencePoint = this.coplanarPoint( v1 ).applyMatrix4( matrix ); var normal = this.normal.applyMatrix3( normalMatrix ).normalize(); this.constant = - referencePoint.dot( normal ); return this; }; }(), translate: function ( offset ) { this.constant -= offset.dot( this.normal ); return this; }, equals: function ( plane ) { return plane.normal.equals( this.normal ) && ( plane.constant === this.constant ); } } ); /** * @author mrdoob / http://mrdoob.com/ * @author alteredq / http://alteredqualia.com/ * @author bhouston / http://clara.io */ function Frustum( p0, p1, p2, p3, p4, p5 ) { this.planes = [ ( p0 !== undefined ) ? p0 : new Plane(), ( p1 !== undefined ) ? p1 : new Plane(), ( p2 !== undefined ) ? p2 : new Plane(), ( p3 !== undefined ) ? p3 : new Plane(), ( p4 !== undefined ) ? p4 : new Plane(), ( p5 !== undefined ) ? p5 : new Plane() ]; } Object.assign( Frustum.prototype, { set: function ( p0, p1, p2, p3, p4, p5 ) { var planes = this.planes; planes[ 0 ].copy( p0 ); planes[ 1 ].copy( p1 ); planes[ 2 ].copy( p2 ); planes[ 3 ].copy( p3 ); planes[ 4 ].copy( p4 ); planes[ 5 ].copy( p5 ); return this; }, clone: function () { return new this.constructor().copy( this ); }, copy: function ( frustum ) { var planes = this.planes; for ( var i = 0; i < 6; i ++ ) { planes[ i ].copy( frustum.planes[ i ] ); } return this; }, setFromMatrix: function ( m ) { var planes = this.planes; var me = m.elements; var me0 = me[ 0 ], me1 = me[ 1 ], me2 = me[ 2 ], me3 = me[ 3 ]; var me4 = me[ 4 ], me5 = me[ 5 ], me6 = me[ 6 ], me7 = me[ 7 ]; var me8 = me[ 8 ], me9 = me[ 9 ], me10 = me[ 10 ], me11 = me[ 11 ]; var me12 = me[ 12 ], me13 = me[ 13 ], me14 = me[ 14 ], me15 = me[ 15 ]; planes[ 0 ].setComponents( me3 - me0, me7 - me4, me11 - me8, me15 - me12 ).normalize(); planes[ 1 ].setComponents( me3 + me0, me7 + me4, me11 + me8, me15 + me12 ).normalize(); planes[ 2 ].setComponents( me3 + me1, me7 + me5, me11 + me9, me15 + me13 ).normalize(); planes[ 3 ].setComponents( me3 - me1, me7 - me5, me11 - me9, me15 - me13 ).normalize(); planes[ 4 ].setComponents( me3 - me2, me7 - me6, me11 - me10, me15 - me14 ).normalize(); planes[ 5 ].setComponents( me3 + me2, me7 + me6, me11 + me10, me15 + me14 ).normalize(); return this; }, intersectsObject: function () { var sphere = new Sphere(); return function intersectsObject( object ) { var geometry = object.geometry; if ( geometry.boundingSphere === null ) geometry.computeBoundingSphere(); sphere.copy( geometry.boundingSphere ) .applyMatrix4( object.matrixWorld ); return this.intersectsSphere( sphere ); }; }(), intersectsSprite: function () { var sphere = new Sphere(); return function intersectsSprite( sprite ) { sphere.center.set( 0, 0, 0 ); sphere.radius = 0.7071067811865476; sphere.applyMatrix4( sprite.matrixWorld ); return this.intersectsSphere( sphere ); }; }(), intersectsSphere: function ( sphere ) { var planes = this.planes; var center = sphere.center; var negRadius = - sphere.radius; for ( var i = 0; i < 6; i ++ ) { var distance = planes[ i ].distanceToPoint( center ); if ( distance < negRadius ) { return false; } } return true; }, intersectsBox: function () { var p = new Vector3(); return function intersectsBox( box ) { var planes = this.planes; for ( var i = 0; i < 6; i ++ ) { var plane = planes[ i ]; // corner at max distance p.x = plane.normal.x > 0 ? box.max.x : box.min.x; p.y = plane.normal.y > 0 ? box.max.y : box.min.y; p.z = plane.normal.z > 0 ? box.max.z : box.min.z; if ( plane.distanceToPoint( p ) < 0 ) { return false; } } return true; }; }(), containsPoint: function ( point ) { var planes = this.planes; for ( var i = 0; i < 6; i ++ ) { if ( planes[ i ].distanceToPoint( point ) < 0 ) { return false; } } return true; } } ); var alphamap_fragment = \"#ifdef USE_ALPHAMAP\\n\\tdiffuseColor.a *= texture2D( alphaMap, vUv ).g;\\n#endif\"; var alphamap_pars_fragment = \"#ifdef USE_ALPHAMAP\\n\\tuniform sampler2D alphaMap;\\n#endif\"; var alphatest_fragment = \"#ifdef ALPHATEST\\n\\tif ( diffuseColor.a < ALPHATEST ) discard;\\n#endif\"; var aomap_fragment = \"#ifdef USE_AOMAP\\n\\tfloat ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\\n\\treflectedLight.indirectDiffuse *= ambientOcclusion;\\n\\t#if defined( USE_ENVMAP ) && defined( PHYSICAL )\\n\\t\\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\\n\\t\\treflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.specularRoughness );\\n\\t#endif\\n#endif\"; var aomap_pars_fragment = \"#ifdef USE_AOMAP\\n\\tuniform sampler2D aoMap;\\n\\tuniform float aoMapIntensity;\\n#endif\"; var begin_vertex = \"vec3 transformed = vec3( position );\"; var beginnormal_vertex = \"vec3 objectNormal = vec3( normal );\"; var bsdfs = \"vec2 integrateSpecularBRDF( const in float dotNV, const in float roughness ) {\\n\\tconst vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\\n\\tconst vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\\n\\tvec4 r = roughness * c0 + c1;\\n\\tfloat a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\\n\\treturn vec2( -1.04, 1.04 ) * a004 + r.zw;\\n}\\nfloat punctualLightIntensityToIrradianceFactor( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\\n#if defined ( PHYSICALLY_CORRECT_LIGHTS )\\n\\tfloat distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\\n\\tif( cutoffDistance > 0.0 ) {\\n\\t\\tdistanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\\n\\t}\\n\\treturn distanceFalloff;\\n#else\\n\\tif( cutoffDistance > 0.0 && decayExponent > 0.0 ) {\\n\\t\\treturn pow( saturate( -lightDistance / cutoffDistance + 1.0 ), decayExponent );\\n\\t}\\n\\treturn 1.0;\\n#endif\\n}\\nvec3 BRDF_Diffuse_Lambert( const in vec3 diffuseColor ) {\\n\\treturn RECIPROCAL_PI * diffuseColor;\\n}\\nvec3 F_Schlick( const in vec3 specularColor, const in float dotLH ) {\\n\\tfloat fresnel = exp2( ( -5.55473 * dotLH - 6.98316 ) * dotLH );\\n\\treturn ( 1.0 - specularColor ) * fresnel + specularColor;\\n}\\nfloat G_GGX_Smith( const in float alpha, const in float dotNL, const in float dotNV ) {\\n\\tfloat a2 = pow2( alpha );\\n\\tfloat gl = dotNL + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\\n\\tfloat gv = dotNV + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\\n\\treturn 1.0 / ( gl * gv );\\n}\\nfloat G_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\\n\\tfloat a2 = pow2( alpha );\\n\\tfloat gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\\n\\tfloat gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\\n\\treturn 0.5 / max( gv + gl, EPSILON );\\n}\\nfloat D_GGX( const in float alpha, const in float dotNH ) {\\n\\tfloat a2 = pow2( alpha );\\n\\tfloat denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\\n\\treturn RECIPROCAL_PI * a2 / pow2( denom );\\n}\\nvec3 BRDF_Specular_GGX( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float roughness ) {\\n\\tfloat alpha = pow2( roughness );\\n\\tvec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\\n\\tfloat dotNL = saturate( dot( geometry.normal, incidentLight.direction ) );\\n\\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\\n\\tfloat dotNH = saturate( dot( geometry.normal, halfDir ) );\\n\\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\\n\\tvec3 F = F_Schlick( specularColor, dotLH );\\n\\tfloat G = G_GGX_SmithCorrelated( alpha, dotNL, dotNV );\\n\\tfloat D = D_GGX( alpha, dotNH );\\n\\treturn F * ( G * D );\\n}\\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\\n\\tconst float LUT_SIZE = 64.0;\\n\\tconst float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\\n\\tconst float LUT_BIAS = 0.5 / LUT_SIZE;\\n\\tfloat dotNV = saturate( dot( N, V ) );\\n\\tvec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );\\n\\tuv = uv * LUT_SCALE + LUT_BIAS;\\n\\treturn uv;\\n}\\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\\n\\tfloat l = length( f );\\n\\treturn max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\\n}\\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\\n\\tfloat x = dot( v1, v2 );\\n\\tfloat y = abs( x );\\n\\tfloat a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;\\n\\tfloat b = 3.4175940 + ( 4.1616724 + y ) * y;\\n\\tfloat v = a / b;\\n\\tfloat theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;\\n\\treturn cross( v1, v2 ) * theta_sintheta;\\n}\\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\\n\\tvec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\\n\\tvec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\\n\\tvec3 lightNormal = cross( v1, v2 );\\n\\tif( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\\n\\tvec3 T1, T2;\\n\\tT1 = normalize( V - N * dot( V, N ) );\\n\\tT2 = - cross( N, T1 );\\n\\tmat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\\n\\tvec3 coords[ 4 ];\\n\\tcoords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\\n\\tcoords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\\n\\tcoords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\\n\\tcoords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\\n\\tcoords[ 0 ] = normalize( coords[ 0 ] );\\n\\tcoords[ 1 ] = normalize( coords[ 1 ] );\\n\\tcoords[ 2 ] = normalize( coords[ 2 ] );\\n\\tcoords[ 3 ] = normalize( coords[ 3 ] );\\n\\tvec3 vectorFormFactor = vec3( 0.0 );\\n\\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\\n\\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\\n\\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\\n\\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\\n\\tfloat result = LTC_ClippedSphereFormFactor( vectorFormFactor );\\n\\treturn vec3( result );\\n}\\nvec3 BRDF_Specular_GGX_Environment( const in GeometricContext geometry, const in vec3 specularColor, const in float roughness ) {\\n\\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\\n\\tvec2 brdf = integrateSpecularBRDF( dotNV, roughness );\\n\\treturn specularColor * brdf.x + brdf.y;\\n}\\nvoid BRDF_Specular_Multiscattering_Environment( const in GeometricContext geometry, const in vec3 specularColor, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\\n\\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\\n\\tvec3 F = F_Schlick( specularColor, dotNV );\\n\\tvec2 brdf = integrateSpecularBRDF( dotNV, roughness );\\n\\tvec3 FssEss = F * brdf.x + brdf.y;\\n\\tfloat Ess = brdf.x + brdf.y;\\n\\tfloat Ems = 1.0 - Ess;\\n\\tvec3 Favg = specularColor + ( 1.0 - specularColor ) * 0.047619;\\tvec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );\\n\\tsingleScatter += FssEss;\\n\\tmultiScatter += Fms * Ems;\\n}\\nfloat G_BlinnPhong_Implicit( ) {\\n\\treturn 0.25;\\n}\\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\\n\\treturn RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\\n}\\nvec3 BRDF_Specular_BlinnPhong( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float shininess ) {\\n\\tvec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\\n\\tfloat dotNH = saturate( dot( geometry.normal, halfDir ) );\\n\\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\\n\\tvec3 F = F_Schlick( specularColor, dotLH );\\n\\tfloat G = G_BlinnPhong_Implicit( );\\n\\tfloat D = D_BlinnPhong( shininess, dotNH );\\n\\treturn F * ( G * D );\\n}\\nfloat GGXRoughnessToBlinnExponent( const in float ggxRoughness ) {\\n\\treturn ( 2.0 / pow2( ggxRoughness + 0.0001 ) - 2.0 );\\n}\\nfloat BlinnExponentToGGXRoughness( const in float blinnExponent ) {\\n\\treturn sqrt( 2.0 / ( blinnExponent + 2.0 ) );\\n}\"; var bumpmap_pars_fragment = \"#ifdef USE_BUMPMAP\\n\\tuniform sampler2D bumpMap;\\n\\tuniform float bumpScale;\\n\\tvec2 dHdxy_fwd() {\\n\\t\\tvec2 dSTdx = dFdx( vUv );\\n\\t\\tvec2 dSTdy = dFdy( vUv );\\n\\t\\tfloat Hll = bumpScale * texture2D( bumpMap, vUv ).x;\\n\\t\\tfloat dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\\n\\t\\tfloat dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\\n\\t\\treturn vec2( dBx, dBy );\\n\\t}\\n\\tvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy ) {\\n\\t\\tvec3 vSigmaX = vec3( dFdx( surf_pos.x ), dFdx( surf_pos.y ), dFdx( surf_pos.z ) );\\n\\t\\tvec3 vSigmaY = vec3( dFdy( surf_pos.x ), dFdy( surf_pos.y ), dFdy( surf_pos.z ) );\\n\\t\\tvec3 vN = surf_norm;\\n\\t\\tvec3 R1 = cross( vSigmaY, vN );\\n\\t\\tvec3 R2 = cross( vN, vSigmaX );\\n\\t\\tfloat fDet = dot( vSigmaX, R1 );\\n\\t\\tfDet *= ( float( gl_FrontFacing ) * 2.0 - 1.0 );\\n\\t\\tvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\\n\\t\\treturn normalize( abs( fDet ) * surf_norm - vGrad );\\n\\t}\\n#endif\"; var clipping_planes_fragment = \"#if NUM_CLIPPING_PLANES > 0\\n\\tvec4 plane;\\n\\t#pragma unroll_loop\\n\\tfor ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\\n\\t\\tplane = clippingPlanes[ i ];\\n\\t\\tif ( dot( vViewPosition, plane.xyz ) > plane.w ) discard;\\n\\t}\\n\\t#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\\n\\t\\tbool clipped = true;\\n\\t\\t#pragma unroll_loop\\n\\t\\tfor ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\\n\\t\\t\\tplane = clippingPlanes[ i ];\\n\\t\\t\\tclipped = ( dot( vViewPosition, plane.xyz ) > plane.w ) && clipped;\\n\\t\\t}\\n\\t\\tif ( clipped ) discard;\\n\\t#endif\\n#endif\"; var clipping_planes_pars_fragment = \"#if NUM_CLIPPING_PLANES > 0\\n\\t#if ! defined( PHYSICAL ) && ! defined( PHONG ) && ! defined( MATCAP )\\n\\t\\tvarying vec3 vViewPosition;\\n\\t#endif\\n\\tuniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\\n#endif\"; var clipping_planes_pars_vertex = \"#if NUM_CLIPPING_PLANES > 0 && ! defined( PHYSICAL ) && ! defined( PHONG ) && ! defined( MATCAP )\\n\\tvarying vec3 vViewPosition;\\n#endif\"; var clipping_planes_vertex = \"#if NUM_CLIPPING_PLANES > 0 && ! defined( PHYSICAL ) && ! defined( PHONG ) && ! defined( MATCAP )\\n\\tvViewPosition = - mvPosition.xyz;\\n#endif\"; var color_fragment = \"#ifdef USE_COLOR\\n\\tdiffuseColor.rgb *= vColor;\\n#endif\"; var color_pars_fragment = \"#ifdef USE_COLOR\\n\\tvarying vec3 vColor;\\n#endif\"; var color_pars_vertex = \"#ifdef USE_COLOR\\n\\tvarying vec3 vColor;\\n#endif\"; var color_vertex = \"#ifdef USE_COLOR\\n\\tvColor.xyz = color.xyz;\\n#endif\"; var common = \"#define PI 3.14159265359\\n#define PI2 6.28318530718\\n#define PI_HALF 1.5707963267949\\n#define RECIPROCAL_PI 0.31830988618\\n#define RECIPROCAL_PI2 0.15915494\\n#define LOG2 1.442695\\n#define EPSILON 1e-6\\n#define saturate(a) clamp( a, 0.0, 1.0 )\\n#define whiteCompliment(a) ( 1.0 - saturate( a ) )\\nfloat pow2( const in float x ) { return x*x; }\\nfloat pow3( const in float x ) { return x*x*x; }\\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\\nfloat average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }\\nhighp float rand( const in vec2 uv ) {\\n\\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\\n\\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\\n\\treturn fract(sin(sn) * c);\\n}\\nstruct IncidentLight {\\n\\tvec3 color;\\n\\tvec3 direction;\\n\\tbool visible;\\n};\\nstruct ReflectedLight {\\n\\tvec3 directDiffuse;\\n\\tvec3 directSpecular;\\n\\tvec3 indirectDiffuse;\\n\\tvec3 indirectSpecular;\\n};\\nstruct GeometricContext {\\n\\tvec3 position;\\n\\tvec3 normal;\\n\\tvec3 viewDir;\\n};\\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\\n\\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\\n}\\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\\n\\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\\n}\\nvec3 projectOnPlane(in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\\n\\tfloat distance = dot( planeNormal, point - pointOnPlane );\\n\\treturn - distance * planeNormal + point;\\n}\\nfloat sideOfPlane( in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\\n\\treturn sign( dot( point - pointOnPlane, planeNormal ) );\\n}\\nvec3 linePlaneIntersect( in vec3 pointOnLine, in vec3 lineDirection, in vec3 pointOnPlane, in vec3 planeNormal ) {\\n\\treturn lineDirection * ( dot( planeNormal, pointOnPlane - pointOnLine ) / dot( planeNormal, lineDirection ) ) + pointOnLine;\\n}\\nmat3 transposeMat3( const in mat3 m ) {\\n\\tmat3 tmp;\\n\\ttmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\\n\\ttmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\\n\\ttmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\\n\\treturn tmp;\\n}\\nfloat linearToRelativeLuminance( const in vec3 color ) {\\n\\tvec3 weights = vec3( 0.2126, 0.7152, 0.0722 );\\n\\treturn dot( weights, color.rgb );\\n}\"; var cube_uv_reflection_fragment = \"#ifdef ENVMAP_TYPE_CUBE_UV\\n#define cubeUV_textureSize (1024.0)\\nint getFaceFromDirection(vec3 direction) {\\n\\tvec3 absDirection = abs(direction);\\n\\tint face = -1;\\n\\tif( absDirection.x > absDirection.z ) {\\n\\t\\tif(absDirection.x > absDirection.y )\\n\\t\\t\\tface = direction.x > 0.0 ? 0 : 3;\\n\\t\\telse\\n\\t\\t\\tface = direction.y > 0.0 ? 1 : 4;\\n\\t}\\n\\telse {\\n\\t\\tif(absDirection.z > absDirection.y )\\n\\t\\t\\tface = direction.z > 0.0 ? 2 : 5;\\n\\t\\telse\\n\\t\\t\\tface = direction.y > 0.0 ? 1 : 4;\\n\\t}\\n\\treturn face;\\n}\\n#define cubeUV_maxLods1 (log2(cubeUV_textureSize*0.25) - 1.0)\\n#define cubeUV_rangeClamp (exp2((6.0 - 1.0) * 2.0))\\nvec2 MipLevelInfo( vec3 vec, float roughnessLevel, float roughness ) {\\n\\tfloat scale = exp2(cubeUV_maxLods1 - roughnessLevel);\\n\\tfloat dxRoughness = dFdx(roughness);\\n\\tfloat dyRoughness = dFdy(roughness);\\n\\tvec3 dx = dFdx( vec * scale * dxRoughness );\\n\\tvec3 dy = dFdy( vec * scale * dyRoughness );\\n\\tfloat d = max( dot( dx, dx ), dot( dy, dy ) );\\n\\td = clamp(d, 1.0, cubeUV_rangeClamp);\\n\\tfloat mipLevel = 0.5 * log2(d);\\n\\treturn vec2(floor(mipLevel), fract(mipLevel));\\n}\\n#define cubeUV_maxLods2 (log2(cubeUV_textureSize*0.25) - 2.0)\\n#define cubeUV_rcpTextureSize (1.0 / cubeUV_textureSize)\\nvec2 getCubeUV(vec3 direction, float roughnessLevel, float mipLevel) {\\n\\tmipLevel = roughnessLevel > cubeUV_maxLods2 - 3.0 ? 0.0 : mipLevel;\\n\\tfloat a = 16.0 * cubeUV_rcpTextureSize;\\n\\tvec2 exp2_packed = exp2( vec2( roughnessLevel, mipLevel ) );\\n\\tvec2 rcp_exp2_packed = vec2( 1.0 ) / exp2_packed;\\n\\tfloat powScale = exp2_packed.x * exp2_packed.y;\\n\\tfloat scale = rcp_exp2_packed.x * rcp_exp2_packed.y * 0.25;\\n\\tfloat mipOffset = 0.75*(1.0 - rcp_exp2_packed.y) * rcp_exp2_packed.x;\\n\\tbool bRes = mipLevel == 0.0;\\n\\tscale = bRes && (scale < a) ? a : scale;\\n\\tvec3 r;\\n\\tvec2 offset;\\n\\tint face = getFaceFromDirection(direction);\\n\\tfloat rcpPowScale = 1.0 / powScale;\\n\\tif( face == 0) {\\n\\t\\tr = vec3(direction.x, -direction.z, direction.y);\\n\\t\\toffset = vec2(0.0+mipOffset,0.75 * rcpPowScale);\\n\\t\\toffset.y = bRes && (offset.y < 2.0*a) ? a : offset.y;\\n\\t}\\n\\telse if( face == 1) {\\n\\t\\tr = vec3(direction.y, direction.x, direction.z);\\n\\t\\toffset = vec2(scale+mipOffset, 0.75 * rcpPowScale);\\n\\t\\toffset.y = bRes && (offset.y < 2.0*a) ? a : offset.y;\\n\\t}\\n\\telse if( face == 2) {\\n\\t\\tr = vec3(direction.z, direction.x, direction.y);\\n\\t\\toffset = vec2(2.0*scale+mipOffset, 0.75 * rcpPowScale);\\n\\t\\toffset.y = bRes && (offset.y < 2.0*a) ? a : offset.y;\\n\\t}\\n\\telse if( face == 3) {\\n\\t\\tr = vec3(direction.x, direction.z, direction.y);\\n\\t\\toffset = vec2(0.0+mipOffset,0.5 * rcpPowScale);\\n\\t\\toffset.y = bRes && (offset.y < 2.0*a) ? 0.0 : offset.y;\\n\\t}\\n\\telse if( face == 4) {\\n\\t\\tr = vec3(direction.y, direction.x, -direction.z);\\n\\t\\toffset = vec2(scale+mipOffset, 0.5 * rcpPowScale);\\n\\t\\toffset.y = bRes && (offset.y < 2.0*a) ? 0.0 : offset.y;\\n\\t}\\n\\telse {\\n\\t\\tr = vec3(direction.z, -direction.x, direction.y);\\n\\t\\toffset = vec2(2.0*scale+mipOffset, 0.5 * rcpPowScale);\\n\\t\\toffset.y = bRes && (offset.y < 2.0*a) ? 0.0 : offset.y;\\n\\t}\\n\\tr = normalize(r);\\n\\tfloat texelOffset = 0.5 * cubeUV_rcpTextureSize;\\n\\tvec2 s = ( r.yz / abs( r.x ) + vec2( 1.0 ) ) * 0.5;\\n\\tvec2 base = offset + vec2( texelOffset );\\n\\treturn base + s * ( scale - 2.0 * texelOffset );\\n}\\n#define cubeUV_maxLods3 (log2(cubeUV_textureSize*0.25) - 3.0)\\nvec4 textureCubeUV( sampler2D envMap, vec3 reflectedDirection, float roughness ) {\\n\\tfloat roughnessVal = roughness* cubeUV_maxLods3;\\n\\tfloat r1 = floor(roughnessVal);\\n\\tfloat r2 = r1 + 1.0;\\n\\tfloat t = fract(roughnessVal);\\n\\tvec2 mipInfo = MipLevelInfo(reflectedDirection, r1, roughness);\\n\\tfloat s = mipInfo.y;\\n\\tfloat level0 = mipInfo.x;\\n\\tfloat level1 = level0 + 1.0;\\n\\tlevel1 = level1 > 5.0 ? 5.0 : level1;\\n\\tlevel0 += min( floor( s + 0.5 ), 5.0 );\\n\\tvec2 uv_10 = getCubeUV(reflectedDirection, r1, level0);\\n\\tvec4 color10 = envMapTexelToLinear(texture2D(envMap, uv_10));\\n\\tvec2 uv_20 = getCubeUV(reflectedDirection, r2, level0);\\n\\tvec4 color20 = envMapTexelToLinear(texture2D(envMap, uv_20));\\n\\tvec4 result = mix(color10, color20, t);\\n\\treturn vec4(result.rgb, 1.0);\\n}\\n#endif\"; var defaultnormal_vertex = \"vec3 transformedNormal = normalMatrix * objectNormal;\\n#ifdef FLIP_SIDED\\n\\ttransformedNormal = - transformedNormal;\\n#endif\"; var displacementmap_pars_vertex = \"#ifdef USE_DISPLACEMENTMAP\\n\\tuniform sampler2D displacementMap;\\n\\tuniform float displacementScale;\\n\\tuniform float displacementBias;\\n#endif\"; var displacementmap_vertex = \"#ifdef USE_DISPLACEMENTMAP\\n\\ttransformed += normalize( objectNormal ) * ( texture2D( displacementMap, uv ).x * displacementScale + displacementBias );\\n#endif\"; var emissivemap_fragment = \"#ifdef USE_EMISSIVEMAP\\n\\tvec4 emissiveColor = texture2D( emissiveMap, vUv );\\n\\temissiveColor.rgb = emissiveMapTexelToLinear( emissiveColor ).rgb;\\n\\ttotalEmissiveRadiance *= emissiveColor.rgb;\\n#endif\"; var emissivemap_pars_fragment = \"#ifdef USE_EMISSIVEMAP\\n\\tuniform sampler2D emissiveMap;\\n#endif\"; var encodings_fragment = \"gl_FragColor = linearToOutputTexel( gl_FragColor );\"; var encodings_pars_fragment = \"\\nvec4 LinearToLinear( in vec4 value ) {\\n\\treturn value;\\n}\\nvec4 GammaToLinear( in vec4 value, in float gammaFactor ) {\\n\\treturn vec4( pow( value.rgb, vec3( gammaFactor ) ), value.a );\\n}\\nvec4 LinearToGamma( in vec4 value, in float gammaFactor ) {\\n\\treturn vec4( pow( value.rgb, vec3( 1.0 / gammaFactor ) ), value.a );\\n}\\nvec4 sRGBToLinear( in vec4 value ) {\\n\\treturn vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.a );\\n}\\nvec4 LinearTosRGB( in vec4 value ) {\\n\\treturn vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );\\n}\\nvec4 RGBEToLinear( in vec4 value ) {\\n\\treturn vec4( value.rgb * exp2( value.a * 255.0 - 128.0 ), 1.0 );\\n}\\nvec4 LinearToRGBE( in vec4 value ) {\\n\\tfloat maxComponent = max( max( value.r, value.g ), value.b );\\n\\tfloat fExp = clamp( ceil( log2( maxComponent ) ), -128.0, 127.0 );\\n\\treturn vec4( value.rgb / exp2( fExp ), ( fExp + 128.0 ) / 255.0 );\\n}\\nvec4 RGBMToLinear( in vec4 value, in float maxRange ) {\\n\\treturn vec4( value.rgb * value.a * maxRange, 1.0 );\\n}\\nvec4 LinearToRGBM( in vec4 value, in float maxRange ) {\\n\\tfloat maxRGB = max( value.r, max( value.g, value.b ) );\\n\\tfloat M = clamp( maxRGB / maxRange, 0.0, 1.0 );\\n\\tM = ceil( M * 255.0 ) / 255.0;\\n\\treturn vec4( value.rgb / ( M * maxRange ), M );\\n}\\nvec4 RGBDToLinear( in vec4 value, in float maxRange ) {\\n\\treturn vec4( value.rgb * ( ( maxRange / 255.0 ) / value.a ), 1.0 );\\n}\\nvec4 LinearToRGBD( in vec4 value, in float maxRange ) {\\n\\tfloat maxRGB = max( value.r, max( value.g, value.b ) );\\n\\tfloat D = max( maxRange / maxRGB, 1.0 );\\n\\tD = min( floor( D ) / 255.0, 1.0 );\\n\\treturn vec4( value.rgb * ( D * ( 255.0 / maxRange ) ), D );\\n}\\nconst mat3 cLogLuvM = mat3( 0.2209, 0.3390, 0.4184, 0.1138, 0.6780, 0.7319, 0.0102, 0.1130, 0.2969 );\\nvec4 LinearToLogLuv( in vec4 value ) {\\n\\tvec3 Xp_Y_XYZp = cLogLuvM * value.rgb;\\n\\tXp_Y_XYZp = max( Xp_Y_XYZp, vec3( 1e-6, 1e-6, 1e-6 ) );\\n\\tvec4 vResult;\\n\\tvResult.xy = Xp_Y_XYZp.xy / Xp_Y_XYZp.z;\\n\\tfloat Le = 2.0 * log2(Xp_Y_XYZp.y) + 127.0;\\n\\tvResult.w = fract( Le );\\n\\tvResult.z = ( Le - ( floor( vResult.w * 255.0 ) ) / 255.0 ) / 255.0;\\n\\treturn vResult;\\n}\\nconst mat3 cLogLuvInverseM = mat3( 6.0014, -2.7008, -1.7996, -1.3320, 3.1029, -5.7721, 0.3008, -1.0882, 5.6268 );\\nvec4 LogLuvToLinear( in vec4 value ) {\\n\\tfloat Le = value.z * 255.0 + value.w;\\n\\tvec3 Xp_Y_XYZp;\\n\\tXp_Y_XYZp.y = exp2( ( Le - 127.0 ) / 2.0 );\\n\\tXp_Y_XYZp.z = Xp_Y_XYZp.y / value.y;\\n\\tXp_Y_XYZp.x = value.x * Xp_Y_XYZp.z;\\n\\tvec3 vRGB = cLogLuvInverseM * Xp_Y_XYZp.rgb;\\n\\treturn vec4( max( vRGB, 0.0 ), 1.0 );\\n}\"; var envmap_fragment = \"#ifdef USE_ENVMAP\\n\\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\\n\\t\\tvec3 cameraToVertex = normalize( vWorldPosition - cameraPosition );\\n\\t\\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\\n\\t\\t#ifdef ENVMAP_MODE_REFLECTION\\n\\t\\t\\tvec3 reflectVec = reflect( cameraToVertex, worldNormal );\\n\\t\\t#else\\n\\t\\t\\tvec3 reflectVec = refract( cameraToVertex, worldNormal, refractionRatio );\\n\\t\\t#endif\\n\\t#else\\n\\t\\tvec3 reflectVec = vReflect;\\n\\t#endif\\n\\t#ifdef ENVMAP_TYPE_CUBE\\n\\t\\tvec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\\n\\t#elif defined( ENVMAP_TYPE_EQUIREC )\\n\\t\\tvec2 sampleUV;\\n\\t\\treflectVec = normalize( reflectVec );\\n\\t\\tsampleUV.y = asin( clamp( reflectVec.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\\n\\t\\tsampleUV.x = atan( reflectVec.z, reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\\n\\t\\tvec4 envColor = texture2D( envMap, sampleUV );\\n\\t#elif defined( ENVMAP_TYPE_SPHERE )\\n\\t\\treflectVec = normalize( reflectVec );\\n\\t\\tvec3 reflectView = normalize( ( viewMatrix * vec4( reflectVec, 0.0 ) ).xyz + vec3( 0.0, 0.0, 1.0 ) );\\n\\t\\tvec4 envColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5 );\\n\\t#else\\n\\t\\tvec4 envColor = vec4( 0.0 );\\n\\t#endif\\n\\tenvColor = envMapTexelToLinear( envColor );\\n\\t#ifdef ENVMAP_BLENDING_MULTIPLY\\n\\t\\toutgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\\n\\t#elif defined( ENVMAP_BLENDING_MIX )\\n\\t\\toutgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\\n\\t#elif defined( ENVMAP_BLENDING_ADD )\\n\\t\\toutgoingLight += envColor.xyz * specularStrength * reflectivity;\\n\\t#endif\\n#endif\"; var envmap_pars_fragment = \"#if defined( USE_ENVMAP ) || defined( PHYSICAL )\\n\\tuniform float reflectivity;\\n\\tuniform float envMapIntensity;\\n#endif\\n#ifdef USE_ENVMAP\\n\\t#if ! defined( PHYSICAL ) && ( defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) )\\n\\t\\tvarying vec3 vWorldPosition;\\n\\t#endif\\n\\t#ifdef ENVMAP_TYPE_CUBE\\n\\t\\tuniform samplerCube envMap;\\n\\t#else\\n\\t\\tuniform sampler2D envMap;\\n\\t#endif\\n\\tuniform float flipEnvMap;\\n\\tuniform int maxMipLevel;\\n\\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( PHYSICAL )\\n\\t\\tuniform float refractionRatio;\\n\\t#else\\n\\t\\tvarying vec3 vReflect;\\n\\t#endif\\n#endif\"; var envmap_pars_vertex = \"#ifdef USE_ENVMAP\\n\\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\\n\\t\\tvarying vec3 vWorldPosition;\\n\\t#else\\n\\t\\tvarying vec3 vReflect;\\n\\t\\tuniform float refractionRatio;\\n\\t#endif\\n#endif\"; var envmap_vertex = \"#ifdef USE_ENVMAP\\n\\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\\n\\t\\tvWorldPosition = worldPosition.xyz;\\n\\t#else\\n\\t\\tvec3 cameraToVertex = normalize( worldPosition.xyz - cameraPosition );\\n\\t\\tvec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\\n\\t\\t#ifdef ENVMAP_MODE_REFLECTION\\n\\t\\t\\tvReflect = reflect( cameraToVertex, worldNormal );\\n\\t\\t#else\\n\\t\\t\\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\\n\\t\\t#endif\\n\\t#endif\\n#endif\"; var fog_vertex = \"#ifdef USE_FOG\\n\\tfogDepth = -mvPosition.z;\\n#endif\"; var fog_pars_vertex = \"#ifdef USE_FOG\\n\\tvarying float fogDepth;\\n#endif\"; var fog_fragment = \"#ifdef USE_FOG\\n\\t#ifdef FOG_EXP2\\n\\t\\tfloat fogFactor = whiteCompliment( exp2( - fogDensity * fogDensity * fogDepth * fogDepth * LOG2 ) );\\n\\t#else\\n\\t\\tfloat fogFactor = smoothstep( fogNear, fogFar, fogDepth );\\n\\t#endif\\n\\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\\n#endif\"; var fog_pars_fragment = \"#ifdef USE_FOG\\n\\tuniform vec3 fogColor;\\n\\tvarying float fogDepth;\\n\\t#ifdef FOG_EXP2\\n\\t\\tuniform float fogDensity;\\n\\t#else\\n\\t\\tuniform float fogNear;\\n\\t\\tuniform float fogFar;\\n\\t#endif\\n#endif\"; var gradientmap_pars_fragment = \"#ifdef TOON\\n\\tuniform sampler2D gradientMap;\\n\\tvec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\\n\\t\\tfloat dotNL = dot( normal, lightDirection );\\n\\t\\tvec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\\n\\t\\t#ifdef USE_GRADIENTMAP\\n\\t\\t\\treturn texture2D( gradientMap, coord ).rgb;\\n\\t\\t#else\\n\\t\\t\\treturn ( coord.x < 0.7 ) ? vec3( 0.7 ) : vec3( 1.0 );\\n\\t\\t#endif\\n\\t}\\n#endif\"; var lightmap_fragment = \"#ifdef USE_LIGHTMAP\\n\\treflectedLight.indirectDiffuse += PI * texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\\n#endif\"; var lightmap_pars_fragment = \"#ifdef USE_LIGHTMAP\\n\\tuniform sampler2D lightMap;\\n\\tuniform float lightMapIntensity;\\n#endif\"; var lights_lambert_vertex = \"vec3 diffuse = vec3( 1.0 );\\nGeometricContext geometry;\\ngeometry.position = mvPosition.xyz;\\ngeometry.normal = normalize( transformedNormal );\\ngeometry.viewDir = normalize( -mvPosition.xyz );\\nGeometricContext backGeometry;\\nbackGeometry.position = geometry.position;\\nbackGeometry.normal = -geometry.normal;\\nbackGeometry.viewDir = geometry.viewDir;\\nvLightFront = vec3( 0.0 );\\nvIndirectFront = vec3( 0.0 );\\n#ifdef DOUBLE_SIDED\\n\\tvLightBack = vec3( 0.0 );\\n\\tvIndirectBack = vec3( 0.0 );\\n#endif\\nIncidentLight directLight;\\nfloat dotNL;\\nvec3 directLightColor_Diffuse;\\n#if NUM_POINT_LIGHTS > 0\\n\\t#pragma unroll_loop\\n\\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\\n\\t\\tgetPointDirectLightIrradiance( pointLights[ i ], geometry, directLight );\\n\\t\\tdotNL = dot( geometry.normal, directLight.direction );\\n\\t\\tdirectLightColor_Diffuse = PI * directLight.color;\\n\\t\\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\\n\\t\\t#ifdef DOUBLE_SIDED\\n\\t\\t\\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\\n\\t\\t#endif\\n\\t}\\n#endif\\n#if NUM_SPOT_LIGHTS > 0\\n\\t#pragma unroll_loop\\n\\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\\n\\t\\tgetSpotDirectLightIrradiance( spotLights[ i ], geometry, directLight );\\n\\t\\tdotNL = dot( geometry.normal, directLight.direction );\\n\\t\\tdirectLightColor_Diffuse = PI * directLight.color;\\n\\t\\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\\n\\t\\t#ifdef DOUBLE_SIDED\\n\\t\\t\\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\\n\\t\\t#endif\\n\\t}\\n#endif\\n#if NUM_DIR_LIGHTS > 0\\n\\t#pragma unroll_loop\\n\\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\\n\\t\\tgetDirectionalDirectLightIrradiance( directionalLights[ i ], geometry, directLight );\\n\\t\\tdotNL = dot( geometry.normal, directLight.direction );\\n\\t\\tdirectLightColor_Diffuse = PI * directLight.color;\\n\\t\\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\\n\\t\\t#ifdef DOUBLE_SIDED\\n\\t\\t\\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\\n\\t\\t#endif\\n\\t}\\n#endif\\n#if NUM_HEMI_LIGHTS > 0\\n\\t#pragma unroll_loop\\n\\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\\n\\t\\tvIndirectFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\\n\\t\\t#ifdef DOUBLE_SIDED\\n\\t\\t\\tvIndirectBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry );\\n\\t\\t#endif\\n\\t}\\n#endif\"; var lights_pars_begin = \"uniform vec3 ambientLightColor;\\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\\n\\tvec3 irradiance = ambientLightColor;\\n\\t#ifndef PHYSICALLY_CORRECT_LIGHTS\\n\\t\\tirradiance *= PI;\\n\\t#endif\\n\\treturn irradiance;\\n}\\n#if NUM_DIR_LIGHTS > 0\\n\\tstruct DirectionalLight {\\n\\t\\tvec3 direction;\\n\\t\\tvec3 color;\\n\\t\\tint shadow;\\n\\t\\tfloat shadowBias;\\n\\t\\tfloat shadowRadius;\\n\\t\\tvec2 shadowMapSize;\\n\\t};\\n\\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\\n\\tvoid getDirectionalDirectLightIrradiance( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight directLight ) {\\n\\t\\tdirectLight.color = directionalLight.color;\\n\\t\\tdirectLight.direction = directionalLight.direction;\\n\\t\\tdirectLight.visible = true;\\n\\t}\\n#endif\\n#if NUM_POINT_LIGHTS > 0\\n\\tstruct PointLight {\\n\\t\\tvec3 position;\\n\\t\\tvec3 color;\\n\\t\\tfloat distance;\\n\\t\\tfloat decay;\\n\\t\\tint shadow;\\n\\t\\tfloat shadowBias;\\n\\t\\tfloat shadowRadius;\\n\\t\\tvec2 shadowMapSize;\\n\\t\\tfloat shadowCameraNear;\\n\\t\\tfloat shadowCameraFar;\\n\\t};\\n\\tuniform PointLight pointLights[ NUM_POINT_LIGHTS ];\\n\\tvoid getPointDirectLightIrradiance( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight directLight ) {\\n\\t\\tvec3 lVector = pointLight.position - geometry.position;\\n\\t\\tdirectLight.direction = normalize( lVector );\\n\\t\\tfloat lightDistance = length( lVector );\\n\\t\\tdirectLight.color = pointLight.color;\\n\\t\\tdirectLight.color *= punctualLightIntensityToIrradianceFactor( lightDistance, pointLight.distance, pointLight.decay );\\n\\t\\tdirectLight.visible = ( directLight.color != vec3( 0.0 ) );\\n\\t}\\n#endif\\n#if NUM_SPOT_LIGHTS > 0\\n\\tstruct SpotLight {\\n\\t\\tvec3 position;\\n\\t\\tvec3 direction;\\n\\t\\tvec3 color;\\n\\t\\tfloat distance;\\n\\t\\tfloat decay;\\n\\t\\tfloat coneCos;\\n\\t\\tfloat penumbraCos;\\n\\t\\tint shadow;\\n\\t\\tfloat shadowBias;\\n\\t\\tfloat shadowRadius;\\n\\t\\tvec2 shadowMapSize;\\n\\t};\\n\\tuniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\\n\\tvoid getSpotDirectLightIrradiance( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight directLight ) {\\n\\t\\tvec3 lVector = spotLight.position - geometry.position;\\n\\t\\tdirectLight.direction = normalize( lVector );\\n\\t\\tfloat lightDistance = length( lVector );\\n\\t\\tfloat angleCos = dot( directLight.direction, spotLight.direction );\\n\\t\\tif ( angleCos > spotLight.coneCos ) {\\n\\t\\t\\tfloat spotEffect = smoothstep( spotLight.coneCos, spotLight.penumbraCos, angleCos );\\n\\t\\t\\tdirectLight.color = spotLight.color;\\n\\t\\t\\tdirectLight.color *= spotEffect * punctualLightIntensityToIrradianceFactor( lightDistance, spotLight.distance, spotLight.decay );\\n\\t\\t\\tdirectLight.visible = true;\\n\\t\\t} else {\\n\\t\\t\\tdirectLight.color = vec3( 0.0 );\\n\\t\\t\\tdirectLight.visible = false;\\n\\t\\t}\\n\\t}\\n#endif\\n#if NUM_RECT_AREA_LIGHTS > 0\\n\\tstruct RectAreaLight {\\n\\t\\tvec3 color;\\n\\t\\tvec3 position;\\n\\t\\tvec3 halfWidth;\\n\\t\\tvec3 halfHeight;\\n\\t};\\n\\tuniform sampler2D ltc_1;\\tuniform sampler2D ltc_2;\\n\\tuniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\\n#endif\\n#if NUM_HEMI_LIGHTS > 0\\n\\tstruct HemisphereLight {\\n\\t\\tvec3 direction;\\n\\t\\tvec3 skyColor;\\n\\t\\tvec3 groundColor;\\n\\t};\\n\\tuniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\\n\\tvec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in GeometricContext geometry ) {\\n\\t\\tfloat dotNL = dot( geometry.normal, hemiLight.direction );\\n\\t\\tfloat hemiDiffuseWeight = 0.5 * dotNL + 0.5;\\n\\t\\tvec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\\n\\t\\t#ifndef PHYSICALLY_CORRECT_LIGHTS\\n\\t\\t\\tirradiance *= PI;\\n\\t\\t#endif\\n\\t\\treturn irradiance;\\n\\t}\\n#endif\"; var envmap_physical_pars_fragment = \"#if defined( USE_ENVMAP ) && defined( PHYSICAL )\\n\\tvec3 getLightProbeIndirectIrradiance( const in GeometricContext geometry, const in int maxMIPLevel ) {\\n\\t\\tvec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\\n\\t\\t#ifdef ENVMAP_TYPE_CUBE\\n\\t\\t\\tvec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\\n\\t\\t\\t#ifdef TEXTURE_LOD_EXT\\n\\t\\t\\t\\tvec4 envMapColor = textureCubeLodEXT( envMap, queryVec, float( maxMIPLevel ) );\\n\\t\\t\\t#else\\n\\t\\t\\t\\tvec4 envMapColor = textureCube( envMap, queryVec, float( maxMIPLevel ) );\\n\\t\\t\\t#endif\\n\\t\\t\\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\\n\\t\\t#elif defined( ENVMAP_TYPE_CUBE_UV )\\n\\t\\t\\tvec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\\n\\t\\t\\tvec4 envMapColor = textureCubeUV( envMap, queryVec, 1.0 );\\n\\t\\t#else\\n\\t\\t\\tvec4 envMapColor = vec4( 0.0 );\\n\\t\\t#endif\\n\\t\\treturn PI * envMapColor.rgb * envMapIntensity;\\n\\t}\\n\\tfloat getSpecularMIPLevel( const in float blinnShininessExponent, const in int maxMIPLevel ) {\\n\\t\\tfloat maxMIPLevelScalar = float( maxMIPLevel );\\n\\t\\tfloat desiredMIPLevel = maxMIPLevelScalar + 0.79248 - 0.5 * log2( pow2( blinnShininessExponent ) + 1.0 );\\n\\t\\treturn clamp( desiredMIPLevel, 0.0, maxMIPLevelScalar );\\n\\t}\\n\\tvec3 getLightProbeIndirectRadiance( const in GeometricContext geometry, const in float blinnShininessExponent, const in int maxMIPLevel ) {\\n\\t\\t#ifdef ENVMAP_MODE_REFLECTION\\n\\t\\t\\tvec3 reflectVec = reflect( -geometry.viewDir, geometry.normal );\\n\\t\\t#else\\n\\t\\t\\tvec3 reflectVec = refract( -geometry.viewDir, geometry.normal, refractionRatio );\\n\\t\\t#endif\\n\\t\\treflectVec = inverseTransformDirection( reflectVec, viewMatrix );\\n\\t\\tfloat specularMIPLevel = getSpecularMIPLevel( blinnShininessExponent, maxMIPLevel );\\n\\t\\t#ifdef ENVMAP_TYPE_CUBE\\n\\t\\t\\tvec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\\n\\t\\t\\t#ifdef TEXTURE_LOD_EXT\\n\\t\\t\\t\\tvec4 envMapColor = textureCubeLodEXT( envMap, queryReflectVec, specularMIPLevel );\\n\\t\\t\\t#else\\n\\t\\t\\t\\tvec4 envMapColor = textureCube( envMap, queryReflectVec, specularMIPLevel );\\n\\t\\t\\t#endif\\n\\t\\t\\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\\n\\t\\t#elif defined( ENVMAP_TYPE_CUBE_UV )\\n\\t\\t\\tvec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\\n\\t\\t\\tvec4 envMapColor = textureCubeUV( envMap, queryReflectVec, BlinnExponentToGGXRoughness(blinnShininessExponent ));\\n\\t\\t#elif defined( ENVMAP_TYPE_EQUIREC )\\n\\t\\t\\tvec2 sampleUV;\\n\\t\\t\\tsampleUV.y = asin( clamp( reflectVec.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\\n\\t\\t\\tsampleUV.x = atan( reflectVec.z, reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\\n\\t\\t\\t#ifdef TEXTURE_LOD_EXT\\n\\t\\t\\t\\tvec4 envMapColor = texture2DLodEXT( envMap, sampleUV, specularMIPLevel );\\n\\t\\t\\t#else\\n\\t\\t\\t\\tvec4 envMapColor = texture2D( envMap, sampleUV, specularMIPLevel );\\n\\t\\t\\t#endif\\n\\t\\t\\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\\n\\t\\t#elif defined( ENVMAP_TYPE_SPHERE )\\n\\t\\t\\tvec3 reflectView = normalize( ( viewMatrix * vec4( reflectVec, 0.0 ) ).xyz + vec3( 0.0,0.0,1.0 ) );\\n\\t\\t\\t#ifdef TEXTURE_LOD_EXT\\n\\t\\t\\t\\tvec4 envMapColor = texture2DLodEXT( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );\\n\\t\\t\\t#else\\n\\t\\t\\t\\tvec4 envMapColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );\\n\\t\\t\\t#endif\\n\\t\\t\\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\\n\\t\\t#endif\\n\\t\\treturn envMapColor.rgb * envMapIntensity;\\n\\t}\\n#endif\"; var lights_phong_fragment = \"BlinnPhongMaterial material;\\nmaterial.diffuseColor = diffuseColor.rgb;\\nmaterial.specularColor = specular;\\nmaterial.specularShininess = shininess;\\nmaterial.specularStrength = specularStrength;\"; var lights_phong_pars_fragment = \"varying vec3 vViewPosition;\\n#ifndef FLAT_SHADED\\n\\tvarying vec3 vNormal;\\n#endif\\nstruct BlinnPhongMaterial {\\n\\tvec3\\tdiffuseColor;\\n\\tvec3\\tspecularColor;\\n\\tfloat\\tspecularShininess;\\n\\tfloat\\tspecularStrength;\\n};\\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\\n\\t#ifdef TOON\\n\\t\\tvec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;\\n\\t#else\\n\\t\\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\\n\\t\\tvec3 irradiance = dotNL * directLight.color;\\n\\t#endif\\n\\t#ifndef PHYSICALLY_CORRECT_LIGHTS\\n\\t\\tirradiance *= PI;\\n\\t#endif\\n\\treflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\\n\\treflectedLight.directSpecular += irradiance * BRDF_Specular_BlinnPhong( directLight, geometry, material.specularColor, material.specularShininess ) * material.specularStrength;\\n}\\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\\n\\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\\n}\\n#define RE_Direct\\t\\t\\t\\tRE_Direct_BlinnPhong\\n#define RE_IndirectDiffuse\\t\\tRE_IndirectDiffuse_BlinnPhong\\n#define Material_LightProbeLOD( material )\\t(0)\"; var lights_physical_fragment = \"PhysicalMaterial material;\\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\\nmaterial.specularRoughness = clamp( roughnessFactor, 0.04, 1.0 );\\n#ifdef STANDARD\\n\\tmaterial.specularColor = mix( vec3( DEFAULT_SPECULAR_COEFFICIENT ), diffuseColor.rgb, metalnessFactor );\\n#else\\n\\tmaterial.specularColor = mix( vec3( MAXIMUM_SPECULAR_COEFFICIENT * pow2( reflectivity ) ), diffuseColor.rgb, metalnessFactor );\\n\\tmaterial.clearCoat = saturate( clearCoat );\\tmaterial.clearCoatRoughness = clamp( clearCoatRoughness, 0.04, 1.0 );\\n#endif\"; var lights_physical_pars_fragment = \"struct PhysicalMaterial {\\n\\tvec3\\tdiffuseColor;\\n\\tfloat\\tspecularRoughness;\\n\\tvec3\\tspecularColor;\\n\\t#ifndef STANDARD\\n\\t\\tfloat clearCoat;\\n\\t\\tfloat clearCoatRoughness;\\n\\t#endif\\n};\\n#define MAXIMUM_SPECULAR_COEFFICIENT 0.16\\n#define DEFAULT_SPECULAR_COEFFICIENT 0.04\\nfloat clearCoatDHRApprox( const in float roughness, const in float dotNL ) {\\n\\treturn DEFAULT_SPECULAR_COEFFICIENT + ( 1.0 - DEFAULT_SPECULAR_COEFFICIENT ) * ( pow( 1.0 - dotNL, 5.0 ) * pow( 1.0 - roughness, 2.0 ) );\\n}\\n#if NUM_RECT_AREA_LIGHTS > 0\\n\\tvoid RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\\n\\t\\tvec3 normal = geometry.normal;\\n\\t\\tvec3 viewDir = geometry.viewDir;\\n\\t\\tvec3 position = geometry.position;\\n\\t\\tvec3 lightPos = rectAreaLight.position;\\n\\t\\tvec3 halfWidth = rectAreaLight.halfWidth;\\n\\t\\tvec3 halfHeight = rectAreaLight.halfHeight;\\n\\t\\tvec3 lightColor = rectAreaLight.color;\\n\\t\\tfloat roughness = material.specularRoughness;\\n\\t\\tvec3 rectCoords[ 4 ];\\n\\t\\trectCoords[ 0 ] = lightPos + halfWidth - halfHeight;\\t\\trectCoords[ 1 ] = lightPos - halfWidth - halfHeight;\\n\\t\\trectCoords[ 2 ] = lightPos - halfWidth + halfHeight;\\n\\t\\trectCoords[ 3 ] = lightPos + halfWidth + halfHeight;\\n\\t\\tvec2 uv = LTC_Uv( normal, viewDir, roughness );\\n\\t\\tvec4 t1 = texture2D( ltc_1, uv );\\n\\t\\tvec4 t2 = texture2D( ltc_2, uv );\\n\\t\\tmat3 mInv = mat3(\\n\\t\\t\\tvec3( t1.x, 0, t1.y ),\\n\\t\\t\\tvec3( 0, 1, 0 ),\\n\\t\\t\\tvec3( t1.z, 0, t1.w )\\n\\t\\t);\\n\\t\\tvec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );\\n\\t\\treflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\\n\\t\\treflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );\\n\\t}\\n#endif\\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\\n\\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\\n\\tvec3 irradiance = dotNL * directLight.color;\\n\\t#ifndef PHYSICALLY_CORRECT_LIGHTS\\n\\t\\tirradiance *= PI;\\n\\t#endif\\n\\t#ifndef STANDARD\\n\\t\\tfloat clearCoatDHR = material.clearCoat * clearCoatDHRApprox( material.clearCoatRoughness, dotNL );\\n\\t#else\\n\\t\\tfloat clearCoatDHR = 0.0;\\n\\t#endif\\n\\treflectedLight.directSpecular += ( 1.0 - clearCoatDHR ) * irradiance * BRDF_Specular_GGX( directLight, geometry, material.specularColor, material.specularRoughness );\\n\\treflectedLight.directDiffuse += ( 1.0 - clearCoatDHR ) * irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\\n\\t#ifndef STANDARD\\n\\t\\treflectedLight.directSpecular += irradiance * material.clearCoat * BRDF_Specular_GGX( directLight, geometry, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearCoatRoughness );\\n\\t#endif\\n}\\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\\n\\t#ifndef ENVMAP_TYPE_CUBE_UV\\n\\t\\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\\n\\t#endif\\n}\\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearCoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {\\n\\t#ifndef STANDARD\\n\\t\\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\\n\\t\\tfloat dotNL = dotNV;\\n\\t\\tfloat clearCoatDHR = material.clearCoat * clearCoatDHRApprox( material.clearCoatRoughness, dotNL );\\n\\t#else\\n\\t\\tfloat clearCoatDHR = 0.0;\\n\\t#endif\\n\\tfloat clearCoatInv = 1.0 - clearCoatDHR;\\n\\t#if defined( ENVMAP_TYPE_CUBE_UV )\\n\\t\\tvec3 singleScattering = vec3( 0.0 );\\n\\t\\tvec3 multiScattering = vec3( 0.0 );\\n\\t\\tvec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;\\n\\t\\tBRDF_Specular_Multiscattering_Environment( geometry, material.specularColor, material.specularRoughness, singleScattering, multiScattering );\\n\\t\\tvec3 diffuse = material.diffuseColor;\\n\\t\\treflectedLight.indirectSpecular += clearCoatInv * radiance * singleScattering;\\n\\t\\treflectedLight.indirectDiffuse += multiScattering * cosineWeightedIrradiance;\\n\\t\\treflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;\\n\\t#else\\n\\t\\treflectedLight.indirectSpecular += clearCoatInv * radiance * BRDF_Specular_GGX_Environment( geometry, material.specularColor, material.specularRoughness );\\n\\t#endif\\n\\t#ifndef STANDARD\\n\\t\\treflectedLight.indirectSpecular += clearCoatRadiance * material.clearCoat * BRDF_Specular_GGX_Environment( geometry, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearCoatRoughness );\\n\\t#endif\\n}\\n#define RE_Direct\\t\\t\\t\\tRE_Direct_Physical\\n#define RE_Direct_RectArea\\t\\tRE_Direct_RectArea_Physical\\n#define RE_IndirectDiffuse\\t\\tRE_IndirectDiffuse_Physical\\n#define RE_IndirectSpecular\\t\\tRE_IndirectSpecular_Physical\\n#define Material_BlinnShininessExponent( material ) GGXRoughnessToBlinnExponent( material.specularRoughness )\\n#define Material_ClearCoat_BlinnShininessExponent( material ) GGXRoughnessToBlinnExponent( material.clearCoatRoughness )\\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\\n\\treturn saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\\n}\"; var lights_fragment_begin = \"\\nGeometricContext geometry;\\ngeometry.position = - vViewPosition;\\ngeometry.normal = normal;\\ngeometry.viewDir = normalize( vViewPosition );\\nIncidentLight directLight;\\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\\n\\tPointLight pointLight;\\n\\t#pragma unroll_loop\\n\\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\\n\\t\\tpointLight = pointLights[ i ];\\n\\t\\tgetPointDirectLightIrradiance( pointLight, geometry, directLight );\\n\\t\\t#ifdef USE_SHADOWMAP\\n\\t\\tdirectLight.color *= all( bvec2( pointLight.shadow, directLight.visible ) ) ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\\n\\t\\t#endif\\n\\t\\tRE_Direct( directLight, geometry, material, reflectedLight );\\n\\t}\\n#endif\\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\\n\\tSpotLight spotLight;\\n\\t#pragma unroll_loop\\n\\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\\n\\t\\tspotLight = spotLights[ i ];\\n\\t\\tgetSpotDirectLightIrradiance( spotLight, geometry, directLight );\\n\\t\\t#ifdef USE_SHADOWMAP\\n\\t\\tdirectLight.color *= all( bvec2( spotLight.shadow, directLight.visible ) ) ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\\n\\t\\t#endif\\n\\t\\tRE_Direct( directLight, geometry, material, reflectedLight );\\n\\t}\\n#endif\\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\\n\\tDirectionalLight directionalLight;\\n\\t#pragma unroll_loop\\n\\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\\n\\t\\tdirectionalLight = directionalLights[ i ];\\n\\t\\tgetDirectionalDirectLightIrradiance( directionalLight, geometry, directLight );\\n\\t\\t#ifdef USE_SHADOWMAP\\n\\t\\tdirectLight.color *= all( bvec2( directionalLight.shadow, directLight.visible ) ) ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\\n\\t\\t#endif\\n\\t\\tRE_Direct( directLight, geometry, material, reflectedLight );\\n\\t}\\n#endif\\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\\n\\tRectAreaLight rectAreaLight;\\n\\t#pragma unroll_loop\\n\\tfor ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\\n\\t\\trectAreaLight = rectAreaLights[ i ];\\n\\t\\tRE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );\\n\\t}\\n#endif\\n#if defined( RE_IndirectDiffuse )\\n\\tvec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\\n\\t#if ( NUM_HEMI_LIGHTS > 0 )\\n\\t\\t#pragma unroll_loop\\n\\t\\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\\n\\t\\t\\tirradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\\n\\t\\t}\\n\\t#endif\\n#endif\\n#if defined( RE_IndirectSpecular )\\n\\tvec3 radiance = vec3( 0.0 );\\n\\tvec3 clearCoatRadiance = vec3( 0.0 );\\n#endif\"; var lights_fragment_maps = \"#if defined( RE_IndirectDiffuse )\\n\\t#ifdef USE_LIGHTMAP\\n\\t\\tvec3 lightMapIrradiance = texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\\n\\t\\t#ifndef PHYSICALLY_CORRECT_LIGHTS\\n\\t\\t\\tlightMapIrradiance *= PI;\\n\\t\\t#endif\\n\\t\\tirradiance += lightMapIrradiance;\\n\\t#endif\\n\\t#if defined( USE_ENVMAP ) && defined( PHYSICAL ) && defined( ENVMAP_TYPE_CUBE_UV )\\n\\t\\tirradiance += getLightProbeIndirectIrradiance( geometry, maxMipLevel );\\n\\t#endif\\n#endif\\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\\n\\tradiance += getLightProbeIndirectRadiance( geometry, Material_BlinnShininessExponent( material ), maxMipLevel );\\n\\t#ifndef STANDARD\\n\\t\\tclearCoatRadiance += getLightProbeIndirectRadiance( geometry, Material_ClearCoat_BlinnShininessExponent( material ), maxMipLevel );\\n\\t#endif\\n#endif\"; var lights_fragment_end = \"#if defined( RE_IndirectDiffuse )\\n\\tRE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\\n#endif\\n#if defined( RE_IndirectSpecular )\\n\\tRE_IndirectSpecular( radiance, irradiance, clearCoatRadiance, geometry, material, reflectedLight );\\n#endif\"; var logdepthbuf_fragment = \"#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\\n\\tgl_FragDepthEXT = log2( vFragDepth ) * logDepthBufFC * 0.5;\\n#endif\"; var logdepthbuf_pars_fragment = \"#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\\n\\tuniform float logDepthBufFC;\\n\\tvarying float vFragDepth;\\n#endif\"; var logdepthbuf_pars_vertex = \"#ifdef USE_LOGDEPTHBUF\\n\\t#ifdef USE_LOGDEPTHBUF_EXT\\n\\t\\tvarying float vFragDepth;\\n\\t#else\\n\\t\\tuniform float logDepthBufFC;\\n\\t#endif\\n#endif\"; var logdepthbuf_vertex = \"#ifdef USE_LOGDEPTHBUF\\n\\t#ifdef USE_LOGDEPTHBUF_EXT\\n\\t\\tvFragDepth = 1.0 + gl_Position.w;\\n\\t#else\\n\\t\\tgl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;\\n\\t\\tgl_Position.z *= gl_Position.w;\\n\\t#endif\\n#endif\"; var map_fragment = \"#ifdef USE_MAP\\n\\tvec4 texelColor = texture2D( map, vUv );\\n\\ttexelColor = mapTexelToLinear( texelColor );\\n\\tdiffuseColor *= texelColor;\\n#endif\"; var map_pars_fragment = \"#ifdef USE_MAP\\n\\tuniform sampler2D map;\\n#endif\"; var map_particle_fragment = \"#ifdef USE_MAP\\n\\tvec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;\\n\\tvec4 mapTexel = texture2D( map, uv );\\n\\tdiffuseColor *= mapTexelToLinear( mapTexel );\\n#endif\"; var map_particle_pars_fragment = \"#ifdef USE_MAP\\n\\tuniform mat3 uvTransform;\\n\\tuniform sampler2D map;\\n#endif\"; var metalnessmap_fragment = \"float metalnessFactor = metalness;\\n#ifdef USE_METALNESSMAP\\n\\tvec4 texelMetalness = texture2D( metalnessMap, vUv );\\n\\tmetalnessFactor *= texelMetalness.b;\\n#endif\"; var metalnessmap_pars_fragment = \"#ifdef USE_METALNESSMAP\\n\\tuniform sampler2D metalnessMap;\\n#endif\"; var morphnormal_vertex = \"#ifdef USE_MORPHNORMALS\\n\\tobjectNormal += ( morphNormal0 - normal ) * morphTargetInfluences[ 0 ];\\n\\tobjectNormal += ( morphNormal1 - normal ) * morphTargetInfluences[ 1 ];\\n\\tobjectNormal += ( morphNormal2 - normal ) * morphTargetInfluences[ 2 ];\\n\\tobjectNormal += ( morphNormal3 - normal ) * morphTargetInfluences[ 3 ];\\n#endif\"; var morphtarget_pars_vertex = \"#ifdef USE_MORPHTARGETS\\n\\t#ifndef USE_MORPHNORMALS\\n\\tuniform float morphTargetInfluences[ 8 ];\\n\\t#else\\n\\tuniform float morphTargetInfluences[ 4 ];\\n\\t#endif\\n#endif\"; var morphtarget_vertex = \"#ifdef USE_MORPHTARGETS\\n\\ttransformed += ( morphTarget0 - position ) * morphTargetInfluences[ 0 ];\\n\\ttransformed += ( morphTarget1 - position ) * morphTargetInfluences[ 1 ];\\n\\ttransformed += ( morphTarget2 - position ) * morphTargetInfluences[ 2 ];\\n\\ttransformed += ( morphTarget3 - position ) * morphTargetInfluences[ 3 ];\\n\\t#ifndef USE_MORPHNORMALS\\n\\ttransformed += ( morphTarget4 - position ) * morphTargetInfluences[ 4 ];\\n\\ttransformed += ( morphTarget5 - position ) * morphTargetInfluences[ 5 ];\\n\\ttransformed += ( morphTarget6 - position ) * morphTargetInfluences[ 6 ];\\n\\ttransformed += ( morphTarget7 - position ) * morphTargetInfluences[ 7 ];\\n\\t#endif\\n#endif\"; var normal_fragment_begin = \"#ifdef FLAT_SHADED\\n\\tvec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );\\n\\tvec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );\\n\\tvec3 normal = normalize( cross( fdx, fdy ) );\\n#else\\n\\tvec3 normal = normalize( vNormal );\\n\\t#ifdef DOUBLE_SIDED\\n\\t\\tnormal = normal * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\\n\\t#endif\\n#endif\"; var normal_fragment_maps = \"#ifdef USE_NORMALMAP\\n\\t#ifdef OBJECTSPACE_NORMALMAP\\n\\t\\tnormal = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\\n\\t\\t#ifdef FLIP_SIDED\\n\\t\\t\\tnormal = - normal;\\n\\t\\t#endif\\n\\t\\t#ifdef DOUBLE_SIDED\\n\\t\\t\\tnormal = normal * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\\n\\t\\t#endif\\n\\t\\tnormal = normalize( normalMatrix * normal );\\n\\t#else\\n\\t\\tnormal = perturbNormal2Arb( -vViewPosition, normal );\\n\\t#endif\\n#elif defined( USE_BUMPMAP )\\n\\tnormal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd() );\\n#endif\"; var normalmap_pars_fragment = \"#ifdef USE_NORMALMAP\\n\\tuniform sampler2D normalMap;\\n\\tuniform vec2 normalScale;\\n\\t#ifdef OBJECTSPACE_NORMALMAP\\n\\t\\tuniform mat3 normalMatrix;\\n\\t#else\\n\\t\\tvec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm ) {\\n\\t\\t\\tvec3 q0 = vec3( dFdx( eye_pos.x ), dFdx( eye_pos.y ), dFdx( eye_pos.z ) );\\n\\t\\t\\tvec3 q1 = vec3( dFdy( eye_pos.x ), dFdy( eye_pos.y ), dFdy( eye_pos.z ) );\\n\\t\\t\\tvec2 st0 = dFdx( vUv.st );\\n\\t\\t\\tvec2 st1 = dFdy( vUv.st );\\n\\t\\t\\tfloat scale = sign( st1.t * st0.s - st0.t * st1.s );\\n\\t\\t\\tvec3 S = normalize( ( q0 * st1.t - q1 * st0.t ) * scale );\\n\\t\\t\\tvec3 T = normalize( ( - q0 * st1.s + q1 * st0.s ) * scale );\\n\\t\\t\\tvec3 N = normalize( surf_norm );\\n\\t\\t\\tmat3 tsn = mat3( S, T, N );\\n\\t\\t\\tvec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\\n\\t\\t\\tmapN.xy *= normalScale;\\n\\t\\t\\tmapN.xy *= ( float( gl_FrontFacing ) * 2.0 - 1.0 );\\n\\t\\t\\treturn normalize( tsn * mapN );\\n\\t\\t}\\n\\t#endif\\n#endif\"; var packing = \"vec3 packNormalToRGB( const in vec3 normal ) {\\n\\treturn normalize( normal ) * 0.5 + 0.5;\\n}\\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\\n\\treturn 2.0 * rgb.xyz - 1.0;\\n}\\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );\\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\\nconst float ShiftRight8 = 1. / 256.;\\nvec4 packDepthToRGBA( const in float v ) {\\n\\tvec4 r = vec4( fract( v * PackFactors ), v );\\n\\tr.yzw -= r.xyz * ShiftRight8;\\treturn r * PackUpscale;\\n}\\nfloat unpackRGBAToDepth( const in vec4 v ) {\\n\\treturn dot( v, UnpackFactors );\\n}\\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\\n\\treturn ( viewZ + near ) / ( near - far );\\n}\\nfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\\n\\treturn linearClipZ * ( near - far ) - near;\\n}\\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\\n\\treturn (( near + viewZ ) * far ) / (( far - near ) * viewZ );\\n}\\nfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\\n\\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\\n}\"; var premultiplied_alpha_fragment = \"#ifdef PREMULTIPLIED_ALPHA\\n\\tgl_FragColor.rgb *= gl_FragColor.a;\\n#endif\"; var project_vertex = \"vec4 mvPosition = modelViewMatrix * vec4( transformed, 1.0 );\\ngl_Position = projectionMatrix * mvPosition;\"; var dithering_fragment = \"#if defined( DITHERING )\\n\\tgl_FragColor.rgb = dithering( gl_FragColor.rgb );\\n#endif\"; var dithering_pars_fragment = \"#if defined( DITHERING )\\n\\tvec3 dithering( vec3 color ) {\\n\\t\\tfloat grid_position = rand( gl_FragCoord.xy );\\n\\t\\tvec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\\n\\t\\tdither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\\n\\t\\treturn color + dither_shift_RGB;\\n\\t}\\n#endif\"; var roughnessmap_fragment = \"float roughnessFactor = roughness;\\n#ifdef USE_ROUGHNESSMAP\\n\\tvec4 texelRoughness = texture2D( roughnessMap, vUv );\\n\\troughnessFactor *= texelRoughness.g;\\n#endif\"; var roughnessmap_pars_fragment = \"#ifdef USE_ROUGHNESSMAP\\n\\tuniform sampler2D roughnessMap;\\n#endif\"; var shadowmap_pars_fragment = \"#ifdef USE_SHADOWMAP\\n\\t#if NUM_DIR_LIGHTS > 0\\n\\t\\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHTS ];\\n\\t\\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\\n\\t#endif\\n\\t#if NUM_SPOT_LIGHTS > 0\\n\\t\\tuniform sampler2D spotShadowMap[ NUM_SPOT_LIGHTS ];\\n\\t\\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHTS ];\\n\\t#endif\\n\\t#if NUM_POINT_LIGHTS > 0\\n\\t\\tuniform sampler2D pointShadowMap[ NUM_POINT_LIGHTS ];\\n\\t\\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHTS ];\\n\\t#endif\\n\\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\\n\\t\\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\\n\\t}\\n\\tfloat texture2DShadowLerp( sampler2D depths, vec2 size, vec2 uv, float compare ) {\\n\\t\\tconst vec2 offset = vec2( 0.0, 1.0 );\\n\\t\\tvec2 texelSize = vec2( 1.0 ) / size;\\n\\t\\tvec2 centroidUV = floor( uv * size + 0.5 ) / size;\\n\\t\\tfloat lb = texture2DCompare( depths, centroidUV + texelSize * offset.xx, compare );\\n\\t\\tfloat lt = texture2DCompare( depths, centroidUV + texelSize * offset.xy, compare );\\n\\t\\tfloat rb = texture2DCompare( depths, centroidUV + texelSize * offset.yx, compare );\\n\\t\\tfloat rt = texture2DCompare( depths, centroidUV + texelSize * offset.yy, compare );\\n\\t\\tvec2 f = fract( uv * size + 0.5 );\\n\\t\\tfloat a = mix( lb, lt, f.y );\\n\\t\\tfloat b = mix( rb, rt, f.y );\\n\\t\\tfloat c = mix( a, b, f.x );\\n\\t\\treturn c;\\n\\t}\\n\\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\\n\\t\\tfloat shadow = 1.0;\\n\\t\\tshadowCoord.xyz /= shadowCoord.w;\\n\\t\\tshadowCoord.z += shadowBias;\\n\\t\\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x = 0.0, shadowCoord.y 0.0 )\\n\\t\\t\\t\\tplanar.x = 4.0 - v.x;\\n\\t\\t} else if ( absV.x >= almostOne ) {\\n\\t\\t\\tfloat signX = sign( v.x );\\n\\t\\t\\tplanar.x = v.z * signX + 2.0 * signX;\\n\\t\\t} else if ( absV.y >= almostOne ) {\\n\\t\\t\\tfloat signY = sign( v.y );\\n\\t\\t\\tplanar.x = v.x + 2.0 * signY + 2.0;\\n\\t\\t\\tplanar.y = v.z * signY - 2.0;\\n\\t\\t}\\n\\t\\treturn vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\\n\\t}\\n\\tfloat getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\\n\\t\\tvec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\\n\\t\\tvec3 lightToPosition = shadowCoord.xyz;\\n\\t\\tfloat dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );\\t\\tdp += shadowBias;\\n\\t\\tvec3 bd3D = normalize( lightToPosition );\\n\\t\\t#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT )\\n\\t\\t\\tvec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\\n\\t\\t\\treturn (\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\\n\\t\\t\\t) * ( 1.0 / 9.0 );\\n\\t\\t#else\\n\\t\\t\\treturn texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\\n\\t\\t#endif\\n\\t}\\n#endif\"; var shadowmap_pars_vertex = \"#ifdef USE_SHADOWMAP\\n\\t#if NUM_DIR_LIGHTS > 0\\n\\t\\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHTS ];\\n\\t\\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\\n\\t#endif\\n\\t#if NUM_SPOT_LIGHTS > 0\\n\\t\\tuniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHTS ];\\n\\t\\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHTS ];\\n\\t#endif\\n\\t#if NUM_POINT_LIGHTS > 0\\n\\t\\tuniform mat4 pointShadowMatrix[ NUM_POINT_LIGHTS ];\\n\\t\\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHTS ];\\n\\t#endif\\n#endif\"; var shadowmap_vertex = \"#ifdef USE_SHADOWMAP\\n\\t#if NUM_DIR_LIGHTS > 0\\n\\t#pragma unroll_loop\\n\\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\\n\\t\\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * worldPosition;\\n\\t}\\n\\t#endif\\n\\t#if NUM_SPOT_LIGHTS > 0\\n\\t#pragma unroll_loop\\n\\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\\n\\t\\tvSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * worldPosition;\\n\\t}\\n\\t#endif\\n\\t#if NUM_POINT_LIGHTS > 0\\n\\t#pragma unroll_loop\\n\\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\\n\\t\\tvPointShadowCoord[ i ] = pointShadowMatrix[ i ] * worldPosition;\\n\\t}\\n\\t#endif\\n#endif\"; var shadowmask_pars_fragment = \"float getShadowMask() {\\n\\tfloat shadow = 1.0;\\n\\t#ifdef USE_SHADOWMAP\\n\\t#if NUM_DIR_LIGHTS > 0\\n\\tDirectionalLight directionalLight;\\n\\t#pragma unroll_loop\\n\\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\\n\\t\\tdirectionalLight = directionalLights[ i ];\\n\\t\\tshadow *= bool( directionalLight.shadow ) ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\\n\\t}\\n\\t#endif\\n\\t#if NUM_SPOT_LIGHTS > 0\\n\\tSpotLight spotLight;\\n\\t#pragma unroll_loop\\n\\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\\n\\t\\tspotLight = spotLights[ i ];\\n\\t\\tshadow *= bool( spotLight.shadow ) ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\\n\\t}\\n\\t#endif\\n\\t#if NUM_POINT_LIGHTS > 0\\n\\tPointLight pointLight;\\n\\t#pragma unroll_loop\\n\\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\\n\\t\\tpointLight = pointLights[ i ];\\n\\t\\tshadow *= bool( pointLight.shadow ) ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\\n\\t}\\n\\t#endif\\n\\t#endif\\n\\treturn shadow;\\n}\"; var skinbase_vertex = \"#ifdef USE_SKINNING\\n\\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\\n\\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\\n\\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\\n\\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\\n#endif\"; var skinning_pars_vertex = \"#ifdef USE_SKINNING\\n\\tuniform mat4 bindMatrix;\\n\\tuniform mat4 bindMatrixInverse;\\n\\t#ifdef BONE_TEXTURE\\n\\t\\tuniform sampler2D boneTexture;\\n\\t\\tuniform int boneTextureSize;\\n\\t\\tmat4 getBoneMatrix( const in float i ) {\\n\\t\\t\\tfloat j = i * 4.0;\\n\\t\\t\\tfloat x = mod( j, float( boneTextureSize ) );\\n\\t\\t\\tfloat y = floor( j / float( boneTextureSize ) );\\n\\t\\t\\tfloat dx = 1.0 / float( boneTextureSize );\\n\\t\\t\\tfloat dy = 1.0 / float( boneTextureSize );\\n\\t\\t\\ty = dy * ( y + 0.5 );\\n\\t\\t\\tvec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\\n\\t\\t\\tvec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\\n\\t\\t\\tvec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\\n\\t\\t\\tvec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\\n\\t\\t\\tmat4 bone = mat4( v1, v2, v3, v4 );\\n\\t\\t\\treturn bone;\\n\\t\\t}\\n\\t#else\\n\\t\\tuniform mat4 boneMatrices[ MAX_BONES ];\\n\\t\\tmat4 getBoneMatrix( const in float i ) {\\n\\t\\t\\tmat4 bone = boneMatrices[ int(i) ];\\n\\t\\t\\treturn bone;\\n\\t\\t}\\n\\t#endif\\n#endif\"; var skinning_vertex = \"#ifdef USE_SKINNING\\n\\tvec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\\n\\tvec4 skinned = vec4( 0.0 );\\n\\tskinned += boneMatX * skinVertex * skinWeight.x;\\n\\tskinned += boneMatY * skinVertex * skinWeight.y;\\n\\tskinned += boneMatZ * skinVertex * skinWeight.z;\\n\\tskinned += boneMatW * skinVertex * skinWeight.w;\\n\\ttransformed = ( bindMatrixInverse * skinned ).xyz;\\n#endif\"; var skinnormal_vertex = \"#ifdef USE_SKINNING\\n\\tmat4 skinMatrix = mat4( 0.0 );\\n\\tskinMatrix += skinWeight.x * boneMatX;\\n\\tskinMatrix += skinWeight.y * boneMatY;\\n\\tskinMatrix += skinWeight.z * boneMatZ;\\n\\tskinMatrix += skinWeight.w * boneMatW;\\n\\tskinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;\\n\\tobjectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\\n#endif\"; var specularmap_fragment = \"float specularStrength;\\n#ifdef USE_SPECULARMAP\\n\\tvec4 texelSpecular = texture2D( specularMap, vUv );\\n\\tspecularStrength = texelSpecular.r;\\n#else\\n\\tspecularStrength = 1.0;\\n#endif\"; var specularmap_pars_fragment = \"#ifdef USE_SPECULARMAP\\n\\tuniform sampler2D specularMap;\\n#endif\"; var tonemapping_fragment = \"#if defined( TONE_MAPPING )\\n\\tgl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\\n#endif\"; var tonemapping_pars_fragment = \"#ifndef saturate\\n\\t#define saturate(a) clamp( a, 0.0, 1.0 )\\n#endif\\nuniform float toneMappingExposure;\\nuniform float toneMappingWhitePoint;\\nvec3 LinearToneMapping( vec3 color ) {\\n\\treturn toneMappingExposure * color;\\n}\\nvec3 ReinhardToneMapping( vec3 color ) {\\n\\tcolor *= toneMappingExposure;\\n\\treturn saturate( color / ( vec3( 1.0 ) + color ) );\\n}\\n#define Uncharted2Helper( x ) max( ( ( x * ( 0.15 * x + 0.10 * 0.50 ) + 0.20 * 0.02 ) / ( x * ( 0.15 * x + 0.50 ) + 0.20 * 0.30 ) ) - 0.02 / 0.30, vec3( 0.0 ) )\\nvec3 Uncharted2ToneMapping( vec3 color ) {\\n\\tcolor *= toneMappingExposure;\\n\\treturn saturate( Uncharted2Helper( color ) / Uncharted2Helper( vec3( toneMappingWhitePoint ) ) );\\n}\\nvec3 OptimizedCineonToneMapping( vec3 color ) {\\n\\tcolor *= toneMappingExposure;\\n\\tcolor = max( vec3( 0.0 ), color - 0.004 );\\n\\treturn pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\\n}\\nvec3 ACESFilmicToneMapping( vec3 color ) {\\n\\tcolor *= toneMappingExposure;\\n\\treturn saturate( ( color * ( 2.51 * color + 0.03 ) ) / ( color * ( 2.43 * color + 0.59 ) + 0.14 ) );\\n}\"; var uv_pars_fragment = \"#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\\n\\tvarying vec2 vUv;\\n#endif\"; var uv_pars_vertex = \"#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\\n\\tvarying vec2 vUv;\\n\\tuniform mat3 uvTransform;\\n#endif\"; var uv_vertex = \"#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\\n\\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\\n#endif\"; var uv2_pars_fragment = \"#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\\n\\tvarying vec2 vUv2;\\n#endif\"; var uv2_pars_vertex = \"#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\\n\\tattribute vec2 uv2;\\n\\tvarying vec2 vUv2;\\n#endif\"; var uv2_vertex = \"#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\\n\\tvUv2 = uv2;\\n#endif\"; var worldpos_vertex = \"#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP )\\n\\tvec4 worldPosition = modelMatrix * vec4( transformed, 1.0 );\\n#endif\"; var background_frag = \"uniform sampler2D t2D;\\nvarying vec2 vUv;\\nvoid main() {\\n\\tvec4 texColor = texture2D( t2D, vUv );\\n\\tgl_FragColor = mapTexelToLinear( texColor );\\n\\t#include \\n\\t#include \\n}\"; var background_vert = \"varying vec2 vUv;\\nuniform mat3 uvTransform;\\nvoid main() {\\n\\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\\n\\tgl_Position = vec4( position.xy, 1.0, 1.0 );\\n}\"; var cube_frag = \"uniform samplerCube tCube;\\nuniform float tFlip;\\nuniform float opacity;\\nvarying vec3 vWorldDirection;\\nvoid main() {\\n\\tvec4 texColor = textureCube( tCube, vec3( tFlip * vWorldDirection.x, vWorldDirection.yz ) );\\n\\tgl_FragColor = mapTexelToLinear( texColor );\\n\\tgl_FragColor.a *= opacity;\\n\\t#include \\n\\t#include \\n}\"; var cube_vert = \"varying vec3 vWorldDirection;\\n#include \\nvoid main() {\\n\\tvWorldDirection = transformDirection( position, modelMatrix );\\n\\t#include \\n\\t#include \\n\\tgl_Position.z = gl_Position.w;\\n}\"; var depth_frag = \"#if DEPTH_PACKING == 3200\\n\\tuniform float opacity;\\n#endif\\n#include \\n#include \\n#include \\n#include \\n#include \\n#include \\n#include \\nvoid main() {\\n\\t#include \\n\\tvec4 diffuseColor = vec4( 1.0 );\\n\\t#if DEPTH_PACKING == 3200\\n\\t\\tdiffuseColor.a = opacity;\\n\\t#endif\\n\\t#include \\n\\t#include \\n\\t#include \\n\\t#include \\n\\t#if DEPTH_PACKING == 3200\\n\\t\\tgl_FragColor = vec4( vec3( 1.0 - gl_FragCoord.z ), opacity );\\n\\t#elif DEPTH_PACKING == 3201\\n\\t\\tgl_FragColor = packDepthToRGBA( gl_FragCoord.z );\\n\\t#endif\\n}\"; var depth_vert = \"#include \\n#include \\n#include \\n#include \\n#include \\n#include \\n#include \\nvoid main() {\\n\\t#include \\n\\t#include \\n\\t#ifdef USE_DISPLACEMENTMAP\\n\\t\\t#include \\n\\t\\t#include \\n\\t\\t#include \\n\\t#endif\\n\\t#include \\n\\t#include \\n\\t#include \\n\\t#include \\n\\t#include \\n\\t#include \\n\\t#include \\n}\"; var distanceRGBA_frag = \"#define DISTANCE\\nuniform vec3 referencePosition;\\nuniform float nearDistance;\\nuniform float farDistance;\\nvarying vec3 vWorldPosition;\\n#include \\n#include \\n#include \\n#include \\n#include \\n#include \\nvoid main () {\\n\\t#include \\n\\tvec4 diffuseColor = vec4( 1.0 );\\n\\t#include \\n\\t#include \\n\\t#include \\n\\tfloat dist = length( vWorldPosition - referencePosition );\\n\\tdist = ( dist - nearDistance ) / ( farDistance - nearDistance );\\n\\tdist = saturate( dist );\\n\\tgl_FragColor = packDepthToRGBA( dist );\\n}\"; var distanceRGBA_vert = \"#define DISTANCE\\nvarying vec3 vWorldPosition;\\n#include \\n#include \\n#include \\n#include \\n#include \\n#include \\nvoid main() {\\n\\t#include \\n\\t#include \\n\\t#ifdef USE_DISPLACEMENTMAP\\n\\t\\t#include \\n\\t\\t#include \\n\\t\\t#include \\n\\t#endif\\n\\t#include \\n\\t#include \\n\\t#include \\n\\t#include \\n\\t#include \\n\\t#include \\n\\t#include \\n\\tvWorldPosition = worldPosition.xyz;\\n}\"; var equirect_frag = \"uniform sampler2D tEquirect;\\nvarying vec3 vWorldDirection;\\n#include \\nvoid main() {\\n\\tvec3 direction = normalize( vWorldDirection );\\n\\tvec2 sampleUV;\\n\\tsampleUV.y = asin( clamp( direction.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\\n\\tsampleUV.x = atan( direction.z, direction.x ) * RECIPROCAL_PI2 + 0.5;\\n\\tvec4 texColor = texture2D( tEquirect, sampleUV );\\n\\tgl_FragColor = mapTexelToLinear( texColor );\\n\\t#include \\n\\t#include \\n}\"; var equirect_vert = \"varying vec3 vWorldDirection;\\n#include \\nvoid main() {\\n\\tvWorldDirection = transformDirection( position, modelMatrix );\\n\\t#include \\n\\t#include \\n}\"; var linedashed_frag = \"uniform vec3 diffuse;\\nuniform float opacity;\\nuniform float dashSize;\\nuniform float totalSize;\\nvarying float vLineDistance;\\n#include \\n#include \\n#include \\n#include \\n#include \\nvoid main() {\\n\\t#include \\n\\tif ( mod( vLineDistance, totalSize ) > dashSize ) {\\n\\t\\tdiscard;\\n\\t}\\n\\tvec3 outgoingLight = vec3( 0.0 );\\n\\tvec4 diffuseColor = vec4( diffuse, opacity );\\n\\t#include \\n\\t#include \\n\\toutgoingLight = diffuseColor.rgb;\\n\\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\\n\\t#include \\n\\t#include \\n\\t#include \\n\\t#include \\n}\"; var linedashed_vert = \"uniform float scale;\\nattribute float lineDistance;\\nvarying float vLineDistance;\\n#include \\n#include \\n#include \\n#include \\n#include \\nvoid main() {\\n\\t#include \\n\\tvLineDistance = scale * lineDistance;\\n\\tvec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\\n\\tgl_Position = projectionMatrix * mvPosition;\\n\\t#include \\n\\t#include \\n\\t#include \\n}\"; var meshbasic_frag = \"uniform vec3 diffuse;\\nuniform float opacity;\\n#ifndef FLAT_SHADED\\n\\tvarying vec3 vNormal;\\n#endif\\n#include \\n#include \\n#include \\n#include \\n#include \\n#include \\n#include \\n#include \\n#include \\n#include \\n#include \\n#include \\n#include \\nvoid main() {\\n\\t#include \\n\\tvec4 diffuseColor = vec4( diffuse, opacity );\\n\\t#include \\n\\t#include \\n\\t#include \\n\\t#include \\n\\t#include \\n\\t#include \\n\\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\\n\\t#ifdef USE_LIGHTMAP\\n\\t\\treflectedLight.indirectDiffuse += texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\\n\\t#else\\n\\t\\treflectedLight.indirectDiffuse += vec3( 1.0 );\\n\\t#endif\\n\\t#include \\n\\treflectedLight.indirectDiffuse *= diffuseColor.rgb;\\n\\tvec3 outgoingLight = reflectedLight.indirectDiffuse;\\n\\t#include \\n\\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\\n\\t#include \\n\\t#include \\n\\t#include \\n\\t#include \\n}\"; var meshbasic_vert = \"#include \\n#include \\n#include \\n#include \\n#include \\n#include \\n#include \\n#include \\n#include \\n#include \\nvoid main() {\\n\\t#include \\n\\t#include \\n\\t#include \\n\\t#include \\n\\t#ifdef USE_ENVMAP\\n\\t#include \\n\\t#include \\n\\t#include \\n\\t#include \\n\\t#endif\\n\\t#include \\n\\t#include \\n\\t#include \\n\\t#include \\n\\t#include \\n\\t#include \\n\\t#include \\n\\t#include \\n\\t#include \\n}\"; var meshlambert_frag = \"uniform vec3 diffuse;\\nuniform vec3 emissive;\\nuniform float opacity;\\nvarying vec3 vLightFront;\\nvarying vec3 vIndirectFront;\\n#ifdef DOUBLE_SIDED\\n\\tvarying vec3 vLightBack;\\n\\tvarying vec3 vIndirectBack;\\n#endif\\n#include \\n#include \\n#include \\n#include \\n#include \\n#include \\n#include \\n#include \\n#include \\n#include \\n#include \\n#include \\n#include \\n#include \\n#include \\n#include \\n#include \\n#include \\n#include \\n#include \\nvoid main() {\\n\\t#include \\n\\tvec4 diffuseColor = vec4( diffuse, opacity );\\n\\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\\n\\tvec3 totalEmissiveRadiance = emissive;\\n\\t#include \\n\\t#include \\n\\t#include \\n\\t#include \\n\\t#include \\n\\t#include \\n\\t#include \\n\\treflectedLight.indirectDiffuse = getAmbientLightIrradiance( ambientLightColor );\\n\\t#ifdef DOUBLE_SIDED\\n\\t\\treflectedLight.indirectDiffuse += ( gl_FrontFacing ) ? vIndirectFront : vIndirectBack;\\n\\t#else\\n\\t\\treflectedLight.indirectDiffuse += vIndirectFront;\\n\\t#endif\\n\\t#include \\n\\treflectedLight.indirectDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb );\\n\\t#ifdef DOUBLE_SIDED\\n\\t\\treflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;\\n\\t#else\\n\\t\\treflectedLight.directDiffuse = vLightFront;\\n\\t#endif\\n\\treflectedLight.directDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb ) * getShadowMask();\\n\\t#include \\n\\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\\n\\t#include \\n\\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\\n\\t#include \\n\\t#include \\n\\t#include \\n\\t#include \\n\\t#include \\n}\"; var meshlambert_vert = \"#define LAMBERT\\nvarying vec3 vLightFront;\\nvarying vec3 vIndirectFront;\\n#ifdef DOUBLE_SIDED\\n\\tvarying vec3 vLightBack;\\n\\tvarying vec3 vIndirectBack;\\n#endif\\n#include \\n#include \\n#include \\n#include \\n#include \\n#include \\n#include \\n#include \\n#include \\n#include \\n#include \\n#include \\n#include \\nvoid main() {\\n\\t#include \\n\\t#include \\n\\t#include \\n\\t#include \\n\\t#include \\n\\t#include \\n\\t#include \\n\\t#include \\n\\t#include \\n\\t#include \\n\\t#include \\n\\t#include \\n\\t#include \\n\\t#include \\n\\t#include \\n\\t#include \\n\\t#include \\n\\t#include \\n\\t#include \\n}\"; var meshmatcap_frag = \"#define MATCAP\\nuniform vec3 diffuse;\\nuniform float opacity;\\nuniform sampler2D matcap;\\nvarying vec3 vViewPosition;\\n#ifndef FLAT_SHADED\\n\\tvarying vec3 vNormal;\\n#endif\\n#include \\n#include \\n#include \\n#include \\n#include \\n#include \\n#include \\n#include \\n#include \\nvoid main() {\\n\\t#include \\n\\tvec4 diffuseColor = vec4( diffuse, opacity );\\n\\t#include \\n\\t#include \\n\\t#include \\n\\t#include \\n\\t#include \\n\\t#include \\n\\tvec3 viewDir = normalize( vViewPosition );\\n\\tvec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );\\n\\tvec3 y = cross( viewDir, x );\\n\\tvec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;\\n\\t#ifdef USE_MATCAP\\n\\t\\tvec4 matcapColor = texture2D( matcap, uv );\\n\\t\\tmatcapColor = matcapTexelToLinear( matcapColor );\\n\\t#else\\n\\t\\tvec4 matcapColor = vec4( 1.0 );\\n\\t#endif\\n\\tvec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;\\n\\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\\n\\t#include \\n\\t#include \\n\\t#include \\n\\t#include \\n}\"; var meshmatcap_vert = \"#define MATCAP\\nvarying vec3 vViewPosition;\\n#ifndef FLAT_SHADED\\n\\tvarying vec3 vNormal;\\n#endif\\n#include \\n#include \\n#include \\n#include \\n#include \\n#include \\n#include \\n#include \\nvoid main() {\\n\\t#include \\n\\t#include \\n\\t#include \\n\\t#include \\n\\t#include \\n\\t#include \\n\\t#ifndef FLAT_SHADED\\n\\t\\tvNormal = normalize( transformedNormal );\\n\\t#endif\\n\\t#include \\n\\t#include \\n\\t#include \\n\\t#include \\n\\t#include \\n\\t#include \\n\\t#include \\n\\t#include \\n\\tvViewPosition = - mvPosition.xyz;\\n}\"; var meshphong_frag = \"#define PHONG\\nuniform vec3 diffuse;\\nuniform vec3 emissive;\\nuniform vec3 specular;\\nuniform float shininess;\\nuniform float opacity;\\n#include \\n#include \\n#include \\n#include \\n#include \\n#include \\n#include \\n#include \\n#include \\n#include \\n#include \\n#include \\n#include \\n#include \\n#include \\n#include \\n#include \\n#include \\n#include \\n#include \\n#include \\n#include \\n#include \\nvoid main() {\\n\\t#include \\n\\tvec4 diffuseColor = vec4( diffuse, opacity );\\n\\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\\n\\tvec3 totalEmissiveRadiance = emissive;\\n\\t#include \\n\\t#include \\n\\t#include \\n\\t#include \\n\\t#include \\n\\t#include \\n\\t#include \\n\\t#include \\n\\t#include \\n\\t#include \\n\\t#include \\n\\t#include \\n\\t#include \\n\\t#include \\n\\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\\n\\t#include \\n\\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\\n\\t#include \\n\\t#include \\n\\t#include \\n\\t#include \\n\\t#include \\n}\"; var meshphong_vert = \"#define PHONG\\nvarying vec3 vViewPosition;\\n#ifndef FLAT_SHADED\\n\\tvarying vec3 vNormal;\\n#endif\\n#include \\n#include \\n#include \\n#include \\n#include \\n#include \\n#include \\n#include \\n#include \\n#include \\n#include \\n#include \\nvoid main() {\\n\\t#include \\n\\t#include \\n\\t#include \\n\\t#include \\n\\t#include \\n\\t#include \\n\\t#include \\n\\t#include \\n#ifndef FLAT_SHADED\\n\\tvNormal = normalize( transformedNormal );\\n#endif\\n\\t#include \\n\\t#include \\n\\t#include \\n\\t#include \\n\\t#include \\n\\t#include \\n\\t#include \\n\\tvViewPosition = - mvPosition.xyz;\\n\\t#include \\n\\t#include \\n\\t#include \\n\\t#include \\n}\"; var meshphysical_frag = \"#define PHYSICAL\\nuniform vec3 diffuse;\\nuniform vec3 emissive;\\nuniform float roughness;\\nuniform float metalness;\\nuniform float opacity;\\n#ifndef STANDARD\\n\\tuniform float clearCoat;\\n\\tuniform float clearCoatRoughness;\\n#endif\\nvarying vec3 vViewPosition;\\n#ifndef FLAT_SHADED\\n\\tvarying vec3 vNormal;\\n#endif\\n#include \\n#include \\n#include \\n#include \\n#include \\n#include \\n#include \\n#include \\n#include \\n#include \\n#include \\n#include \\n#include \\n#include \\n#include \\n#include \\n#include \\n#include \\n#include \\n#include \\n#include \\n#include \\n#include \\n#include \\n#include \\nvoid main() {\\n\\t#include \\n\\tvec4 diffuseColor = vec4( diffuse, opacity );\\n\\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\\n\\tvec3 totalEmissiveRadiance = emissive;\\n\\t#include \\n\\t#include \\n\\t#include \\n\\t#include \\n\\t#include \\n\\t#include \\n\\t#include \\n\\t#include \\n\\t#include \\n\\t#include \\n\\t#include \\n\\t#include \\n\\t#include \\n\\t#include \\n\\t#include \\n\\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\\n\\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\\n\\t#include \\n\\t#include \\n\\t#include \\n\\t#include \\n\\t#include \\n}\"; var meshphysical_vert = \"#define PHYSICAL\\nvarying vec3 vViewPosition;\\n#ifndef FLAT_SHADED\\n\\tvarying vec3 vNormal;\\n#endif\\n#include \\n#include \\n#include \\n#include \\n#include \\n#include \\n#include \\n#include \\n#include \\n#include \\n#include \\nvoid main() {\\n\\t#include \\n\\t#include \\n\\t#include \\n\\t#include \\n\\t#include \\n\\t#include \\n\\t#include \\n\\t#include \\n#ifndef FLAT_SHADED\\n\\tvNormal = normalize( transformedNormal );\\n#endif\\n\\t#include \\n\\t#include \\n\\t#include \\n\\t#include \\n\\t#include \\n\\t#include \\n\\t#include \\n\\tvViewPosition = - mvPosition.xyz;\\n\\t#include \\n\\t#include \\n\\t#include \\n}\"; var normal_frag = \"#define NORMAL\\nuniform float opacity;\\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || ( defined( USE_NORMALMAP ) && ! defined( OBJECTSPACE_NORMALMAP ) )\\n\\tvarying vec3 vViewPosition;\\n#endif\\n#ifndef FLAT_SHADED\\n\\tvarying vec3 vNormal;\\n#endif\\n#include \\n#include \\n#include \\n#include \\n#include \\nvoid main() {\\n\\t#include \\n\\t#include \\n\\t#include \\n\\tgl_FragColor = vec4( packNormalToRGB( normal ), opacity );\\n}\"; var normal_vert = \"#define NORMAL\\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || ( defined( USE_NORMALMAP ) && ! defined( OBJECTSPACE_NORMALMAP ) )\\n\\tvarying vec3 vViewPosition;\\n#endif\\n#ifndef FLAT_SHADED\\n\\tvarying vec3 vNormal;\\n#endif\\n#include \\n#include \\n#include \\n#include \\n#include \\nvoid main() {\\n\\t#include \\n\\t#include \\n\\t#include \\n\\t#include \\n\\t#include \\n\\t#include \\n#ifndef FLAT_SHADED\\n\\tvNormal = normalize( transformedNormal );\\n#endif\\n\\t#include \\n\\t#include \\n\\t#include \\n\\t#include \\n\\t#include \\n\\t#include \\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || ( defined( USE_NORMALMAP ) && ! defined( OBJECTSPACE_NORMALMAP ) )\\n\\tvViewPosition = - mvPosition.xyz;\\n#endif\\n}\"; var points_frag = \"uniform vec3 diffuse;\\nuniform float opacity;\\n#include \\n#include \\n#include \\n#include \\n#include \\n#include \\nvoid main() {\\n\\t#include \\n\\tvec3 outgoingLight = vec3( 0.0 );\\n\\tvec4 diffuseColor = vec4( diffuse, opacity );\\n\\t#include \\n\\t#include \\n\\t#include \\n\\t#include \\n\\toutgoingLight = diffuseColor.rgb;\\n\\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\\n\\t#include \\n\\t#include \\n\\t#include \\n\\t#include \\n}\"; var points_vert = \"uniform float size;\\nuniform float scale;\\n#include \\n#include \\n#include \\n#include \\n#include \\n#include \\nvoid main() {\\n\\t#include \\n\\t#include \\n\\t#include \\n\\t#include \\n\\tgl_PointSize = size;\\n\\t#ifdef USE_SIZEATTENUATION\\n\\t\\tbool isPerspective = ( projectionMatrix[ 2 ][ 3 ] == - 1.0 );\\n\\t\\tif ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );\\n\\t#endif\\n\\t#include \\n\\t#include \\n\\t#include \\n\\t#include \\n}\"; var shadow_frag = \"uniform vec3 color;\\nuniform float opacity;\\n#include \\n#include \\n#include \\n#include \\n#include \\n#include \\n#include \\nvoid main() {\\n\\tgl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );\\n\\t#include \\n}\"; var shadow_vert = \"#include \\n#include \\nvoid main() {\\n\\t#include \\n\\t#include \\n\\t#include \\n\\t#include \\n\\t#include \\n}\"; var sprite_frag = \"uniform vec3 diffuse;\\nuniform float opacity;\\n#include \\n#include \\n#include \\n#include \\n#include \\n#include \\nvoid main() {\\n\\t#include \\n\\tvec3 outgoingLight = vec3( 0.0 );\\n\\tvec4 diffuseColor = vec4( diffuse, opacity );\\n\\t#include \\n\\t#include \\n\\t#include \\n\\toutgoingLight = diffuseColor.rgb;\\n\\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\\n\\t#include \\n\\t#include \\n\\t#include \\n}\"; var sprite_vert = \"uniform float rotation;\\nuniform vec2 center;\\n#include \\n#include \\n#include \\n#include \\n#include \\nvoid main() {\\n\\t#include \\n\\tvec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );\\n\\tvec2 scale;\\n\\tscale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );\\n\\tscale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );\\n\\t#ifndef USE_SIZEATTENUATION\\n\\t\\tbool isPerspective = ( projectionMatrix[ 2 ][ 3 ] == - 1.0 );\\n\\t\\tif ( isPerspective ) scale *= - mvPosition.z;\\n\\t#endif\\n\\tvec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;\\n\\tvec2 rotatedPosition;\\n\\trotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\\n\\trotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\\n\\tmvPosition.xy += rotatedPosition;\\n\\tgl_Position = projectionMatrix * mvPosition;\\n\\t#include \\n\\t#include \\n\\t#include \\n}\"; var ShaderChunk = { alphamap_fragment: alphamap_fragment, alphamap_pars_fragment: alphamap_pars_fragment, alphatest_fragment: alphatest_fragment, aomap_fragment: aomap_fragment, aomap_pars_fragment: aomap_pars_fragment, begin_vertex: begin_vertex, beginnormal_vertex: beginnormal_vertex, bsdfs: bsdfs, bumpmap_pars_fragment: bumpmap_pars_fragment, clipping_planes_fragment: clipping_planes_fragment, clipping_planes_pars_fragment: clipping_planes_pars_fragment, clipping_planes_pars_vertex: clipping_planes_pars_vertex, clipping_planes_vertex: clipping_planes_vertex, color_fragment: color_fragment, color_pars_fragment: color_pars_fragment, color_pars_vertex: color_pars_vertex, color_vertex: color_vertex, common: common, cube_uv_reflection_fragment: cube_uv_reflection_fragment, defaultnormal_vertex: defaultnormal_vertex, displacementmap_pars_vertex: displacementmap_pars_vertex, displacementmap_vertex: displacementmap_vertex, emissivemap_fragment: emissivemap_fragment, emissivemap_pars_fragment: emissivemap_pars_fragment, encodings_fragment: encodings_fragment, encodings_pars_fragment: encodings_pars_fragment, envmap_fragment: envmap_fragment, envmap_pars_fragment: envmap_pars_fragment, envmap_pars_vertex: envmap_pars_vertex, envmap_physical_pars_fragment: envmap_physical_pars_fragment, envmap_vertex: envmap_vertex, fog_vertex: fog_vertex, fog_pars_vertex: fog_pars_vertex, fog_fragment: fog_fragment, fog_pars_fragment: fog_pars_fragment, gradientmap_pars_fragment: gradientmap_pars_fragment, lightmap_fragment: lightmap_fragment, lightmap_pars_fragment: lightmap_pars_fragment, lights_lambert_vertex: lights_lambert_vertex, lights_pars_begin: lights_pars_begin, lights_phong_fragment: lights_phong_fragment, lights_phong_pars_fragment: lights_phong_pars_fragment, lights_physical_fragment: lights_physical_fragment, lights_physical_pars_fragment: lights_physical_pars_fragment, lights_fragment_begin: lights_fragment_begin, lights_fragment_maps: lights_fragment_maps, lights_fragment_end: lights_fragment_end, logdepthbuf_fragment: logdepthbuf_fragment, logdepthbuf_pars_fragment: logdepthbuf_pars_fragment, logdepthbuf_pars_vertex: logdepthbuf_pars_vertex, logdepthbuf_vertex: logdepthbuf_vertex, map_fragment: map_fragment, map_pars_fragment: map_pars_fragment, map_particle_fragment: map_particle_fragment, map_particle_pars_fragment: map_particle_pars_fragment, metalnessmap_fragment: metalnessmap_fragment, metalnessmap_pars_fragment: metalnessmap_pars_fragment, morphnormal_vertex: morphnormal_vertex, morphtarget_pars_vertex: morphtarget_pars_vertex, morphtarget_vertex: morphtarget_vertex, normal_fragment_begin: normal_fragment_begin, normal_fragment_maps: normal_fragment_maps, normalmap_pars_fragment: normalmap_pars_fragment, packing: packing, premultiplied_alpha_fragment: premultiplied_alpha_fragment, project_vertex: project_vertex, dithering_fragment: dithering_fragment, dithering_pars_fragment: dithering_pars_fragment, roughnessmap_fragment: roughnessmap_fragment, roughnessmap_pars_fragment: roughnessmap_pars_fragment, shadowmap_pars_fragment: shadowmap_pars_fragment, shadowmap_pars_vertex: shadowmap_pars_vertex, shadowmap_vertex: shadowmap_vertex, shadowmask_pars_fragment: shadowmask_pars_fragment, skinbase_vertex: skinbase_vertex, skinning_pars_vertex: skinning_pars_vertex, skinning_vertex: skinning_vertex, skinnormal_vertex: skinnormal_vertex, specularmap_fragment: specularmap_fragment, specularmap_pars_fragment: specularmap_pars_fragment, tonemapping_fragment: tonemapping_fragment, tonemapping_pars_fragment: tonemapping_pars_fragment, uv_pars_fragment: uv_pars_fragment, uv_pars_vertex: uv_pars_vertex, uv_vertex: uv_vertex, uv2_pars_fragment: uv2_pars_fragment, uv2_pars_vertex: uv2_pars_vertex, uv2_vertex: uv2_vertex, worldpos_vertex: worldpos_vertex, background_frag: background_frag, background_vert: background_vert, cube_frag: cube_frag, cube_vert: cube_vert, depth_frag: depth_frag, depth_vert: depth_vert, distanceRGBA_frag: distanceRGBA_frag, distanceRGBA_vert: distanceRGBA_vert, equirect_frag: equirect_frag, equirect_vert: equirect_vert, linedashed_frag: linedashed_frag, linedashed_vert: linedashed_vert, meshbasic_frag: meshbasic_frag, meshbasic_vert: meshbasic_vert, meshlambert_frag: meshlambert_frag, meshlambert_vert: meshlambert_vert, meshmatcap_frag: meshmatcap_frag, meshmatcap_vert: meshmatcap_vert, meshphong_frag: meshphong_frag, meshphong_vert: meshphong_vert, meshphysical_frag: meshphysical_frag, meshphysical_vert: meshphysical_vert, normal_frag: normal_frag, normal_vert: normal_vert, points_frag: points_frag, points_vert: points_vert, shadow_frag: shadow_frag, shadow_vert: shadow_vert, sprite_frag: sprite_frag, sprite_vert: sprite_vert }; /** * Uniform Utilities */ function cloneUniforms( src ) { var dst = {}; for ( var u in src ) { dst[ u ] = {}; for ( var p in src[ u ] ) { var property = src[ u ][ p ]; if ( property && ( property.isColor || property.isMatrix3 || property.isMatrix4 || property.isVector2 || property.isVector3 || property.isVector4 || property.isTexture ) ) { dst[ u ][ p ] = property.clone(); } else if ( Array.isArray( property ) ) { dst[ u ][ p ] = property.slice(); } else { dst[ u ][ p ] = property; } } } return dst; } function mergeUniforms( uniforms ) { var merged = {}; for ( var u = 0; u < uniforms.length; u ++ ) { var tmp = cloneUniforms( uniforms[ u ] ); for ( var p in tmp ) { merged[ p ] = tmp[ p ]; } } return merged; } // Legacy var UniformsUtils = { clone: cloneUniforms, merge: mergeUniforms }; /** * @author mrdoob / http://mrdoob.com/ */ var ColorKeywords = { 'aliceblue': 0xF0F8FF, 'antiquewhite': 0xFAEBD7, 'aqua': 0x00FFFF, 'aquamarine': 0x7FFFD4, 'azure': 0xF0FFFF, 'beige': 0xF5F5DC, 'bisque': 0xFFE4C4, 'black': 0x000000, 'blanchedalmond': 0xFFEBCD, 'blue': 0x0000FF, 'blueviolet': 0x8A2BE2, 'brown': 0xA52A2A, 'burlywood': 0xDEB887, 'cadetblue': 0x5F9EA0, 'chartreuse': 0x7FFF00, 'chocolate': 0xD2691E, 'coral': 0xFF7F50, 'cornflowerblue': 0x6495ED, 'cornsilk': 0xFFF8DC, 'crimson': 0xDC143C, 'cyan': 0x00FFFF, 'darkblue': 0x00008B, 'darkcyan': 0x008B8B, 'darkgoldenrod': 0xB8860B, 'darkgray': 0xA9A9A9, 'darkgreen': 0x006400, 'darkgrey': 0xA9A9A9, 'darkkhaki': 0xBDB76B, 'darkmagenta': 0x8B008B, 'darkolivegreen': 0x556B2F, 'darkorange': 0xFF8C00, 'darkorchid': 0x9932CC, 'darkred': 0x8B0000, 'darksalmon': 0xE9967A, 'darkseagreen': 0x8FBC8F, 'darkslateblue': 0x483D8B, 'darkslategray': 0x2F4F4F, 'darkslategrey': 0x2F4F4F, 'darkturquoise': 0x00CED1, 'darkviolet': 0x9400D3, 'deeppink': 0xFF1493, 'deepskyblue': 0x00BFFF, 'dimgray': 0x696969, 'dimgrey': 0x696969, 'dodgerblue': 0x1E90FF, 'firebrick': 0xB22222, 'floralwhite': 0xFFFAF0, 'forestgreen': 0x228B22, 'fuchsia': 0xFF00FF, 'gainsboro': 0xDCDCDC, 'ghostwhite': 0xF8F8FF, 'gold': 0xFFD700, 'goldenrod': 0xDAA520, 'gray': 0x808080, 'green': 0x008000, 'greenyellow': 0xADFF2F, 'grey': 0x808080, 'honeydew': 0xF0FFF0, 'hotpink': 0xFF69B4, 'indianred': 0xCD5C5C, 'indigo': 0x4B0082, 'ivory': 0xFFFFF0, 'khaki': 0xF0E68C, 'lavender': 0xE6E6FA, 'lavenderblush': 0xFFF0F5, 'lawngreen': 0x7CFC00, 'lemonchiffon': 0xFFFACD, 'lightblue': 0xADD8E6, 'lightcoral': 0xF08080, 'lightcyan': 0xE0FFFF, 'lightgoldenrodyellow': 0xFAFAD2, 'lightgray': 0xD3D3D3, 'lightgreen': 0x90EE90, 'lightgrey': 0xD3D3D3, 'lightpink': 0xFFB6C1, 'lightsalmon': 0xFFA07A, 'lightseagreen': 0x20B2AA, 'lightskyblue': 0x87CEFA, 'lightslategray': 0x778899, 'lightslategrey': 0x778899, 'lightsteelblue': 0xB0C4DE, 'lightyellow': 0xFFFFE0, 'lime': 0x00FF00, 'limegreen': 0x32CD32, 'linen': 0xFAF0E6, 'magenta': 0xFF00FF, 'maroon': 0x800000, 'mediumaquamarine': 0x66CDAA, 'mediumblue': 0x0000CD, 'mediumorchid': 0xBA55D3, 'mediumpurple': 0x9370DB, 'mediumseagreen': 0x3CB371, 'mediumslateblue': 0x7B68EE, 'mediumspringgreen': 0x00FA9A, 'mediumturquoise': 0x48D1CC, 'mediumvioletred': 0xC71585, 'midnightblue': 0x191970, 'mintcream': 0xF5FFFA, 'mistyrose': 0xFFE4E1, 'moccasin': 0xFFE4B5, 'navajowhite': 0xFFDEAD, 'navy': 0x000080, 'oldlace': 0xFDF5E6, 'olive': 0x808000, 'olivedrab': 0x6B8E23, 'orange': 0xFFA500, 'orangered': 0xFF4500, 'orchid': 0xDA70D6, 'palegoldenrod': 0xEEE8AA, 'palegreen': 0x98FB98, 'paleturquoise': 0xAFEEEE, 'palevioletred': 0xDB7093, 'papayawhip': 0xFFEFD5, 'peachpuff': 0xFFDAB9, 'peru': 0xCD853F, 'pink': 0xFFC0CB, 'plum': 0xDDA0DD, 'powderblue': 0xB0E0E6, 'purple': 0x800080, 'rebeccapurple': 0x663399, 'red': 0xFF0000, 'rosybrown': 0xBC8F8F, 'royalblue': 0x4169E1, 'saddlebrown': 0x8B4513, 'salmon': 0xFA8072, 'sandybrown': 0xF4A460, 'seagreen': 0x2E8B57, 'seashell': 0xFFF5EE, 'sienna': 0xA0522D, 'silver': 0xC0C0C0, 'skyblue': 0x87CEEB, 'slateblue': 0x6A5ACD, 'slategray': 0x708090, 'slategrey': 0x708090, 'snow': 0xFFFAFA, 'springgreen': 0x00FF7F, 'steelblue': 0x4682B4, 'tan': 0xD2B48C, 'teal': 0x008080, 'thistle': 0xD8BFD8, 'tomato': 0xFF6347, 'turquoise': 0x40E0D0, 'violet': 0xEE82EE, 'wheat': 0xF5DEB3, 'white': 0xFFFFFF, 'whitesmoke': 0xF5F5F5, 'yellow': 0xFFFF00, 'yellowgreen': 0x9ACD32 }; function Color( r, g, b ) { if ( g === undefined && b === undefined ) { // r is THREE.Color, hex or string return this.set( r ); } return this.setRGB( r, g, b ); } Object.assign( Color.prototype, { isColor: true, r: 1, g: 1, b: 1, set: function ( value ) { if ( value && value.isColor ) { this.copy( value ); } else if ( typeof value === 'number' ) { this.setHex( value ); } else if ( typeof value === 'string' ) { this.setStyle( value ); } return this; }, setScalar: function ( scalar ) { this.r = scalar; this.g = scalar; this.b = scalar; return this; }, setHex: function ( hex ) { hex = Math.floor( hex ); this.r = ( hex >> 16 & 255 ) / 255; this.g = ( hex >> 8 & 255 ) / 255; this.b = ( hex & 255 ) / 255; return this; }, setRGB: function ( r, g, b ) { this.r = r; this.g = g; this.b = b; return this; }, setHSL: function () { function hue2rgb( p, q, t ) { if ( t < 0 ) t += 1; if ( t > 1 ) t -= 1; if ( t < 1 / 6 ) return p + ( q - p ) * 6 * t; if ( t < 1 / 2 ) return q; if ( t < 2 / 3 ) return p + ( q - p ) * 6 * ( 2 / 3 - t ); return p; } return function setHSL( h, s, l ) { // h,s,l ranges are in 0.0 - 1.0 h = _Math.euclideanModulo( h, 1 ); s = _Math.clamp( s, 0, 1 ); l = _Math.clamp( l, 0, 1 ); if ( s === 0 ) { this.r = this.g = this.b = l; } else { var p = l 0; } else if ( geometry && geometry.isGeometry ) { useMorphing = geometry.morphTargets && geometry.morphTargets.length > 0; } } if ( object.isSkinnedMesh && material.skinning === false ) { console.warn( 'THREE.WebGLShadowMap: THREE.SkinnedMesh with material.skinning set to false:', object ); } var useSkinning = object.isSkinnedMesh && material.skinning; var variantIndex = 0; if ( useMorphing ) variantIndex |= _MorphingFlag; if ( useSkinning ) variantIndex |= _SkinningFlag; result = materialVariants[ variantIndex ]; } else { result = customMaterial; } if ( _renderer.localClippingEnabled && material.clipShadows === true && material.clippingPlanes.length !== 0 ) { // in this case we need a unique material instance reflecting the // appropriate state var keyA = result.uuid, keyB = material.uuid; var materialsForVariant = _materialCache[ keyA ]; if ( materialsForVariant === undefined ) { materialsForVariant = {}; _materialCache[ keyA ] = materialsForVariant; } var cachedMaterial = materialsForVariant[ keyB ]; if ( cachedMaterial === undefined ) { cachedMaterial = result.clone(); materialsForVariant[ keyB ] = cachedMaterial; } result = cachedMaterial; } result.visible = material.visible; result.wireframe = material.wireframe; result.side = ( material.shadowSide != null ) ? material.shadowSide : shadowSide[ material.side ]; result.clipShadows = material.clipShadows; result.clippingPlanes = material.clippingPlanes; result.clipIntersection = material.clipIntersection; result.wireframeLinewidth = material.wireframeLinewidth; result.linewidth = material.linewidth; if ( isPointLight && result.isMeshDistanceMaterial ) { result.referencePosition.copy( lightPositionWorld ); result.nearDistance = shadowCameraNear; result.farDistance = shadowCameraFar; } return result; } function renderObject( object, camera, shadowCamera, isPointLight ) { if ( object.visible === false ) return; var visible = object.layers.test( camera.layers ); if ( visible && ( object.isMesh || object.isLine || object.isPoints ) ) { if ( object.castShadow && ( ! object.frustumCulled || _frustum.intersectsObject( object ) ) ) { object.modelViewMatrix.multiplyMatrices( shadowCamera.matrixWorldInverse, object.matrixWorld ); var geometry = _objects.update( object ); var material = object.material; if ( Array.isArray( material ) ) { var groups = geometry.groups; for ( var k = 0, kl = groups.length; k < kl; k ++ ) { var group = groups[ k ]; var groupMaterial = material[ group.materialIndex ]; if ( groupMaterial && groupMaterial.visible ) { var depthMaterial = getDepthMaterial( object, groupMaterial, isPointLight, _lightPositionWorld, shadowCamera.near, shadowCamera.far ); _renderer.renderBufferDirect( shadowCamera, null, geometry, depthMaterial, object, group ); } } } else if ( material.visible ) { var depthMaterial = getDepthMaterial( object, material, isPointLight, _lightPositionWorld, shadowCamera.near, shadowCamera.far ); _renderer.renderBufferDirect( shadowCamera, null, geometry, depthMaterial, object, null ); } } } var children = object.children; for ( var i = 0, l = children.length; i < l; i ++ ) { renderObject( children[ i ], camera, shadowCamera, isPointLight ); } } } /** * @author mrdoob / http://mrdoob.com/ */ function WebGLState( gl, extensions, utils, capabilities ) { function ColorBuffer() { var locked = false; var color = new Vector4(); var currentColorMask = null; var currentColorClear = new Vector4( 0, 0, 0, 0 ); return { setMask: function ( colorMask ) { if ( currentColorMask !== colorMask && ! locked ) { gl.colorMask( colorMask, colorMask, colorMask, colorMask ); currentColorMask = colorMask; } }, setLocked: function ( lock ) { locked = lock; }, setClear: function ( r, g, b, a, premultipliedAlpha ) { if ( premultipliedAlpha === true ) { r *= a; g *= a; b *= a; } color.set( r, g, b, a ); if ( currentColorClear.equals( color ) === false ) { gl.clearColor( r, g, b, a ); currentColorClear.copy( color ); } }, reset: function () { locked = false; currentColorMask = null; currentColorClear.set( - 1, 0, 0, 0 ); // set to invalid state } }; } function DepthBuffer() { var locked = false; var currentDepthMask = null; var currentDepthFunc = null; var currentDepthClear = null; return { setTest: function ( depthTest ) { if ( depthTest ) { enable( 2929 ); } else { disable( 2929 ); } }, setMask: function ( depthMask ) { if ( currentDepthMask !== depthMask && ! locked ) { gl.depthMask( depthMask ); currentDepthMask = depthMask; } }, setFunc: function ( depthFunc ) { if ( currentDepthFunc !== depthFunc ) { if ( depthFunc ) { switch ( depthFunc ) { case NeverDepth: gl.depthFunc( 512 ); break; case AlwaysDepth: gl.depthFunc( 519 ); break; case LessDepth: gl.depthFunc( 513 ); break; case LessEqualDepth: gl.depthFunc( 515 ); break; case EqualDepth: gl.depthFunc( 514 ); break; case GreaterEqualDepth: gl.depthFunc( 518 ); break; case GreaterDepth: gl.depthFunc( 516 ); break; case NotEqualDepth: gl.depthFunc( 517 ); break; default: gl.depthFunc( 515 ); } } else { gl.depthFunc( 515 ); } currentDepthFunc = depthFunc; } }, setLocked: function ( lock ) { locked = lock; }, setClear: function ( depth ) { if ( currentDepthClear !== depth ) { gl.clearDepth( depth ); currentDepthClear = depth; } }, reset: function () { locked = false; currentDepthMask = null; currentDepthFunc = null; currentDepthClear = null; } }; } function StencilBuffer() { var locked = false; var currentStencilMask = null; var currentStencilFunc = null; var currentStencilRef = null; var currentStencilFuncMask = null; var currentStencilFail = null; var currentStencilZFail = null; var currentStencilZPass = null; var currentStencilClear = null; return { setTest: function ( stencilTest ) { if ( stencilTest ) { enable( 2960 ); } else { disable( 2960 ); } }, setMask: function ( stencilMask ) { if ( currentStencilMask !== stencilMask && ! locked ) { gl.stencilMask( stencilMask ); currentStencilMask = stencilMask; } }, setFunc: function ( stencilFunc, stencilRef, stencilMask ) { if ( currentStencilFunc !== stencilFunc || currentStencilRef !== stencilRef || currentStencilFuncMask !== stencilMask ) { gl.stencilFunc( stencilFunc, stencilRef, stencilMask ); currentStencilFunc = stencilFunc; currentStencilRef = stencilRef; currentStencilFuncMask = stencilMask; } }, setOp: function ( stencilFail, stencilZFail, stencilZPass ) { if ( currentStencilFail !== stencilFail || currentStencilZFail !== stencilZFail || currentStencilZPass !== stencilZPass ) { gl.stencilOp( stencilFail, stencilZFail, stencilZPass ); currentStencilFail = stencilFail; currentStencilZFail = stencilZFail; currentStencilZPass = stencilZPass; } }, setLocked: function ( lock ) { locked = lock; }, setClear: function ( stencil ) { if ( currentStencilClear !== stencil ) { gl.clearStencil( stencil ); currentStencilClear = stencil; } }, reset: function () { locked = false; currentStencilMask = null; currentStencilFunc = null; currentStencilRef = null; currentStencilFuncMask = null; currentStencilFail = null; currentStencilZFail = null; currentStencilZPass = null; currentStencilClear = null; } }; } // var colorBuffer = new ColorBuffer(); var depthBuffer = new DepthBuffer(); var stencilBuffer = new StencilBuffer(); var maxVertexAttributes = gl.getParameter( 34921 ); var newAttributes = new Uint8Array( maxVertexAttributes ); var enabledAttributes = new Uint8Array( maxVertexAttributes ); var attributeDivisors = new Uint8Array( maxVertexAttributes ); var enabledCapabilities = {}; var compressedTextureFormats = null; var currentProgram = null; var currentBlendingEnabled = null; var currentBlending = null; var currentBlendEquation = null; var currentBlendSrc = null; var currentBlendDst = null; var currentBlendEquationAlpha = null; var currentBlendSrcAlpha = null; var currentBlendDstAlpha = null; var currentPremultipledAlpha = false; var currentFlipSided = null; var currentCullFace = null; var currentLineWidth = null; var currentPolygonOffsetFactor = null; var currentPolygonOffsetUnits = null; var maxTextures = gl.getParameter( 35661 ); var lineWidthAvailable = false; var version = 0; var glVersion = gl.getParameter( 7938 ); if ( glVersion.indexOf( 'WebGL' ) !== - 1 ) { version = parseFloat( /^WebGL\\ ([0-9])/.exec( glVersion )[ 1 ] ); lineWidthAvailable = ( version >= 1.0 ); } else if ( glVersion.indexOf( 'OpenGL ES' ) !== - 1 ) { version = parseFloat( /^OpenGL\\ ES\\ ([0-9])/.exec( glVersion )[ 1 ] ); lineWidthAvailable = ( version >= 2.0 ); } var currentTextureSlot = null; var currentBoundTextures = {}; var currentScissor = new Vector4(); var currentViewport = new Vector4(); function createTexture( type, target, count ) { var data = new Uint8Array( 4 ); // 4 is required to match default unpack alignment of 4. var texture = gl.createTexture(); gl.bindTexture( type, texture ); gl.texParameteri( type, 10241, 9728 ); gl.texParameteri( type, 10240, 9728 ); for ( var i = 0; i < count; i ++ ) { gl.texImage2D( target + i, 0, 6408, 1, 1, 0, 6408, 5121, data ); } return texture; } var emptyTextures = {}; emptyTextures[ 3553 ] = createTexture( 3553, 3553, 1 ); emptyTextures[ 34067 ] = createTexture( 34067, 34069, 6 ); // init colorBuffer.setClear( 0, 0, 0, 1 ); depthBuffer.setClear( 1 ); stencilBuffer.setClear( 0 ); enable( 2929 ); depthBuffer.setFunc( LessEqualDepth ); setFlipSided( false ); setCullFace( CullFaceBack ); enable( 2884 ); setBlending( NoBlending ); // function initAttributes() { for ( var i = 0, l = newAttributes.length; i < l; i ++ ) { newAttributes[ i ] = 0; } } function enableAttribute( attribute ) { enableAttributeAndDivisor( attribute, 0 ); } function enableAttributeAndDivisor( attribute, meshPerAttribute ) { newAttributes[ attribute ] = 1; if ( enabledAttributes[ attribute ] === 0 ) { gl.enableVertexAttribArray( attribute ); enabledAttributes[ attribute ] = 1; } if ( attributeDivisors[ attribute ] !== meshPerAttribute ) { var extension = capabilities.isWebGL2 ? gl : extensions.get( 'ANGLE_instanced_arrays' ); extension[ capabilities.isWebGL2 ? 'vertexAttribDivisor' : 'vertexAttribDivisorANGLE' ]( attribute, meshPerAttribute ); attributeDivisors[ attribute ] = meshPerAttribute; } } function disableUnusedAttributes() { for ( var i = 0, l = enabledAttributes.length; i !== l; ++ i ) { if ( enabledAttributes[ i ] !== newAttributes[ i ] ) { gl.disableVertexAttribArray( i ); enabledAttributes[ i ] = 0; } } } function enable( id ) { if ( enabledCapabilities[ id ] !== true ) { gl.enable( id ); enabledCapabilities[ id ] = true; } } function disable( id ) { if ( enabledCapabilities[ id ] !== false ) { gl.disable( id ); enabledCapabilities[ id ] = false; } } function getCompressedTextureFormats() { if ( compressedTextureFormats === null ) { compressedTextureFormats = []; if ( extensions.get( 'WEBGL_compressed_texture_pvrtc' ) || extensions.get( 'WEBGL_compressed_texture_s3tc' ) || extensions.get( 'WEBGL_compressed_texture_etc1' ) || extensions.get( 'WEBGL_compressed_texture_astc' ) ) { var formats = gl.getParameter( 34467 ); for ( var i = 0; i < formats.length; i ++ ) { compressedTextureFormats.push( formats[ i ] ); } } } return compressedTextureFormats; } function useProgram( program ) { if ( currentProgram !== program ) { gl.useProgram( program ); currentProgram = program; return true; } return false; } function setBlending( blending, blendEquation, blendSrc, blendDst, blendEquationAlpha, blendSrcAlpha, blendDstAlpha, premultipliedAlpha ) { if ( blending === NoBlending ) { if ( currentBlendingEnabled ) { disable( 3042 ); currentBlendingEnabled = false; } return; } if ( ! currentBlendingEnabled ) { enable( 3042 ); currentBlendingEnabled = true; } if ( blending !== CustomBlending ) { if ( blending !== currentBlending || premultipliedAlpha !== currentPremultipledAlpha ) { if ( currentBlendEquation !== AddEquation || currentBlendEquationAlpha !== AddEquation ) { gl.blendEquation( 32774 ); currentBlendEquation = AddEquation; currentBlendEquationAlpha = AddEquation; } if ( premultipliedAlpha ) { switch ( blending ) { case NormalBlending: gl.blendFuncSeparate( 1, 771, 1, 771 ); break; case AdditiveBlending: gl.blendFunc( 1, 1 ); break; case SubtractiveBlending: gl.blendFuncSeparate( 0, 0, 769, 771 ); break; case MultiplyBlending: gl.blendFuncSeparate( 0, 768, 0, 770 ); break; default: console.error( 'THREE.WebGLState: Invalid blending: ', blending ); break; } } else { switch ( blending ) { case NormalBlending: gl.blendFuncSeparate( 770, 771, 1, 771 ); break; case AdditiveBlending: gl.blendFunc( 770, 1 ); break; case SubtractiveBlending: gl.blendFunc( 0, 769 ); break; case MultiplyBlending: gl.blendFunc( 0, 768 ); break; default: console.error( 'THREE.WebGLState: Invalid blending: ', blending ); break; } } currentBlendSrc = null; currentBlendDst = null; currentBlendSrcAlpha = null; currentBlendDstAlpha = null; currentBlending = blending; currentPremultipledAlpha = premultipliedAlpha; } return; } // custom blending blendEquationAlpha = blendEquationAlpha || blendEquation; blendSrcAlpha = blendSrcAlpha || blendSrc; blendDstAlpha = blendDstAlpha || blendDst; if ( blendEquation !== currentBlendEquation || blendEquationAlpha !== currentBlendEquationAlpha ) { gl.blendEquationSeparate( utils.convert( blendEquation ), utils.convert( blendEquationAlpha ) ); currentBlendEquation = blendEquation; currentBlendEquationAlpha = blendEquationAlpha; } if ( blendSrc !== currentBlendSrc || blendDst !== currentBlendDst || blendSrcAlpha !== currentBlendSrcAlpha || blendDstAlpha !== currentBlendDstAlpha ) { gl.blendFuncSeparate( utils.convert( blendSrc ), utils.convert( blendDst ), utils.convert( blendSrcAlpha ), utils.convert( blendDstAlpha ) ); currentBlendSrc = blendSrc; currentBlendDst = blendDst; currentBlendSrcAlpha = blendSrcAlpha; currentBlendDstAlpha = blendDstAlpha; } currentBlending = blending; currentPremultipledAlpha = null; } function setMaterial( material, frontFaceCW ) { material.side === DoubleSide ? disable( 2884 ) : enable( 2884 ); var flipSided = ( material.side === BackSide ); if ( frontFaceCW ) flipSided = ! flipSided; setFlipSided( flipSided ); ( material.blending === NormalBlending && material.transparent === false ) ? setBlending( NoBlending ) : setBlending( material.blending, material.blendEquation, material.blendSrc, material.blendDst, material.blendEquationAlpha, material.blendSrcAlpha, material.blendDstAlpha, material.premultipliedAlpha ); depthBuffer.setFunc( material.depthFunc ); depthBuffer.setTest( material.depthTest ); depthBuffer.setMask( material.depthWrite ); colorBuffer.setMask( material.colorWrite ); setPolygonOffset( material.polygonOffset, material.polygonOffsetFactor, material.polygonOffsetUnits ); } // function setFlipSided( flipSided ) { if ( currentFlipSided !== flipSided ) { if ( flipSided ) { gl.frontFace( 2304 ); } else { gl.frontFace( 2305 ); } currentFlipSided = flipSided; } } function setCullFace( cullFace ) { if ( cullFace !== CullFaceNone ) { enable( 2884 ); if ( cullFace !== currentCullFace ) { if ( cullFace === CullFaceBack ) { gl.cullFace( 1029 ); } else if ( cullFace === CullFaceFront ) { gl.cullFace( 1028 ); } else { gl.cullFace( 1032 ); } } } else { disable( 2884 ); } currentCullFace = cullFace; } function setLineWidth( width ) { if ( width !== currentLineWidth ) { if ( lineWidthAvailable ) gl.lineWidth( width ); currentLineWidth = width; } } function setPolygonOffset( polygonOffset, factor, units ) { if ( polygonOffset ) { enable( 32823 ); if ( currentPolygonOffsetFactor !== factor || currentPolygonOffsetUnits !== units ) { gl.polygonOffset( factor, units ); currentPolygonOffsetFactor = factor; currentPolygonOffsetUnits = units; } } else { disable( 32823 ); } } function setScissorTest( scissorTest ) { if ( scissorTest ) { enable( 3089 ); } else { disable( 3089 ); } } // texture function activeTexture( webglSlot ) { if ( webglSlot === undefined ) webglSlot = 33984 + maxTextures - 1; if ( currentTextureSlot !== webglSlot ) { gl.activeTexture( webglSlot ); currentTextureSlot = webglSlot; } } function bindTexture( webglType, webglTexture ) { if ( currentTextureSlot === null ) { activeTexture(); } var boundTexture = currentBoundTextures[ currentTextureSlot ]; if ( boundTexture === undefined ) { boundTexture = { type: undefined, texture: undefined }; currentBoundTextures[ currentTextureSlot ] = boundTexture; } if ( boundTexture.type !== webglType || boundTexture.texture !== webglTexture ) { gl.bindTexture( webglType, webglTexture || emptyTextures[ webglType ] ); boundTexture.type = webglType; boundTexture.texture = webglTexture; } } function compressedTexImage2D() { try { gl.compressedTexImage2D.apply( gl, arguments ); } catch ( error ) { console.error( 'THREE.WebGLState:', error ); } } function texImage2D() { try { gl.texImage2D.apply( gl, arguments ); } catch ( error ) { console.error( 'THREE.WebGLState:', error ); } } function texImage3D() { try { gl.texImage3D.apply( gl, arguments ); } catch ( error ) { console.error( 'THREE.WebGLState:', error ); } } // function scissor( scissor ) { if ( currentScissor.equals( scissor ) === false ) { gl.scissor( scissor.x, scissor.y, scissor.z, scissor.w ); currentScissor.copy( scissor ); } } function viewport( viewport ) { if ( currentViewport.equals( viewport ) === false ) { gl.viewport( viewport.x, viewport.y, viewport.z, viewport.w ); currentViewport.copy( viewport ); } } // function reset() { for ( var i = 0; i < enabledAttributes.length; i ++ ) { if ( enabledAttributes[ i ] === 1 ) { gl.disableVertexAttribArray( i ); enabledAttributes[ i ] = 0; } } enabledCapabilities = {}; compressedTextureFormats = null; currentTextureSlot = null; currentBoundTextures = {}; currentProgram = null; currentBlending = null; currentFlipSided = null; currentCullFace = null; colorBuffer.reset(); depthBuffer.reset(); stencilBuffer.reset(); } return { buffers: { color: colorBuffer, depth: depthBuffer, stencil: stencilBuffer }, initAttributes: initAttributes, enableAttribute: enableAttribute, enableAttributeAndDivisor: enableAttributeAndDivisor, disableUnusedAttributes: disableUnusedAttributes, enable: enable, disable: disable, getCompressedTextureFormats: getCompressedTextureFormats, useProgram: useProgram, setBlending: setBlending, setMaterial: setMaterial, setFlipSided: setFlipSided, setCullFace: setCullFace, setLineWidth: setLineWidth, setPolygonOffset: setPolygonOffset, setScissorTest: setScissorTest, activeTexture: activeTexture, bindTexture: bindTexture, compressedTexImage2D: compressedTexImage2D, texImage2D: texImage2D, texImage3D: texImage3D, scissor: scissor, viewport: viewport, reset: reset }; } /** * @author mrdoob / http://mrdoob.com/ */ function WebGLTextures( _gl, extensions, state, properties, capabilities, utils, info ) { var _videoTextures = {}; var _canvas; // function resizeImage( image, needsPowerOfTwo, needsNewCanvas, maxSize ) { var scale = 1; // handle case if texture exceeds max size if ( image.width > maxSize || image.height > maxSize ) { scale = maxSize / Math.max( image.width, image.height ); } // only perform resize if necessary if ( scale < 1 || needsPowerOfTwo === true ) { // only perform resize for certain image types if ( image instanceof HTMLImageElement || image instanceof HTMLCanvasElement || image instanceof ImageBitmap ) { if ( _canvas === undefined ) _canvas = document.createElementNS( 'http://www.w3.org/1999/xhtml', 'canvas' ); // cube textures can't reuse the same canvas var canvas = needsNewCanvas ? document.createElementNS( 'http://www.w3.org/1999/xhtml', 'canvas' ) : _canvas; var floor = needsPowerOfTwo ? _Math.floorPowerOfTwo : Math.floor; canvas.width = floor( scale * image.width ); canvas.height = floor( scale * image.height ); var context = canvas.getContext( '2d' ); context.drawImage( image, 0, 0, canvas.width, canvas.height ); console.warn( 'THREE.WebGLRenderer: Texture has been resized from (' + image.width + 'x' + image.height + ') to (' + canvas.width + 'x' + canvas.height + ').' ); return canvas; } else { if ( 'data' in image ) { console.warn( 'THREE.WebGLRenderer: Image in DataTexture is too big (' + image.width + 'x' + image.height + ').' ); } return image; } } return image; } function isPowerOfTwo( image ) { return _Math.isPowerOfTwo( image.width ) && _Math.isPowerOfTwo( image.height ); } function textureNeedsPowerOfTwo( texture ) { if ( capabilities.isWebGL2 ) return false; return ( texture.wrapS !== ClampToEdgeWrapping || texture.wrapT !== ClampToEdgeWrapping ) || ( texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter ); } function textureNeedsGenerateMipmaps( texture, supportsMips ) { return texture.generateMipmaps && supportsMips && texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter; } function generateMipmap( target, texture, width, height ) { _gl.generateMipmap( target ); var textureProperties = properties.get( texture ); // Note: Math.log( x ) * Math.LOG2E used instead of Math.log2( x ) which is not supported by IE11 textureProperties.__maxMipLevel = Math.log( Math.max( width, height ) ) * Math.LOG2E; } function getInternalFormat( glFormat, glType ) { if ( ! capabilities.isWebGL2 ) return glFormat; var internalFormat = glFormat; if ( glFormat === 6403 ) { if ( glType === 5126 ) internalFormat = 33326; if ( glType === 5131 ) internalFormat = 33325; if ( glType === 5121 ) internalFormat = 33321; } if ( glFormat === 6407 ) { if ( glType === 5126 ) internalFormat = 34837; if ( glType === 5131 ) internalFormat = 34843; if ( glType === 5121 ) internalFormat = 32849; } if ( glFormat === 6408 ) { if ( glType === 5126 ) internalFormat = 34836; if ( glType === 5131 ) internalFormat = 34842; if ( glType === 5121 ) internalFormat = 32856; } if ( internalFormat === 33325 || internalFormat === 33326 || internalFormat === 34842 || internalFormat === 34836 ) { extensions.get( 'EXT_color_buffer_float' ); } else if ( internalFormat === 34843 || internalFormat === 34837 ) { console.warn( 'THREE.WebGLRenderer: Floating point textures with RGB format not supported. Please use RGBA instead.' ); } return internalFormat; } // Fallback filters for non-power-of-2 textures function filterFallback( f ) { if ( f === NearestFilter || f === NearestMipMapNearestFilter || f === NearestMipMapLinearFilter ) { return 9728; } return 9729; } // function onTextureDispose( event ) { var texture = event.target; texture.removeEventListener( 'dispose', onTextureDispose ); deallocateTexture( texture ); if ( texture.isVideoTexture ) { delete _videoTextures[ texture.id ]; } info.memory.textures --; } function onRenderTargetDispose( event ) { var renderTarget = event.target; renderTarget.removeEventListener( 'dispose', onRenderTargetDispose ); deallocateRenderTarget( renderTarget ); info.memory.textures --; } // function deallocateTexture( texture ) { var textureProperties = properties.get( texture ); if ( textureProperties.__webglInit === undefined ) return; _gl.deleteTexture( textureProperties.__webglTexture ); properties.remove( texture ); } function deallocateRenderTarget( renderTarget ) { var renderTargetProperties = properties.get( renderTarget ); var textureProperties = properties.get( renderTarget.texture ); if ( ! renderTarget ) return; if ( textureProperties.__webglTexture !== undefined ) { _gl.deleteTexture( textureProperties.__webglTexture ); } if ( renderTarget.depthTexture ) { renderTarget.depthTexture.dispose(); } if ( renderTarget.isWebGLRenderTargetCube ) { for ( var i = 0; i < 6; i ++ ) { _gl.deleteFramebuffer( renderTargetProperties.__webglFramebuffer[ i ] ); if ( renderTargetProperties.__webglDepthbuffer ) _gl.deleteRenderbuffer( renderTargetProperties.__webglDepthbuffer[ i ] ); } } else { _gl.deleteFramebuffer( renderTargetProperties.__webglFramebuffer ); if ( renderTargetProperties.__webglDepthbuffer ) _gl.deleteRenderbuffer( renderTargetProperties.__webglDepthbuffer ); } properties.remove( renderTarget.texture ); properties.remove( renderTarget ); } // function setTexture2D( texture, slot ) { var textureProperties = properties.get( texture ); if ( texture.isVideoTexture ) updateVideoTexture( texture ); if ( texture.version > 0 && textureProperties.__version !== texture.version ) { var image = texture.image; if ( image === undefined ) { console.warn( 'THREE.WebGLRenderer: Texture marked for update but image is undefined' ); } else if ( image.complete === false ) { console.warn( 'THREE.WebGLRenderer: Texture marked for update but image is incomplete' ); } else { uploadTexture( textureProperties, texture, slot ); return; } } state.activeTexture( 33984 + slot ); state.bindTexture( 3553, textureProperties.__webglTexture ); } function setTexture3D( texture, slot ) { var textureProperties = properties.get( texture ); if ( texture.version > 0 && textureProperties.__version !== texture.version ) { uploadTexture( textureProperties, texture, slot ); return; } state.activeTexture( 33984 + slot ); state.bindTexture( 32879, textureProperties.__webglTexture ); } function setTextureCube( texture, slot ) { var textureProperties = properties.get( texture ); if ( texture.image.length === 6 ) { if ( texture.version > 0 && textureProperties.__version !== texture.version ) { initTexture( textureProperties, texture ); state.activeTexture( 33984 + slot ); state.bindTexture( 34067, textureProperties.__webglTexture ); _gl.pixelStorei( 37440, texture.flipY ); var isCompressed = ( texture && texture.isCompressedTexture ); var isDataTexture = ( texture.image[ 0 ] && texture.image[ 0 ].isDataTexture ); var cubeImage = []; for ( var i = 0; i < 6; i ++ ) { if ( ! isCompressed && ! isDataTexture ) { cubeImage[ i ] = resizeImage( texture.image[ i ], false, true, capabilities.maxCubemapSize ); } else { cubeImage[ i ] = isDataTexture ? texture.image[ i ].image : texture.image[ i ]; } } var image = cubeImage[ 0 ], supportsMips = isPowerOfTwo( image ) || capabilities.isWebGL2, glFormat = utils.convert( texture.format ), glType = utils.convert( texture.type ), glInternalFormat = getInternalFormat( glFormat, glType ); setTextureParameters( 34067, texture, supportsMips ); for ( var i = 0; i < 6; i ++ ) { if ( ! isCompressed ) { if ( isDataTexture ) { state.texImage2D( 34069 + i, 0, glInternalFormat, cubeImage[ i ].width, cubeImage[ i ].height, 0, glFormat, glType, cubeImage[ i ].data ); } else { state.texImage2D( 34069 + i, 0, glInternalFormat, glFormat, glType, cubeImage[ i ] ); } } else { var mipmap, mipmaps = cubeImage[ i ].mipmaps; for ( var j = 0, jl = mipmaps.length; j < jl; j ++ ) { mipmap = mipmaps[ j ]; if ( texture.format !== RGBAFormat && texture.format !== RGBFormat ) { if ( state.getCompressedTextureFormats().indexOf( glFormat ) > - 1 ) { state.compressedTexImage2D( 34069 + i, j, glInternalFormat, mipmap.width, mipmap.height, 0, mipmap.data ); } else { console.warn( 'THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()' ); } } else { state.texImage2D( 34069 + i, j, glInternalFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data ); } } } } if ( ! isCompressed ) { textureProperties.__maxMipLevel = 0; } else { textureProperties.__maxMipLevel = mipmaps.length - 1; } if ( textureNeedsGenerateMipmaps( texture, supportsMips ) ) { // We assume images for cube map have the same size. generateMipmap( 34067, texture, image.width, image.height ); } textureProperties.__version = texture.version; if ( texture.onUpdate ) texture.onUpdate( texture ); } else { state.activeTexture( 33984 + slot ); state.bindTexture( 34067, textureProperties.__webglTexture ); } } } function setTextureCubeDynamic( texture, slot ) { state.activeTexture( 33984 + slot ); state.bindTexture( 34067, properties.get( texture ).__webglTexture ); } function setTextureParameters( textureType, texture, supportsMips ) { var extension; if ( supportsMips ) { _gl.texParameteri( textureType, 10242, utils.convert( texture.wrapS ) ); _gl.texParameteri( textureType, 10243, utils.convert( texture.wrapT ) ); if ( textureType === 32879 ) { _gl.texParameteri( textureType, 32882, utils.convert( texture.wrapR ) ); } _gl.texParameteri( textureType, 10240, utils.convert( texture.magFilter ) ); _gl.texParameteri( textureType, 10241, utils.convert( texture.minFilter ) ); } else { _gl.texParameteri( textureType, 10242, 33071 ); _gl.texParameteri( textureType, 10243, 33071 ); if ( textureType === 32879 ) { _gl.texParameteri( textureType, 32882, 33071 ); } if ( texture.wrapS !== ClampToEdgeWrapping || texture.wrapT !== ClampToEdgeWrapping ) { console.warn( 'THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping.' ); } _gl.texParameteri( textureType, 10240, filterFallback( texture.magFilter ) ); _gl.texParameteri( textureType, 10241, filterFallback( texture.minFilter ) ); if ( texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter ) { console.warn( 'THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.' ); } } extension = extensions.get( 'EXT_texture_filter_anisotropic' ); if ( extension ) { if ( texture.type === FloatType && extensions.get( 'OES_texture_float_linear' ) === null ) return; if ( texture.type === HalfFloatType && ( capabilities.isWebGL2 || extensions.get( 'OES_texture_half_float_linear' ) ) === null ) return; if ( texture.anisotropy > 1 || properties.get( texture ).__currentAnisotropy ) { _gl.texParameterf( textureType, extension.TEXTURE_MAX_ANISOTROPY_EXT, Math.min( texture.anisotropy, capabilities.getMaxAnisotropy() ) ); properties.get( texture ).__currentAnisotropy = texture.anisotropy; } } } function initTexture( textureProperties, texture ) { if ( textureProperties.__webglInit === undefined ) { textureProperties.__webglInit = true; texture.addEventListener( 'dispose', onTextureDispose ); textureProperties.__webglTexture = _gl.createTexture(); info.memory.textures ++; } } function uploadTexture( textureProperties, texture, slot ) { var textureType = ( texture.isDataTexture3D ) ? 32879 : 3553; initTexture( textureProperties, texture ); state.activeTexture( 33984 + slot ); state.bindTexture( textureType, textureProperties.__webglTexture ); _gl.pixelStorei( 37440, texture.flipY ); _gl.pixelStorei( 37441, texture.premultiplyAlpha ); _gl.pixelStorei( 3317, texture.unpackAlignment ); var needsPowerOfTwo = textureNeedsPowerOfTwo( texture ) && isPowerOfTwo( texture.image ) === false; var image = resizeImage( texture.image, needsPowerOfTwo, false, capabilities.maxTextureSize ); var supportsMips = isPowerOfTwo( image ) || capabilities.isWebGL2, glFormat = utils.convert( texture.format ), glType = utils.convert( texture.type ), glInternalFormat = getInternalFormat( glFormat, glType ); setTextureParameters( textureType, texture, supportsMips ); var mipmap, mipmaps = texture.mipmaps; if ( texture.isDepthTexture ) { // populate depth texture with dummy data glInternalFormat = 6402; if ( texture.type === FloatType ) { if ( ! capabilities.isWebGL2 ) throw new Error( 'Float Depth Texture only supported in WebGL2.0' ); glInternalFormat = 36012; } else if ( capabilities.isWebGL2 ) { // WebGL 2.0 requires signed internalformat for glTexImage2D glInternalFormat = 33189; } if ( texture.format === DepthFormat && glInternalFormat === 6402 ) { // The error INVALID_OPERATION is generated by texImage2D if format and internalformat are // DEPTH_COMPONENT and type is not UNSIGNED_SHORT or UNSIGNED_INT // (https://www.khronos.org/registry/webgl/extensions/WEBGL_depth_texture/) if ( texture.type !== UnsignedShortType && texture.type !== UnsignedIntType ) { console.warn( 'THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture.' ); texture.type = UnsignedShortType; glType = utils.convert( texture.type ); } } // Depth stencil textures need the DEPTH_STENCIL internal format // (https://www.khronos.org/registry/webgl/extensions/WEBGL_depth_texture/) if ( texture.format === DepthStencilFormat ) { glInternalFormat = 34041; // The error INVALID_OPERATION is generated by texImage2D if format and internalformat are // DEPTH_STENCIL and type is not UNSIGNED_INT_24_8_WEBGL. // (https://www.khronos.org/registry/webgl/extensions/WEBGL_depth_texture/) if ( texture.type !== UnsignedInt248Type ) { console.warn( 'THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture.' ); texture.type = UnsignedInt248Type; glType = utils.convert( texture.type ); } } state.texImage2D( 3553, 0, glInternalFormat, image.width, image.height, 0, glFormat, glType, null ); } else if ( texture.isDataTexture ) { // use manually created mipmaps if available // if there are no manual mipmaps // set 0 level mipmap and then use GL to generate other mipmap levels if ( mipmaps.length > 0 && supportsMips ) { for ( var i = 0, il = mipmaps.length; i < il; i ++ ) { mipmap = mipmaps[ i ]; state.texImage2D( 3553, i, glInternalFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data ); } texture.generateMipmaps = false; textureProperties.__maxMipLevel = mipmaps.length - 1; } else { state.texImage2D( 3553, 0, glInternalFormat, image.width, image.height, 0, glFormat, glType, image.data ); textureProperties.__maxMipLevel = 0; } } else if ( texture.isCompressedTexture ) { for ( var i = 0, il = mipmaps.length; i < il; i ++ ) { mipmap = mipmaps[ i ]; if ( texture.format !== RGBAFormat && texture.format !== RGBFormat ) { if ( state.getCompressedTextureFormats().indexOf( glFormat ) > - 1 ) { state.compressedTexImage2D( 3553, i, glInternalFormat, mipmap.width, mipmap.height, 0, mipmap.data ); } else { console.warn( 'THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()' ); } } else { state.texImage2D( 3553, i, glInternalFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data ); } } textureProperties.__maxMipLevel = mipmaps.length - 1; } else if ( texture.isDataTexture3D ) { state.texImage3D( 32879, 0, glInternalFormat, image.width, image.height, image.depth, 0, glFormat, glType, image.data ); textureProperties.__maxMipLevel = 0; } else { // regular Texture (image, video, canvas) // use manually created mipmaps if available // if there are no manual mipmaps // set 0 level mipmap and then use GL to generate other mipmap levels if ( mipmaps.length > 0 && supportsMips ) { for ( var i = 0, il = mipmaps.length; i < il; i ++ ) { mipmap = mipmaps[ i ]; state.texImage2D( 3553, i, glInternalFormat, glFormat, glType, mipmap ); } texture.generateMipmaps = false; textureProperties.__maxMipLevel = mipmaps.length - 1; } else { state.texImage2D( 3553, 0, glInternalFormat, glFormat, glType, image ); textureProperties.__maxMipLevel = 0; } } if ( textureNeedsGenerateMipmaps( texture, supportsMips ) ) { generateMipmap( 3553, texture, image.width, image.height ); } textureProperties.__version = texture.version; if ( texture.onUpdate ) texture.onUpdate( texture ); } // Render targets // Setup storage for target texture and bind it to correct framebuffer function setupFrameBufferTexture( framebuffer, renderTarget, attachment, textureTarget ) { var glFormat = utils.convert( renderTarget.texture.format ); var glType = utils.convert( renderTarget.texture.type ); var glInternalFormat = getInternalFormat( glFormat, glType ); state.texImage2D( textureTarget, 0, glInternalFormat, renderTarget.width, renderTarget.height, 0, glFormat, glType, null ); _gl.bindFramebuffer( 36160, framebuffer ); _gl.framebufferTexture2D( 36160, attachment, textureTarget, properties.get( renderTarget.texture ).__webglTexture, 0 ); _gl.bindFramebuffer( 36160, null ); } // Setup storage for internal depth/stencil buffers and bind to correct framebuffer function setupRenderBufferStorage( renderbuffer, renderTarget, isMultisample ) { _gl.bindRenderbuffer( 36161, renderbuffer ); if ( renderTarget.depthBuffer && ! renderTarget.stencilBuffer ) { if ( isMultisample ) { var samples = getRenderTargetSamples( renderTarget ); _gl.renderbufferStorageMultisample( 36161, samples, 33189, renderTarget.width, renderTarget.height ); } else { _gl.renderbufferStorage( 36161, 33189, renderTarget.width, renderTarget.height ); } _gl.framebufferRenderbuffer( 36160, 36096, 36161, renderbuffer ); } else if ( renderTarget.depthBuffer && renderTarget.stencilBuffer ) { if ( isMultisample ) { var samples = getRenderTargetSamples( renderTarget ); _gl.renderbufferStorageMultisample( 36161, samples, 34041, renderTarget.width, renderTarget.height ); } else { _gl.renderbufferStorage( 36161, 34041, renderTarget.width, renderTarget.height ); } _gl.framebufferRenderbuffer( 36160, 33306, 36161, renderbuffer ); } else { var glFormat = utils.convert( renderTarget.texture.format ); var glType = utils.convert( renderTarget.texture.type ); var glInternalFormat = getInternalFormat( glFormat, glType ); if ( isMultisample ) { var samples = getRenderTargetSamples( renderTarget ); _gl.renderbufferStorageMultisample( 36161, samples, glInternalFormat, renderTarget.width, renderTarget.height ); } else { _gl.renderbufferStorage( 36161, glInternalFormat, renderTarget.width, renderTarget.height ); } } _gl.bindRenderbuffer( 36161, null ); } // Setup resources for a Depth Texture for a FBO (needs an extension) function setupDepthTexture( framebuffer, renderTarget ) { var isCube = ( renderTarget && renderTarget.isWebGLRenderTargetCube ); if ( isCube ) throw new Error( 'Depth Texture with cube render targets is not supported' ); _gl.bindFramebuffer( 36160, framebuffer ); if ( ! ( renderTarget.depthTexture && renderTarget.depthTexture.isDepthTexture ) ) { throw new Error( 'renderTarget.depthTexture must be an instance of THREE.DepthTexture' ); } // upload an empty depth texture with framebuffer size if ( ! properties.get( renderTarget.depthTexture ).__webglTexture || renderTarget.depthTexture.image.width !== renderTarget.width || renderTarget.depthTexture.image.height !== renderTarget.height ) { renderTarget.depthTexture.image.width = renderTarget.width; renderTarget.depthTexture.image.height = renderTarget.height; renderTarget.depthTexture.needsUpdate = true; } setTexture2D( renderTarget.depthTexture, 0 ); var webglDepthTexture = properties.get( renderTarget.depthTexture ).__webglTexture; if ( renderTarget.depthTexture.format === DepthFormat ) { _gl.framebufferTexture2D( 36160, 36096, 3553, webglDepthTexture, 0 ); } else if ( renderTarget.depthTexture.format === DepthStencilFormat ) { _gl.framebufferTexture2D( 36160, 33306, 3553, webglDepthTexture, 0 ); } else { throw new Error( 'Unknown depthTexture format' ); } } // Setup GL resources for a non-texture depth buffer function setupDepthRenderbuffer( renderTarget ) { var renderTargetProperties = properties.get( renderTarget ); var isCube = ( renderTarget.isWebGLRenderTargetCube === true ); if ( renderTarget.depthTexture ) { if ( isCube ) throw new Error( 'target.depthTexture not supported in Cube render targets' ); setupDepthTexture( renderTargetProperties.__webglFramebuffer, renderTarget ); } else { if ( isCube ) { renderTargetProperties.__webglDepthbuffer = []; for ( var i = 0; i < 6; i ++ ) { _gl.bindFramebuffer( 36160, renderTargetProperties.__webglFramebuffer[ i ] ); renderTargetProperties.__webglDepthbuffer[ i ] = _gl.createRenderbuffer(); setupRenderBufferStorage( renderTargetProperties.__webglDepthbuffer[ i ], renderTarget ); } } else { _gl.bindFramebuffer( 36160, renderTargetProperties.__webglFramebuffer ); renderTargetProperties.__webglDepthbuffer = _gl.createRenderbuffer(); setupRenderBufferStorage( renderTargetProperties.__webglDepthbuffer, renderTarget ); } } _gl.bindFramebuffer( 36160, null ); } // Set up GL resources for the render target function setupRenderTarget( renderTarget ) { var renderTargetProperties = properties.get( renderTarget ); var textureProperties = properties.get( renderTarget.texture ); renderTarget.addEventListener( 'dispose', onRenderTargetDispose ); textureProperties.__webglTexture = _gl.createTexture(); info.memory.textures ++; var isCube = ( renderTarget.isWebGLRenderTargetCube === true ); var isMultisample = ( renderTarget.isWebGLMultisampleRenderTarget === true ); var supportsMips = isPowerOfTwo( renderTarget ) || capabilities.isWebGL2; // Setup framebuffer if ( isCube ) { renderTargetProperties.__webglFramebuffer = []; for ( var i = 0; i < 6; i ++ ) { renderTargetProperties.__webglFramebuffer[ i ] = _gl.createFramebuffer(); } } else { renderTargetProperties.__webglFramebuffer = _gl.createFramebuffer(); if ( isMultisample ) { if ( capabilities.isWebGL2 ) { renderTargetProperties.__webglMultisampledFramebuffer = _gl.createFramebuffer(); renderTargetProperties.__webglColorRenderbuffer = _gl.createRenderbuffer(); _gl.bindRenderbuffer( 36161, renderTargetProperties.__webglColorRenderbuffer ); var glFormat = utils.convert( renderTarget.texture.format ); var glType = utils.convert( renderTarget.texture.type ); var glInternalFormat = getInternalFormat( glFormat, glType ); var samples = getRenderTargetSamples( renderTarget ); _gl.renderbufferStorageMultisample( 36161, samples, glInternalFormat, renderTarget.width, renderTarget.height ); _gl.bindFramebuffer( 36160, renderTargetProperties.__webglMultisampledFramebuffer ); _gl.framebufferRenderbuffer( 36160, 36064, 36161, renderTargetProperties.__webglColorRenderbuffer ); _gl.bindRenderbuffer( 36161, null ); if ( renderTarget.depthBuffer ) { renderTargetProperties.__webglDepthRenderbuffer = _gl.createRenderbuffer(); setupRenderBufferStorage( renderTargetProperties.__webglDepthRenderbuffer, renderTarget, true ); } _gl.bindFramebuffer( 36160, null ); } else { console.warn( 'THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.' ); } } } // Setup color buffer if ( isCube ) { state.bindTexture( 34067, textureProperties.__webglTexture ); setTextureParameters( 34067, renderTarget.texture, supportsMips ); for ( var i = 0; i < 6; i ++ ) { setupFrameBufferTexture( renderTargetProperties.__webglFramebuffer[ i ], renderTarget, 36064, 34069 + i ); } if ( textureNeedsGenerateMipmaps( renderTarget.texture, supportsMips ) ) { generateMipmap( 34067, renderTarget.texture, renderTarget.width, renderTarget.height ); } state.bindTexture( 34067, null ); } else { state.bindTexture( 3553, textureProperties.__webglTexture ); setTextureParameters( 3553, renderTarget.texture, supportsMips ); setupFrameBufferTexture( renderTargetProperties.__webglFramebuffer, renderTarget, 36064, 3553 ); if ( textureNeedsGenerateMipmaps( renderTarget.texture, supportsMips ) ) { generateMipmap( 3553, renderTarget.texture, renderTarget.width, renderTarget.height ); } state.bindTexture( 3553, null ); } // Setup depth and stencil buffers if ( renderTarget.depthBuffer ) { setupDepthRenderbuffer( renderTarget ); } } function updateRenderTargetMipmap( renderTarget ) { var texture = renderTarget.texture; var supportsMips = isPowerOfTwo( renderTarget ) || capabilities.isWebGL2; if ( textureNeedsGenerateMipmaps( texture, supportsMips ) ) { var target = renderTarget.isWebGLRenderTargetCube ? 34067 : 3553; var webglTexture = properties.get( texture ).__webglTexture; state.bindTexture( target, webglTexture ); generateMipmap( target, texture, renderTarget.width, renderTarget.height ); state.bindTexture( target, null ); } } function updateMultisampleRenderTarget( renderTarget ) { if ( renderTarget.isWebGLMultisampleRenderTarget ) { if ( capabilities.isWebGL2 ) { var renderTargetProperties = properties.get( renderTarget ); _gl.bindFramebuffer( 36008, renderTargetProperties.__webglMultisampledFramebuffer ); _gl.bindFramebuffer( 36009, renderTargetProperties.__webglFramebuffer ); var width = renderTarget.width; var height = renderTarget.height; var mask = 16384; if ( renderTarget.depthBuffer ) mask |= 256; if ( renderTarget.stencilBuffer ) mask |= 1024; _gl.blitFramebuffer( 0, 0, width, height, 0, 0, width, height, mask, 9728 ); } else { console.warn( 'THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.' ); } } } function getRenderTargetSamples( renderTarget ) { return ( capabilities.isWebGL2 && renderTarget.isWebGLMultisampleRenderTarget ) ? Math.min( capabilities.maxSamples, renderTarget.samples ) : 0; } function updateVideoTexture( texture ) { var id = texture.id; var frame = info.render.frame; // Check the last frame we updated the VideoTexture if ( _videoTextures[ id ] !== frame ) { _videoTextures[ id ] = frame; texture.update(); } } this.setTexture2D = setTexture2D; this.setTexture3D = setTexture3D; this.setTextureCube = setTextureCube; this.setTextureCubeDynamic = setTextureCubeDynamic; this.setupRenderTarget = setupRenderTarget; this.updateRenderTargetMipmap = updateRenderTargetMipmap; this.updateMultisampleRenderTarget = updateMultisampleRenderTarget; } /** * @author thespite / http://www.twitter.com/thespite */ function WebGLUtils( gl, extensions, capabilities ) { function convert( p ) { var extension; if ( p === RepeatWrapping ) return 10497; if ( p === ClampToEdgeWrapping ) return 33071; if ( p === MirroredRepeatWrapping ) return 33648; if ( p === NearestFilter ) return 9728; if ( p === NearestMipMapNearestFilter ) return 9984; if ( p === NearestMipMapLinearFilter ) return 9986; if ( p === LinearFilter ) return 9729; if ( p === LinearMipMapNearestFilter ) return 9985; if ( p === LinearMipMapLinearFilter ) return 9987; if ( p === UnsignedByteType ) return 5121; if ( p === UnsignedShort4444Type ) return 32819; if ( p === UnsignedShort5551Type ) return 32820; if ( p === UnsignedShort565Type ) return 33635; if ( p === ByteType ) return 5120; if ( p === ShortType ) return 5122; if ( p === UnsignedShortType ) return 5123; if ( p === IntType ) return 5124; if ( p === UnsignedIntType ) return 5125; if ( p === FloatType ) return 5126; if ( p === HalfFloatType ) { if ( capabilities.isWebGL2 ) return 5131; extension = extensions.get( 'OES_texture_half_float' ); if ( extension !== null ) return extension.HALF_FLOAT_OES; } if ( p === AlphaFormat ) return 6406; if ( p === RGBFormat ) return 6407; if ( p === RGBAFormat ) return 6408; if ( p === LuminanceFormat ) return 6409; if ( p === LuminanceAlphaFormat ) return 6410; if ( p === DepthFormat ) return 6402; if ( p === DepthStencilFormat ) return 34041; if ( p === RedFormat ) return 6403; if ( p === AddEquation ) return 32774; if ( p === SubtractEquation ) return 32778; if ( p === ReverseSubtractEquation ) return 32779; if ( p === ZeroFactor ) return 0; if ( p === OneFactor ) return 1; if ( p === SrcColorFactor ) return 768; if ( p === OneMinusSrcColorFactor ) return 769; if ( p === SrcAlphaFactor ) return 770; if ( p === OneMinusSrcAlphaFactor ) return 771; if ( p === DstAlphaFactor ) return 772; if ( p === OneMinusDstAlphaFactor ) return 773; if ( p === DstColorFactor ) return 774; if ( p === OneMinusDstColorFactor ) return 775; if ( p === SrcAlphaSaturateFactor ) return 776; if ( p === RGB_S3TC_DXT1_Format || p === RGBA_S3TC_DXT1_Format || p === RGBA_S3TC_DXT3_Format || p === RGBA_S3TC_DXT5_Format ) { extension = extensions.get( 'WEBGL_compressed_texture_s3tc' ); if ( extension !== null ) { if ( p === RGB_S3TC_DXT1_Format ) return extension.COMPRESSED_RGB_S3TC_DXT1_EXT; if ( p === RGBA_S3TC_DXT1_Format ) return extension.COMPRESSED_RGBA_S3TC_DXT1_EXT; if ( p === RGBA_S3TC_DXT3_Format ) return extension.COMPRESSED_RGBA_S3TC_DXT3_EXT; if ( p === RGBA_S3TC_DXT5_Format ) return extension.COMPRESSED_RGBA_S3TC_DXT5_EXT; } } if ( p === RGB_PVRTC_4BPPV1_Format || p === RGB_PVRTC_2BPPV1_Format || p === RGBA_PVRTC_4BPPV1_Format || p === RGBA_PVRTC_2BPPV1_Format ) { extension = extensions.get( 'WEBGL_compressed_texture_pvrtc' ); if ( extension !== null ) { if ( p === RGB_PVRTC_4BPPV1_Format ) return extension.COMPRESSED_RGB_PVRTC_4BPPV1_IMG; if ( p === RGB_PVRTC_2BPPV1_Format ) return extension.COMPRESSED_RGB_PVRTC_2BPPV1_IMG; if ( p === RGBA_PVRTC_4BPPV1_Format ) return extension.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG; if ( p === RGBA_PVRTC_2BPPV1_Format ) return extension.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG; } } if ( p === RGB_ETC1_Format ) { extension = extensions.get( 'WEBGL_compressed_texture_etc1' ); if ( extension !== null ) return extension.COMPRESSED_RGB_ETC1_WEBGL; } if ( p === RGBA_ASTC_4x4_Format || p === RGBA_ASTC_5x4_Format || p === RGBA_ASTC_5x5_Format || p === RGBA_ASTC_6x5_Format || p === RGBA_ASTC_6x6_Format || p === RGBA_ASTC_8x5_Format || p === RGBA_ASTC_8x6_Format || p === RGBA_ASTC_8x8_Format || p === RGBA_ASTC_10x5_Format || p === RGBA_ASTC_10x6_Format || p === RGBA_ASTC_10x8_Format || p === RGBA_ASTC_10x10_Format || p === RGBA_ASTC_12x10_Format || p === RGBA_ASTC_12x12_Format ) { extension = extensions.get( 'WEBGL_compressed_texture_astc' ); if ( extension !== null ) { return p; } } if ( p === MinEquation || p === MaxEquation ) { if ( capabilities.isWebGL2 ) { if ( p === MinEquation ) return 32775; if ( p === MaxEquation ) return 32776; } extension = extensions.get( 'EXT_blend_minmax' ); if ( extension !== null ) { if ( p === MinEquation ) return extension.MIN_EXT; if ( p === MaxEquation ) return extension.MAX_EXT; } } if ( p === UnsignedInt248Type ) { if ( capabilities.isWebGL2 ) return 34042; extension = extensions.get( 'WEBGL_depth_texture' ); if ( extension !== null ) return extension.UNSIGNED_INT_24_8_WEBGL; } return 0; } return { convert: convert }; } /** * @author mrdoob / http://mrdoob.com/ */ function Group() { Object3D.call( this ); this.type = 'Group'; } Group.prototype = Object.assign( Object.create( Object3D.prototype ), { constructor: Group, isGroup: true } ); /** * @author mrdoob / http://mrdoob.com/ * @author mikael emtinger / http://gomo.se/ * @author WestLangley / http://github.com/WestLangley */ function Camera() { Object3D.call( this ); this.type = 'Camera'; this.matrixWorldInverse = new Matrix4(); this.projectionMatrix = new Matrix4(); this.projectionMatrixInverse = new Matrix4(); } Camera.prototype = Object.assign( Object.create( Object3D.prototype ), { constructor: Camera, isCamera: true, copy: function ( source, recursive ) { Object3D.prototype.copy.call( this, source, recursive ); this.matrixWorldInverse.copy( source.matrixWorldInverse ); this.projectionMatrix.copy( source.projectionMatrix ); this.projectionMatrixInverse.copy( source.projectionMatrixInverse ); return this; }, getWorldDirection: function ( target ) { if ( target === undefined ) { console.warn( 'THREE.Camera: .getWorldDirection() target is now required' ); target = new Vector3(); } this.updateMatrixWorld( true ); var e = this.matrixWorld.elements; return target.set( - e[ 8 ], - e[ 9 ], - e[ 10 ] ).normalize(); }, updateMatrixWorld: function ( force ) { Object3D.prototype.updateMatrixWorld.call( this, force ); this.matrixWorldInverse.getInverse( this.matrixWorld ); }, clone: function () { return new this.constructor().copy( this ); } } ); /** * @author mrdoob / http://mrdoob.com/ * @author greggman / http://games.greggman.com/ * @author zz85 / http://www.lab4games.net/zz85/blog * @author tschw */ function PerspectiveCamera( fov, aspect, near, far ) { Camera.call( this ); this.type = 'PerspectiveCamera'; this.fov = fov !== undefined ? fov : 50; this.zoom = 1; this.near = near !== undefined ? near : 0.1; this.far = far !== undefined ? far : 2000; this.focus = 10; this.aspect = aspect !== undefined ? aspect : 1; this.view = null; this.filmGauge = 35; // width of the film (default in millimeters) this.filmOffset = 0; // horizontal film offset (same unit as gauge) this.updateProjectionMatrix(); } PerspectiveCamera.prototype = Object.assign( Object.create( Camera.prototype ), { constructor: PerspectiveCamera, isPerspectiveCamera: true, copy: function ( source, recursive ) { Camera.prototype.copy.call( this, source, recursive ); this.fov = source.fov; this.zoom = source.zoom; this.near = source.near; this.far = source.far; this.focus = source.focus; this.aspect = source.aspect; this.view = source.view === null ? null : Object.assign( {}, source.view ); this.filmGauge = source.filmGauge; this.filmOffset = source.filmOffset; return this; }, /** * Sets the FOV by focal length in respect to the current .filmGauge. * * The default film gauge is 35, so that the focal length can be specified for * a 35mm (full frame) camera. * * Values for focal length and film gauge must have the same unit. */ setFocalLength: function ( focalLength ) { // see http://www.bobatkins.com/photography/technical/field_of_view.html var vExtentSlope = 0.5 * this.getFilmHeight() / focalLength; this.fov = _Math.RAD2DEG * 2 * Math.atan( vExtentSlope ); this.updateProjectionMatrix(); }, /** * Calculates the focal length from the current .fov and .filmGauge. */ getFocalLength: function () { var vExtentSlope = Math.tan( _Math.DEG2RAD * 0.5 * this.fov ); return 0.5 * this.getFilmHeight() / vExtentSlope; }, getEffectiveFOV: function () { return _Math.RAD2DEG * 2 * Math.atan( Math.tan( _Math.DEG2RAD * 0.5 * this.fov ) / this.zoom ); }, getFilmWidth: function () { // film not completely covered in portrait format (aspect < 1) return this.filmGauge * Math.min( this.aspect, 1 ); }, getFilmHeight: function () { // film not completely covered in landscape format (aspect > 1) return this.filmGauge / Math.max( this.aspect, 1 ); }, /** * Sets an offset in a larger frustum. This is useful for multi-window or * multi-monitor/multi-machine setups. * * For example, if you have 3x2 monitors and each monitor is 1920x1080 and * the monitors are in grid like this * * +---+---+---+ * | A | B | C | * +---+---+---+ * | D | E | F | * +---+---+---+ * * then for each monitor you would call it like this * * var w = 1920; * var h = 1080; * var fullWidth = w * 3; * var fullHeight = h * 2; * * --A-- * camera.setOffset( fullWidth, fullHeight, w * 0, h * 0, w, h ); * --B-- * camera.setOffset( fullWidth, fullHeight, w * 1, h * 0, w, h ); * --C-- * camera.setOffset( fullWidth, fullHeight, w * 2, h * 0, w, h ); * --D-- * camera.setOffset( fullWidth, fullHeight, w * 0, h * 1, w, h ); * --E-- * camera.setOffset( fullWidth, fullHeight, w * 1, h * 1, w, h ); * --F-- * camera.setOffset( fullWidth, fullHeight, w * 2, h * 1, w, h ); * * Note there is no reason monitors have to be the same size or in a grid. */ setViewOffset: function ( fullWidth, fullHeight, x, y, width, height ) { this.aspect = fullWidth / fullHeight; if ( this.view === null ) { this.view = { enabled: true, fullWidth: 1, fullHeight: 1, offsetX: 0, offsetY: 0, width: 1, height: 1 }; } this.view.enabled = true; this.view.fullWidth = fullWidth; this.view.fullHeight = fullHeight; this.view.offsetX = x; this.view.offsetY = y; this.view.width = width; this.view.height = height; this.updateProjectionMatrix(); }, clearViewOffset: function () { if ( this.view !== null ) { this.view.enabled = false; } this.updateProjectionMatrix(); }, updateProjectionMatrix: function () { var near = this.near, top = near * Math.tan( _Math.DEG2RAD * 0.5 * this.fov ) / this.zoom, height = 2 * top, width = this.aspect * height, left = - 0.5 * width, view = this.view; if ( this.view !== null && this.view.enabled ) { var fullWidth = view.fullWidth, fullHeight = view.fullHeight; left += view.offsetX * width / fullWidth; top -= view.offsetY * height / fullHeight; width *= view.width / fullWidth; height *= view.height / fullHeight; } var skew = this.filmOffset; if ( skew !== 0 ) left += near * skew / this.getFilmWidth(); this.projectionMatrix.makePerspective( left, left + width, top, top - height, near, this.far ); this.projectionMatrixInverse.getInverse( this.projectionMatrix ); }, toJSON: function ( meta ) { var data = Object3D.prototype.toJSON.call( this, meta ); data.object.fov = this.fov; data.object.zoom = this.zoom; data.object.near = this.near; data.object.far = this.far; data.object.focus = this.focus; data.object.aspect = this.aspect; if ( this.view !== null ) data.object.view = Object.assign( {}, this.view ); data.object.filmGauge = this.filmGauge; data.object.filmOffset = this.filmOffset; return data; } } ); /** * @author mrdoob / http://mrdoob.com/ */ function ArrayCamera( array ) { PerspectiveCamera.call( this ); this.cameras = array || []; } ArrayCamera.prototype = Object.assign( Object.create( PerspectiveCamera.prototype ), { constructor: ArrayCamera, isArrayCamera: true } ); /** * @author jsantell / https://www.jsantell.com/ * @author mrdoob / http://mrdoob.com/ */ var cameraLPos = new Vector3(); var cameraRPos = new Vector3(); /** * Assumes 2 cameras that are parallel and share an X-axis, and that * the cameras' projection and world matrices have already been set. * And that near and far planes are identical for both cameras. * Visualization of this technique: https://computergraphics.stackexchange.com/a/4765 */ function setProjectionFromUnion( camera, cameraL, cameraR ) { cameraLPos.setFromMatrixPosition( cameraL.matrixWorld ); cameraRPos.setFromMatrixPosition( cameraR.matrixWorld ); var ipd = cameraLPos.distanceTo( cameraRPos ); var projL = cameraL.projectionMatrix.elements; var projR = cameraR.projectionMatrix.elements; // VR systems will have identical far and near planes, and // most likely identical top and bottom frustum extents. // Use the left camera for these values. var near = projL[ 14 ] / ( projL[ 10 ] - 1 ); var far = projL[ 14 ] / ( projL[ 10 ] + 1 ); var topFov = ( projL[ 9 ] + 1 ) / projL[ 5 ]; var bottomFov = ( projL[ 9 ] - 1 ) / projL[ 5 ]; var leftFov = ( projL[ 8 ] - 1 ) / projL[ 0 ]; var rightFov = ( projR[ 8 ] + 1 ) / projR[ 0 ]; var left = near * leftFov; var right = near * rightFov; // Calculate the new camera's position offset from the // left camera. xOffset should be roughly half `ipd`. var zOffset = ipd / ( - leftFov + rightFov ); var xOffset = zOffset * - leftFov; // TODO: Better way to apply this offset? cameraL.matrixWorld.decompose( camera.position, camera.quaternion, camera.scale ); camera.translateX( xOffset ); camera.translateZ( zOffset ); camera.matrixWorld.compose( camera.position, camera.quaternion, camera.scale ); camera.matrixWorldInverse.getInverse( camera.matrixWorld ); // Find the union of the frustum values of the cameras and scale // the values so that the near plane's position does not change in world space, // although must now be relative to the new union camera. var near2 = near + zOffset; var far2 = far + zOffset; var left2 = left - xOffset; var right2 = right + ( ipd - xOffset ); var top2 = topFov * far / far2 * near2; var bottom2 = bottomFov * far / far2 * near2; camera.projectionMatrix.makePerspective( left2, right2, top2, bottom2, near2, far2 ); } /** * @author mrdoob / http://mrdoob.com/ */ function WebVRManager( renderer ) { var scope = this; var device = null; var frameData = null; var poseTarget = null; var controllers = []; var standingMatrix = new Matrix4(); var standingMatrixInverse = new Matrix4(); var framebufferScaleFactor = 1.0; var frameOfReferenceType = 'stage'; if ( typeof window !== 'undefined' && 'VRFrameData' in window ) { frameData = new window.VRFrameData(); window.addEventListener( 'vrdisplaypresentchange', onVRDisplayPresentChange, false ); } var matrixWorldInverse = new Matrix4(); var tempQuaternion = new Quaternion(); var tempPosition = new Vector3(); var cameraL = new PerspectiveCamera(); cameraL.bounds = new Vector4( 0.0, 0.0, 0.5, 1.0 ); cameraL.layers.enable( 1 ); var cameraR = new PerspectiveCamera(); cameraR.bounds = new Vector4( 0.5, 0.0, 0.5, 1.0 ); cameraR.layers.enable( 2 ); var cameraVR = new ArrayCamera( [ cameraL, cameraR ] ); cameraVR.layers.enable( 1 ); cameraVR.layers.enable( 2 ); // function isPresenting() { return device !== null && device.isPresenting === true; } var currentSize, currentPixelRatio; function onVRDisplayPresentChange() { if ( isPresenting() ) { var eyeParameters = device.getEyeParameters( 'left' ); var renderWidth = eyeParameters.renderWidth * framebufferScaleFactor; var renderHeight = eyeParameters.renderHeight * framebufferScaleFactor; currentPixelRatio = renderer.getPixelRatio(); currentSize = renderer.getSize(); renderer.setDrawingBufferSize( renderWidth * 2, renderHeight, 1 ); animation.start(); } else { if ( scope.enabled ) { renderer.setDrawingBufferSize( currentSize.width, currentSize.height, currentPixelRatio ); } animation.stop(); } } // var triggers = []; function findGamepad( id ) { var gamepads = navigator.getGamepads && navigator.getGamepads(); for ( var i = 0, j = 0, l = gamepads.length; i < l; i ++ ) { var gamepad = gamepads[ i ]; if ( gamepad && ( gamepad.id === 'Daydream Controller' || gamepad.id === 'Gear VR Controller' || gamepad.id === 'Oculus Go Controller' || gamepad.id === 'OpenVR Gamepad' || gamepad.id.startsWith( 'Oculus Touch' ) || gamepad.id.startsWith( 'Spatial Controller' ) ) ) { if ( j === id ) return gamepad; j ++; } } } function updateControllers() { for ( var i = 0; i < controllers.length; i ++ ) { var controller = controllers[ i ]; var gamepad = findGamepad( i ); if ( gamepad !== undefined && gamepad.pose !== undefined ) { if ( gamepad.pose === null ) return; // Pose var pose = gamepad.pose; if ( pose.hasPosition === false ) controller.position.set( 0.2, - 0.6, - 0.05 ); if ( pose.position !== null ) controller.position.fromArray( pose.position ); if ( pose.orientation !== null ) controller.quaternion.fromArray( pose.orientation ); controller.matrix.compose( controller.position, controller.quaternion, controller.scale ); controller.matrix.premultiply( standingMatrix ); controller.matrix.decompose( controller.position, controller.quaternion, controller.scale ); controller.matrixWorldNeedsUpdate = true; controller.visible = true; // Trigger var buttonId = gamepad.id === 'Daydream Controller' ? 0 : 1; if ( triggers[ i ] !== gamepad.buttons[ buttonId ].pressed ) { triggers[ i ] = gamepad.buttons[ buttonId ].pressed; if ( triggers[ i ] === true ) { controller.dispatchEvent( { type: 'selectstart' } ); } else { controller.dispatchEvent( { type: 'selectend' } ); controller.dispatchEvent( { type: 'select' } ); } } } else { controller.visible = false; } } } // this.enabled = false; this.getController = function ( id ) { var controller = controllers[ id ]; if ( controller === undefined ) { controller = new Group(); controller.matrixAutoUpdate = false; controller.visible = false; controllers[ id ] = controller; } return controller; }; this.getDevice = function () { return device; }; this.setDevice = function ( value ) { if ( value !== undefined ) device = value; animation.setContext( value ); }; this.setFramebufferScaleFactor = function ( value ) { framebufferScaleFactor = value; }; this.setFrameOfReferenceType = function ( value ) { frameOfReferenceType = value; }; this.setPoseTarget = function ( object ) { if ( object !== undefined ) poseTarget = object; }; this.getCamera = function ( camera ) { var userHeight = frameOfReferenceType === 'stage' ? 1.6 : 0; if ( device === null ) { camera.position.set( 0, userHeight, 0 ); return camera; } device.depthNear = camera.near; device.depthFar = camera.far; device.getFrameData( frameData ); // if ( frameOfReferenceType === 'stage' ) { var stageParameters = device.stageParameters; if ( stageParameters ) { standingMatrix.fromArray( stageParameters.sittingToStandingTransform ); } else { standingMatrix.makeTranslation( 0, userHeight, 0 ); } } var pose = frameData.pose; var poseObject = poseTarget !== null ? poseTarget : camera; // We want to manipulate poseObject by its position and quaternion components since users may rely on them. poseObject.matrix.copy( standingMatrix ); poseObject.matrix.decompose( poseObject.position, poseObject.quaternion, poseObject.scale ); if ( pose.orientation !== null ) { tempQuaternion.fromArray( pose.orientation ); poseObject.quaternion.multiply( tempQuaternion ); } if ( pose.position !== null ) { tempQuaternion.setFromRotationMatrix( standingMatrix ); tempPosition.fromArray( pose.position ); tempPosition.applyQuaternion( tempQuaternion ); poseObject.position.add( tempPosition ); } poseObject.updateMatrixWorld(); if ( device.isPresenting === false ) return camera; // cameraL.near = camera.near; cameraR.near = camera.near; cameraL.far = camera.far; cameraR.far = camera.far; cameraL.matrixWorldInverse.fromArray( frameData.leftViewMatrix ); cameraR.matrixWorldInverse.fromArray( frameData.rightViewMatrix ); // TODO (mrdoob) Double check this code standingMatrixInverse.getInverse( standingMatrix ); if ( frameOfReferenceType === 'stage' ) { cameraL.matrixWorldInverse.multiply( standingMatrixInverse ); cameraR.matrixWorldInverse.multiply( standingMatrixInverse ); } var parent = poseObject.parent; if ( parent !== null ) { matrixWorldInverse.getInverse( parent.matrixWorld ); cameraL.matrixWorldInverse.multiply( matrixWorldInverse ); cameraR.matrixWorldInverse.multiply( matrixWorldInverse ); } // envMap and Mirror needs camera.matrixWorld cameraL.matrixWorld.getInverse( cameraL.matrixWorldInverse ); cameraR.matrixWorld.getInverse( cameraR.matrixWorldInverse ); cameraL.projectionMatrix.fromArray( frameData.leftProjectionMatrix ); cameraR.projectionMatrix.fromArray( frameData.rightProjectionMatrix ); setProjectionFromUnion( cameraVR, cameraL, cameraR ); // var layers = device.getLayers(); if ( layers.length ) { var layer = layers[ 0 ]; if ( layer.leftBounds !== null && layer.leftBounds.length === 4 ) { cameraL.bounds.fromArray( layer.leftBounds ); } if ( layer.rightBounds !== null && layer.rightBounds.length === 4 ) { cameraR.bounds.fromArray( layer.rightBounds ); } } updateControllers(); return cameraVR; }; this.getStandingMatrix = function () { return standingMatrix; }; this.isPresenting = isPresenting; // Animation Loop var animation = new WebGLAnimation(); this.setAnimationLoop = function ( callback ) { animation.setAnimationLoop( callback ); }; this.submitFrame = function () { if ( isPresenting() ) device.submitFrame(); }; this.dispose = function () { if ( typeof window !== 'undefined' ) { window.removeEventListener( 'vrdisplaypresentchange', onVRDisplayPresentChange ); } }; } /** * @author mrdoob / http://mrdoob.com/ */ function WebXRManager( renderer ) { var gl = renderer.context; var device = null; var session = null; var framebufferScaleFactor = 1.0; var frameOfReference = null; var frameOfReferenceType = 'stage'; var pose = null; var controllers = []; var inputSources = []; function isPresenting() { return session !== null && frameOfReference !== null; } // var cameraL = new PerspectiveCamera(); cameraL.layers.enable( 1 ); cameraL.viewport = new Vector4(); var cameraR = new PerspectiveCamera(); cameraR.layers.enable( 2 ); cameraR.viewport = new Vector4(); var cameraVR = new ArrayCamera( [ cameraL, cameraR ] ); cameraVR.layers.enable( 1 ); cameraVR.layers.enable( 2 ); // this.enabled = false; this.getController = function ( id ) { var controller = controllers[ id ]; if ( controller === undefined ) { controller = new Group(); controller.matrixAutoUpdate = false; controller.visible = false; controllers[ id ] = controller; } return controller; }; this.getDevice = function () { return device; }; this.setDevice = function ( value ) { if ( value !== undefined ) device = value; if ( value instanceof XRDevice ) gl.setCompatibleXRDevice( value ); }; // function onSessionEvent( event ) { var controller = controllers[ inputSources.indexOf( event.inputSource ) ]; if ( controller ) controller.dispatchEvent( { type: event.type } ); } function onSessionEnd() { renderer.setFramebuffer( null ); animation.stop(); } this.setFramebufferScaleFactor = function ( value ) { framebufferScaleFactor = value; }; this.setFrameOfReferenceType = function ( value ) { frameOfReferenceType = value; }; this.setSession = function ( value ) { session = value; if ( session !== null ) { session.addEventListener( 'select', onSessionEvent ); session.addEventListener( 'selectstart', onSessionEvent ); session.addEventListener( 'selectend', onSessionEvent ); session.addEventListener( 'end', onSessionEnd ); session.baseLayer = new XRWebGLLayer( session, gl, { framebufferScaleFactor: framebufferScaleFactor } ); session.requestFrameOfReference( frameOfReferenceType ).then( function ( value ) { frameOfReference = value; renderer.setFramebuffer( session.baseLayer.framebuffer ); animation.setContext( session ); animation.start(); } ); // inputSources = session.getInputSources(); session.addEventListener( 'inputsourceschange', function () { inputSources = session.getInputSources(); console.log( inputSources ); for ( var i = 0; i < controllers.length; i ++ ) { var controller = controllers[ i ]; controller.userData.inputSource = inputSources[ i ]; } } ); } }; function updateCamera( camera, parent ) { if ( parent === null ) { camera.matrixWorld.copy( camera.matrix ); } else { camera.matrixWorld.multiplyMatrices( parent.matrixWorld, camera.matrix ); } camera.matrixWorldInverse.getInverse( camera.matrixWorld ); } this.getCamera = function ( camera ) { if ( isPresenting() ) { var parent = camera.parent; var cameras = cameraVR.cameras; updateCamera( cameraVR, parent ); for ( var i = 0; i < cameras.length; i ++ ) { updateCamera( cameras[ i ], parent ); } // update camera and its children camera.matrixWorld.copy( cameraVR.matrixWorld ); var children = camera.children; for ( var i = 0, l = children.length; i < l; i ++ ) { children[ i ].updateMatrixWorld( true ); } setProjectionFromUnion( cameraVR, cameraL, cameraR ); return cameraVR; } return camera; }; this.isPresenting = isPresenting; // Animation Loop var onAnimationFrameCallback = null; function onAnimationFrame( time, frame ) { pose = frame.getDevicePose( frameOfReference ); if ( pose !== null ) { var layer = session.baseLayer; var views = frame.views; for ( var i = 0; i < views.length; i ++ ) { var view = views[ i ]; var viewport = layer.getViewport( view ); var viewMatrix = pose.getViewMatrix( view ); var camera = cameraVR.cameras[ i ]; camera.matrix.fromArray( viewMatrix ).getInverse( camera.matrix ); camera.projectionMatrix.fromArray( view.projectionMatrix ); camera.viewport.set( viewport.x, viewport.y, viewport.width, viewport.height ); if ( i === 0 ) { cameraVR.matrix.copy( camera.matrix ); } } } // for ( var i = 0; i < controllers.length; i ++ ) { var controller = controllers[ i ]; var inputSource = inputSources[ i ]; if ( inputSource ) { var inputPose = frame.getInputPose( inputSource, frameOfReference ); if ( inputPose !== null ) { if ( 'targetRay' in inputPose ) { controller.matrix.elements = inputPose.targetRay.transformMatrix; } else if ( 'pointerMatrix' in inputPose ) { // DEPRECATED controller.matrix.elements = inputPose.pointerMatrix; } controller.matrix.decompose( controller.position, controller.rotation, controller.scale ); controller.visible = true; continue; } } controller.visible = false; } if ( onAnimationFrameCallback ) onAnimationFrameCallback( time ); } var animation = new WebGLAnimation(); animation.setAnimationLoop( onAnimationFrame ); this.setAnimationLoop = function ( callback ) { onAnimationFrameCallback = callback; }; this.dispose = function () {}; // DEPRECATED this.getStandingMatrix = function () { console.warn( 'THREE.WebXRManager: getStandingMatrix() is no longer needed.' ); return new THREE.Matrix4(); }; this.submitFrame = function () {}; } /** * @author supereggbert / http://www.paulbrunt.co.uk/ * @author mrdoob / http://mrdoob.com/ * @author alteredq / http://alteredqualia.com/ * @author szimek / https://github.com/szimek/ * @author tschw */ function WebGLRenderer( parameters ) { console.log( 'THREE.WebGLRenderer', REVISION ); parameters = parameters || {}; var _canvas = parameters.canvas !== undefined ? parameters.canvas : document.createElementNS( 'http://www.w3.org/1999/xhtml', 'canvas' ), _context = parameters.context !== undefined ? parameters.context : null, _alpha = parameters.alpha !== undefined ? parameters.alpha : false, _depth = parameters.depth !== undefined ? parameters.depth : true, _stencil = parameters.stencil !== undefined ? parameters.stencil : true, _antialias = parameters.antialias !== undefined ? parameters.antialias : false, _premultipliedAlpha = parameters.premultipliedAlpha !== undefined ? parameters.premultipliedAlpha : true, _preserveDrawingBuffer = parameters.preserveDrawingBuffer !== undefined ? parameters.preserveDrawingBuffer : false, _powerPreference = parameters.powerPreference !== undefined ? parameters.powerPreference : 'default'; var currentRenderList = null; var currentRenderState = null; // public properties this.domElement = _canvas; this.context = null; // clearing this.autoClear = true; this.autoClearColor = true; this.autoClearDepth = true; this.autoClearStencil = true; // scene graph this.sortObjects = true; // user-defined clipping this.clippingPlanes = []; this.localClippingEnabled = false; // physically based shading this.gammaFactor = 2.0; // for backwards compatibility this.gammaInput = false; this.gammaOutput = false; // physical lights this.physicallyCorrectLights = false; // tone mapping this.toneMapping = LinearToneMapping; this.toneMappingExposure = 1.0; this.toneMappingWhitePoint = 1.0; // morphs this.maxMorphTargets = 8; this.maxMorphNormals = 4; // internal properties var _this = this, _isContextLost = false, // internal state cache _framebuffer = null, _currentRenderTarget = null, _currentFramebuffer = null, _currentMaterialId = - 1, // geometry and program caching _currentGeometryProgram = { geometry: null, program: null, wireframe: false }, _currentCamera = null, _currentArrayCamera = null, _currentViewport = new Vector4(), _currentScissor = new Vector4(), _currentScissorTest = null, // _usedTextureUnits = 0, // _width = _canvas.width, _height = _canvas.height, _pixelRatio = 1, _viewport = new Vector4( 0, 0, _width, _height ), _scissor = new Vector4( 0, 0, _width, _height ), _scissorTest = false, // frustum _frustum = new Frustum(), // clipping _clipping = new WebGLClipping(), _clippingEnabled = false, _localClippingEnabled = false, // camera matrices cache _projScreenMatrix = new Matrix4(), _vector3 = new Vector3(); function getTargetPixelRatio() { return _currentRenderTarget === null ? _pixelRatio : 1; } // initialize var _gl; try { var contextAttributes = { alpha: _alpha, depth: _depth, stencil: _stencil, antialias: _antialias, premultipliedAlpha: _premultipliedAlpha, preserveDrawingBuffer: _preserveDrawingBuffer, powerPreference: _powerPreference }; // event listeners must be registered before WebGL context is created, see #12753 _canvas.addEventListener( 'webglcontextlost', onContextLost, false ); _canvas.addEventListener( 'webglcontextrestored', onContextRestore, false ); _gl = _context || _canvas.getContext( 'webgl', contextAttributes ) || _canvas.getContext( 'experimental-webgl', contextAttributes ); if ( _gl === null ) { if ( _canvas.getContext( 'webgl' ) !== null ) { throw new Error( 'Error creating WebGL context with your selected attributes.' ); } else { throw new Error( 'Error creating WebGL context.' ); } } // Some experimental-webgl implementations do not have getShaderPrecisionFormat if ( _gl.getShaderPrecisionFormat === undefined ) { _gl.getShaderPrecisionFormat = function () { return { 'rangeMin': 1, 'rangeMax': 1, 'precision': 1 }; }; } } catch ( error ) { console.error( 'THREE.WebGLRenderer: ' + error.message ); } var extensions, capabilities, state, info; var properties, textures, attributes, geometries, objects; var programCache, renderLists, renderStates; var background, morphtargets, bufferRenderer, indexedBufferRenderer; var utils; function initGLContext() { extensions = new WebGLExtensions( _gl ); capabilities = new WebGLCapabilities( _gl, extensions, parameters ); if ( ! capabilities.isWebGL2 ) { extensions.get( 'WEBGL_depth_texture' ); extensions.get( 'OES_texture_float' ); extensions.get( 'OES_texture_half_float' ); extensions.get( 'OES_texture_half_float_linear' ); extensions.get( 'OES_standard_derivatives' ); extensions.get( 'OES_element_index_uint' ); extensions.get( 'ANGLE_instanced_arrays' ); } extensions.get( 'OES_texture_float_linear' ); utils = new WebGLUtils( _gl, extensions, capabilities ); state = new WebGLState( _gl, extensions, utils, capabilities ); state.scissor( _currentScissor.copy( _scissor ).multiplyScalar( _pixelRatio ) ); state.viewport( _currentViewport.copy( _viewport ).multiplyScalar( _pixelRatio ) ); info = new WebGLInfo( _gl ); properties = new WebGLProperties(); textures = new WebGLTextures( _gl, extensions, state, properties, capabilities, utils, info ); attributes = new WebGLAttributes( _gl ); geometries = new WebGLGeometries( _gl, attributes, info ); objects = new WebGLObjects( geometries, info ); morphtargets = new WebGLMorphtargets( _gl ); programCache = new WebGLPrograms( _this, extensions, capabilities ); renderLists = new WebGLRenderLists(); renderStates = new WebGLRenderStates(); background = new WebGLBackground( _this, state, objects, _premultipliedAlpha ); bufferRenderer = new WebGLBufferRenderer( _gl, extensions, info, capabilities ); indexedBufferRenderer = new WebGLIndexedBufferRenderer( _gl, extensions, info, capabilities ); info.programs = programCache.programs; _this.context = _gl; _this.capabilities = capabilities; _this.extensions = extensions; _this.properties = properties; _this.renderLists = renderLists; _this.state = state; _this.info = info; } initGLContext(); // vr var vr = null; if ( typeof navigator !== 'undefined' ) { vr = ( 'xr' in navigator ) ? new WebXRManager( _this ) : new WebVRManager( _this ); } this.vr = vr; // shadow map var shadowMap = new WebGLShadowMap( _this, objects, capabilities.maxTextureSize ); this.shadowMap = shadowMap; // API this.getContext = function () { return _gl; }; this.getContextAttributes = function () { return _gl.getContextAttributes(); }; this.forceContextLoss = function () { var extension = extensions.get( 'WEBGL_lose_context' ); if ( extension ) extension.loseContext(); }; this.forceContextRestore = function () { var extension = extensions.get( 'WEBGL_lose_context' ); if ( extension ) extension.restoreContext(); }; this.getPixelRatio = function () { return _pixelRatio; }; this.setPixelRatio = function ( value ) { if ( value === undefined ) return; _pixelRatio = value; this.setSize( _width, _height, false ); }; this.getSize = function () { return { width: _width, height: _height }; }; this.setSize = function ( width, height, updateStyle ) { if ( vr.isPresenting() ) { console.warn( 'THREE.WebGLRenderer: Can\\'t change size while VR device is presenting.' ); return; } _width = width; _height = height; _canvas.width = width * _pixelRatio; _canvas.height = height * _pixelRatio; if ( updateStyle !== false ) { _canvas.style.width = width + 'px'; _canvas.style.height = height + 'px'; } this.setViewport( 0, 0, width, height ); }; this.getDrawingBufferSize = function () { return { width: _width * _pixelRatio, height: _height * _pixelRatio }; }; this.setDrawingBufferSize = function ( width, height, pixelRatio ) { _width = width; _height = height; _pixelRatio = pixelRatio; _canvas.width = width * pixelRatio; _canvas.height = height * pixelRatio; this.setViewport( 0, 0, width, height ); }; this.getCurrentViewport = function () { return _currentViewport; }; this.setViewport = function ( x, y, width, height ) { _viewport.set( x, _height - y - height, width, height ); state.viewport( _currentViewport.copy( _viewport ).multiplyScalar( _pixelRatio ) ); }; this.setScissor = function ( x, y, width, height ) { _scissor.set( x, _height - y - height, width, height ); state.scissor( _currentScissor.copy( _scissor ).multiplyScalar( _pixelRatio ) ); }; this.setScissorTest = function ( boolean ) { state.setScissorTest( _scissorTest = boolean ); }; // Clearing this.getClearColor = function () { return background.getClearColor(); }; this.setClearColor = function () { background.setClearColor.apply( background, arguments ); }; this.getClearAlpha = function () { return background.getClearAlpha(); }; this.setClearAlpha = function () { background.setClearAlpha.apply( background, arguments ); }; this.clear = function ( color, depth, stencil ) { var bits = 0; if ( color === undefined || color ) bits |= 16384; if ( depth === undefined || depth ) bits |= 256; if ( stencil === undefined || stencil ) bits |= 1024; _gl.clear( bits ); }; this.clearColor = function () { this.clear( true, false, false ); }; this.clearDepth = function () { this.clear( false, true, false ); }; this.clearStencil = function () { this.clear( false, false, true ); }; // this.dispose = function () { _canvas.removeEventListener( 'webglcontextlost', onContextLost, false ); _canvas.removeEventListener( 'webglcontextrestored', onContextRestore, false ); renderLists.dispose(); renderStates.dispose(); properties.dispose(); objects.dispose(); vr.dispose(); animation.stop(); }; // Events function onContextLost( event ) { event.preventDefault(); console.log( 'THREE.WebGLRenderer: Context Lost.' ); _isContextLost = true; } function onContextRestore( /* event */ ) { console.log( 'THREE.WebGLRenderer: Context Restored.' ); _isContextLost = false; initGLContext(); } function onMaterialDispose( event ) { var material = event.target; material.removeEventListener( 'dispose', onMaterialDispose ); deallocateMaterial( material ); } // Buffer deallocation function deallocateMaterial( material ) { releaseMaterialProgramReference( material ); properties.remove( material ); } function releaseMaterialProgramReference( material ) { var programInfo = properties.get( material ).program; material.program = undefined; if ( programInfo !== undefined ) { programCache.releaseProgram( programInfo ); } } // Buffer rendering function renderObjectImmediate( object, program ) { object.render( function ( object ) { _this.renderBufferImmediate( object, program ); } ); } this.renderBufferImmediate = function ( object, program ) { state.initAttributes(); var buffers = properties.get( object ); if ( object.hasPositions && ! buffers.position ) buffers.position = _gl.createBuffer(); if ( object.hasNormals && ! buffers.normal ) buffers.normal = _gl.createBuffer(); if ( object.hasUvs && ! buffers.uv ) buffers.uv = _gl.createBuffer(); if ( object.hasColors && ! buffers.color ) buffers.color = _gl.createBuffer(); var programAttributes = program.getAttributes(); if ( object.hasPositions ) { _gl.bindBuffer( 34962, buffers.position ); _gl.bufferData( 34962, object.positionArray, 35048 ); state.enableAttribute( programAttributes.position ); _gl.vertexAttribPointer( programAttributes.position, 3, 5126, false, 0, 0 ); } if ( object.hasNormals ) { _gl.bindBuffer( 34962, buffers.normal ); _gl.bufferData( 34962, object.normalArray, 35048 ); state.enableAttribute( programAttributes.normal ); _gl.vertexAttribPointer( programAttributes.normal, 3, 5126, false, 0, 0 ); } if ( object.hasUvs ) { _gl.bindBuffer( 34962, buffers.uv ); _gl.bufferData( 34962, object.uvArray, 35048 ); state.enableAttribute( programAttributes.uv ); _gl.vertexAttribPointer( programAttributes.uv, 2, 5126, false, 0, 0 ); } if ( object.hasColors ) { _gl.bindBuffer( 34962, buffers.color ); _gl.bufferData( 34962, object.colorArray, 35048 ); state.enableAttribute( programAttributes.color ); _gl.vertexAttribPointer( programAttributes.color, 3, 5126, false, 0, 0 ); } state.disableUnusedAttributes(); _gl.drawArrays( 4, 0, object.count ); object.count = 0; }; this.renderBufferDirect = function ( camera, fog, geometry, material, object, group ) { var frontFaceCW = ( object.isMesh && object.normalMatrix.determinant() < 0 ); state.setMaterial( material, frontFaceCW ); var program = setProgram( camera, fog, material, object ); var updateBuffers = false; if ( _currentGeometryProgram.geometry !== geometry.id || _currentGeometryProgram.program !== program.id || _currentGeometryProgram.wireframe !== ( material.wireframe === true ) ) { _currentGeometryProgram.geometry = geometry.id; _currentGeometryProgram.program = program.id; _currentGeometryProgram.wireframe = material.wireframe === true; updateBuffers = true; } if ( object.morphTargetInfluences ) { morphtargets.update( object, geometry, material, program ); updateBuffers = true; } // var index = geometry.index; var position = geometry.attributes.position; var rangeFactor = 1; if ( material.wireframe === true ) { index = geometries.getWireframeAttribute( geometry ); rangeFactor = 2; } var attribute; var renderer = bufferRenderer; if ( index !== null ) { attribute = attributes.get( index ); renderer = indexedBufferRenderer; renderer.setIndex( attribute ); } if ( updateBuffers ) { setupVertexAttributes( material, program, geometry ); if ( index !== null ) { _gl.bindBuffer( 34963, attribute.buffer ); } } // var dataCount = Infinity; if ( index !== null ) { dataCount = index.count; } else if ( position !== undefined ) { dataCount = position.count; } var rangeStart = geometry.drawRange.start * rangeFactor; var rangeCount = geometry.drawRange.count * rangeFactor; var groupStart = group !== null ? group.start * rangeFactor : 0; var groupCount = group !== null ? group.count * rangeFactor : Infinity; var drawStart = Math.max( rangeStart, groupStart ); var drawEnd = Math.min( dataCount, rangeStart + rangeCount, groupStart + groupCount ) - 1; var drawCount = Math.max( 0, drawEnd - drawStart + 1 ); if ( drawCount === 0 ) return; // if ( object.isMesh ) { if ( material.wireframe === true ) { state.setLineWidth( material.wireframeLinewidth * getTargetPixelRatio() ); renderer.setMode( 1 ); } else { switch ( object.drawMode ) { case TrianglesDrawMode: renderer.setMode( 4 ); break; case TriangleStripDrawMode: renderer.setMode( 5 ); break; case TriangleFanDrawMode: renderer.setMode( 6 ); break; } } } else if ( object.isLine ) { var lineWidth = material.linewidth; if ( lineWidth === undefined ) lineWidth = 1; // Not using Line*Material state.setLineWidth( lineWidth * getTargetPixelRatio() ); if ( object.isLineSegments ) { renderer.setMode( 1 ); } else if ( object.isLineLoop ) { renderer.setMode( 2 ); } else { renderer.setMode( 3 ); } } else if ( object.isPoints ) { renderer.setMode( 0 ); } else if ( object.isSprite ) { renderer.setMode( 4 ); } if ( geometry && geometry.isInstancedBufferGeometry ) { if ( geometry.maxInstancedCount > 0 ) { renderer.renderInstances( geometry, drawStart, drawCount ); } } else { renderer.render( drawStart, drawCount ); } }; function setupVertexAttributes( material, program, geometry ) { if ( geometry && geometry.isInstancedBufferGeometry && ! capabilities.isWebGL2 ) { if ( extensions.get( 'ANGLE_instanced_arrays' ) === null ) { console.error( 'THREE.WebGLRenderer.setupVertexAttributes: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.' ); return; } } state.initAttributes(); var geometryAttributes = geometry.attributes; var programAttributes = program.getAttributes(); var materialDefaultAttributeValues = material.defaultAttributeValues; for ( var name in programAttributes ) { var programAttribute = programAttributes[ name ]; if ( programAttribute >= 0 ) { var geometryAttribute = geometryAttributes[ name ]; if ( geometryAttribute !== undefined ) { var normalized = geometryAttribute.normalized; var size = geometryAttribute.itemSize; var attribute = attributes.get( geometryAttribute ); // TODO Attribute may not be available on context restore if ( attribute === undefined ) continue; var buffer = attribute.buffer; var type = attribute.type; var bytesPerElement = attribute.bytesPerElement; if ( geometryAttribute.isInterleavedBufferAttribute ) { var data = geometryAttribute.data; var stride = data.stride; var offset = geometryAttribute.offset; if ( data && data.isInstancedInterleavedBuffer ) { state.enableAttributeAndDivisor( programAttribute, data.meshPerAttribute ); if ( geometry.maxInstancedCount === undefined ) { geometry.maxInstancedCount = data.meshPerAttribute * data.count; } } else { state.enableAttribute( programAttribute ); } _gl.bindBuffer( 34962, buffer ); _gl.vertexAttribPointer( programAttribute, size, type, normalized, stride * bytesPerElement, offset * bytesPerElement ); } else { if ( geometryAttribute.isInstancedBufferAttribute ) { state.enableAttributeAndDivisor( programAttribute, geometryAttribute.meshPerAttribute ); if ( geometry.maxInstancedCount === undefined ) { geometry.maxInstancedCount = geometryAttribute.meshPerAttribute * geometryAttribute.count; } } else { state.enableAttribute( programAttribute ); } _gl.bindBuffer( 34962, buffer ); _gl.vertexAttribPointer( programAttribute, size, type, normalized, 0, 0 ); } } else if ( materialDefaultAttributeValues !== undefined ) { var value = materialDefaultAttributeValues[ name ]; if ( value !== undefined ) { switch ( value.length ) { case 2: _gl.vertexAttrib2fv( programAttribute, value ); break; case 3: _gl.vertexAttrib3fv( programAttribute, value ); break; case 4: _gl.vertexAttrib4fv( programAttribute, value ); break; default: _gl.vertexAttrib1fv( programAttribute, value ); } } } } } state.disableUnusedAttributes(); } // Compile this.compile = function ( scene, camera ) { currentRenderState = renderStates.get( scene, camera ); currentRenderState.init(); scene.traverse( function ( object ) { if ( object.isLight ) { currentRenderState.pushLight( object ); if ( object.castShadow ) { currentRenderState.pushShadow( object ); } } } ); currentRenderState.setupLights( camera ); scene.traverse( function ( object ) { if ( object.material ) { if ( Array.isArray( object.material ) ) { for ( var i = 0; i < object.material.length; i ++ ) { initMaterial( object.material[ i ], scene.fog, object ); } } else { initMaterial( object.material, scene.fog, object ); } } } ); }; // Animation Loop var onAnimationFrameCallback = null; function onAnimationFrame( time ) { if ( vr.isPresenting() ) return; if ( onAnimationFrameCallback ) onAnimationFrameCallback( time ); } var animation = new WebGLAnimation(); animation.setAnimationLoop( onAnimationFrame ); if ( typeof window !== 'undefined' ) animation.setContext( window ); this.setAnimationLoop = function ( callback ) { onAnimationFrameCallback = callback; vr.setAnimationLoop( callback ); animation.start(); }; // Rendering this.render = function ( scene, camera ) { var renderTarget, forceClear; if ( arguments[ 2 ] !== undefined ) { console.warn( 'THREE.WebGLRenderer.render(): the renderTarget argument has been removed. Use .setRenderTarget() instead.' ); renderTarget = arguments[ 2 ]; } if ( arguments[ 3 ] !== undefined ) { console.warn( 'THREE.WebGLRenderer.render(): the forceClear argument has been removed. Use .clear() instead.' ); forceClear = arguments[ 3 ]; } if ( ! ( camera && camera.isCamera ) ) { console.error( 'THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.' ); return; } if ( _isContextLost ) return; // reset caching for this frame _currentGeometryProgram.geometry = null; _currentGeometryProgram.program = null; _currentGeometryProgram.wireframe = false; _currentMaterialId = - 1; _currentCamera = null; // update scene graph if ( scene.autoUpdate === true ) scene.updateMatrixWorld(); // update camera matrices and frustum if ( camera.parent === null ) camera.updateMatrixWorld(); if ( vr.enabled ) { camera = vr.getCamera( camera ); } // currentRenderState = renderStates.get( scene, camera ); currentRenderState.init(); scene.onBeforeRender( _this, scene, camera, renderTarget ); _projScreenMatrix.multiplyMatrices( camera.projectionMatrix, camera.matrixWorldInverse ); _frustum.setFromMatrix( _projScreenMatrix ); _localClippingEnabled = this.localClippingEnabled; _clippingEnabled = _clipping.init( this.clippingPlanes, _localClippingEnabled, camera ); currentRenderList = renderLists.get( scene, camera ); currentRenderList.init(); projectObject( scene, camera, 0, _this.sortObjects ); if ( _this.sortObjects === true ) { currentRenderList.sort(); } // if ( _clippingEnabled ) _clipping.beginShadows(); var shadowsArray = currentRenderState.state.shadowsArray; shadowMap.render( shadowsArray, scene, camera ); currentRenderState.setupLights( camera ); if ( _clippingEnabled ) _clipping.endShadows(); // if ( this.info.autoReset ) this.info.reset(); if ( renderTarget !== undefined ) { this.setRenderTarget( renderTarget ); } // background.render( currentRenderList, scene, camera, forceClear ); // render scene var opaqueObjects = currentRenderList.opaque; var transparentObjects = currentRenderList.transparent; if ( scene.overrideMaterial ) { var overrideMaterial = scene.overrideMaterial; if ( opaqueObjects.length ) renderObjects( opaqueObjects, scene, camera, overrideMaterial ); if ( transparentObjects.length ) renderObjects( transparentObjects, scene, camera, overrideMaterial ); } else { // opaque pass (front-to-back order) if ( opaqueObjects.length ) renderObjects( opaqueObjects, scene, camera ); // transparent pass (back-to-front order) if ( transparentObjects.length ) renderObjects( transparentObjects, scene, camera ); } // if ( renderTarget ) { // Generate mipmap if we're using any kind of mipmap filtering textures.updateRenderTargetMipmap( renderTarget ); // resolve multisample renderbuffers to a single-sample texture if necessary textures.updateMultisampleRenderTarget( renderTarget ); } // Ensure depth buffer writing is enabled so it can be cleared on next render state.buffers.depth.setTest( true ); state.buffers.depth.setMask( true ); state.buffers.color.setMask( true ); state.setPolygonOffset( false ); scene.onAfterRender( _this, scene, camera ); if ( vr.enabled ) { vr.submitFrame(); } // _gl.finish(); currentRenderList = null; currentRenderState = null; }; function projectObject( object, camera, groupOrder, sortObjects ) { if ( object.visible === false ) return; var visible = object.layers.test( camera.layers ); if ( visible ) { if ( object.isGroup ) { groupOrder = object.renderOrder; } else if ( object.isLight ) { currentRenderState.pushLight( object ); if ( object.castShadow ) { currentRenderState.pushShadow( object ); } } else if ( object.isSprite ) { if ( ! object.frustumCulled || _frustum.intersectsSprite( object ) ) { if ( sortObjects ) { _vector3.setFromMatrixPosition( object.matrixWorld ) .applyMatrix4( _projScreenMatrix ); } var geometry = objects.update( object ); var material = object.material; currentRenderList.push( object, geometry, material, groupOrder, _vector3.z, null ); } } else if ( object.isImmediateRenderObject ) { if ( sortObjects ) { _vector3.setFromMatrixPosition( object.matrixWorld ) .applyMatrix4( _projScreenMatrix ); } currentRenderList.push( object, null, object.material, groupOrder, _vector3.z, null ); } else if ( object.isMesh || object.isLine || object.isPoints ) { if ( object.isSkinnedMesh ) { object.skeleton.update(); } if ( ! object.frustumCulled || _frustum.intersectsObject( object ) ) { if ( sortObjects ) { _vector3.setFromMatrixPosition( object.matrixWorld ) .applyMatrix4( _projScreenMatrix ); } var geometry = objects.update( object ); var material = object.material; if ( Array.isArray( material ) ) { var groups = geometry.groups; for ( var i = 0, l = groups.length; i < l; i ++ ) { var group = groups[ i ]; var groupMaterial = material[ group.materialIndex ]; if ( groupMaterial && groupMaterial.visible ) { currentRenderList.push( object, geometry, groupMaterial, groupOrder, _vector3.z, group ); } } } else if ( material.visible ) { currentRenderList.push( object, geometry, material, groupOrder, _vector3.z, null ); } } } } var children = object.children; for ( var i = 0, l = children.length; i < l; i ++ ) { projectObject( children[ i ], camera, groupOrder, sortObjects ); } } function renderObjects( renderList, scene, camera, overrideMaterial ) { for ( var i = 0, l = renderList.length; i < l; i ++ ) { var renderItem = renderList[ i ]; var object = renderItem.object; var geometry = renderItem.geometry; var material = overrideMaterial === undefined ? renderItem.material : overrideMaterial; var group = renderItem.group; if ( camera.isArrayCamera ) { _currentArrayCamera = camera; var cameras = camera.cameras; for ( var j = 0, jl = cameras.length; j < jl; j ++ ) { var camera2 = cameras[ j ]; if ( object.layers.test( camera2.layers ) ) { if ( 'viewport' in camera2 ) { // XR state.viewport( _currentViewport.copy( camera2.viewport ) ); } else { var bounds = camera2.bounds; var x = bounds.x * _width; var y = bounds.y * _height; var width = bounds.z * _width; var height = bounds.w * _height; state.viewport( _currentViewport.set( x, y, width, height ).multiplyScalar( _pixelRatio ) ); } currentRenderState.setupLights( camera2 ); renderObject( object, scene, camera2, geometry, material, group ); } } } else { _currentArrayCamera = null; renderObject( object, scene, camera, geometry, material, group ); } } } function renderObject( object, scene, camera, geometry, material, group ) { object.onBeforeRender( _this, scene, camera, geometry, material, group ); currentRenderState = renderStates.get( scene, _currentArrayCamera || camera ); object.modelViewMatrix.multiplyMatrices( camera.matrixWorldInverse, object.matrixWorld ); object.normalMatrix.getNormalMatrix( object.modelViewMatrix ); if ( object.isImmediateRenderObject ) { state.setMaterial( material ); var program = setProgram( camera, scene.fog, material, object ); _currentGeometryProgram.geometry = null; _currentGeometryProgram.program = null; _currentGeometryProgram.wireframe = false; renderObjectImmediate( object, program ); } else { _this.renderBufferDirect( camera, scene.fog, geometry, material, object, group ); } object.onAfterRender( _this, scene, camera, geometry, material, group ); currentRenderState = renderStates.get( scene, _currentArrayCamera || camera ); } function initMaterial( material, fog, object ) { var materialProperties = properties.get( material ); var lights = currentRenderState.state.lights; var shadowsArray = currentRenderState.state.shadowsArray; var lightsHash = materialProperties.lightsHash; var lightsStateHash = lights.state.hash; var parameters = programCache.getParameters( material, lights.state, shadowsArray, fog, _clipping.numPlanes, _clipping.numIntersection, object ); var code = programCache.getProgramCode( material, parameters ); var program = materialProperties.program; var programChange = true; if ( program === undefined ) { // new material material.addEventListener( 'dispose', onMaterialDispose ); } else if ( program.code !== code ) { // changed glsl or parameters releaseMaterialProgramReference( material ); } else if ( lightsHash.stateID !== lightsStateHash.stateID || lightsHash.directionalLength !== lightsStateHash.directionalLength || lightsHash.pointLength !== lightsStateHash.pointLength || lightsHash.spotLength !== lightsStateHash.spotLength || lightsHash.rectAreaLength !== lightsStateHash.rectAreaLength || lightsHash.hemiLength !== lightsStateHash.hemiLength || lightsHash.shadowsLength !== lightsStateHash.shadowsLength ) { lightsHash.stateID = lightsStateHash.stateID; lightsHash.directionalLength = lightsStateHash.directionalLength; lightsHash.pointLength = lightsStateHash.pointLength; lightsHash.spotLength = lightsStateHash.spotLength; lightsHash.rectAreaLength = lightsStateHash.rectAreaLength; lightsHash.hemiLength = lightsStateHash.hemiLength; lightsHash.shadowsLength = lightsStateHash.shadowsLength; programChange = false; } else if ( parameters.shaderID !== undefined ) { // same glsl and uniform list return; } else { // only rebuild uniform list programChange = false; } if ( programChange ) { if ( parameters.shaderID ) { var shader = ShaderLib[ parameters.shaderID ]; materialProperties.shader = { name: material.type, uniforms: cloneUniforms( shader.uniforms ), vertexShader: shader.vertexShader, fragmentShader: shader.fragmentShader }; } else { materialProperties.shader = { name: material.type, uniforms: material.uniforms, vertexShader: material.vertexShader, fragmentShader: material.fragmentShader }; } material.onBeforeCompile( materialProperties.shader, _this ); // Computing code again as onBeforeCompile may have changed the shaders code = programCache.getProgramCode( material, parameters ); program = programCache.acquireProgram( material, materialProperties.shader, parameters, code ); materialProperties.program = program; material.program = program; } var programAttributes = program.getAttributes(); if ( material.morphTargets ) { material.numSupportedMorphTargets = 0; for ( var i = 0; i < _this.maxMorphTargets; i ++ ) { if ( programAttributes[ 'morphTarget' + i ] >= 0 ) { material.numSupportedMorphTargets ++; } } } if ( material.morphNormals ) { material.numSupportedMorphNormals = 0; for ( var i = 0; i < _this.maxMorphNormals; i ++ ) { if ( programAttributes[ 'morphNormal' + i ] >= 0 ) { material.numSupportedMorphNormals ++; } } } var uniforms = materialProperties.shader.uniforms; if ( ! material.isShaderMaterial && ! material.isRawShaderMaterial || material.clipping === true ) { materialProperties.numClippingPlanes = _clipping.numPlanes; materialProperties.numIntersection = _clipping.numIntersection; uniforms.clippingPlanes = _clipping.uniform; } materialProperties.fog = fog; // store the light setup it was created for if ( lightsHash === undefined ) { materialProperties.lightsHash = lightsHash = {}; } lightsHash.stateID = lightsStateHash.stateID; lightsHash.directionalLength = lightsStateHash.directionalLength; lightsHash.pointLength = lightsStateHash.pointLength; lightsHash.spotLength = lightsStateHash.spotLength; lightsHash.rectAreaLength = lightsStateHash.rectAreaLength; lightsHash.hemiLength = lightsStateHash.hemiLength; lightsHash.shadowsLength = lightsStateHash.shadowsLength; if ( material.lights ) { // wire up the material to this renderer's lighting state uniforms.ambientLightColor.value = lights.state.ambient; uniforms.directionalLights.value = lights.state.directional; uniforms.spotLights.value = lights.state.spot; uniforms.rectAreaLights.value = lights.state.rectArea; uniforms.pointLights.value = lights.state.point; uniforms.hemisphereLights.value = lights.state.hemi; uniforms.directionalShadowMap.value = lights.state.directionalShadowMap; uniforms.directionalShadowMatrix.value = lights.state.directionalShadowMatrix; uniforms.spotShadowMap.value = lights.state.spotShadowMap; uniforms.spotShadowMatrix.value = lights.state.spotShadowMatrix; uniforms.pointShadowMap.value = lights.state.pointShadowMap; uniforms.pointShadowMatrix.value = lights.state.pointShadowMatrix; // TODO (abelnation): add area lights shadow info to uniforms } var progUniforms = materialProperties.program.getUniforms(), uniformsList = WebGLUniforms.seqWithValue( progUniforms.seq, uniforms ); materialProperties.uniformsList = uniformsList; } function setProgram( camera, fog, material, object ) { _usedTextureUnits = 0; var materialProperties = properties.get( material ); var lights = currentRenderState.state.lights; var lightsHash = materialProperties.lightsHash; var lightsStateHash = lights.state.hash; if ( _clippingEnabled ) { if ( _localClippingEnabled || camera !== _currentCamera ) { var useCache = camera === _currentCamera && material.id === _currentMaterialId; // we might want to call this function with some ClippingGroup // object instead of the material, once it becomes feasible // (#8465, #8379) _clipping.setState( material.clippingPlanes, material.clipIntersection, material.clipShadows, camera, materialProperties, useCache ); } } if ( material.needsUpdate === false ) { if ( materialProperties.program === undefined ) { material.needsUpdate = true; } else if ( material.fog && materialProperties.fog !== fog ) { material.needsUpdate = true; } else if ( material.lights && ( lightsHash.stateID !== lightsStateHash.stateID || lightsHash.directionalLength !== lightsStateHash.directionalLength || lightsHash.pointLength !== lightsStateHash.pointLength || lightsHash.spotLength !== lightsStateHash.spotLength || lightsHash.rectAreaLength !== lightsStateHash.rectAreaLength || lightsHash.hemiLength !== lightsStateHash.hemiLength || lightsHash.shadowsLength !== lightsStateHash.shadowsLength ) ) { material.needsUpdate = true; } else if ( materialProperties.numClippingPlanes !== undefined && ( materialProperties.numClippingPlanes !== _clipping.numPlanes || materialProperties.numIntersection !== _clipping.numIntersection ) ) { material.needsUpdate = true; } } if ( material.needsUpdate ) { initMaterial( material, fog, object ); material.needsUpdate = false; } var refreshProgram = false; var refreshMaterial = false; var refreshLights = false; var program = materialProperties.program, p_uniforms = program.getUniforms(), m_uniforms = materialProperties.shader.uniforms; if ( state.useProgram( program.program ) ) { refreshProgram = true; refreshMaterial = true; refreshLights = true; } if ( material.id !== _currentMaterialId ) { _currentMaterialId = material.id; refreshMaterial = true; } if ( refreshProgram || _currentCamera !== camera ) { p_uniforms.setValue( _gl, 'projectionMatrix', camera.projectionMatrix ); if ( capabilities.logarithmicDepthBuffer ) { p_uniforms.setValue( _gl, 'logDepthBufFC', 2.0 / ( Math.log( camera.far + 1.0 ) / Math.LN2 ) ); } if ( _currentCamera !== camera ) { _currentCamera = camera; // lighting uniforms depend on the camera so enforce an update // now, in case this material supports lights - or later, when // the next material that does gets activated: refreshMaterial = true; // set to true on material change refreshLights = true; // remains set until update done } // load material specific uniforms // (shader material also gets them for the sake of genericity) if ( material.isShaderMaterial || material.isMeshPhongMaterial || material.isMeshStandardMaterial || material.envMap ) { var uCamPos = p_uniforms.map.cameraPosition; if ( uCamPos !== undefined ) { uCamPos.setValue( _gl, _vector3.setFromMatrixPosition( camera.matrixWorld ) ); } } if ( material.isMeshPhongMaterial || material.isMeshLambertMaterial || material.isMeshBasicMaterial || material.isMeshStandardMaterial || material.isShaderMaterial || material.skinning ) { p_uniforms.setValue( _gl, 'viewMatrix', camera.matrixWorldInverse ); } } // skinning uniforms must be set even if material didn't change // auto-setting of texture unit for bone texture must go before other textures // not sure why, but otherwise weird things happen if ( material.skinning ) { p_uniforms.setOptional( _gl, object, 'bindMatrix' ); p_uniforms.setOptional( _gl, object, 'bindMatrixInverse' ); var skeleton = object.skeleton; if ( skeleton ) { var bones = skeleton.bones; if ( capabilities.floatVertexTextures ) { if ( skeleton.boneTexture === undefined ) { // layout (1 matrix = 4 pixels) // RGBA RGBA RGBA RGBA (=> column1, column2, column3, column4) // with 8x8 pixel texture max 16 bones * 4 pixels = (8 * 8) // 16x16 pixel texture max 64 bones * 4 pixels = (16 * 16) // 32x32 pixel texture max 256 bones * 4 pixels = (32 * 32) // 64x64 pixel texture max 1024 bones * 4 pixels = (64 * 64) var size = Math.sqrt( bones.length * 4 ); // 4 pixels needed for 1 matrix size = _Math.ceilPowerOfTwo( size ); size = Math.max( size, 4 ); var boneMatrices = new Float32Array( size * size * 4 ); // 4 floats per RGBA pixel boneMatrices.set( skeleton.boneMatrices ); // copy current values var boneTexture = new DataTexture( boneMatrices, size, size, RGBAFormat, FloatType ); boneTexture.needsUpdate = true; skeleton.boneMatrices = boneMatrices; skeleton.boneTexture = boneTexture; skeleton.boneTextureSize = size; } p_uniforms.setValue( _gl, 'boneTexture', skeleton.boneTexture ); p_uniforms.setValue( _gl, 'boneTextureSize', skeleton.boneTextureSize ); } else { p_uniforms.setOptional( _gl, skeleton, 'boneMatrices' ); } } } if ( refreshMaterial ) { p_uniforms.setValue( _gl, 'toneMappingExposure', _this.toneMappingExposure ); p_uniforms.setValue( _gl, 'toneMappingWhitePoint', _this.toneMappingWhitePoint ); if ( material.lights ) { // the current material requires lighting info // note: all lighting uniforms are always set correctly // they simply reference the renderer's state for their // values // // use the current material's .needsUpdate flags to set // the GL state when required markUniformsLightsNeedsUpdate( m_uniforms, refreshLights ); } // refresh uniforms common to several materials if ( fog && material.fog ) { refreshUniformsFog( m_uniforms, fog ); } if ( material.isMeshBasicMaterial ) { refreshUniformsCommon( m_uniforms, material ); } else if ( material.isMeshLambertMaterial ) { refreshUniformsCommon( m_uniforms, material ); refreshUniformsLambert( m_uniforms, material ); } else if ( material.isMeshPhongMaterial ) { refreshUniformsCommon( m_uniforms, material ); if ( material.isMeshToonMaterial ) { refreshUniformsToon( m_uniforms, material ); } else { refreshUniformsPhong( m_uniforms, material ); } } else if ( material.isMeshStandardMaterial ) { refreshUniformsCommon( m_uniforms, material ); if ( material.isMeshPhysicalMaterial ) { refreshUniformsPhysical( m_uniforms, material ); } else { refreshUniformsStandard( m_uniforms, material ); } } else if ( material.isMeshMatcapMaterial ) { refreshUniformsCommon( m_uniforms, material ); refreshUniformsMatcap( m_uniforms, material ); } else if ( material.isMeshDepthMaterial ) { refreshUniformsCommon( m_uniforms, material ); refreshUniformsDepth( m_uniforms, material ); } else if ( material.isMeshDistanceMaterial ) { refreshUniformsCommon( m_uniforms, material ); refreshUniformsDistance( m_uniforms, material ); } else if ( material.isMeshNormalMaterial ) { refreshUniformsCommon( m_uniforms, material ); refreshUniformsNormal( m_uniforms, material ); } else if ( material.isLineBasicMaterial ) { refreshUniformsLine( m_uniforms, material ); if ( material.isLineDashedMaterial ) { refreshUniformsDash( m_uniforms, material ); } } else if ( material.isPointsMaterial ) { refreshUniformsPoints( m_uniforms, material ); } else if ( material.isSpriteMaterial ) { refreshUniformsSprites( m_uniforms, material ); } else if ( material.isShadowMaterial ) { m_uniforms.color.value = material.color; m_uniforms.opacity.value = material.opacity; } // RectAreaLight Texture // TODO (mrdoob): Find a nicer implementation if ( m_uniforms.ltc_1 !== undefined ) m_uniforms.ltc_1.value = UniformsLib.LTC_1; if ( m_uniforms.ltc_2 !== undefined ) m_uniforms.ltc_2.value = UniformsLib.LTC_2; WebGLUniforms.upload( _gl, materialProperties.uniformsList, m_uniforms, _this ); } if ( material.isShaderMaterial && material.uniformsNeedUpdate === true ) { WebGLUniforms.upload( _gl, materialProperties.uniformsList, m_uniforms, _this ); material.uniformsNeedUpdate = false; } if ( material.isSpriteMaterial ) { p_uniforms.setValue( _gl, 'center', object.center ); } // common matrices p_uniforms.setValue( _gl, 'modelViewMatrix', object.modelViewMatrix ); p_uniforms.setValue( _gl, 'normalMatrix', object.normalMatrix ); p_uniforms.setValue( _gl, 'modelMatrix', object.matrixWorld ); return program; } // Uniforms (refresh uniforms objects) function refreshUniformsCommon( uniforms, material ) { uniforms.opacity.value = material.opacity; if ( material.color ) { uniforms.diffuse.value = material.color; } if ( material.emissive ) { uniforms.emissive.value.copy( material.emissive ).multiplyScalar( material.emissiveIntensity ); } if ( material.map ) { uniforms.map.value = material.map; } if ( material.alphaMap ) { uniforms.alphaMap.value = material.alphaMap; } if ( material.specularMap ) { uniforms.specularMap.value = material.specularMap; } if ( material.envMap ) { uniforms.envMap.value = material.envMap; // don't flip CubeTexture envMaps, flip everything else: // WebGLRenderTargetCube will be flipped for backwards compatibility // WebGLRenderTargetCube.texture will be flipped because it's a Texture and NOT a CubeTexture // this check must be handled differently, or removed entirely, if WebGLRenderTargetCube uses a CubeTexture in the future uniforms.flipEnvMap.value = material.envMap.isCubeTexture ? - 1 : 1; uniforms.reflectivity.value = material.reflectivity; uniforms.refractionRatio.value = material.refractionRatio; uniforms.maxMipLevel.value = properties.get( material.envMap ).__maxMipLevel; } if ( material.lightMap ) { uniforms.lightMap.value = material.lightMap; uniforms.lightMapIntensity.value = material.lightMapIntensity; } if ( material.aoMap ) { uniforms.aoMap.value = material.aoMap; uniforms.aoMapIntensity.value = material.aoMapIntensity; } // uv repeat and offset setting priorities // 1. color map // 2. specular map // 3. normal map // 4. bump map // 5. alpha map // 6. emissive map var uvScaleMap; if ( material.map ) { uvScaleMap = material.map; } else if ( material.specularMap ) { uvScaleMap = material.specularMap; } else if ( material.displacementMap ) { uvScaleMap = material.displacementMap; } else if ( material.normalMap ) { uvScaleMap = material.normalMap; } else if ( material.bumpMap ) { uvScaleMap = material.bumpMap; } else if ( material.roughnessMap ) { uvScaleMap = material.roughnessMap; } else if ( material.metalnessMap ) { uvScaleMap = material.metalnessMap; } else if ( material.alphaMap ) { uvScaleMap = material.alphaMap; } else if ( material.emissiveMap ) { uvScaleMap = material.emissiveMap; } if ( uvScaleMap !== undefined ) { // backwards compatibility if ( uvScaleMap.isWebGLRenderTarget ) { uvScaleMap = uvScaleMap.texture; } if ( uvScaleMap.matrixAutoUpdate === true ) { uvScaleMap.updateMatrix(); } uniforms.uvTransform.value.copy( uvScaleMap.matrix ); } } function refreshUniformsLine( uniforms, material ) { uniforms.diffuse.value = material.color; uniforms.opacity.value = material.opacity; } function refreshUniformsDash( uniforms, material ) { uniforms.dashSize.value = material.dashSize; uniforms.totalSize.value = material.dashSize + material.gapSize; uniforms.scale.value = material.scale; } function refreshUniformsPoints( uniforms, material ) { uniforms.diffuse.value = material.color; uniforms.opacity.value = material.opacity; uniforms.size.value = material.size * _pixelRatio; uniforms.scale.value = _height * 0.5; uniforms.map.value = material.map; if ( material.map !== null ) { if ( material.map.matrixAutoUpdate === true ) { material.map.updateMatrix(); } uniforms.uvTransform.value.copy( material.map.matrix ); } } function refreshUniformsSprites( uniforms, material ) { uniforms.diffuse.value = material.color; uniforms.opacity.value = material.opacity; uniforms.rotation.value = material.rotation; uniforms.map.value = material.map; if ( material.map !== null ) { if ( material.map.matrixAutoUpdate === true ) { material.map.updateMatrix(); } uniforms.uvTransform.value.copy( material.map.matrix ); } } function refreshUniformsFog( uniforms, fog ) { uniforms.fogColor.value = fog.color; if ( fog.isFog ) { uniforms.fogNear.value = fog.near; uniforms.fogFar.value = fog.far; } else if ( fog.isFogExp2 ) { uniforms.fogDensity.value = fog.density; } } function refreshUniformsLambert( uniforms, material ) { if ( material.emissiveMap ) { uniforms.emissiveMap.value = material.emissiveMap; } } function refreshUniformsPhong( uniforms, material ) { uniforms.specular.value = material.specular; uniforms.shininess.value = Math.max( material.shininess, 1e-4 ); // to prevent pow( 0.0, 0.0 ) if ( material.emissiveMap ) { uniforms.emissiveMap.value = material.emissiveMap; } if ( material.bumpMap ) { uniforms.bumpMap.value = material.bumpMap; uniforms.bumpScale.value = material.bumpScale; if ( material.side === BackSide ) uniforms.bumpScale.value *= - 1; } if ( material.normalMap ) { uniforms.normalMap.value = material.normalMap; uniforms.normalScale.value.copy( material.normalScale ); if ( material.side === BackSide ) uniforms.normalScale.value.negate(); } if ( material.displacementMap ) { uniforms.displacementMap.value = material.displacementMap; uniforms.displacementScale.value = material.displacementScale; uniforms.displacementBias.value = material.displacementBias; } } function refreshUniformsToon( uniforms, material ) { refreshUniformsPhong( uniforms, material ); if ( material.gradientMap ) { uniforms.gradientMap.value = material.gradientMap; } } function refreshUniformsStandard( uniforms, material ) { uniforms.roughness.value = material.roughness; uniforms.metalness.value = material.metalness; if ( material.roughnessMap ) { uniforms.roughnessMap.value = material.roughnessMap; } if ( material.metalnessMap ) { uniforms.metalnessMap.value = material.metalnessMap; } if ( material.emissiveMap ) { uniforms.emissiveMap.value = material.emissiveMap; } if ( material.bumpMap ) { uniforms.bumpMap.value = material.bumpMap; uniforms.bumpScale.value = material.bumpScale; if ( material.side === BackSide ) uniforms.bumpScale.value *= - 1; } if ( material.normalMap ) { uniforms.normalMap.value = material.normalMap; uniforms.normalScale.value.copy( material.normalScale ); if ( material.side === BackSide ) uniforms.normalScale.value.negate(); } if ( material.displacementMap ) { uniforms.displacementMap.value = material.displacementMap; uniforms.displacementScale.value = material.displacementScale; uniforms.displacementBias.value = material.displacementBias; } if ( material.envMap ) { //uniforms.envMap.value = material.envMap; // part of uniforms common uniforms.envMapIntensity.value = material.envMapIntensity; } } function refreshUniformsPhysical( uniforms, material ) { refreshUniformsStandard( uniforms, material ); uniforms.reflectivity.value = material.reflectivity; // also part of uniforms common uniforms.clearCoat.value = material.clearCoat; uniforms.clearCoatRoughness.value = material.clearCoatRoughness; } function refreshUniformsMatcap( uniforms, material ) { if ( material.matcap ) { uniforms.matcap.value = material.matcap; } if ( material.bumpMap ) { uniforms.bumpMap.value = material.bumpMap; uniforms.bumpScale.value = material.bumpScale; if ( material.side === BackSide ) uniforms.bumpScale.value *= - 1; } if ( material.normalMap ) { uniforms.normalMap.value = material.normalMap; uniforms.normalScale.value.copy( material.normalScale ); if ( material.side === BackSide ) uniforms.normalScale.value.negate(); } if ( material.displacementMap ) { uniforms.displacementMap.value = material.displacementMap; uniforms.displacementScale.value = material.displacementScale; uniforms.displacementBias.value = material.displacementBias; } } function refreshUniformsDepth( uniforms, material ) { if ( material.displacementMap ) { uniforms.displacementMap.value = material.displacementMap; uniforms.displacementScale.value = material.displacementScale; uniforms.displacementBias.value = material.displacementBias; } } function refreshUniformsDistance( uniforms, material ) { if ( material.displacementMap ) { uniforms.displacementMap.value = material.displacementMap; uniforms.displacementScale.value = material.displacementScale; uniforms.displacementBias.value = material.displacementBias; } uniforms.referencePosition.value.copy( material.referencePosition ); uniforms.nearDistance.value = material.nearDistance; uniforms.farDistance.value = material.farDistance; } function refreshUniformsNormal( uniforms, material ) { if ( material.bumpMap ) { uniforms.bumpMap.value = material.bumpMap; uniforms.bumpScale.value = material.bumpScale; if ( material.side === BackSide ) uniforms.bumpScale.value *= - 1; } if ( material.normalMap ) { uniforms.normalMap.value = material.normalMap; uniforms.normalScale.value.copy( material.normalScale ); if ( material.side === BackSide ) uniforms.normalScale.value.negate(); } if ( material.displacementMap ) { uniforms.displacementMap.value = material.displacementMap; uniforms.displacementScale.value = material.displacementScale; uniforms.displacementBias.value = material.displacementBias; } } // If uniforms are marked as clean, they don't need to be loaded to the GPU. function markUniformsLightsNeedsUpdate( uniforms, value ) { uniforms.ambientLightColor.needsUpdate = value; uniforms.directionalLights.needsUpdate = value; uniforms.pointLights.needsUpdate = value; uniforms.spotLights.needsUpdate = value; uniforms.rectAreaLights.needsUpdate = value; uniforms.hemisphereLights.needsUpdate = value; } // Textures function allocTextureUnit() { var textureUnit = _usedTextureUnits; if ( textureUnit >= capabilities.maxTextures ) { console.warn( 'THREE.WebGLRenderer: Trying to use ' + textureUnit + ' texture units while this GPU supports only ' + capabilities.maxTextures ); } _usedTextureUnits += 1; return textureUnit; } this.allocTextureUnit = allocTextureUnit; // this.setTexture2D = setTexture2D; this.setTexture2D = ( function () { var warned = false; // backwards compatibility: peel texture.texture return function setTexture2D( texture, slot ) { if ( texture && texture.isWebGLRenderTarget ) { if ( ! warned ) { console.warn( \"THREE.WebGLRenderer.setTexture2D: don't use render targets as textures. Use their .texture property instead.\" ); warned = true; } texture = texture.texture; } textures.setTexture2D( texture, slot ); }; }() ); this.setTexture3D = ( function () { // backwards compatibility: peel texture.texture return function setTexture3D( texture, slot ) { textures.setTexture3D( texture, slot ); }; }() ); this.setTexture = ( function () { var warned = false; return function setTexture( texture, slot ) { if ( ! warned ) { console.warn( \"THREE.WebGLRenderer: .setTexture is deprecated, use setTexture2D instead.\" ); warned = true; } textures.setTexture2D( texture, slot ); }; }() ); this.setTextureCube = ( function () { var warned = false; return function setTextureCube( texture, slot ) { // backwards compatibility: peel texture.texture if ( texture && texture.isWebGLRenderTargetCube ) { if ( ! warned ) { console.warn( \"THREE.WebGLRenderer.setTextureCube: don't use cube render targets as textures. Use their .texture property instead.\" ); warned = true; } texture = texture.texture; } // currently relying on the fact that WebGLRenderTargetCube.texture is a Texture and NOT a CubeTexture // TODO: unify these code paths if ( ( texture && texture.isCubeTexture ) || ( Array.isArray( texture.image ) && texture.image.length === 6 ) ) { // CompressedTexture can have Array in image :/ // this function alone should take care of cube textures textures.setTextureCube( texture, slot ); } else { // assumed: texture property of THREE.WebGLRenderTargetCube textures.setTextureCubeDynamic( texture, slot ); } }; }() ); // this.setFramebuffer = function ( value ) { _framebuffer = value; }; this.getRenderTarget = function () { return _currentRenderTarget; }; this.setRenderTarget = function ( renderTarget ) { _currentRenderTarget = renderTarget; if ( renderTarget && properties.get( renderTarget ).__webglFramebuffer === undefined ) { textures.setupRenderTarget( renderTarget ); } var framebuffer = _framebuffer; var isCube = false; if ( renderTarget ) { var __webglFramebuffer = properties.get( renderTarget ).__webglFramebuffer; if ( renderTarget.isWebGLRenderTargetCube ) { framebuffer = __webglFramebuffer[ renderTarget.activeCubeFace ]; isCube = true; } else if ( renderTarget.isWebGLMultisampleRenderTarget ) { framebuffer = properties.get( renderTarget ).__webglMultisampledFramebuffer; } else { framebuffer = __webglFramebuffer; } _currentViewport.copy( renderTarget.viewport ); _currentScissor.copy( renderTarget.scissor ); _currentScissorTest = renderTarget.scissorTest; } else { _currentViewport.copy( _viewport ).multiplyScalar( _pixelRatio ); _currentScissor.copy( _scissor ).multiplyScalar( _pixelRatio ); _currentScissorTest = _scissorTest; } if ( _currentFramebuffer !== framebuffer ) { _gl.bindFramebuffer( 36160, framebuffer ); _currentFramebuffer = framebuffer; } state.viewport( _currentViewport ); state.scissor( _currentScissor ); state.setScissorTest( _currentScissorTest ); if ( isCube ) { var textureProperties = properties.get( renderTarget.texture ); _gl.framebufferTexture2D( 36160, 36064, 34069 + renderTarget.activeCubeFace, textureProperties.__webglTexture, renderTarget.activeMipMapLevel ); } }; this.readRenderTargetPixels = function ( renderTarget, x, y, width, height, buffer ) { if ( ! ( renderTarget && renderTarget.isWebGLRenderTarget ) ) { console.error( 'THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.' ); return; } var framebuffer = properties.get( renderTarget ).__webglFramebuffer; if ( framebuffer ) { var restore = false; if ( framebuffer !== _currentFramebuffer ) { _gl.bindFramebuffer( 36160, framebuffer ); restore = true; } try { var texture = renderTarget.texture; var textureFormat = texture.format; var textureType = texture.type; if ( textureFormat !== RGBAFormat && utils.convert( textureFormat ) !== _gl.getParameter( 35739 ) ) { console.error( 'THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.' ); return; } if ( textureType !== UnsignedByteType && utils.convert( textureType ) !== _gl.getParameter( 35738 ) && // IE11, Edge and Chrome Mac < 52 (#9513) ! ( textureType === FloatType && ( capabilities.isWebGL2 || extensions.get( 'OES_texture_float' ) || extensions.get( 'WEBGL_color_buffer_float' ) ) ) && // Chrome Mac >= 52 and Firefox ! ( textureType === HalfFloatType && ( capabilities.isWebGL2 ? extensions.get( 'EXT_color_buffer_float' ) : extensions.get( 'EXT_color_buffer_half_float' ) ) ) ) { console.error( 'THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.' ); return; } if ( _gl.checkFramebufferStatus( 36160 ) === 36053 ) { // the following if statement ensures valid read requests (no out-of-bounds pixels, see #8604) if ( ( x >= 0 && x = 0 && y 1 ) { v1.setFromMatrixPosition( camera.matrixWorld ); v2.setFromMatrixPosition( this.matrixWorld ); var distance = v1.distanceTo( v2 ); levels[ 0 ].object.visible = true; for ( var i = 1, l = levels.length; i < l; i ++ ) { if ( distance >= levels[ i ].distance ) { levels[ i - 1 ].object.visible = false; levels[ i ].object.visible = true; } else { break; } } for ( ; i < l; i ++ ) { levels[ i ].object.visible = false; } } }; }(), toJSON: function ( meta ) { var data = Object3D.prototype.toJSON.call( this, meta ); data.object.levels = []; var levels = this.levels; for ( var i = 0, l = levels.length; i < l; i ++ ) { var level = levels[ i ]; data.object.levels.push( { object: level.object.uuid, distance: level.distance } ); } return data; } } ); /** * @author mikael emtinger / http://gomo.se/ * @author alteredq / http://alteredqualia.com/ * @author ikerr / http://verold.com */ function SkinnedMesh( geometry, material ) { if ( geometry && geometry.isGeometry ) { console.error( 'THREE.SkinnedMesh no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.' ); } Mesh.call( this, geometry, material ); this.type = 'SkinnedMesh'; this.bindMode = 'attached'; this.bindMatrix = new Matrix4(); this.bindMatrixInverse = new Matrix4(); } SkinnedMesh.prototype = Object.assign( Object.create( Mesh.prototype ), { constructor: SkinnedMesh, isSkinnedMesh: true, bind: function ( skeleton, bindMatrix ) { this.skeleton = skeleton; if ( bindMatrix === undefined ) { this.updateMatrixWorld( true ); this.skeleton.calculateInverses(); bindMatrix = this.matrixWorld; } this.bindMatrix.copy( bindMatrix ); this.bindMatrixInverse.getInverse( bindMatrix ); }, pose: function () { this.skeleton.pose(); }, normalizeSkinWeights: function () { var vector = new Vector4(); var skinWeight = this.geometry.attributes.skinWeight; for ( var i = 0, l = skinWeight.count; i < l; i ++ ) { vector.x = skinWeight.getX( i ); vector.y = skinWeight.getY( i ); vector.z = skinWeight.getZ( i ); vector.w = skinWeight.getW( i ); var scale = 1.0 / vector.manhattanLength(); if ( scale !== Infinity ) { vector.multiplyScalar( scale ); } else { vector.set( 1, 0, 0, 0 ); // do something reasonable } skinWeight.setXYZW( i, vector.x, vector.y, vector.z, vector.w ); } }, updateMatrixWorld: function ( force ) { Mesh.prototype.updateMatrixWorld.call( this, force ); if ( this.bindMode === 'attached' ) { this.bindMatrixInverse.getInverse( this.matrixWorld ); } else if ( this.bindMode === 'detached' ) { this.bindMatrixInverse.getInverse( this.bindMatrix ); } else { console.warn( 'THREE.SkinnedMesh: Unrecognized bindMode: ' + this.bindMode ); } }, clone: function () { return new this.constructor( this.geometry, this.material ).copy( this ); } } ); /** * @author mikael emtinger / http://gomo.se/ * @author alteredq / http://alteredqualia.com/ * @author michael guerrero / http://realitymeltdown.com * @author ikerr / http://verold.com */ function Skeleton( bones, boneInverses ) { // copy the bone array bones = bones || []; this.bones = bones.slice( 0 ); this.boneMatrices = new Float32Array( this.bones.length * 16 ); // use the supplied bone inverses or calculate the inverses if ( boneInverses === undefined ) { this.calculateInverses(); } else { if ( this.bones.length === boneInverses.length ) { this.boneInverses = boneInverses.slice( 0 ); } else { console.warn( 'THREE.Skeleton boneInverses is the wrong length.' ); this.boneInverses = []; for ( var i = 0, il = this.bones.length; i < il; i ++ ) { this.boneInverses.push( new Matrix4() ); } } } } Object.assign( Skeleton.prototype, { calculateInverses: function () { this.boneInverses = []; for ( var i = 0, il = this.bones.length; i < il; i ++ ) { var inverse = new Matrix4(); if ( this.bones[ i ] ) { inverse.getInverse( this.bones[ i ].matrixWorld ); } this.boneInverses.push( inverse ); } }, pose: function () { var bone, i, il; // recover the bind-time world matrices for ( i = 0, il = this.bones.length; i < il; i ++ ) { bone = this.bones[ i ]; if ( bone ) { bone.matrixWorld.getInverse( this.boneInverses[ i ] ); } } // compute the local matrices, positions, rotations and scales for ( i = 0, il = this.bones.length; i < il; i ++ ) { bone = this.bones[ i ]; if ( bone ) { if ( bone.parent && bone.parent.isBone ) { bone.matrix.getInverse( bone.parent.matrixWorld ); bone.matrix.multiply( bone.matrixWorld ); } else { bone.matrix.copy( bone.matrixWorld ); } bone.matrix.decompose( bone.position, bone.quaternion, bone.scale ); } } }, update: ( function () { var offsetMatrix = new Matrix4(); var identityMatrix = new Matrix4(); return function update() { var bones = this.bones; var boneInverses = this.boneInverses; var boneMatrices = this.boneMatrices; var boneTexture = this.boneTexture; // flatten bone matrices to array for ( var i = 0, il = bones.length; i < il; i ++ ) { // compute the offset between the current and the original transform var matrix = bones[ i ] ? bones[ i ].matrixWorld : identityMatrix; offsetMatrix.multiplyMatrices( matrix, boneInverses[ i ] ); offsetMatrix.toArray( boneMatrices, i * 16 ); } if ( boneTexture !== undefined ) { boneTexture.needsUpdate = true; } }; } )(), clone: function () { return new Skeleton( this.bones, this.boneInverses ); }, getBoneByName: function ( name ) { for ( var i = 0, il = this.bones.length; i < il; i ++ ) { var bone = this.bones[ i ]; if ( bone.name === name ) { return bone; } } return undefined; } } ); /** * @author mikael emtinger / http://gomo.se/ * @author alteredq / http://alteredqualia.com/ * @author ikerr / http://verold.com */ function Bone() { Object3D.call( this ); this.type = 'Bone'; } Bone.prototype = Object.assign( Object.create( Object3D.prototype ), { constructor: Bone, isBone: true } ); /** * @author mrdoob / http://mrdoob.com/ * @author alteredq / http://alteredqualia.com/ * * parameters = { * color: , * opacity: , * * linewidth: , * linecap: \"round\", * linejoin: \"round\" * } */ function LineBasicMaterial( parameters ) { Material.call( this ); this.type = 'LineBasicMaterial'; this.color = new Color( 0xffffff ); this.linewidth = 1; this.linecap = 'round'; this.linejoin = 'round'; this.lights = false; this.setValues( parameters ); } LineBasicMaterial.prototype = Object.create( Material.prototype ); LineBasicMaterial.prototype.constructor = LineBasicMaterial; LineBasicMaterial.prototype.isLineBasicMaterial = true; LineBasicMaterial.prototype.copy = function ( source ) { Material.prototype.copy.call( this, source ); this.color.copy( source.color ); this.linewidth = source.linewidth; this.linecap = source.linecap; this.linejoin = source.linejoin; return this; }; /** * @author mrdoob / http://mrdoob.com/ */ function Line( geometry, material, mode ) { if ( mode === 1 ) { console.error( 'THREE.Line: parameter THREE.LinePieces no longer supported. Use THREE.LineSegments instead.' ); } Object3D.call( this ); this.type = 'Line'; this.geometry = geometry !== undefined ? geometry : new BufferGeometry(); this.material = material !== undefined ? material : new LineBasicMaterial( { color: Math.random() * 0xffffff } ); } Line.prototype = Object.assign( Object.create( Object3D.prototype ), { constructor: Line, isLine: true, computeLineDistances: ( function () { var start = new Vector3(); var end = new Vector3(); return function computeLineDistances() { var geometry = this.geometry; if ( geometry.isBufferGeometry ) { // we assume non-indexed geometry if ( geometry.index === null ) { var positionAttribute = geometry.attributes.position; var lineDistances = [ 0 ]; for ( var i = 1, l = positionAttribute.count; i < l; i ++ ) { start.fromBufferAttribute( positionAttribute, i - 1 ); end.fromBufferAttribute( positionAttribute, i ); lineDistances[ i ] = lineDistances[ i - 1 ]; lineDistances[ i ] += start.distanceTo( end ); } geometry.addAttribute( 'lineDistance', new Float32BufferAttribute( lineDistances, 1 ) ); } else { console.warn( 'THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.' ); } } else if ( geometry.isGeometry ) { var vertices = geometry.vertices; var lineDistances = geometry.lineDistances; lineDistances[ 0 ] = 0; for ( var i = 1, l = vertices.length; i < l; i ++ ) { lineDistances[ i ] = lineDistances[ i - 1 ]; lineDistances[ i ] += vertices[ i - 1 ].distanceTo( vertices[ i ] ); } } return this; }; }() ), raycast: ( function () { var inverseMatrix = new Matrix4(); var ray = new Ray(); var sphere = new Sphere(); return function raycast( raycaster, intersects ) { var precision = raycaster.linePrecision; var geometry = this.geometry; var matrixWorld = this.matrixWorld; // Checking boundingSphere distance to ray if ( geometry.boundingSphere === null ) geometry.computeBoundingSphere(); sphere.copy( geometry.boundingSphere ); sphere.applyMatrix4( matrixWorld ); sphere.radius += precision; if ( raycaster.ray.intersectsSphere( sphere ) === false ) return; // inverseMatrix.getInverse( matrixWorld ); ray.copy( raycaster.ray ).applyMatrix4( inverseMatrix ); var localPrecision = precision / ( ( this.scale.x + this.scale.y + this.scale.z ) / 3 ); var localPrecisionSq = localPrecision * localPrecision; var vStart = new Vector3(); var vEnd = new Vector3(); var interSegment = new Vector3(); var interRay = new Vector3(); var step = ( this && this.isLineSegments ) ? 2 : 1; if ( geometry.isBufferGeometry ) { var index = geometry.index; var attributes = geometry.attributes; var positions = attributes.position.array; if ( index !== null ) { var indices = index.array; for ( var i = 0, l = indices.length - 1; i < l; i += step ) { var a = indices[ i ]; var b = indices[ i + 1 ]; vStart.fromArray( positions, a * 3 ); vEnd.fromArray( positions, b * 3 ); var distSq = ray.distanceSqToSegment( vStart, vEnd, interRay, interSegment ); if ( distSq > localPrecisionSq ) continue; interRay.applyMatrix4( this.matrixWorld ); //Move back to world space for distance calculation var distance = raycaster.ray.origin.distanceTo( interRay ); if ( distance < raycaster.near || distance > raycaster.far ) continue; intersects.push( { distance: distance, // What do we want? intersection point on the ray or on the segment?? // point: raycaster.ray.at( distance ), point: interSegment.clone().applyMatrix4( this.matrixWorld ), index: i, face: null, faceIndex: null, object: this } ); } } else { for ( var i = 0, l = positions.length / 3 - 1; i < l; i += step ) { vStart.fromArray( positions, 3 * i ); vEnd.fromArray( positions, 3 * i + 3 ); var distSq = ray.distanceSqToSegment( vStart, vEnd, interRay, interSegment ); if ( distSq > localPrecisionSq ) continue; interRay.applyMatrix4( this.matrixWorld ); //Move back to world space for distance calculation var distance = raycaster.ray.origin.distanceTo( interRay ); if ( distance < raycaster.near || distance > raycaster.far ) continue; intersects.push( { distance: distance, // What do we want? intersection point on the ray or on the segment?? // point: raycaster.ray.at( distance ), point: interSegment.clone().applyMatrix4( this.matrixWorld ), index: i, face: null, faceIndex: null, object: this } ); } } } else if ( geometry.isGeometry ) { var vertices = geometry.vertices; var nbVertices = vertices.length; for ( var i = 0; i < nbVertices - 1; i += step ) { var distSq = ray.distanceSqToSegment( vertices[ i ], vertices[ i + 1 ], interRay, interSegment ); if ( distSq > localPrecisionSq ) continue; interRay.applyMatrix4( this.matrixWorld ); //Move back to world space for distance calculation var distance = raycaster.ray.origin.distanceTo( interRay ); if ( distance < raycaster.near || distance > raycaster.far ) continue; intersects.push( { distance: distance, // What do we want? intersection point on the ray or on the segment?? // point: raycaster.ray.at( distance ), point: interSegment.clone().applyMatrix4( this.matrixWorld ), index: i, face: null, faceIndex: null, object: this } ); } } }; }() ), copy: function ( source ) { Object3D.prototype.copy.call( this, source ); this.geometry.copy( source.geometry ); this.material.copy( source.material ); return this; }, clone: function () { return new this.constructor().copy( this ); } } ); /** * @author mrdoob / http://mrdoob.com/ */ function LineSegments( geometry, material ) { Line.call( this, geometry, material ); this.type = 'LineSegments'; } LineSegments.prototype = Object.assign( Object.create( Line.prototype ), { constructor: LineSegments, isLineSegments: true, computeLineDistances: ( function () { var start = new Vector3(); var end = new Vector3(); return function computeLineDistances() { var geometry = this.geometry; if ( geometry.isBufferGeometry ) { // we assume non-indexed geometry if ( geometry.index === null ) { var positionAttribute = geometry.attributes.position; var lineDistances = []; for ( var i = 0, l = positionAttribute.count; i < l; i += 2 ) { start.fromBufferAttribute( positionAttribute, i ); end.fromBufferAttribute( positionAttribute, i + 1 ); lineDistances[ i ] = ( i === 0 ) ? 0 : lineDistances[ i - 1 ]; lineDistances[ i + 1 ] = lineDistances[ i ] + start.distanceTo( end ); } geometry.addAttribute( 'lineDistance', new Float32BufferAttribute( lineDistances, 1 ) ); } else { console.warn( 'THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.' ); } } else if ( geometry.isGeometry ) { var vertices = geometry.vertices; var lineDistances = geometry.lineDistances; for ( var i = 0, l = vertices.length; i < l; i += 2 ) { start.copy( vertices[ i ] ); end.copy( vertices[ i + 1 ] ); lineDistances[ i ] = ( i === 0 ) ? 0 : lineDistances[ i - 1 ]; lineDistances[ i + 1 ] = lineDistances[ i ] + start.distanceTo( end ); } } return this; }; }() ) } ); /** * @author mgreter / http://github.com/mgreter */ function LineLoop( geometry, material ) { Line.call( this, geometry, material ); this.type = 'LineLoop'; } LineLoop.prototype = Object.assign( Object.create( Line.prototype ), { constructor: LineLoop, isLineLoop: true, } ); /** * @author mrdoob / http://mrdoob.com/ * @author alteredq / http://alteredqualia.com/ * * parameters = { * color: , * opacity: , * map: new THREE.Texture( ), * * size: , * sizeAttenuation: * * morphTargets: * } */ function PointsMaterial( parameters ) { Material.call( this ); this.type = 'PointsMaterial'; this.color = new Color( 0xffffff ); this.map = null; this.size = 1; this.sizeAttenuation = true; this.morphTargets = false; this.lights = false; this.setValues( parameters ); } PointsMaterial.prototype = Object.create( Material.prototype ); PointsMaterial.prototype.constructor = PointsMaterial; PointsMaterial.prototype.isPointsMaterial = true; PointsMaterial.prototype.copy = function ( source ) { Material.prototype.copy.call( this, source ); this.color.copy( source.color ); this.map = source.map; this.size = source.size; this.sizeAttenuation = source.sizeAttenuation; this.morphTargets = source.morphTargets; return this; }; /** * @author alteredq / http://alteredqualia.com/ */ function Points( geometry, material ) { Object3D.call( this ); this.type = 'Points'; this.geometry = geometry !== undefined ? geometry : new BufferGeometry(); this.material = material !== undefined ? material : new PointsMaterial( { color: Math.random() * 0xffffff } ); } Points.prototype = Object.assign( Object.create( Object3D.prototype ), { constructor: Points, isPoints: true, raycast: ( function () { var inverseMatrix = new Matrix4(); var ray = new Ray(); var sphere = new Sphere(); return function raycast( raycaster, intersects ) { var object = this; var geometry = this.geometry; var matrixWorld = this.matrixWorld; var threshold = raycaster.params.Points.threshold; // Checking boundingSphere distance to ray if ( geometry.boundingSphere === null ) geometry.computeBoundingSphere(); sphere.copy( geometry.boundingSphere ); sphere.applyMatrix4( matrixWorld ); sphere.radius += threshold; if ( raycaster.ray.intersectsSphere( sphere ) === false ) return; // inverseMatrix.getInverse( matrixWorld ); ray.copy( raycaster.ray ).applyMatrix4( inverseMatrix ); var localThreshold = threshold / ( ( this.scale.x + this.scale.y + this.scale.z ) / 3 ); var localThresholdSq = localThreshold * localThreshold; var position = new Vector3(); var intersectPoint = new Vector3(); function testPoint( point, index ) { var rayPointDistanceSq = ray.distanceSqToPoint( point ); if ( rayPointDistanceSq < localThresholdSq ) { ray.closestPointToPoint( point, intersectPoint ); intersectPoint.applyMatrix4( matrixWorld ); var distance = raycaster.ray.origin.distanceTo( intersectPoint ); if ( distance < raycaster.near || distance > raycaster.far ) return; intersects.push( { distance: distance, distanceToRay: Math.sqrt( rayPointDistanceSq ), point: intersectPoint.clone(), index: index, face: null, object: object } ); } } if ( geometry.isBufferGeometry ) { var index = geometry.index; var attributes = geometry.attributes; var positions = attributes.position.array; if ( index !== null ) { var indices = index.array; for ( var i = 0, il = indices.length; i < il; i ++ ) { var a = indices[ i ]; position.fromArray( positions, a * 3 ); testPoint( position, a ); } } else { for ( var i = 0, l = positions.length / 3; i < l; i ++ ) { position.fromArray( positions, i * 3 ); testPoint( position, i ); } } } else { var vertices = geometry.vertices; for ( var i = 0, l = vertices.length; i < l; i ++ ) { testPoint( vertices[ i ], i ); } } }; }() ), clone: function () { return new this.constructor( this.geometry, this.material ).copy( this ); } } ); /** * @author mrdoob / http://mrdoob.com/ */ function VideoTexture( video, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy ) { Texture.call( this, video, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy ); this.format = format !== undefined ? format : RGBFormat; this.minFilter = minFilter !== undefined ? minFilter : LinearFilter; this.magFilter = magFilter !== undefined ? magFilter : LinearFilter; this.generateMipmaps = false; } VideoTexture.prototype = Object.assign( Object.create( Texture.prototype ), { constructor: VideoTexture, isVideoTexture: true, update: function () { var video = this.image; if ( video.readyState >= video.HAVE_CURRENT_DATA ) { this.needsUpdate = true; } } } ); /** * @author alteredq / http://alteredqualia.com/ */ function CompressedTexture( mipmaps, width, height, format, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, encoding ) { Texture.call( this, null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding ); this.image = { width: width, height: height }; this.mipmaps = mipmaps; // no flipping for cube textures // (also flipping doesn't work for compressed textures ) this.flipY = false; // can't generate mipmaps for compressed textures // mips must be embedded in DDS files this.generateMipmaps = false; } CompressedTexture.prototype = Object.create( Texture.prototype ); CompressedTexture.prototype.constructor = CompressedTexture; CompressedTexture.prototype.isCompressedTexture = true; /** * @author mrdoob / http://mrdoob.com/ */ function CanvasTexture( canvas, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy ) { Texture.call( this, canvas, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy ); this.needsUpdate = true; } CanvasTexture.prototype = Object.create( Texture.prototype ); CanvasTexture.prototype.constructor = CanvasTexture; CanvasTexture.prototype.isCanvasTexture = true; /** * @author Matt DesLauriers / @mattdesl * @author atix / arthursilber.de */ function DepthTexture( width, height, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, format ) { format = format !== undefined ? format : DepthFormat; if ( format !== DepthFormat && format !== DepthStencilFormat ) { throw new Error( 'DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat' ); } if ( type === undefined && format === DepthFormat ) type = UnsignedShortType; if ( type === undefined && format === DepthStencilFormat ) type = UnsignedInt248Type; Texture.call( this, null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy ); this.image = { width: width, height: height }; this.magFilter = magFilter !== undefined ? magFilter : NearestFilter; this.minFilter = minFilter !== undefined ? minFilter : NearestFilter; this.flipY = false; this.generateMipmaps = false; } DepthTexture.prototype = Object.create( Texture.prototype ); DepthTexture.prototype.constructor = DepthTexture; DepthTexture.prototype.isDepthTexture = true; /** * @author mrdoob / http://mrdoob.com/ * @author Mugen87 / https://github.com/Mugen87 */ function WireframeGeometry( geometry ) { BufferGeometry.call( this ); this.type = 'WireframeGeometry'; // buffer var vertices = []; // helper variables var i, j, l, o, ol; var edge = [ 0, 0 ], edges = {}, e, edge1, edge2; var key, keys = [ 'a', 'b', 'c' ]; var vertex; // different logic for Geometry and BufferGeometry if ( geometry && geometry.isGeometry ) { // create a data structure that contains all edges without duplicates var faces = geometry.faces; for ( i = 0, l = faces.length; i < l; i ++ ) { var face = faces[ i ]; for ( j = 0; j < 3; j ++ ) { edge1 = face[ keys[ j ] ]; edge2 = face[ keys[ ( j + 1 ) % 3 ] ]; edge[ 0 ] = Math.min( edge1, edge2 ); // sorting prevents duplicates edge[ 1 ] = Math.max( edge1, edge2 ); key = edge[ 0 ] + ',' + edge[ 1 ]; if ( edges[ key ] === undefined ) { edges[ key ] = { index1: edge[ 0 ], index2: edge[ 1 ] }; } } } // generate vertices for ( key in edges ) { e = edges[ key ]; vertex = geometry.vertices[ e.index1 ]; vertices.push( vertex.x, vertex.y, vertex.z ); vertex = geometry.vertices[ e.index2 ]; vertices.push( vertex.x, vertex.y, vertex.z ); } } else if ( geometry && geometry.isBufferGeometry ) { var position, indices, groups; var group, start, count; var index1, index2; vertex = new Vector3(); if ( geometry.index !== null ) { // indexed BufferGeometry position = geometry.attributes.position; indices = geometry.index; groups = geometry.groups; if ( groups.length === 0 ) { groups = [ { start: 0, count: indices.count, materialIndex: 0 } ]; } // create a data structure that contains all eges without duplicates for ( o = 0, ol = groups.length; o < ol; ++ o ) { group = groups[ o ]; start = group.start; count = group.count; for ( i = start, l = ( start + count ); i < l; i += 3 ) { for ( j = 0; j < 3; j ++ ) { edge1 = indices.getX( i + j ); edge2 = indices.getX( i + ( j + 1 ) % 3 ); edge[ 0 ] = Math.min( edge1, edge2 ); // sorting prevents duplicates edge[ 1 ] = Math.max( edge1, edge2 ); key = edge[ 0 ] + ',' + edge[ 1 ]; if ( edges[ key ] === undefined ) { edges[ key ] = { index1: edge[ 0 ], index2: edge[ 1 ] }; } } } } // generate vertices for ( key in edges ) { e = edges[ key ]; vertex.fromBufferAttribute( position, e.index1 ); vertices.push( vertex.x, vertex.y, vertex.z ); vertex.fromBufferAttribute( position, e.index2 ); vertices.push( vertex.x, vertex.y, vertex.z ); } } else { // non-indexed BufferGeometry position = geometry.attributes.position; for ( i = 0, l = ( position.count / 3 ); i < l; i ++ ) { for ( j = 0; j < 3; j ++ ) { // three edges per triangle, an edge is represented as (index1, index2) // e.g. the first triangle has the following edges: (0,1),(1,2),(2,0) index1 = 3 * i + j; vertex.fromBufferAttribute( position, index1 ); vertices.push( vertex.x, vertex.y, vertex.z ); index2 = 3 * i + ( ( j + 1 ) % 3 ); vertex.fromBufferAttribute( position, index2 ); vertices.push( vertex.x, vertex.y, vertex.z ); } } } } // build geometry this.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) ); } WireframeGeometry.prototype = Object.create( BufferGeometry.prototype ); WireframeGeometry.prototype.constructor = WireframeGeometry; /** * @author zz85 / https://github.com/zz85 * @author Mugen87 / https://github.com/Mugen87 * * Parametric Surfaces Geometry * based on the brilliant article by @prideout http://prideout.net/blog/?p=44 */ // ParametricGeometry function ParametricGeometry( func, slices, stacks ) { Geometry.call( this ); this.type = 'ParametricGeometry'; this.parameters = { func: func, slices: slices, stacks: stacks }; this.fromBufferGeometry( new ParametricBufferGeometry( func, slices, stacks ) ); this.mergeVertices(); } ParametricGeometry.prototype = Object.create( Geometry.prototype ); ParametricGeometry.prototype.constructor = ParametricGeometry; // ParametricBufferGeometry function ParametricBufferGeometry( func, slices, stacks ) { BufferGeometry.call( this ); this.type = 'ParametricBufferGeometry'; this.parameters = { func: func, slices: slices, stacks: stacks }; // buffers var indices = []; var vertices = []; var normals = []; var uvs = []; var EPS = 0.00001; var normal = new Vector3(); var p0 = new Vector3(), p1 = new Vector3(); var pu = new Vector3(), pv = new Vector3(); var i, j; if ( func.length < 3 ) { console.error( 'THREE.ParametricGeometry: Function must now modify a Vector3 as third parameter.' ); } // generate vertices, normals and uvs var sliceCount = slices + 1; for ( i = 0; i = 0 ) { func( u, v - EPS, p1 ); pv.subVectors( p0, p1 ); } else { func( u, v + EPS, p1 ); pv.subVectors( p1, p0 ); } // cross product of tangent vectors returns surface normal normal.crossVectors( pu, pv ).normalize(); normals.push( normal.x, normal.y, normal.z ); // uv uvs.push( u, v ); } } // generate indices for ( i = 0; i < stacks; i ++ ) { for ( j = 0; j < slices; j ++ ) { var a = i * sliceCount + j; var b = i * sliceCount + j + 1; var c = ( i + 1 ) * sliceCount + j + 1; var d = ( i + 1 ) * sliceCount + j; // faces one and two indices.push( a, b, d ); indices.push( b, c, d ); } } // build geometry this.setIndex( indices ); this.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) ); this.addAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) ); this.addAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) ); } ParametricBufferGeometry.prototype = Object.create( BufferGeometry.prototype ); ParametricBufferGeometry.prototype.constructor = ParametricBufferGeometry; /** * @author clockworkgeek / https://github.com/clockworkgeek * @author timothypratley / https://github.com/timothypratley * @author WestLangley / http://github.com/WestLangley * @author Mugen87 / https://github.com/Mugen87 */ // PolyhedronGeometry function PolyhedronGeometry( vertices, indices, radius, detail ) { Geometry.call( this ); this.type = 'PolyhedronGeometry'; this.parameters = { vertices: vertices, indices: indices, radius: radius, detail: detail }; this.fromBufferGeometry( new PolyhedronBufferGeometry( vertices, indices, radius, detail ) ); this.mergeVertices(); } PolyhedronGeometry.prototype = Object.create( Geometry.prototype ); PolyhedronGeometry.prototype.constructor = PolyhedronGeometry; // PolyhedronBufferGeometry function PolyhedronBufferGeometry( vertices, indices, radius, detail ) { BufferGeometry.call( this ); this.type = 'PolyhedronBufferGeometry'; this.parameters = { vertices: vertices, indices: indices, radius: radius, detail: detail }; radius = radius || 1; detail = detail || 0; // default buffer data var vertexBuffer = []; var uvBuffer = []; // the subdivision creates the vertex buffer data subdivide( detail ); // all vertices should lie on a conceptual sphere with a given radius appplyRadius( radius ); // finally, create the uv data generateUVs(); // build non-indexed geometry this.addAttribute( 'position', new Float32BufferAttribute( vertexBuffer, 3 ) ); this.addAttribute( 'normal', new Float32BufferAttribute( vertexBuffer.slice(), 3 ) ); this.addAttribute( 'uv', new Float32BufferAttribute( uvBuffer, 2 ) ); if ( detail === 0 ) { this.computeVertexNormals(); // flat normals } else { this.normalizeNormals(); // smooth normals } // helper functions function subdivide( detail ) { var a = new Vector3(); var b = new Vector3(); var c = new Vector3(); // iterate over all faces and apply a subdivison with the given detail value for ( var i = 0; i < indices.length; i += 3 ) { // get the vertices of the face getVertexByIndex( indices[ i + 0 ], a ); getVertexByIndex( indices[ i + 1 ], b ); getVertexByIndex( indices[ i + 2 ], c ); // perform subdivision subdivideFace( a, b, c, detail ); } } function subdivideFace( a, b, c, detail ) { var cols = Math.pow( 2, detail ); // we use this multidimensional array as a data structure for creating the subdivision var v = []; var i, j; // construct all of the vertices for this subdivision for ( i = 0; i maxY ) maxY = y; } // minX, minY and invSize are later used to transform coords into integers for z-order calculation invSize = Math.max( maxX - minX, maxY - minY ); invSize = invSize !== 0 ? 1 / invSize : 0; } earcutLinked( outerNode, triangles, dim, minX, minY, invSize ); return triangles; } }; // create a circular doubly linked list from polygon points in the specified winding order function linkedList( data, start, end, dim, clockwise ) { var i, last; if ( clockwise === ( signedArea( data, start, end, dim ) > 0 ) ) { for ( i = start; i < end; i += dim ) last = insertNode( i, data[ i ], data[ i + 1 ], last ); } else { for ( i = end - dim; i >= start; i -= dim ) last = insertNode( i, data[ i ], data[ i + 1 ], last ); } if ( last && equals( last, last.next ) ) { removeNode( last ); last = last.next; } return last; } // eliminate colinear or duplicate points function filterPoints( start, end ) { if ( ! start ) return start; if ( ! end ) end = start; var p = start, again; do { again = false; if ( ! p.steiner && ( equals( p, p.next ) || area( p.prev, p, p.next ) === 0 ) ) { removeNode( p ); p = end = p.prev; if ( p === p.next ) break; again = true; } else { p = p.next; } } while ( again || p !== end ); return end; } // main ear slicing loop which triangulates a polygon (given as a linked list) function earcutLinked( ear, triangles, dim, minX, minY, invSize, pass ) { if ( ! ear ) return; // interlink polygon nodes in z-order if ( ! pass && invSize ) indexCurve( ear, minX, minY, invSize ); var stop = ear, prev, next; // iterate through ears, slicing them one by one while ( ear.prev !== ear.next ) { prev = ear.prev; next = ear.next; if ( invSize ? isEarHashed( ear, minX, minY, invSize ) : isEar( ear ) ) { // cut off the triangle triangles.push( prev.i / dim ); triangles.push( ear.i / dim ); triangles.push( next.i / dim ); removeNode( ear ); // skipping the next vertice leads to less sliver triangles ear = next.next; stop = next.next; continue; } ear = next; // if we looped through the whole remaining polygon and can't find any more ears if ( ear === stop ) { // try filtering points and slicing again if ( ! pass ) { earcutLinked( filterPoints( ear ), triangles, dim, minX, minY, invSize, 1 ); // if this didn't work, try curing all small self-intersections locally } else if ( pass === 1 ) { ear = cureLocalIntersections( ear, triangles, dim ); earcutLinked( ear, triangles, dim, minX, minY, invSize, 2 ); // as a last resort, try splitting the remaining polygon into two } else if ( pass === 2 ) { splitEarcut( ear, triangles, dim, minX, minY, invSize ); } break; } } } // check whether a polygon node forms a valid ear with adjacent nodes function isEar( ear ) { var a = ear.prev, b = ear, c = ear.next; if ( area( a, b, c ) >= 0 ) return false; // reflex, can't be an ear // now make sure we don't have other points inside the potential ear var p = ear.next.next; while ( p !== ear.prev ) { if ( pointInTriangle( a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y ) && area( p.prev, p, p.next ) >= 0 ) { return false; } p = p.next; } return true; } function isEarHashed( ear, minX, minY, invSize ) { var a = ear.prev, b = ear, c = ear.next; if ( area( a, b, c ) >= 0 ) return false; // reflex, can't be an ear // triangle bbox; min & max are calculated like this for speed var minTX = a.x < b.x ? ( a.x < c.x ? a.x : c.x ) : ( b.x < c.x ? b.x : c.x ), minTY = a.y < b.y ? ( a.y < c.y ? a.y : c.y ) : ( b.y < c.y ? b.y : c.y ), maxTX = a.x > b.x ? ( a.x > c.x ? a.x : c.x ) : ( b.x > c.x ? b.x : c.x ), maxTY = a.y > b.y ? ( a.y > c.y ? a.y : c.y ) : ( b.y > c.y ? b.y : c.y ); // z-order range for the current triangle bbox; var minZ = zOrder( minTX, minTY, minX, minY, invSize ), maxZ = zOrder( maxTX, maxTY, minX, minY, invSize ); // first look for points inside the triangle in increasing z-order var p = ear.nextZ; while ( p && p.z = 0 ) return false; p = p.nextZ; } // then look for points in decreasing z-order p = ear.prevZ; while ( p && p.z >= minZ ) { if ( p !== ear.prev && p !== ear.next && pointInTriangle( a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y ) && area( p.prev, p, p.next ) >= 0 ) return false; p = p.prevZ; } return true; } // go through all polygon nodes and cure small local self-intersections function cureLocalIntersections( start, triangles, dim ) { var p = start; do { var a = p.prev, b = p.next.next; if ( ! equals( a, b ) && intersects( a, p, p.next, b ) && locallyInside( a, b ) && locallyInside( b, a ) ) { triangles.push( a.i / dim ); triangles.push( p.i / dim ); triangles.push( b.i / dim ); // remove two nodes involved removeNode( p ); removeNode( p.next ); p = start = b; } p = p.next; } while ( p !== start ); return p; } // try splitting polygon into two and triangulate them independently function splitEarcut( start, triangles, dim, minX, minY, invSize ) { // look for a valid diagonal that divides the polygon into two var a = start; do { var b = a.next.next; while ( b !== a.prev ) { if ( a.i !== b.i && isValidDiagonal( a, b ) ) { // split the polygon in two by the diagonal var c = splitPolygon( a, b ); // filter colinear points around the cuts a = filterPoints( a, a.next ); c = filterPoints( c, c.next ); // run earcut on each half earcutLinked( a, triangles, dim, minX, minY, invSize ); earcutLinked( c, triangles, dim, minX, minY, invSize ); return; } b = b.next; } a = a.next; } while ( a !== start ); } // link every hole into the outer loop, producing a single-ring polygon without holes function eliminateHoles( data, holeIndices, outerNode, dim ) { var queue = [], i, len, start, end, list; for ( i = 0, len = holeIndices.length; i < len; i ++ ) { start = holeIndices[ i ] * dim; end = i < len - 1 ? holeIndices[ i + 1 ] * dim : data.length; list = linkedList( data, start, end, dim, false ); if ( list === list.next ) list.steiner = true; queue.push( getLeftmost( list ) ); } queue.sort( compareX ); // process holes from left to right for ( i = 0; i < queue.length; i ++ ) { eliminateHole( queue[ i ], outerNode ); outerNode = filterPoints( outerNode, outerNode.next ); } return outerNode; } function compareX( a, b ) { return a.x - b.x; } // find a bridge between vertices that connects hole with an outer ring and and link it function eliminateHole( hole, outerNode ) { outerNode = findHoleBridge( hole, outerNode ); if ( outerNode ) { var b = splitPolygon( outerNode, hole ); filterPoints( b, b.next ); } } // David Eberly's algorithm for finding a bridge between hole and outer polygon function findHoleBridge( hole, outerNode ) { var p = outerNode, hx = hole.x, hy = hole.y, qx = - Infinity, m; // find a segment intersected by a ray from the hole's leftmost point to the left; // segment's endpoint with lesser x will be potential connection point do { if ( hy = p.next.y && p.next.y !== p.y ) { var x = p.x + ( hy - p.y ) * ( p.next.x - p.x ) / ( p.next.y - p.y ); if ( x qx ) { qx = x; if ( x === hx ) { if ( hy === p.y ) return p; if ( hy === p.next.y ) return p.next; } m = p.x < p.next.x ? p : p.next; } } p = p.next; } while ( p !== outerNode ); if ( ! m ) return null; if ( hx === qx ) return m.prev; // hole touches outer segment; pick lower endpoint // look for points inside the triangle of hole point, segment intersection and endpoint; // if there are no points found, we have a valid connection; // otherwise choose the point of the minimum angle with the ray as connection point var stop = m, mx = m.x, my = m.y, tanMin = Infinity, tan; p = m.next; while ( p !== stop ) { if ( hx >= p.x && p.x >= mx && hx !== p.x && pointInTriangle( hy < my ? hx : qx, hy, mx, my, hy < my ? qx : hx, hy, p.x, p.y ) ) { tan = Math.abs( hy - p.y ) / ( hx - p.x ); // tangential if ( ( tan < tanMin || ( tan === tanMin && p.x > m.x ) ) && locallyInside( p, hole ) ) { m = p; tanMin = tan; } } p = p.next; } return m; } // interlink polygon nodes in z-order function indexCurve( start, minX, minY, invSize ) { var p = start; do { if ( p.z === null ) p.z = zOrder( p.x, p.y, minX, minY, invSize ); p.prevZ = p.prev; p.nextZ = p.next; p = p.next; } while ( p !== start ); p.prevZ.nextZ = null; p.prevZ = null; sortLinked( p ); } // Simon Tatham's linked list merge sort algorithm // http://www.chiark.greenend.org.uk/~sgtatham/algorithms/listsort.html function sortLinked( list ) { var i, p, q, e, tail, numMerges, pSize, qSize, inSize = 1; do { p = list; list = null; tail = null; numMerges = 0; while ( p ) { numMerges ++; q = p; pSize = 0; for ( i = 0; i < inSize; i ++ ) { pSize ++; q = q.nextZ; if ( ! q ) break; } qSize = inSize; while ( pSize > 0 || ( qSize > 0 && q ) ) { if ( pSize !== 0 && ( qSize === 0 || ! q || p.z 1 ); return list; } // z-order of a point given coords and inverse of the longer side of data bbox function zOrder( x, y, minX, minY, invSize ) { // coords are transformed into non-negative 15-bit integer range x = 32767 * ( x - minX ) * invSize; y = 32767 * ( y - minY ) * invSize; x = ( x | ( x = 0 : area( a, b, a.prev ) < 0 || area( a, a.next, b ) < 0; } // check if the middle point of a polygon diagonal is inside the polygon function middleInside( a, b ) { var p = a, inside = false, px = ( a.x + b.x ) / 2, py = ( a.y + b.y ) / 2; do { if ( ( ( p.y > py ) !== ( p.next.y > py ) ) && p.next.y !== p.y && ( px < ( p.next.x - p.x ) * ( py - p.y ) / ( p.next.y - p.y ) + p.x ) ) { inside = ! inside; } p = p.next; } while ( p !== a ); return inside; } // link two polygon vertices with a bridge; if the vertices belong to the same ring, it splits polygon into two; // if one belongs to the outer ring and another to a hole, it merges it into a single ring function splitPolygon( a, b ) { var a2 = new Node( a.i, a.x, a.y ), b2 = new Node( b.i, b.x, b.y ), an = a.next, bp = b.prev; a.next = b; b.prev = a; a2.next = an; an.prev = a2; b2.next = a2; a2.prev = b2; bp.next = b2; b2.prev = bp; return b2; } // create a node and optionally link it with previous one (in a circular doubly linked list) function insertNode( i, x, y, last ) { var p = new Node( i, x, y ); if ( ! last ) { p.prev = p; p.next = p; } else { p.next = last.next; p.prev = last; last.next.prev = p; last.next = p; } return p; } function removeNode( p ) { p.next.prev = p.prev; p.prev.next = p.next; if ( p.prevZ ) p.prevZ.nextZ = p.nextZ; if ( p.nextZ ) p.nextZ.prevZ = p.prevZ; } function Node( i, x, y ) { // vertice index in coordinates array this.i = i; // vertex coordinates this.x = x; this.y = y; // previous and next vertice nodes in a polygon ring this.prev = null; this.next = null; // z-order curve value this.z = null; // previous and next nodes in z-order this.prevZ = null; this.nextZ = null; // indicates whether this is a steiner point this.steiner = false; } function signedArea( data, start, end, dim ) { var sum = 0; for ( var i = start, j = end - dim; i < end; i += dim ) { sum += ( data[ j ] - data[ i ] ) * ( data[ i + 1 ] + data[ j + 1 ] ); j = i; } return sum; } /** * @author zz85 / http://www.lab4games.net/zz85/blog */ var ShapeUtils = { // calculate area of the contour polygon area: function ( contour ) { var n = contour.length; var a = 0.0; for ( var p = n - 1, q = 0; q < n; p = q ++ ) { a += contour[ p ].x * contour[ q ].y - contour[ q ].x * contour[ p ].y; } return a * 0.5; }, isClockWise: function ( pts ) { return ShapeUtils.area( pts ) < 0; }, triangulateShape: function ( contour, holes ) { var vertices = []; // flat array of vertices like [ x0,y0, x1,y1, x2,y2, ... ] var holeIndices = []; // array of hole indices var faces = []; // final array of vertex indices like [ [ a,b,d ], [ b,c,d ] ] removeDupEndPts( contour ); addContour( vertices, contour ); // var holeIndex = contour.length; holes.forEach( removeDupEndPts ); for ( var i = 0; i < holes.length; i ++ ) { holeIndices.push( holeIndex ); holeIndex += holes[ i ].length; addContour( vertices, holes[ i ] ); } // var triangles = Earcut.triangulate( vertices, holeIndices ); // for ( var i = 0; i < triangles.length; i += 3 ) { faces.push( triangles.slice( i, i + 3 ) ); } return faces; } }; function removeDupEndPts( points ) { var l = points.length; if ( l > 2 && points[ l - 1 ].equals( points[ 0 ] ) ) { points.pop(); } } function addContour( vertices, contour ) { for ( var i = 0; i < contour.length; i ++ ) { vertices.push( contour[ i ].x ); vertices.push( contour[ i ].y ); } } /** * @author zz85 / http://www.lab4games.net/zz85/blog * * Creates extruded geometry from a path shape. * * parameters = { * * curveSegments: , // number of points on the curves * steps: , // number of points for z-side extrusions / used for subdividing segments of extrude spline too * depth: , // Depth to extrude the shape * * bevelEnabled: , // turn on bevel * bevelThickness: , // how deep into the original shape bevel goes * bevelSize: , // how far from shape outline is bevel * bevelSegments: , // number of bevel layers * * extrudePath: // curve to extrude shape along * * UVGenerator: // object that provides UV generator functions * * } */ // ExtrudeGeometry function ExtrudeGeometry( shapes, options ) { Geometry.call( this ); this.type = 'ExtrudeGeometry'; this.parameters = { shapes: shapes, options: options }; this.fromBufferGeometry( new ExtrudeBufferGeometry( shapes, options ) ); this.mergeVertices(); } ExtrudeGeometry.prototype = Object.create( Geometry.prototype ); ExtrudeGeometry.prototype.constructor = ExtrudeGeometry; ExtrudeGeometry.prototype.toJSON = function () { var data = Geometry.prototype.toJSON.call( this ); var shapes = this.parameters.shapes; var options = this.parameters.options; return toJSON( shapes, options, data ); }; // ExtrudeBufferGeometry function ExtrudeBufferGeometry( shapes, options ) { BufferGeometry.call( this ); this.type = 'ExtrudeBufferGeometry'; this.parameters = { shapes: shapes, options: options }; shapes = Array.isArray( shapes ) ? shapes : [ shapes ]; var scope = this; var verticesArray = []; var uvArray = []; for ( var i = 0, l = shapes.length; i < l; i ++ ) { var shape = shapes[ i ]; addShape( shape ); } // build geometry this.addAttribute( 'position', new Float32BufferAttribute( verticesArray, 3 ) ); this.addAttribute( 'uv', new Float32BufferAttribute( uvArray, 2 ) ); this.computeVertexNormals(); // functions function addShape( shape ) { var placeholder = []; // options var curveSegments = options.curveSegments !== undefined ? options.curveSegments : 12; var steps = options.steps !== undefined ? options.steps : 1; var depth = options.depth !== undefined ? options.depth : 100; var bevelEnabled = options.bevelEnabled !== undefined ? options.bevelEnabled : true; var bevelThickness = options.bevelThickness !== undefined ? options.bevelThickness : 6; var bevelSize = options.bevelSize !== undefined ? options.bevelSize : bevelThickness - 2; var bevelSegments = options.bevelSegments !== undefined ? options.bevelSegments : 3; var extrudePath = options.extrudePath; var uvgen = options.UVGenerator !== undefined ? options.UVGenerator : WorldUVGenerator; // deprecated options if ( options.amount !== undefined ) { console.warn( 'THREE.ExtrudeBufferGeometry: amount has been renamed to depth.' ); depth = options.amount; } // var extrudePts, extrudeByPath = false; var splineTube, binormal, normal, position2; if ( extrudePath ) { extrudePts = extrudePath.getSpacedPoints( steps ); extrudeByPath = true; bevelEnabled = false; // bevels not supported for path extrusion // SETUP TNB variables // TODO1 - have a .isClosed in spline? splineTube = extrudePath.computeFrenetFrames( steps, false ); // console.log(splineTube, 'splineTube', splineTube.normals.length, 'steps', steps, 'extrudePts', extrudePts.length); binormal = new Vector3(); normal = new Vector3(); position2 = new Vector3(); } // Safeguards if bevels are not enabled if ( ! bevelEnabled ) { bevelSegments = 0; bevelThickness = 0; bevelSize = 0; } // Variables initialization var ahole, h, hl; // looping of holes var shapePoints = shape.extractPoints( curveSegments ); var vertices = shapePoints.shape; var holes = shapePoints.holes; var reverse = ! ShapeUtils.isClockWise( vertices ); if ( reverse ) { vertices = vertices.reverse(); // Maybe we should also check if holes are in the opposite direction, just to be safe ... for ( h = 0, hl = holes.length; h < hl; h ++ ) { ahole = holes[ h ]; if ( ShapeUtils.isClockWise( ahole ) ) { holes[ h ] = ahole.reverse(); } } } var faces = ShapeUtils.triangulateShape( vertices, holes ); /* Vertices */ var contour = vertices; // vertices has all points but contour has only points of circumference for ( h = 0, hl = holes.length; h < hl; h ++ ) { ahole = holes[ h ]; vertices = vertices.concat( ahole ); } function scalePt2( pt, vec, size ) { if ( ! vec ) console.error( \"THREE.ExtrudeGeometry: vec does not exist\" ); return vec.clone().multiplyScalar( size ).add( pt ); } var b, bs, t, z, vert, vlen = vertices.length, face, flen = faces.length; // Find directions for point movement function getBevelVec( inPt, inPrev, inNext ) { // computes for inPt the corresponding point inPt' on a new contour // shifted by 1 unit (length of normalized vector) to the left // if we walk along contour clockwise, this new contour is outside the old one // // inPt' is the intersection of the two lines parallel to the two // adjacent edges of inPt at a distance of 1 unit on the left side. var v_trans_x, v_trans_y, shrink_by; // resulting translation vector for inPt // good reading for geometry algorithms (here: line-line intersection) // http://geomalgorithms.com/a05-_intersect-1.html var v_prev_x = inPt.x - inPrev.x, v_prev_y = inPt.y - inPrev.y; var v_next_x = inNext.x - inPt.x, v_next_y = inNext.y - inPt.y; var v_prev_lensq = ( v_prev_x * v_prev_x + v_prev_y * v_prev_y ); // check for collinear edges var collinear0 = ( v_prev_x * v_next_y - v_prev_y * v_next_x ); if ( Math.abs( collinear0 ) > Number.EPSILON ) { // not collinear // length of vectors for normalizing var v_prev_len = Math.sqrt( v_prev_lensq ); var v_next_len = Math.sqrt( v_next_x * v_next_x + v_next_y * v_next_y ); // shift adjacent points by unit vectors to the left var ptPrevShift_x = ( inPrev.x - v_prev_y / v_prev_len ); var ptPrevShift_y = ( inPrev.y + v_prev_x / v_prev_len ); var ptNextShift_x = ( inNext.x - v_next_y / v_next_len ); var ptNextShift_y = ( inNext.y + v_next_x / v_next_len ); // scaling factor for v_prev to intersection point var sf = ( ( ptNextShift_x - ptPrevShift_x ) * v_next_y - ( ptNextShift_y - ptPrevShift_y ) * v_next_x ) / ( v_prev_x * v_next_y - v_prev_y * v_next_x ); // vector from inPt to intersection point v_trans_x = ( ptPrevShift_x + v_prev_x * sf - inPt.x ); v_trans_y = ( ptPrevShift_y + v_prev_y * sf - inPt.y ); // Don't normalize!, otherwise sharp corners become ugly // but prevent crazy spikes var v_trans_lensq = ( v_trans_x * v_trans_x + v_trans_y * v_trans_y ); if ( v_trans_lensq Number.EPSILON ) { if ( v_next_x > Number.EPSILON ) { direction_eq = true; } } else { if ( v_prev_x < - Number.EPSILON ) { if ( v_next_x < - Number.EPSILON ) { direction_eq = true; } } else { if ( Math.sign( v_prev_y ) === Math.sign( v_next_y ) ) { direction_eq = true; } } } if ( direction_eq ) { // console.log(\"Warning: lines are a straight sequence\"); v_trans_x = - v_prev_y; v_trans_y = v_prev_x; shrink_by = Math.sqrt( v_prev_lensq ); } else { // console.log(\"Warning: lines are a straight spike\"); v_trans_x = v_prev_x; v_trans_y = v_prev_y; shrink_by = Math.sqrt( v_prev_lensq / 2 ); } } return new Vector2( v_trans_x / shrink_by, v_trans_y / shrink_by ); } var contourMovements = []; for ( var i = 0, il = contour.length, j = il - 1, k = i + 1; i < il; i ++, j ++, k ++ ) { if ( j === il ) j = 0; if ( k === il ) k = 0; // (j)---(i)---(k) // console.log('i,j,k', i, j , k) contourMovements[ i ] = getBevelVec( contour[ i ], contour[ j ], contour[ k ] ); } var holesMovements = [], oneHoleMovements, verticesMovements = contourMovements.concat(); for ( h = 0, hl = holes.length; h < hl; h ++ ) { ahole = holes[ h ]; oneHoleMovements = []; for ( i = 0, il = ahole.length, j = il - 1, k = i + 1; i < il; i ++, j ++, k ++ ) { if ( j === il ) j = 0; if ( k === il ) k = 0; // (j)---(i)---(k) oneHoleMovements[ i ] = getBevelVec( ahole[ i ], ahole[ j ], ahole[ k ] ); } holesMovements.push( oneHoleMovements ); verticesMovements = verticesMovements.concat( oneHoleMovements ); } // Loop bevelSegments, 1 for the front, 1 for the back for ( b = 0; b < bevelSegments; b ++ ) { //for ( b = bevelSegments; b > 0; b -- ) { t = b / bevelSegments; z = bevelThickness * Math.cos( t * Math.PI / 2 ); bs = bevelSize * Math.sin( t * Math.PI / 2 ); // contract shape for ( i = 0, il = contour.length; i < il; i ++ ) { vert = scalePt2( contour[ i ], contourMovements[ i ], bs ); v( vert.x, vert.y, - z ); } // expand holes for ( h = 0, hl = holes.length; h < hl; h ++ ) { ahole = holes[ h ]; oneHoleMovements = holesMovements[ h ]; for ( i = 0, il = ahole.length; i < il; i ++ ) { vert = scalePt2( ahole[ i ], oneHoleMovements[ i ], bs ); v( vert.x, vert.y, - z ); } } } bs = bevelSize; // Back facing vertices for ( i = 0; i < vlen; i ++ ) { vert = bevelEnabled ? scalePt2( vertices[ i ], verticesMovements[ i ], bs ) : vertices[ i ]; if ( ! extrudeByPath ) { v( vert.x, vert.y, 0 ); } else { // v( vert.x, vert.y + extrudePts[ 0 ].y, extrudePts[ 0 ].x ); normal.copy( splineTube.normals[ 0 ] ).multiplyScalar( vert.x ); binormal.copy( splineTube.binormals[ 0 ] ).multiplyScalar( vert.y ); position2.copy( extrudePts[ 0 ] ).add( normal ).add( binormal ); v( position2.x, position2.y, position2.z ); } } // Add stepped vertices... // Including front facing vertices var s; for ( s = 1; s = 0 ) { j = i; k = i - 1; if ( k < 0 ) k = contour.length - 1; //console.log('b', i,j, i-1, k,vertices.length); var s = 0, sl = steps + bevelSegments * 2; for ( s = 0; s < sl; s ++ ) { var slen1 = vlen * s; var slen2 = vlen * ( s + 1 ); var a = layeroffset + j + slen1, b = layeroffset + k + slen1, c = layeroffset + k + slen2, d = layeroffset + j + slen2; f4( a, b, c, d ); } } } function v( x, y, z ) { placeholder.push( x ); placeholder.push( y ); placeholder.push( z ); } function f3( a, b, c ) { addVertex( a ); addVertex( b ); addVertex( c ); var nextIndex = verticesArray.length / 3; var uvs = uvgen.generateTopUV( scope, verticesArray, nextIndex - 3, nextIndex - 2, nextIndex - 1 ); addUV( uvs[ 0 ] ); addUV( uvs[ 1 ] ); addUV( uvs[ 2 ] ); } function f4( a, b, c, d ) { addVertex( a ); addVertex( b ); addVertex( d ); addVertex( b ); addVertex( c ); addVertex( d ); var nextIndex = verticesArray.length / 3; var uvs = uvgen.generateSideWallUV( scope, verticesArray, nextIndex - 6, nextIndex - 3, nextIndex - 2, nextIndex - 1 ); addUV( uvs[ 0 ] ); addUV( uvs[ 1 ] ); addUV( uvs[ 3 ] ); addUV( uvs[ 1 ] ); addUV( uvs[ 2 ] ); addUV( uvs[ 3 ] ); } function addVertex( index ) { verticesArray.push( placeholder[ index * 3 + 0 ] ); verticesArray.push( placeholder[ index * 3 + 1 ] ); verticesArray.push( placeholder[ index * 3 + 2 ] ); } function addUV( vector2 ) { uvArray.push( vector2.x ); uvArray.push( vector2.y ); } } } ExtrudeBufferGeometry.prototype = Object.create( BufferGeometry.prototype ); ExtrudeBufferGeometry.prototype.constructor = ExtrudeBufferGeometry; ExtrudeBufferGeometry.prototype.toJSON = function () { var data = BufferGeometry.prototype.toJSON.call( this ); var shapes = this.parameters.shapes; var options = this.parameters.options; return toJSON( shapes, options, data ); }; // var WorldUVGenerator = { generateTopUV: function ( geometry, vertices, indexA, indexB, indexC ) { var a_x = vertices[ indexA * 3 ]; var a_y = vertices[ indexA * 3 + 1 ]; var b_x = vertices[ indexB * 3 ]; var b_y = vertices[ indexB * 3 + 1 ]; var c_x = vertices[ indexC * 3 ]; var c_y = vertices[ indexC * 3 + 1 ]; return [ new Vector2( a_x, a_y ), new Vector2( b_x, b_y ), new Vector2( c_x, c_y ) ]; }, generateSideWallUV: function ( geometry, vertices, indexA, indexB, indexC, indexD ) { var a_x = vertices[ indexA * 3 ]; var a_y = vertices[ indexA * 3 + 1 ]; var a_z = vertices[ indexA * 3 + 2 ]; var b_x = vertices[ indexB * 3 ]; var b_y = vertices[ indexB * 3 + 1 ]; var b_z = vertices[ indexB * 3 + 2 ]; var c_x = vertices[ indexC * 3 ]; var c_y = vertices[ indexC * 3 + 1 ]; var c_z = vertices[ indexC * 3 + 2 ]; var d_x = vertices[ indexD * 3 ]; var d_y = vertices[ indexD * 3 + 1 ]; var d_z = vertices[ indexD * 3 + 2 ]; if ( Math.abs( a_y - b_y ) < 0.01 ) { return [ new Vector2( a_x, 1 - a_z ), new Vector2( b_x, 1 - b_z ), new Vector2( c_x, 1 - c_z ), new Vector2( d_x, 1 - d_z ) ]; } else { return [ new Vector2( a_y, 1 - a_z ), new Vector2( b_y, 1 - b_z ), new Vector2( c_y, 1 - c_z ), new Vector2( d_y, 1 - d_z ) ]; } } }; function toJSON( shapes, options, data ) { // data.shapes = []; if ( Array.isArray( shapes ) ) { for ( var i = 0, l = shapes.length; i < l; i ++ ) { var shape = shapes[ i ]; data.shapes.push( shape.uuid ); } } else { data.shapes.push( shapes.uuid ); } // if ( options.extrudePath !== undefined ) data.options.extrudePath = options.extrudePath.toJSON(); return data; } /** * @author zz85 / http://www.lab4games.net/zz85/blog * @author alteredq / http://alteredqualia.com/ * * Text = 3D Text * * parameters = { * font: , // font * * size: , // size of the text * height: , // thickness to extrude text * curveSegments: , // number of points on the curves * * bevelEnabled: , // turn on bevel * bevelThickness: , // how deep into text bevel goes * bevelSize: // how far from text outline is bevel * } */ // TextGeometry function TextGeometry( text, parameters ) { Geometry.call( this ); this.type = 'TextGeometry'; this.parameters = { text: text, parameters: parameters }; this.fromBufferGeometry( new TextBufferGeometry( text, parameters ) ); this.mergeVertices(); } TextGeometry.prototype = Object.create( Geometry.prototype ); TextGeometry.prototype.constructor = TextGeometry; // TextBufferGeometry function TextBufferGeometry( text, parameters ) { parameters = parameters || {}; var font = parameters.font; if ( ! ( font && font.isFont ) ) { console.error( 'THREE.TextGeometry: font parameter is not an instance of THREE.Font.' ); return new Geometry(); } var shapes = font.generateShapes( text, parameters.size ); // translate parameters to ExtrudeGeometry API parameters.depth = parameters.height !== undefined ? parameters.height : 50; // defaults if ( parameters.bevelThickness === undefined ) parameters.bevelThickness = 10; if ( parameters.bevelSize === undefined ) parameters.bevelSize = 8; if ( parameters.bevelEnabled === undefined ) parameters.bevelEnabled = false; ExtrudeBufferGeometry.call( this, shapes, parameters ); this.type = 'TextBufferGeometry'; } TextBufferGeometry.prototype = Object.create( ExtrudeBufferGeometry.prototype ); TextBufferGeometry.prototype.constructor = TextBufferGeometry; /** * @author mrdoob / http://mrdoob.com/ * @author benaadams / https://twitter.com/ben_a_adams * @author Mugen87 / https://github.com/Mugen87 */ // SphereGeometry function SphereGeometry( radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength ) { Geometry.call( this ); this.type = 'SphereGeometry'; this.parameters = { radius: radius, widthSegments: widthSegments, heightSegments: heightSegments, phiStart: phiStart, phiLength: phiLength, thetaStart: thetaStart, thetaLength: thetaLength }; this.fromBufferGeometry( new SphereBufferGeometry( radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength ) ); this.mergeVertices(); } SphereGeometry.prototype = Object.create( Geometry.prototype ); SphereGeometry.prototype.constructor = SphereGeometry; // SphereBufferGeometry function SphereBufferGeometry( radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength ) { BufferGeometry.call( this ); this.type = 'SphereBufferGeometry'; this.parameters = { radius: radius, widthSegments: widthSegments, heightSegments: heightSegments, phiStart: phiStart, phiLength: phiLength, thetaStart: thetaStart, thetaLength: thetaLength }; radius = radius || 1; widthSegments = Math.max( 3, Math.floor( widthSegments ) || 8 ); heightSegments = Math.max( 2, Math.floor( heightSegments ) || 6 ); phiStart = phiStart !== undefined ? phiStart : 0; phiLength = phiLength !== undefined ? phiLength : Math.PI * 2; thetaStart = thetaStart !== undefined ? thetaStart : 0; thetaLength = thetaLength !== undefined ? thetaLength : Math.PI; var thetaEnd = thetaStart + thetaLength; var ix, iy; var index = 0; var grid = []; var vertex = new Vector3(); var normal = new Vector3(); // buffers var indices = []; var vertices = []; var normals = []; var uvs = []; // generate vertices, normals and uvs for ( iy = 0; iy 0 ) { high = i - 1; } else { high = i; break; // DONE } } i = high; if ( arcLengths[ i ] === targetArcLength ) { return i / ( il - 1 ); } // we could get finer grain at lengths, or use simple interpolation between two points var lengthBefore = arcLengths[ i ]; var lengthAfter = arcLengths[ i + 1 ]; var segmentLength = lengthAfter - lengthBefore; // determine where we are between the 'before' and 'after' points var segmentFraction = ( targetArcLength - lengthBefore ) / segmentLength; // add that fractional amount to t var t = ( i + segmentFraction ) / ( il - 1 ); return t; }, // Returns a unit vector tangent at t // In case any sub curve does not implement its tangent derivation, // 2 points a small delta apart will be used to find its gradient // which seems to give a reasonable approximation getTangent: function ( t ) { var delta = 0.0001; var t1 = t - delta; var t2 = t + delta; // Capping in case of danger if ( t1 < 0 ) t1 = 0; if ( t2 > 1 ) t2 = 1; var pt1 = this.getPoint( t1 ); var pt2 = this.getPoint( t2 ); var vec = pt2.clone().sub( pt1 ); return vec.normalize(); }, getTangentAt: function ( u ) { var t = this.getUtoTmapping( u ); return this.getTangent( t ); }, computeFrenetFrames: function ( segments, closed ) { // see http://www.cs.indiana.edu/pub/techreports/TR425.pdf var normal = new Vector3(); var tangents = []; var normals = []; var binormals = []; var vec = new Vector3(); var mat = new Matrix4(); var i, u, theta; // compute the tangent vectors for each segment on the curve for ( i = 0; i 0 ) { theta = - theta; } for ( i = 1; i 0 ? 0 : ( Math.floor( Math.abs( intPoint ) / l ) + 1 ) * l; } else if ( weight === 0 && intPoint === l - 1 ) { intPoint = l - 2; weight = 1; } var p0, p1, p2, p3; // 4 points if ( this.closed || intPoint > 0 ) { p0 = points[ ( intPoint - 1 ) % l ]; } else { // extrapolate first point tmp.subVectors( points[ 0 ], points[ 1 ] ).add( points[ 0 ] ); p0 = tmp; } p1 = points[ intPoint % l ]; p2 = points[ ( intPoint + 1 ) % l ]; if ( this.closed || intPoint + 2 < l ) { p3 = points[ ( intPoint + 2 ) % l ]; } else { // extrapolate last point tmp.subVectors( points[ l - 1 ], points[ l - 2 ] ).add( points[ l - 1 ] ); p3 = tmp; } if ( this.curveType === 'centripetal' || this.curveType === 'chordal' ) { // init Centripetal / Chordal Catmull-Rom var pow = this.curveType === 'chordal' ? 0.5 : 0.25; var dt0 = Math.pow( p0.distanceToSquared( p1 ), pow ); var dt1 = Math.pow( p1.distanceToSquared( p2 ), pow ); var dt2 = Math.pow( p2.distanceToSquared( p3 ), pow ); // safety check for repeated points if ( dt1 < 1e-4 ) dt1 = 1.0; if ( dt0 < 1e-4 ) dt0 = dt1; if ( dt2 < 1e-4 ) dt2 = dt1; px.initNonuniformCatmullRom( p0.x, p1.x, p2.x, p3.x, dt0, dt1, dt2 ); py.initNonuniformCatmullRom( p0.y, p1.y, p2.y, p3.y, dt0, dt1, dt2 ); pz.initNonuniformCatmullRom( p0.z, p1.z, p2.z, p3.z, dt0, dt1, dt2 ); } else if ( this.curveType === 'catmullrom' ) { px.initCatmullRom( p0.x, p1.x, p2.x, p3.x, this.tension ); py.initCatmullRom( p0.y, p1.y, p2.y, p3.y, this.tension ); pz.initCatmullRom( p0.z, p1.z, p2.z, p3.z, this.tension ); } point.set( px.calc( weight ), py.calc( weight ), pz.calc( weight ) ); return point; }; CatmullRomCurve3.prototype.copy = function ( source ) { Curve.prototype.copy.call( this, source ); this.points = []; for ( var i = 0, l = source.points.length; i < l; i ++ ) { var point = source.points[ i ]; this.points.push( point.clone() ); } this.closed = source.closed; this.curveType = source.curveType; this.tension = source.tension; return this; }; CatmullRomCurve3.prototype.toJSON = function () { var data = Curve.prototype.toJSON.call( this ); data.points = []; for ( var i = 0, l = this.points.length; i < l; i ++ ) { var point = this.points[ i ]; data.points.push( point.toArray() ); } data.closed = this.closed; data.curveType = this.curveType; data.tension = this.tension; return data; }; CatmullRomCurve3.prototype.fromJSON = function ( json ) { Curve.prototype.fromJSON.call( this, json ); this.points = []; for ( var i = 0, l = json.points.length; i < l; i ++ ) { var point = json.points[ i ]; this.points.push( new Vector3().fromArray( point ) ); } this.closed = json.closed; this.curveType = json.curveType; this.tension = json.tension; return this; }; /** * @author zz85 / http://www.lab4games.net/zz85/blog * * Bezier Curves formulas obtained from * http://en.wikipedia.org/wiki/Bézier_curve */ function CatmullRom( t, p0, p1, p2, p3 ) { var v0 = ( p2 - p0 ) * 0.5; var v1 = ( p3 - p1 ) * 0.5; var t2 = t * t; var t3 = t * t2; return ( 2 * p1 - 2 * p2 + v0 + v1 ) * t3 + ( - 3 * p1 + 3 * p2 - 2 * v0 - v1 ) * t2 + v0 * t + p1; } // function QuadraticBezierP0( t, p ) { var k = 1 - t; return k * k * p; } function QuadraticBezierP1( t, p ) { return 2 * ( 1 - t ) * t * p; } function QuadraticBezierP2( t, p ) { return t * t * p; } function QuadraticBezier( t, p0, p1, p2 ) { return QuadraticBezierP0( t, p0 ) + QuadraticBezierP1( t, p1 ) + QuadraticBezierP2( t, p2 ); } // function CubicBezierP0( t, p ) { var k = 1 - t; return k * k * k * p; } function CubicBezierP1( t, p ) { var k = 1 - t; return 3 * k * k * t * p; } function CubicBezierP2( t, p ) { return 3 * ( 1 - t ) * t * t * p; } function CubicBezierP3( t, p ) { return t * t * t * p; } function CubicBezier( t, p0, p1, p2, p3 ) { return CubicBezierP0( t, p0 ) + CubicBezierP1( t, p1 ) + CubicBezierP2( t, p2 ) + CubicBezierP3( t, p3 ); } function CubicBezierCurve( v0, v1, v2, v3 ) { Curve.call( this ); this.type = 'CubicBezierCurve'; this.v0 = v0 || new Vector2(); this.v1 = v1 || new Vector2(); this.v2 = v2 || new Vector2(); this.v3 = v3 || new Vector2(); } CubicBezierCurve.prototype = Object.create( Curve.prototype ); CubicBezierCurve.prototype.constructor = CubicBezierCurve; CubicBezierCurve.prototype.isCubicBezierCurve = true; CubicBezierCurve.prototype.getPoint = function ( t, optionalTarget ) { var point = optionalTarget || new Vector2(); var v0 = this.v0, v1 = this.v1, v2 = this.v2, v3 = this.v3; point.set( CubicBezier( t, v0.x, v1.x, v2.x, v3.x ), CubicBezier( t, v0.y, v1.y, v2.y, v3.y ) ); return point; }; CubicBezierCurve.prototype.copy = function ( source ) { Curve.prototype.copy.call( this, source ); this.v0.copy( source.v0 ); this.v1.copy( source.v1 ); this.v2.copy( source.v2 ); this.v3.copy( source.v3 ); return this; }; CubicBezierCurve.prototype.toJSON = function () { var data = Curve.prototype.toJSON.call( this ); data.v0 = this.v0.toArray(); data.v1 = this.v1.toArray(); data.v2 = this.v2.toArray(); data.v3 = this.v3.toArray(); return data; }; CubicBezierCurve.prototype.fromJSON = function ( json ) { Curve.prototype.fromJSON.call( this, json ); this.v0.fromArray( json.v0 ); this.v1.fromArray( json.v1 ); this.v2.fromArray( json.v2 ); this.v3.fromArray( json.v3 ); return this; }; function CubicBezierCurve3( v0, v1, v2, v3 ) { Curve.call( this ); this.type = 'CubicBezierCurve3'; this.v0 = v0 || new Vector3(); this.v1 = v1 || new Vector3(); this.v2 = v2 || new Vector3(); this.v3 = v3 || new Vector3(); } CubicBezierCurve3.prototype = Object.create( Curve.prototype ); CubicBezierCurve3.prototype.constructor = CubicBezierCurve3; CubicBezierCurve3.prototype.isCubicBezierCurve3 = true; CubicBezierCurve3.prototype.getPoint = function ( t, optionalTarget ) { var point = optionalTarget || new Vector3(); var v0 = this.v0, v1 = this.v1, v2 = this.v2, v3 = this.v3; point.set( CubicBezier( t, v0.x, v1.x, v2.x, v3.x ), CubicBezier( t, v0.y, v1.y, v2.y, v3.y ), CubicBezier( t, v0.z, v1.z, v2.z, v3.z ) ); return point; }; CubicBezierCurve3.prototype.copy = function ( source ) { Curve.prototype.copy.call( this, source ); this.v0.copy( source.v0 ); this.v1.copy( source.v1 ); this.v2.copy( source.v2 ); this.v3.copy( source.v3 ); return this; }; CubicBezierCurve3.prototype.toJSON = function () { var data = Curve.prototype.toJSON.call( this ); data.v0 = this.v0.toArray(); data.v1 = this.v1.toArray(); data.v2 = this.v2.toArray(); data.v3 = this.v3.toArray(); return data; }; CubicBezierCurve3.prototype.fromJSON = function ( json ) { Curve.prototype.fromJSON.call( this, json ); this.v0.fromArray( json.v0 ); this.v1.fromArray( json.v1 ); this.v2.fromArray( json.v2 ); this.v3.fromArray( json.v3 ); return this; }; function LineCurve( v1, v2 ) { Curve.call( this ); this.type = 'LineCurve'; this.v1 = v1 || new Vector2(); this.v2 = v2 || new Vector2(); } LineCurve.prototype = Object.create( Curve.prototype ); LineCurve.prototype.constructor = LineCurve; LineCurve.prototype.isLineCurve = true; LineCurve.prototype.getPoint = function ( t, optionalTarget ) { var point = optionalTarget || new Vector2(); if ( t === 1 ) { point.copy( this.v2 ); } else { point.copy( this.v2 ).sub( this.v1 ); point.multiplyScalar( t ).add( this.v1 ); } return point; }; // Line curve is linear, so we can overwrite default getPointAt LineCurve.prototype.getPointAt = function ( u, optionalTarget ) { return this.getPoint( u, optionalTarget ); }; LineCurve.prototype.getTangent = function ( /* t */ ) { var tangent = this.v2.clone().sub( this.v1 ); return tangent.normalize(); }; LineCurve.prototype.copy = function ( source ) { Curve.prototype.copy.call( this, source ); this.v1.copy( source.v1 ); this.v2.copy( source.v2 ); return this; }; LineCurve.prototype.toJSON = function () { var data = Curve.prototype.toJSON.call( this ); data.v1 = this.v1.toArray(); data.v2 = this.v2.toArray(); return data; }; LineCurve.prototype.fromJSON = function ( json ) { Curve.prototype.fromJSON.call( this, json ); this.v1.fromArray( json.v1 ); this.v2.fromArray( json.v2 ); return this; }; function LineCurve3( v1, v2 ) { Curve.call( this ); this.type = 'LineCurve3'; this.v1 = v1 || new Vector3(); this.v2 = v2 || new Vector3(); } LineCurve3.prototype = Object.create( Curve.prototype ); LineCurve3.prototype.constructor = LineCurve3; LineCurve3.prototype.isLineCurve3 = true; LineCurve3.prototype.getPoint = function ( t, optionalTarget ) { var point = optionalTarget || new Vector3(); if ( t === 1 ) { point.copy( this.v2 ); } else { point.copy( this.v2 ).sub( this.v1 ); point.multiplyScalar( t ).add( this.v1 ); } return point; }; // Line curve is linear, so we can overwrite default getPointAt LineCurve3.prototype.getPointAt = function ( u, optionalTarget ) { return this.getPoint( u, optionalTarget ); }; LineCurve3.prototype.copy = function ( source ) { Curve.prototype.copy.call( this, source ); this.v1.copy( source.v1 ); this.v2.copy( source.v2 ); return this; }; LineCurve3.prototype.toJSON = function () { var data = Curve.prototype.toJSON.call( this ); data.v1 = this.v1.toArray(); data.v2 = this.v2.toArray(); return data; }; LineCurve3.prototype.fromJSON = function ( json ) { Curve.prototype.fromJSON.call( this, json ); this.v1.fromArray( json.v1 ); this.v2.fromArray( json.v2 ); return this; }; function QuadraticBezierCurve( v0, v1, v2 ) { Curve.call( this ); this.type = 'QuadraticBezierCurve'; this.v0 = v0 || new Vector2(); this.v1 = v1 || new Vector2(); this.v2 = v2 || new Vector2(); } QuadraticBezierCurve.prototype = Object.create( Curve.prototype ); QuadraticBezierCurve.prototype.constructor = QuadraticBezierCurve; QuadraticBezierCurve.prototype.isQuadraticBezierCurve = true; QuadraticBezierCurve.prototype.getPoint = function ( t, optionalTarget ) { var point = optionalTarget || new Vector2(); var v0 = this.v0, v1 = this.v1, v2 = this.v2; point.set( QuadraticBezier( t, v0.x, v1.x, v2.x ), QuadraticBezier( t, v0.y, v1.y, v2.y ) ); return point; }; QuadraticBezierCurve.prototype.copy = function ( source ) { Curve.prototype.copy.call( this, source ); this.v0.copy( source.v0 ); this.v1.copy( source.v1 ); this.v2.copy( source.v2 ); return this; }; QuadraticBezierCurve.prototype.toJSON = function () { var data = Curve.prototype.toJSON.call( this ); data.v0 = this.v0.toArray(); data.v1 = this.v1.toArray(); data.v2 = this.v2.toArray(); return data; }; QuadraticBezierCurve.prototype.fromJSON = function ( json ) { Curve.prototype.fromJSON.call( this, json ); this.v0.fromArray( json.v0 ); this.v1.fromArray( json.v1 ); this.v2.fromArray( json.v2 ); return this; }; function QuadraticBezierCurve3( v0, v1, v2 ) { Curve.call( this ); this.type = 'QuadraticBezierCurve3'; this.v0 = v0 || new Vector3(); this.v1 = v1 || new Vector3(); this.v2 = v2 || new Vector3(); } QuadraticBezierCurve3.prototype = Object.create( Curve.prototype ); QuadraticBezierCurve3.prototype.constructor = QuadraticBezierCurve3; QuadraticBezierCurve3.prototype.isQuadraticBezierCurve3 = true; QuadraticBezierCurve3.prototype.getPoint = function ( t, optionalTarget ) { var point = optionalTarget || new Vector3(); var v0 = this.v0, v1 = this.v1, v2 = this.v2; point.set( QuadraticBezier( t, v0.x, v1.x, v2.x ), QuadraticBezier( t, v0.y, v1.y, v2.y ), QuadraticBezier( t, v0.z, v1.z, v2.z ) ); return point; }; QuadraticBezierCurve3.prototype.copy = function ( source ) { Curve.prototype.copy.call( this, source ); this.v0.copy( source.v0 ); this.v1.copy( source.v1 ); this.v2.copy( source.v2 ); return this; }; QuadraticBezierCurve3.prototype.toJSON = function () { var data = Curve.prototype.toJSON.call( this ); data.v0 = this.v0.toArray(); data.v1 = this.v1.toArray(); data.v2 = this.v2.toArray(); return data; }; QuadraticBezierCurve3.prototype.fromJSON = function ( json ) { Curve.prototype.fromJSON.call( this, json ); this.v0.fromArray( json.v0 ); this.v1.fromArray( json.v1 ); this.v2.fromArray( json.v2 ); return this; }; function SplineCurve( points /* array of Vector2 */ ) { Curve.call( this ); this.type = 'SplineCurve'; this.points = points || []; } SplineCurve.prototype = Object.create( Curve.prototype ); SplineCurve.prototype.constructor = SplineCurve; SplineCurve.prototype.isSplineCurve = true; SplineCurve.prototype.getPoint = function ( t, optionalTarget ) { var point = optionalTarget || new Vector2(); var points = this.points; var p = ( points.length - 1 ) * t; var intPoint = Math.floor( p ); var weight = p - intPoint; var p0 = points[ intPoint === 0 ? intPoint : intPoint - 1 ]; var p1 = points[ intPoint ]; var p2 = points[ intPoint > points.length - 2 ? points.length - 1 : intPoint + 1 ]; var p3 = points[ intPoint > points.length - 3 ? points.length - 1 : intPoint + 2 ]; point.set( CatmullRom( weight, p0.x, p1.x, p2.x, p3.x ), CatmullRom( weight, p0.y, p1.y, p2.y, p3.y ) ); return point; }; SplineCurve.prototype.copy = function ( source ) { Curve.prototype.copy.call( this, source ); this.points = []; for ( var i = 0, l = source.points.length; i < l; i ++ ) { var point = source.points[ i ]; this.points.push( point.clone() ); } return this; }; SplineCurve.prototype.toJSON = function () { var data = Curve.prototype.toJSON.call( this ); data.points = []; for ( var i = 0, l = this.points.length; i < l; i ++ ) { var point = this.points[ i ]; data.points.push( point.toArray() ); } return data; }; SplineCurve.prototype.fromJSON = function ( json ) { Curve.prototype.fromJSON.call( this, json ); this.points = []; for ( var i = 0, l = json.points.length; i < l; i ++ ) { var point = json.points[ i ]; this.points.push( new Vector2().fromArray( point ) ); } return this; }; var Curves = /*#__PURE__*/Object.freeze({ ArcCurve: ArcCurve, CatmullRomCurve3: CatmullRomCurve3, CubicBezierCurve: CubicBezierCurve, CubicBezierCurve3: CubicBezierCurve3, EllipseCurve: EllipseCurve, LineCurve: LineCurve, LineCurve3: LineCurve3, QuadraticBezierCurve: QuadraticBezierCurve, QuadraticBezierCurve3: QuadraticBezierCurve3, SplineCurve: SplineCurve }); /** * @author zz85 / http://www.lab4games.net/zz85/blog * **/ /************************************************************** * Curved Path - a curve path is simply a array of connected * curves, but retains the api of a curve **************************************************************/ function CurvePath() { Curve.call( this ); this.type = 'CurvePath'; this.curves = []; this.autoClose = false; // Automatically closes the path } CurvePath.prototype = Object.assign( Object.create( Curve.prototype ), { constructor: CurvePath, add: function ( curve ) { this.curves.push( curve ); }, closePath: function () { // Add a line curve if start and end of lines are not connected var startPoint = this.curves[ 0 ].getPoint( 0 ); var endPoint = this.curves[ this.curves.length - 1 ].getPoint( 1 ); if ( ! startPoint.equals( endPoint ) ) { this.curves.push( new LineCurve( endPoint, startPoint ) ); } }, // To get accurate point with reference to // entire path distance at time t, // following has to be done: // 1. Length of each sub path have to be known // 2. Locate and identify type of curve // 3. Get t for the curve // 4. Return curve.getPointAt(t') getPoint: function ( t ) { var d = t * this.getLength(); var curveLengths = this.getCurveLengths(); var i = 0; // To think about boundaries points. while ( i < curveLengths.length ) { if ( curveLengths[ i ] >= d ) { var diff = curveLengths[ i ] - d; var curve = this.curves[ i ]; var segmentLength = curve.getLength(); var u = segmentLength === 0 ? 0 : 1 - diff / segmentLength; return curve.getPointAt( u ); } i ++; } return null; // loop where sum != 0, sum > d , sum+1 0 ) { // if a previous curve is present, attempt to join var firstPoint = curve.getPoint( 0 ); if ( ! firstPoint.equals( this.currentPoint ) ) { this.lineTo( firstPoint.x, firstPoint.y ); } } this.curves.push( curve ); var lastPoint = curve.getPoint( 1 ); this.currentPoint.copy( lastPoint ); }, copy: function ( source ) { CurvePath.prototype.copy.call( this, source ); this.currentPoint.copy( source.currentPoint ); return this; }, toJSON: function () { var data = CurvePath.prototype.toJSON.call( this ); data.currentPoint = this.currentPoint.toArray(); return data; }, fromJSON: function ( json ) { CurvePath.prototype.fromJSON.call( this, json ); this.currentPoint.fromArray( json.currentPoint ); return this; } } ); /** * @author zz85 / http://www.lab4games.net/zz85/blog * Defines a 2d shape plane using paths. **/ // STEP 1 Create a path. // STEP 2 Turn path into shape. // STEP 3 ExtrudeGeometry takes in Shape/Shapes // STEP 3a - Extract points from each shape, turn to vertices // STEP 3b - Triangulate each shape, add faces. function Shape( points ) { Path.call( this, points ); this.uuid = _Math.generateUUID(); this.type = 'Shape'; this.holes = []; } Shape.prototype = Object.assign( Object.create( Path.prototype ), { constructor: Shape, getPointsHoles: function ( divisions ) { var holesPts = []; for ( var i = 0, l = this.holes.length; i < l; i ++ ) { holesPts[ i ] = this.holes[ i ].getPoints( divisions ); } return holesPts; }, // get points of shape and holes (keypoints based on segments parameter) extractPoints: function ( divisions ) { return { shape: this.getPoints( divisions ), holes: this.getPointsHoles( divisions ) }; }, copy: function ( source ) { Path.prototype.copy.call( this, source ); this.holes = []; for ( var i = 0, l = source.holes.length; i < l; i ++ ) { var hole = source.holes[ i ]; this.holes.push( hole.clone() ); } return this; }, toJSON: function () { var data = Path.prototype.toJSON.call( this ); data.uuid = this.uuid; data.holes = []; for ( var i = 0, l = this.holes.length; i < l; i ++ ) { var hole = this.holes[ i ]; data.holes.push( hole.toJSON() ); } return data; }, fromJSON: function ( json ) { Path.prototype.fromJSON.call( this, json ); this.uuid = json.uuid; this.holes = []; for ( var i = 0, l = json.holes.length; i < l; i ++ ) { var hole = json.holes[ i ]; this.holes.push( new Path().fromJSON( hole ) ); } return this; } } ); /** * @author mrdoob / http://mrdoob.com/ * @author alteredq / http://alteredqualia.com/ */ function Light( color, intensity ) { Object3D.call( this ); this.type = 'Light'; this.color = new Color( color ); this.intensity = intensity !== undefined ? intensity : 1; this.receiveShadow = undefined; } Light.prototype = Object.assign( Object.create( Object3D.prototype ), { constructor: Light, isLight: true, copy: function ( source ) { Object3D.prototype.copy.call( this, source ); this.color.copy( source.color ); this.intensity = source.intensity; return this; }, toJSON: function ( meta ) { var data = Object3D.prototype.toJSON.call( this, meta ); data.object.color = this.color.getHex(); data.object.intensity = this.intensity; if ( this.groundColor !== undefined ) data.object.groundColor = this.groundColor.getHex(); if ( this.distance !== undefined ) data.object.distance = this.distance; if ( this.angle !== undefined ) data.object.angle = this.angle; if ( this.decay !== undefined ) data.object.decay = this.decay; if ( this.penumbra !== undefined ) data.object.penumbra = this.penumbra; if ( this.shadow !== undefined ) data.object.shadow = this.shadow.toJSON(); return data; } } ); /** * @author alteredq / http://alteredqualia.com/ */ function HemisphereLight( skyColor, groundColor, intensity ) { Light.call( this, skyColor, intensity ); this.type = 'HemisphereLight'; this.castShadow = undefined; this.position.copy( Object3D.DefaultUp ); this.updateMatrix(); this.groundColor = new Color( groundColor ); } HemisphereLight.prototype = Object.assign( Object.create( Light.prototype ), { constructor: HemisphereLight, isHemisphereLight: true, copy: function ( source ) { Light.prototype.copy.call( this, source ); this.groundColor.copy( source.groundColor ); return this; } } ); /** * @author mrdoob / http://mrdoob.com/ */ function LightShadow( camera ) { this.camera = camera; this.bias = 0; this.radius = 1; this.mapSize = new Vector2( 512, 512 ); this.map = null; this.matrix = new Matrix4(); } Object.assign( LightShadow.prototype, { copy: function ( source ) { this.camera = source.camera.clone(); this.bias = source.bias; this.radius = source.radius; this.mapSize.copy( source.mapSize ); return this; }, clone: function () { return new this.constructor().copy( this ); }, toJSON: function () { var object = {}; if ( this.bias !== 0 ) object.bias = this.bias; if ( this.radius !== 1 ) object.radius = this.radius; if ( this.mapSize.x !== 512 || this.mapSize.y !== 512 ) object.mapSize = this.mapSize.toArray(); object.camera = this.camera.toJSON( false ).object; delete object.camera.matrix; return object; } } ); /** * @author mrdoob / http://mrdoob.com/ */ function SpotLightShadow() { LightShadow.call( this, new PerspectiveCamera( 50, 1, 0.5, 500 ) ); } SpotLightShadow.prototype = Object.assign( Object.create( LightShadow.prototype ), { constructor: SpotLightShadow, isSpotLightShadow: true, update: function ( light ) { var camera = this.camera; var fov = _Math.RAD2DEG * 2 * light.angle; var aspect = this.mapSize.width / this.mapSize.height; var far = light.distance || camera.far; if ( fov !== camera.fov || aspect !== camera.aspect || far !== camera.far ) { camera.fov = fov; camera.aspect = aspect; camera.far = far; camera.updateProjectionMatrix(); } } } ); /** * @author alteredq / http://alteredqualia.com/ */ function SpotLight( color, intensity, distance, angle, penumbra, decay ) { Light.call( this, color, intensity ); this.type = 'SpotLight'; this.position.copy( Object3D.DefaultUp ); this.updateMatrix(); this.target = new Object3D(); Object.defineProperty( this, 'power', { get: function () { // intensity = power per solid angle. // ref: equation (17) from https://seblagarde.files.wordpress.com/2015/07/course_notes_moving_frostbite_to_pbr_v32.pdf return this.intensity * Math.PI; }, set: function ( power ) { // intensity = power per solid angle. // ref: equation (17) from https://seblagarde.files.wordpress.com/2015/07/course_notes_moving_frostbite_to_pbr_v32.pdf this.intensity = power / Math.PI; } } ); this.distance = ( distance !== undefined ) ? distance : 0; this.angle = ( angle !== undefined ) ? angle : Math.PI / 3; this.penumbra = ( penumbra !== undefined ) ? penumbra : 0; this.decay = ( decay !== undefined ) ? decay : 1; // for physically correct lights, should be 2. this.shadow = new SpotLightShadow(); } SpotLight.prototype = Object.assign( Object.create( Light.prototype ), { constructor: SpotLight, isSpotLight: true, copy: function ( source ) { Light.prototype.copy.call( this, source ); this.distance = source.distance; this.angle = source.angle; this.penumbra = source.penumbra; this.decay = source.decay; this.target = source.target.clone(); this.shadow = source.shadow.clone(); return this; } } ); /** * @author mrdoob / http://mrdoob.com/ */ function PointLight( color, intensity, distance, decay ) { Light.call( this, color, intensity ); this.type = 'PointLight'; Object.defineProperty( this, 'power', { get: function () { // intensity = power per solid angle. // ref: equation (15) from https://seblagarde.files.wordpress.com/2015/07/course_notes_moving_frostbite_to_pbr_v32.pdf return this.intensity * 4 * Math.PI; }, set: function ( power ) { // intensity = power per solid angle. // ref: equation (15) from https://seblagarde.files.wordpress.com/2015/07/course_notes_moving_frostbite_to_pbr_v32.pdf this.intensity = power / ( 4 * Math.PI ); } } ); this.distance = ( distance !== undefined ) ? distance : 0; this.decay = ( decay !== undefined ) ? decay : 1; // for physically correct lights, should be 2. this.shadow = new LightShadow( new PerspectiveCamera( 90, 1, 0.5, 500 ) ); } PointLight.prototype = Object.assign( Object.create( Light.prototype ), { constructor: PointLight, isPointLight: true, copy: function ( source ) { Light.prototype.copy.call( this, source ); this.distance = source.distance; this.decay = source.decay; this.shadow = source.shadow.clone(); return this; } } ); /** * @author alteredq / http://alteredqualia.com/ * @author arose / http://github.com/arose */ function OrthographicCamera( left, right, top, bottom, near, far ) { Camera.call( this ); this.type = 'OrthographicCamera'; this.zoom = 1; this.view = null; this.left = ( left !== undefined ) ? left : - 1; this.right = ( right !== undefined ) ? right : 1; this.top = ( top !== undefined ) ? top : 1; this.bottom = ( bottom !== undefined ) ? bottom : - 1; this.near = ( near !== undefined ) ? near : 0.1; this.far = ( far !== undefined ) ? far : 2000; this.updateProjectionMatrix(); } OrthographicCamera.prototype = Object.assign( Object.create( Camera.prototype ), { constructor: OrthographicCamera, isOrthographicCamera: true, copy: function ( source, recursive ) { Camera.prototype.copy.call( this, source, recursive ); this.left = source.left; this.right = source.right; this.top = source.top; this.bottom = source.bottom; this.near = source.near; this.far = source.far; this.zoom = source.zoom; this.view = source.view === null ? null : Object.assign( {}, source.view ); return this; }, setViewOffset: function ( fullWidth, fullHeight, x, y, width, height ) { if ( this.view === null ) { this.view = { enabled: true, fullWidth: 1, fullHeight: 1, offsetX: 0, offsetY: 0, width: 1, height: 1 }; } this.view.enabled = true; this.view.fullWidth = fullWidth; this.view.fullHeight = fullHeight; this.view.offsetX = x; this.view.offsetY = y; this.view.width = width; this.view.height = height; this.updateProjectionMatrix(); }, clearViewOffset: function () { if ( this.view !== null ) { this.view.enabled = false; } this.updateProjectionMatrix(); }, updateProjectionMatrix: function () { var dx = ( this.right - this.left ) / ( 2 * this.zoom ); var dy = ( this.top - this.bottom ) / ( 2 * this.zoom ); var cx = ( this.right + this.left ) / 2; var cy = ( this.top + this.bottom ) / 2; var left = cx - dx; var right = cx + dx; var top = cy + dy; var bottom = cy - dy; if ( this.view !== null && this.view.enabled ) { var zoomW = this.zoom / ( this.view.width / this.view.fullWidth ); var zoomH = this.zoom / ( this.view.height / this.view.fullHeight ); var scaleW = ( this.right - this.left ) / this.view.width; var scaleH = ( this.top - this.bottom ) / this.view.height; left += scaleW * ( this.view.offsetX / zoomW ); right = left + scaleW * ( this.view.width / zoomW ); top -= scaleH * ( this.view.offsetY / zoomH ); bottom = top - scaleH * ( this.view.height / zoomH ); } this.projectionMatrix.makeOrthographic( left, right, top, bottom, this.near, this.far ); this.projectionMatrixInverse.getInverse( this.projectionMatrix ); }, toJSON: function ( meta ) { var data = Object3D.prototype.toJSON.call( this, meta ); data.object.zoom = this.zoom; data.object.left = this.left; data.object.right = this.right; data.object.top = this.top; data.object.bottom = this.bottom; data.object.near = this.near; data.object.far = this.far; if ( this.view !== null ) data.object.view = Object.assign( {}, this.view ); return data; } } ); /** * @author mrdoob / http://mrdoob.com/ */ function DirectionalLightShadow( ) { LightShadow.call( this, new OrthographicCamera( - 5, 5, 5, - 5, 0.5, 500 ) ); } DirectionalLightShadow.prototype = Object.assign( Object.create( LightShadow.prototype ), { constructor: DirectionalLightShadow } ); /** * @author mrdoob / http://mrdoob.com/ * @author alteredq / http://alteredqualia.com/ */ function DirectionalLight( color, intensity ) { Light.call( this, color, intensity ); this.type = 'DirectionalLight'; this.position.copy( Object3D.DefaultUp ); this.updateMatrix(); this.target = new Object3D(); this.shadow = new DirectionalLightShadow(); } DirectionalLight.prototype = Object.assign( Object.create( Light.prototype ), { constructor: DirectionalLight, isDirectionalLight: true, copy: function ( source ) { Light.prototype.copy.call( this, source ); this.target = source.target.clone(); this.shadow = source.shadow.clone(); return this; } } ); /** * @author mrdoob / http://mrdoob.com/ */ function AmbientLight( color, intensity ) { Light.call( this, color, intensity ); this.type = 'AmbientLight'; this.castShadow = undefined; } AmbientLight.prototype = Object.assign( Object.create( Light.prototype ), { constructor: AmbientLight, isAmbientLight: true } ); /** * @author abelnation / http://github.com/abelnation */ function RectAreaLight( color, intensity, width, height ) { Light.call( this, color, intensity ); this.type = 'RectAreaLight'; this.width = ( width !== undefined ) ? width : 10; this.height = ( height !== undefined ) ? height : 10; } RectAreaLight.prototype = Object.assign( Object.create( Light.prototype ), { constructor: RectAreaLight, isRectAreaLight: true, copy: function ( source ) { Light.prototype.copy.call( this, source ); this.width = source.width; this.height = source.height; return this; }, toJSON: function ( meta ) { var data = Light.prototype.toJSON.call( this, meta ); data.object.width = this.width; data.object.height = this.height; return data; } } ); /** * @author mrdoob / http://mrdoob.com/ */ function MaterialLoader( manager ) { this.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager; this.textures = {}; } Object.assign( MaterialLoader.prototype, { load: function ( url, onLoad, onProgress, onError ) { var scope = this; var loader = new FileLoader( scope.manager ); loader.setPath( scope.path ); loader.load( url, function ( text ) { onLoad( scope.parse( JSON.parse( text ) ) ); }, onProgress, onError ); }, parse: function ( json ) { var textures = this.textures; function getTexture( name ) { if ( textures[ name ] === undefined ) { console.warn( 'THREE.MaterialLoader: Undefined texture', name ); } return textures[ name ]; } var material = new Materials[ json.type ](); if ( json.uuid !== undefined ) material.uuid = json.uuid; if ( json.name !== undefined ) material.name = json.name; if ( json.color !== undefined ) material.color.setHex( json.color ); if ( json.roughness !== undefined ) material.roughness = json.roughness; if ( json.metalness !== undefined ) material.metalness = json.metalness; if ( json.emissive !== undefined ) material.emissive.setHex( json.emissive ); if ( json.specular !== undefined ) material.specular.setHex( json.specular ); if ( json.shininess !== undefined ) material.shininess = json.shininess; if ( json.clearCoat !== undefined ) material.clearCoat = json.clearCoat; if ( json.clearCoatRoughness !== undefined ) material.clearCoatRoughness = json.clearCoatRoughness; if ( json.vertexColors !== undefined ) material.vertexColors = json.vertexColors; if ( json.fog !== undefined ) material.fog = json.fog; if ( json.flatShading !== undefined ) material.flatShading = json.flatShading; if ( json.blending !== undefined ) material.blending = json.blending; if ( json.combine !== undefined ) material.combine = json.combine; if ( json.side !== undefined ) material.side = json.side; if ( json.opacity !== undefined ) material.opacity = json.opacity; if ( json.transparent !== undefined ) material.transparent = json.transparent; if ( json.alphaTest !== undefined ) material.alphaTest = json.alphaTest; if ( json.depthTest !== undefined ) material.depthTest = json.depthTest; if ( json.depthWrite !== undefined ) material.depthWrite = json.depthWrite; if ( json.colorWrite !== undefined ) material.colorWrite = json.colorWrite; if ( json.wireframe !== undefined ) material.wireframe = json.wireframe; if ( json.wireframeLinewidth !== undefined ) material.wireframeLinewidth = json.wireframeLinewidth; if ( json.wireframeLinecap !== undefined ) material.wireframeLinecap = json.wireframeLinecap; if ( json.wireframeLinejoin !== undefined ) material.wireframeLinejoin = json.wireframeLinejoin; if ( json.rotation !== undefined ) material.rotation = json.rotation; if ( json.linewidth !== 1 ) material.linewidth = json.linewidth; if ( json.dashSize !== undefined ) material.dashSize = json.dashSize; if ( json.gapSize !== undefined ) material.gapSize = json.gapSize; if ( json.scale !== undefined ) material.scale = json.scale; if ( json.polygonOffset !== undefined ) material.polygonOffset = json.polygonOffset; if ( json.polygonOffsetFactor !== undefined ) material.polygonOffsetFactor = json.polygonOffsetFactor; if ( json.polygonOffsetUnits !== undefined ) material.polygonOffsetUnits = json.polygonOffsetUnits; if ( json.skinning !== undefined ) material.skinning = json.skinning; if ( json.morphTargets !== undefined ) material.morphTargets = json.morphTargets; if ( json.dithering !== undefined ) material.dithering = json.dithering; if ( json.visible !== undefined ) material.visible = json.visible; if ( json.userData !== undefined ) material.userData = json.userData; // Shader Material if ( json.uniforms !== undefined ) { for ( var name in json.uniforms ) { var uniform = json.uniforms[ name ]; material.uniforms[ name ] = {}; switch ( uniform.type ) { case 't': material.uniforms[ name ].value = getTexture( uniform.value ); break; case 'c': material.uniforms[ name ].value = new Color().setHex( uniform.value ); break; case 'v2': material.uniforms[ name ].value = new Vector2().fromArray( uniform.value ); break; case 'v3': material.uniforms[ name ].value = new Vector3().fromArray( uniform.value ); break; case 'v4': material.uniforms[ name ].value = new Vector4().fromArray( uniform.value ); break; case 'm3': material.uniforms[ name ].value = new Matrix3().fromArray( uniform.value ); case 'm4': material.uniforms[ name ].value = new Matrix4().fromArray( uniform.value ); break; default: material.uniforms[ name ].value = uniform.value; } } } if ( json.defines !== undefined ) material.defines = json.defines; if ( json.vertexShader !== undefined ) material.vertexShader = json.vertexShader; if ( json.fragmentShader !== undefined ) material.fragmentShader = json.fragmentShader; if ( json.extensions !== undefined ) { for ( var key in json.extensions ) { material.extensions[ key ] = json.extensions[ key ]; } } // Deprecated if ( json.shading !== undefined ) material.flatShading = json.shading === 1; // THREE.FlatShading // for PointsMaterial if ( json.size !== undefined ) material.size = json.size; if ( json.sizeAttenuation !== undefined ) material.sizeAttenuation = json.sizeAttenuation; // maps if ( json.map !== undefined ) material.map = getTexture( json.map ); if ( json.alphaMap !== undefined ) { material.alphaMap = getTexture( json.alphaMap ); material.transparent = true; } if ( json.bumpMap !== undefined ) material.bumpMap = getTexture( json.bumpMap ); if ( json.bumpScale !== undefined ) material.bumpScale = json.bumpScale; if ( json.normalMap !== undefined ) material.normalMap = getTexture( json.normalMap ); if ( json.normalMapType !== undefined ) material.normalMapType = json.normalMapType; if ( json.normalScale !== undefined ) { var normalScale = json.normalScale; if ( Array.isArray( normalScale ) === false ) { // Blender exporter used to export a scalar. See #7459 normalScale = [ normalScale, normalScale ]; } material.normalScale = new Vector2().fromArray( normalScale ); } if ( json.displacementMap !== undefined ) material.displacementMap = getTexture( json.displacementMap ); if ( json.displacementScale !== undefined ) material.displacementScale = json.displacementScale; if ( json.displacementBias !== undefined ) material.displacementBias = json.displacementBias; if ( json.roughnessMap !== undefined ) material.roughnessMap = getTexture( json.roughnessMap ); if ( json.metalnessMap !== undefined ) material.metalnessMap = getTexture( json.metalnessMap ); if ( json.emissiveMap !== undefined ) material.emissiveMap = getTexture( json.emissiveMap ); if ( json.emissiveIntensity !== undefined ) material.emissiveIntensity = json.emissiveIntensity; if ( json.specularMap !== undefined ) material.specularMap = getTexture( json.specularMap ); if ( json.envMap !== undefined ) material.envMap = getTexture( json.envMap ); if ( json.envMapIntensity !== undefined ) material.envMapIntensity = json.envMapIntensity; if ( json.reflectivity !== undefined ) material.reflectivity = json.reflectivity; if ( json.lightMap !== undefined ) material.lightMap = getTexture( json.lightMap ); if ( json.lightMapIntensity !== undefined ) material.lightMapIntensity = json.lightMapIntensity; if ( json.aoMap !== undefined ) material.aoMap = getTexture( json.aoMap ); if ( json.aoMapIntensity !== undefined ) material.aoMapIntensity = json.aoMapIntensity; if ( json.gradientMap !== undefined ) material.gradientMap = getTexture( json.gradientMap ); return material; }, setPath: function ( value ) { this.path = value; return this; }, setTextures: function ( value ) { this.textures = value; return this; } } ); /** * @author Don McCurdy / https://www.donmccurdy.com */ var LoaderUtils = { decodeText: function ( array ) { if ( typeof TextDecoder !== 'undefined' ) { return new TextDecoder().decode( array ); } // Avoid the String.fromCharCode.apply(null, array) shortcut, which // throws a \"maximum call stack size exceeded\" error for large arrays. var s = ''; for ( var i = 0, il = array.length; i < il; i ++ ) { // Implicitly assumes little-endian. s += String.fromCharCode( array[ i ] ); } // Merges multi-byte utf-8 characters. return decodeURIComponent( escape( s ) ); }, extractUrlBase: function ( url ) { var index = url.lastIndexOf( '/' ); if ( index === - 1 ) return './'; return url.substr( 0, index + 1 ); } }; /** * @author mrdoob / http://mrdoob.com/ */ function BufferGeometryLoader( manager ) { this.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager; } Object.assign( BufferGeometryLoader.prototype, { load: function ( url, onLoad, onProgress, onError ) { var scope = this; var loader = new FileLoader( scope.manager ); loader.setPath( scope.path ); loader.load( url, function ( text ) { onLoad( scope.parse( JSON.parse( text ) ) ); }, onProgress, onError ); }, parse: function ( json ) { var geometry = new BufferGeometry(); var index = json.data.index; if ( index !== undefined ) { var typedArray = new TYPED_ARRAYS[ index.type ]( index.array ); geometry.setIndex( new BufferAttribute( typedArray, 1 ) ); } var attributes = json.data.attributes; for ( var key in attributes ) { var attribute = attributes[ key ]; var typedArray = new TYPED_ARRAYS[ attribute.type ]( attribute.array ); geometry.addAttribute( key, new BufferAttribute( typedArray, attribute.itemSize, attribute.normalized ) ); } var groups = json.data.groups || json.data.drawcalls || json.data.offsets; if ( groups !== undefined ) { for ( var i = 0, n = groups.length; i !== n; ++ i ) { var group = groups[ i ]; geometry.addGroup( group.start, group.count, group.materialIndex ); } } var boundingSphere = json.data.boundingSphere; if ( boundingSphere !== undefined ) { var center = new Vector3(); if ( boundingSphere.center !== undefined ) { center.fromArray( boundingSphere.center ); } geometry.boundingSphere = new Sphere( center, boundingSphere.radius ); } if ( json.name ) geometry.name = json.name; if ( json.userData ) geometry.userData = json.userData; return geometry; }, setPath: function ( value ) { this.path = value; return this; } } ); var TYPED_ARRAYS = { Int8Array: Int8Array, Uint8Array: Uint8Array, // Workaround for IE11 pre KB2929437. See #11440 Uint8ClampedArray: typeof Uint8ClampedArray !== 'undefined' ? Uint8ClampedArray : Uint8Array, Int16Array: Int16Array, Uint16Array: Uint16Array, Int32Array: Int32Array, Uint32Array: Uint32Array, Float32Array: Float32Array, Float64Array: Float64Array }; /** * @author mrdoob / http://mrdoob.com/ */ function ObjectLoader( manager ) { this.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager; this.resourcePath = ''; } Object.assign( ObjectLoader.prototype, { crossOrigin: 'anonymous', load: function ( url, onLoad, onProgress, onError ) { var scope = this; var path = ( this.path === undefined ) ? LoaderUtils.extractUrlBase( url ) : this.path; this.resourcePath = this.resourcePath || path; var loader = new FileLoader( scope.manager ); loader.setPath( this.path ); loader.load( url, function ( text ) { var json = null; try { json = JSON.parse( text ); } catch ( error ) { if ( onError !== undefined ) onError( error ); console.error( 'THREE:ObjectLoader: Can\\'t parse ' + url + '.', error.message ); return; } var metadata = json.metadata; if ( metadata === undefined || metadata.type === undefined || metadata.type.toLowerCase() === 'geometry' ) { console.error( 'THREE.ObjectLoader: Can\\'t load ' + url ); return; } scope.parse( json, onLoad ); }, onProgress, onError ); }, setPath: function ( value ) { this.path = value; return this; }, setResourcePath: function ( value ) { this.resourcePath = value; return this; }, setCrossOrigin: function ( value ) { this.crossOrigin = value; return this; }, parse: function ( json, onLoad ) { var shapes = this.parseShape( json.shapes ); var geometries = this.parseGeometries( json.geometries, shapes ); var images = this.parseImages( json.images, function () { if ( onLoad !== undefined ) onLoad( object ); } ); var textures = this.parseTextures( json.textures, images ); var materials = this.parseMaterials( json.materials, textures ); var object = this.parseObject( json.object, geometries, materials ); if ( json.animations ) { object.animations = this.parseAnimations( json.animations ); } if ( json.images === undefined || json.images.length === 0 ) { if ( onLoad !== undefined ) onLoad( object ); } return object; }, parseShape: function ( json ) { var shapes = {}; if ( json !== undefined ) { for ( var i = 0, l = json.length; i < l; i ++ ) { var shape = new Shape().fromJSON( json[ i ] ); shapes[ shape.uuid ] = shape; } } return shapes; }, parseGeometries: function ( json, shapes ) { var geometries = {}; if ( json !== undefined ) { var bufferGeometryLoader = new BufferGeometryLoader(); for ( var i = 0, l = json.length; i < l; i ++ ) { var geometry; var data = json[ i ]; switch ( data.type ) { case 'PlaneGeometry': case 'PlaneBufferGeometry': geometry = new Geometries[ data.type ]( data.width, data.height, data.widthSegments, data.heightSegments ); break; case 'BoxGeometry': case 'BoxBufferGeometry': case 'CubeGeometry': // backwards compatible geometry = new Geometries[ data.type ]( data.width, data.height, data.depth, data.widthSegments, data.heightSegments, data.depthSegments ); break; case 'CircleGeometry': case 'CircleBufferGeometry': geometry = new Geometries[ data.type ]( data.radius, data.segments, data.thetaStart, data.thetaLength ); break; case 'CylinderGeometry': case 'CylinderBufferGeometry': geometry = new Geometries[ data.type ]( data.radiusTop, data.radiusBottom, data.height, data.radialSegments, data.heightSegments, data.openEnded, data.thetaStart, data.thetaLength ); break; case 'ConeGeometry': case 'ConeBufferGeometry': geometry = new Geometries[ data.type ]( data.radius, data.height, data.radialSegments, data.heightSegments, data.openEnded, data.thetaStart, data.thetaLength ); break; case 'SphereGeometry': case 'SphereBufferGeometry': geometry = new Geometries[ data.type ]( data.radius, data.widthSegments, data.heightSegments, data.phiStart, data.phiLength, data.thetaStart, data.thetaLength ); break; case 'DodecahedronGeometry': case 'DodecahedronBufferGeometry': case 'IcosahedronGeometry': case 'IcosahedronBufferGeometry': case 'OctahedronGeometry': case 'OctahedronBufferGeometry': case 'TetrahedronGeometry': case 'TetrahedronBufferGeometry': geometry = new Geometries[ data.type ]( data.radius, data.detail ); break; case 'RingGeometry': case 'RingBufferGeometry': geometry = new Geometries[ data.type ]( data.innerRadius, data.outerRadius, data.thetaSegments, data.phiSegments, data.thetaStart, data.thetaLength ); break; case 'TorusGeometry': case 'TorusBufferGeometry': geometry = new Geometries[ data.type ]( data.radius, data.tube, data.radialSegments, data.tubularSegments, data.arc ); break; case 'TorusKnotGeometry': case 'TorusKnotBufferGeometry': geometry = new Geometries[ data.type ]( data.radius, data.tube, data.tubularSegments, data.radialSegments, data.p, data.q ); break; case 'LatheGeometry': case 'LatheBufferGeometry': geometry = new Geometries[ data.type ]( data.points, data.segments, data.phiStart, data.phiLength ); break; case 'PolyhedronGeometry': case 'PolyhedronBufferGeometry': geometry = new Geometries[ data.type ]( data.vertices, data.indices, data.radius, data.details ); break; case 'ShapeGeometry': case 'ShapeBufferGeometry': var geometryShapes = []; for ( var j = 0, jl = data.shapes.length; j < jl; j ++ ) { var shape = shapes[ data.shapes[ j ] ]; geometryShapes.push( shape ); } geometry = new Geometries[ data.type ]( geometryShapes, data.curveSegments ); break; case 'ExtrudeGeometry': case 'ExtrudeBufferGeometry': var geometryShapes = []; for ( var j = 0, jl = data.shapes.length; j < jl; j ++ ) { var shape = shapes[ data.shapes[ j ] ]; geometryShapes.push( shape ); } var extrudePath = data.options.extrudePath; if ( extrudePath !== undefined ) { data.options.extrudePath = new Curves[ extrudePath.type ]().fromJSON( extrudePath ); } geometry = new Geometries[ data.type ]( geometryShapes, data.options ); break; case 'BufferGeometry': geometry = bufferGeometryLoader.parse( data ); break; case 'Geometry': if ( 'THREE' in window && 'LegacyJSONLoader' in THREE ) { var geometryLoader = new THREE.LegacyJSONLoader(); geometry = geometryLoader.parse( data, this.resourcePath ).geometry; } else { console.error( 'THREE.ObjectLoader: You have to import LegacyJSONLoader in order load geometry data of type \"Geometry\".' ); } break; default: console.warn( 'THREE.ObjectLoader: Unsupported geometry type \"' + data.type + '\"' ); continue; } geometry.uuid = data.uuid; if ( data.name !== undefined ) geometry.name = data.name; if ( geometry.isBufferGeometry === true && data.userData !== undefined ) geometry.userData = data.userData; geometries[ data.uuid ] = geometry; } } return geometries; }, parseMaterials: function ( json, textures ) { var cache = {}; // MultiMaterial var materials = {}; if ( json !== undefined ) { var loader = new MaterialLoader(); loader.setTextures( textures ); for ( var i = 0, l = json.length; i < l; i ++ ) { var data = json[ i ]; if ( data.type === 'MultiMaterial' ) { // Deprecated var array = []; for ( var j = 0; j < data.materials.length; j ++ ) { var material = data.materials[ j ]; if ( cache[ material.uuid ] === undefined ) { cache[ material.uuid ] = loader.parse( material ); } array.push( cache[ material.uuid ] ); } materials[ data.uuid ] = array; } else { if ( cache[ data.uuid ] === undefined ) { cache[ data.uuid ] = loader.parse( data ); } materials[ data.uuid ] = cache[ data.uuid ]; } } } return materials; }, parseAnimations: function ( json ) { var animations = []; for ( var i = 0; i < json.length; i ++ ) { var data = json[ i ]; var clip = AnimationClip.parse( data ); if ( data.uuid !== undefined ) clip.uuid = data.uuid; animations.push( clip ); } return animations; }, parseImages: function ( json, onLoad ) { var scope = this; var images = {}; function loadImage( url ) { scope.manager.itemStart( url ); return loader.load( url, function () { scope.manager.itemEnd( url ); }, undefined, function () { scope.manager.itemError( url ); scope.manager.itemEnd( url ); } ); } if ( json !== undefined && json.length > 0 ) { var manager = new LoadingManager( onLoad ); var loader = new ImageLoader( manager ); loader.setCrossOrigin( this.crossOrigin ); for ( var i = 0, il = json.length; i < il; i ++ ) { var image = json[ i ]; var url = image.url; if ( Array.isArray( url ) ) { // load array of images e.g CubeTexture images[ image.uuid ] = []; for ( var j = 0, jl = url.length; j < jl; j ++ ) { var currentUrl = url[ j ]; var path = /^(\\/\\/)|([a-z]+:(\\/\\/)?)/i.test( currentUrl ) ? currentUrl : scope.resourcePath + currentUrl; images[ image.uuid ].push( loadImage( path ) ); } } else { // load single image var path = /^(\\/\\/)|([a-z]+:(\\/\\/)?)/i.test( image.url ) ? image.url : scope.resourcePath + image.url; images[ image.uuid ] = loadImage( path ); } } } return images; }, parseTextures: function ( json, images ) { function parseConstant( value, type ) { if ( typeof value === 'number' ) return value; console.warn( 'THREE.ObjectLoader.parseTexture: Constant should be in numeric form.', value ); return type[ value ]; } var textures = {}; if ( json !== undefined ) { for ( var i = 0, l = json.length; i < l; i ++ ) { var data = json[ i ]; if ( data.image === undefined ) { console.warn( 'THREE.ObjectLoader: No \"image\" specified for', data.uuid ); } if ( images[ data.image ] === undefined ) { console.warn( 'THREE.ObjectLoader: Undefined image', data.image ); } var texture; if ( Array.isArray( images[ data.image ] ) ) { texture = new CubeTexture( images[ data.image ] ); } else { texture = new Texture( images[ data.image ] ); } texture.needsUpdate = true; texture.uuid = data.uuid; if ( data.name !== undefined ) texture.name = data.name; if ( data.mapping !== undefined ) texture.mapping = parseConstant( data.mapping, TEXTURE_MAPPING ); if ( data.offset !== undefined ) texture.offset.fromArray( data.offset ); if ( data.repeat !== undefined ) texture.repeat.fromArray( data.repeat ); if ( data.center !== undefined ) texture.center.fromArray( data.center ); if ( data.rotation !== undefined ) texture.rotation = data.rotation; if ( data.wrap !== undefined ) { texture.wrapS = parseConstant( data.wrap[ 0 ], TEXTURE_WRAPPING ); texture.wrapT = parseConstant( data.wrap[ 1 ], TEXTURE_WRAPPING ); } if ( data.format !== undefined ) texture.format = data.format; if ( data.type !== undefined ) texture.type = data.type; if ( data.encoding !== undefined ) texture.encoding = data.encoding; if ( data.minFilter !== undefined ) texture.minFilter = parseConstant( data.minFilter, TEXTURE_FILTER ); if ( data.magFilter !== undefined ) texture.magFilter = parseConstant( data.magFilter, TEXTURE_FILTER ); if ( data.anisotropy !== undefined ) texture.anisotropy = data.anisotropy; if ( data.flipY !== undefined ) texture.flipY = data.flipY; if ( data.premultiplyAlpha !== undefined ) texture.premultiplyAlpha = data.premultiplyAlpha; if ( data.unpackAlignment !== undefined ) texture.unpackAlignment = data.unpackAlignment; textures[ data.uuid ] = texture; } } return textures; }, parseObject: function ( data, geometries, materials ) { var object; function getGeometry( name ) { if ( geometries[ name ] === undefined ) { console.warn( 'THREE.ObjectLoader: Undefined geometry', name ); } return geometries[ name ]; } function getMaterial( name ) { if ( name === undefined ) return undefined; if ( Array.isArray( name ) ) { var array = []; for ( var i = 0, l = name.length; i < l; i ++ ) { var uuid = name[ i ]; if ( materials[ uuid ] === undefined ) { console.warn( 'THREE.ObjectLoader: Undefined material', uuid ); } array.push( materials[ uuid ] ); } return array; } if ( materials[ name ] === undefined ) { console.warn( 'THREE.ObjectLoader: Undefined material', name ); } return materials[ name ]; } switch ( data.type ) { case 'Scene': object = new Scene(); if ( data.background !== undefined ) { if ( Number.isInteger( data.background ) ) { object.background = new Color( data.background ); } } if ( data.fog !== undefined ) { if ( data.fog.type === 'Fog' ) { object.fog = new Fog( data.fog.color, data.fog.near, data.fog.far ); } else if ( data.fog.type === 'FogExp2' ) { object.fog = new FogExp2( data.fog.color, data.fog.density ); } } break; case 'PerspectiveCamera': object = new PerspectiveCamera( data.fov, data.aspect, data.near, data.far ); if ( data.focus !== undefined ) object.focus = data.focus; if ( data.zoom !== undefined ) object.zoom = data.zoom; if ( data.filmGauge !== undefined ) object.filmGauge = data.filmGauge; if ( data.filmOffset !== undefined ) object.filmOffset = data.filmOffset; if ( data.view !== undefined ) object.view = Object.assign( {}, data.view ); break; case 'OrthographicCamera': object = new OrthographicCamera( data.left, data.right, data.top, data.bottom, data.near, data.far ); if ( data.zoom !== undefined ) object.zoom = data.zoom; if ( data.view !== undefined ) object.view = Object.assign( {}, data.view ); break; case 'AmbientLight': object = new AmbientLight( data.color, data.intensity ); break; case 'DirectionalLight': object = new DirectionalLight( data.color, data.intensity ); break; case 'PointLight': object = new PointLight( data.color, data.intensity, data.distance, data.decay ); break; case 'RectAreaLight': object = new RectAreaLight( data.color, data.intensity, data.width, data.height ); break; case 'SpotLight': object = new SpotLight( data.color, data.intensity, data.distance, data.angle, data.penumbra, data.decay ); break; case 'HemisphereLight': object = new HemisphereLight( data.color, data.groundColor, data.intensity ); break; case 'SkinnedMesh': console.warn( 'THREE.ObjectLoader.parseObject() does not support SkinnedMesh yet.' ); case 'Mesh': var geometry = getGeometry( data.geometry ); var material = getMaterial( data.material ); if ( geometry.bones && geometry.bones.length > 0 ) { object = new SkinnedMesh( geometry, material ); } else { object = new Mesh( geometry, material ); } if ( data.drawMode !== undefined ) object.setDrawMode( data.drawMode ); break; case 'LOD': object = new LOD(); break; case 'Line': object = new Line( getGeometry( data.geometry ), getMaterial( data.material ), data.mode ); break; case 'LineLoop': object = new LineLoop( getGeometry( data.geometry ), getMaterial( data.material ) ); break; case 'LineSegments': object = new LineSegments( getGeometry( data.geometry ), getMaterial( data.material ) ); break; case 'PointCloud': case 'Points': object = new Points( getGeometry( data.geometry ), getMaterial( data.material ) ); break; case 'Sprite': object = new Sprite( getMaterial( data.material ) ); break; case 'Group': object = new Group(); break; default: object = new Object3D(); } object.uuid = data.uuid; if ( data.name !== undefined ) object.name = data.name; if ( data.matrix !== undefined ) { object.matrix.fromArray( data.matrix ); if ( data.matrixAutoUpdate !== undefined ) object.matrixAutoUpdate = data.matrixAutoUpdate; if ( object.matrixAutoUpdate ) object.matrix.decompose( object.position, object.quaternion, object.scale ); } else { if ( data.position !== undefined ) object.position.fromArray( data.position ); if ( data.rotation !== undefined ) object.rotation.fromArray( data.rotation ); if ( data.quaternion !== undefined ) object.quaternion.fromArray( data.quaternion ); if ( data.scale !== undefined ) object.scale.fromArray( data.scale ); } if ( data.castShadow !== undefined ) object.castShadow = data.castShadow; if ( data.receiveShadow !== undefined ) object.receiveShadow = data.receiveShadow; if ( data.shadow ) { if ( data.shadow.bias !== undefined ) object.shadow.bias = data.shadow.bias; if ( data.shadow.radius !== undefined ) object.shadow.radius = data.shadow.radius; if ( data.shadow.mapSize !== undefined ) object.shadow.mapSize.fromArray( data.shadow.mapSize ); if ( data.shadow.camera !== undefined ) object.shadow.camera = this.parseObject( data.shadow.camera ); } if ( data.visible !== undefined ) object.visible = data.visible; if ( data.frustumCulled !== undefined ) object.frustumCulled = data.frustumCulled; if ( data.renderOrder !== undefined ) object.renderOrder = data.renderOrder; if ( data.userData !== undefined ) object.userData = data.userData; if ( data.layers !== undefined ) object.layers.mask = data.layers; if ( data.children !== undefined ) { var children = data.children; for ( var i = 0; i < children.length; i ++ ) { object.add( this.parseObject( children[ i ], geometries, materials ) ); } } if ( data.type === 'LOD' ) { var levels = data.levels; for ( var l = 0; l < levels.length; l ++ ) { var level = levels[ l ]; var child = object.getObjectByProperty( 'uuid', level.object ); if ( child !== undefined ) { object.addLevel( child, level.distance ); } } } return object; } } ); var TEXTURE_MAPPING = { UVMapping: UVMapping, CubeReflectionMapping: CubeReflectionMapping, CubeRefractionMapping: CubeRefractionMapping, EquirectangularReflectionMapping: EquirectangularReflectionMapping, EquirectangularRefractionMapping: EquirectangularRefractionMapping, SphericalReflectionMapping: SphericalReflectionMapping, CubeUVReflectionMapping: CubeUVReflectionMapping, CubeUVRefractionMapping: CubeUVRefractionMapping }; var TEXTURE_WRAPPING = { RepeatWrapping: RepeatWrapping, ClampToEdgeWrapping: ClampToEdgeWrapping, MirroredRepeatWrapping: MirroredRepeatWrapping }; var TEXTURE_FILTER = { NearestFilter: NearestFilter, NearestMipMapNearestFilter: NearestMipMapNearestFilter, NearestMipMapLinearFilter: NearestMipMapLinearFilter, LinearFilter: LinearFilter, LinearMipMapNearestFilter: LinearMipMapNearestFilter, LinearMipMapLinearFilter: LinearMipMapLinearFilter }; /** * @author thespite / http://clicktorelease.com/ */ function ImageBitmapLoader( manager ) { if ( typeof createImageBitmap === 'undefined' ) { console.warn( 'THREE.ImageBitmapLoader: createImageBitmap() not supported.' ); } if ( typeof fetch === 'undefined' ) { console.warn( 'THREE.ImageBitmapLoader: fetch() not supported.' ); } this.manager = manager !== undefined ? manager : DefaultLoadingManager; this.options = undefined; } ImageBitmapLoader.prototype = { constructor: ImageBitmapLoader, setOptions: function setOptions( options ) { this.options = options; return this; }, load: function ( url, onLoad, onProgress, onError ) { if ( url === undefined ) url = ''; if ( this.path !== undefined ) url = this.path + url; url = this.manager.resolveURL( url ); var scope = this; var cached = Cache.get( url ); if ( cached !== undefined ) { scope.manager.itemStart( url ); setTimeout( function () { if ( onLoad ) onLoad( cached ); scope.manager.itemEnd( url ); }, 0 ); return cached; } fetch( url ).then( function ( res ) { return res.blob(); } ).then( function ( blob ) { return createImageBitmap( blob, scope.options ); } ).then( function ( imageBitmap ) { Cache.add( url, imageBitmap ); if ( onLoad ) onLoad( imageBitmap ); scope.manager.itemEnd( url ); } ).catch( function ( e ) { if ( onError ) onError( e ); scope.manager.itemError( url ); scope.manager.itemEnd( url ); } ); }, setCrossOrigin: function ( /* value */ ) { return this; }, setPath: function ( value ) { this.path = value; return this; } }; /** * @author zz85 / http://www.lab4games.net/zz85/blog * minimal class for proxing functions to Path. Replaces old \"extractSubpaths()\" **/ function ShapePath() { this.type = 'ShapePath'; this.color = new Color(); this.subPaths = []; this.currentPath = null; } Object.assign( ShapePath.prototype, { moveTo: function ( x, y ) { this.currentPath = new Path(); this.subPaths.push( this.currentPath ); this.currentPath.moveTo( x, y ); }, lineTo: function ( x, y ) { this.currentPath.lineTo( x, y ); }, quadraticCurveTo: function ( aCPx, aCPy, aX, aY ) { this.currentPath.quadraticCurveTo( aCPx, aCPy, aX, aY ); }, bezierCurveTo: function ( aCP1x, aCP1y, aCP2x, aCP2y, aX, aY ) { this.currentPath.bezierCurveTo( aCP1x, aCP1y, aCP2x, aCP2y, aX, aY ); }, splineThru: function ( pts ) { this.currentPath.splineThru( pts ); }, toShapes: function ( isCCW, noHoles ) { function toShapesNoHoles( inSubpaths ) { var shapes = []; for ( var i = 0, l = inSubpaths.length; i < l; i ++ ) { var tmpPath = inSubpaths[ i ]; var tmpShape = new Shape(); tmpShape.curves = tmpPath.curves; shapes.push( tmpShape ); } return shapes; } function isPointInsidePolygon( inPt, inPolygon ) { var polyLen = inPolygon.length; // inPt on polygon contour => immediate success or // toggling of inside/outside at every single! intersection point of an edge // with the horizontal line through inPt, left of inPt // not counting lowerY endpoints of edges and whole edges on that line var inside = false; for ( var p = polyLen - 1, q = 0; q < polyLen; p = q ++ ) { var edgeLowPt = inPolygon[ p ]; var edgeHighPt = inPolygon[ q ]; var edgeDx = edgeHighPt.x - edgeLowPt.x; var edgeDy = edgeHighPt.y - edgeLowPt.y; if ( Math.abs( edgeDy ) > Number.EPSILON ) { // not parallel if ( edgeDy < 0 ) { edgeLowPt = inPolygon[ q ]; edgeDx = - edgeDx; edgeHighPt = inPolygon[ p ]; edgeDy = - edgeDy; } if ( ( inPt.y < edgeLowPt.y ) || ( inPt.y > edgeHighPt.y ) ) continue; if ( inPt.y === edgeLowPt.y ) { if ( inPt.x === edgeLowPt.x ) return true; // inPt is on contour ? // continue; // no intersection or edgeLowPt => doesn't count !!! } else { var perpEdge = edgeDy * ( inPt.x - edgeLowPt.x ) - edgeDx * ( inPt.y - edgeLowPt.y ); if ( perpEdge === 0 ) return true; // inPt is on contour ? if ( perpEdge < 0 ) continue; inside = ! inside; // true intersection left of inPt } } else { // parallel or collinear if ( inPt.y !== edgeLowPt.y ) continue; // parallel // edge lies on the same horizontal line as inPt if ( ( ( edgeHighPt.x 1 ) { var ambiguous = false; var toChange = []; for ( var sIdx = 0, sLen = newShapes.length; sIdx < sLen; sIdx ++ ) { betterShapeHoles[ sIdx ] = []; } for ( var sIdx = 0, sLen = newShapes.length; sIdx < sLen; sIdx ++ ) { var sho = newShapeHoles[ sIdx ]; for ( var hIdx = 0; hIdx < sho.length; hIdx ++ ) { var ho = sho[ hIdx ]; var hole_unassigned = true; for ( var s2Idx = 0; s2Idx < newShapes.length; s2Idx ++ ) { if ( isPointInsidePolygon( ho.p, newShapes[ s2Idx ].p ) ) { if ( sIdx !== s2Idx ) toChange.push( { froms: sIdx, tos: s2Idx, hole: hIdx } ); if ( hole_unassigned ) { hole_unassigned = false; betterShapeHoles[ s2Idx ].push( ho ); } else { ambiguous = true; } } } if ( hole_unassigned ) { betterShapeHoles[ sIdx ].push( ho ); } } } // console.log(\"ambiguous: \", ambiguous); if ( toChange.length > 0 ) { // console.log(\"to change: \", toChange); if ( ! ambiguous ) newShapeHoles = betterShapeHoles; } } var tmpHoles; for ( var i = 0, il = newShapes.length; i < il; i ++ ) { tmpShape = newShapes[ i ].s; shapes.push( tmpShape ); tmpHoles = newShapeHoles[ i ]; for ( var j = 0, jl = tmpHoles.length; j < jl; j ++ ) { tmpShape.holes.push( tmpHoles[ j ].h ); } } //console.log(\"shape\", shapes); return shapes; } } ); /** * @author zz85 / http://www.lab4games.net/zz85/blog * @author mrdoob / http://mrdoob.com/ */ function Font( data ) { this.type = 'Font'; this.data = data; } Object.assign( Font.prototype, { isFont: true, generateShapes: function ( text, size ) { if ( size === undefined ) size = 100; var shapes = []; var paths = createPaths( text, size, this.data ); for ( var p = 0, pl = paths.length; p < pl; p ++ ) { Array.prototype.push.apply( shapes, paths[ p ].toShapes() ); } return shapes; } } ); function createPaths( text, size, data ) { var chars = Array.from ? Array.from( text ) : String( text ).split( '' ); // see #13988 var scale = size / data.resolution; var line_height = ( data.boundingBox.yMax - data.boundingBox.yMin + data.underlineThickness ) * scale; var paths = []; var offsetX = 0, offsetY = 0; for ( var i = 0; i < chars.length; i ++ ) { var char = chars[ i ]; if ( char === '\\n' ) { offsetX = 0; offsetY -= line_height; } else { var ret = createPath( char, scale, offsetX, offsetY, data ); offsetX += ret.offsetX; paths.push( ret.path ); } } return paths; } function createPath( char, scale, offsetX, offsetY, data ) { var glyph = data.glyphs[ char ] || data.glyphs[ '?' ]; if ( ! glyph ) return; var path = new ShapePath(); var x, y, cpx, cpy, cpx1, cpy1, cpx2, cpy2; if ( glyph.o ) { var outline = glyph._cachedOutline || ( glyph._cachedOutline = glyph.o.split( ' ' ) ); for ( var i = 0, l = outline.length; i < l; ) { var action = outline[ i ++ ]; switch ( action ) { case 'm': // moveTo x = outline[ i ++ ] * scale + offsetX; y = outline[ i ++ ] * scale + offsetY; path.moveTo( x, y ); break; case 'l': // lineTo x = outline[ i ++ ] * scale + offsetX; y = outline[ i ++ ] * scale + offsetY; path.lineTo( x, y ); break; case 'q': // quadraticCurveTo cpx = outline[ i ++ ] * scale + offsetX; cpy = outline[ i ++ ] * scale + offsetY; cpx1 = outline[ i ++ ] * scale + offsetX; cpy1 = outline[ i ++ ] * scale + offsetY; path.quadraticCurveTo( cpx1, cpy1, cpx, cpy ); break; case 'b': // bezierCurveTo cpx = outline[ i ++ ] * scale + offsetX; cpy = outline[ i ++ ] * scale + offsetY; cpx1 = outline[ i ++ ] * scale + offsetX; cpy1 = outline[ i ++ ] * scale + offsetY; cpx2 = outline[ i ++ ] * scale + offsetX; cpy2 = outline[ i ++ ] * scale + offsetY; path.bezierCurveTo( cpx1, cpy1, cpx2, cpy2, cpx, cpy ); break; } } } return { offsetX: glyph.ha * scale, path: path }; } /** * @author mrdoob / http://mrdoob.com/ */ function FontLoader( manager ) { this.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager; } Object.assign( FontLoader.prototype, { load: function ( url, onLoad, onProgress, onError ) { var scope = this; var loader = new FileLoader( this.manager ); loader.setPath( this.path ); loader.load( url, function ( text ) { var json; try { json = JSON.parse( text ); } catch ( e ) { console.warn( 'THREE.FontLoader: typeface.js support is being deprecated. Use typeface.json instead.' ); json = JSON.parse( text.substring( 65, text.length - 2 ) ); } var font = scope.parse( json ); if ( onLoad ) onLoad( font ); }, onProgress, onError ); }, parse: function ( json ) { return new Font( json ); }, setPath: function ( value ) { this.path = value; return this; } } ); /** * @author alteredq / http://alteredqualia.com/ */ function Loader() {} Loader.Handlers = { handlers: [], add: function ( regex, loader ) { this.handlers.push( regex, loader ); }, get: function ( file ) { var handlers = this.handlers; for ( var i = 0, l = handlers.length; i < l; i += 2 ) { var regex = handlers[ i ]; var loader = handlers[ i + 1 ]; if ( regex.test( file ) ) { return loader; } } return null; } }; Object.assign( Loader.prototype, { crossOrigin: 'anonymous', onLoadStart: function () {}, onLoadProgress: function () {}, onLoadComplete: function () {}, initMaterials: function ( materials, texturePath, crossOrigin ) { var array = []; for ( var i = 0; i < materials.length; ++ i ) { array[ i ] = this.createMaterial( materials[ i ], texturePath, crossOrigin ); } return array; }, createMaterial: ( function () { var BlendingMode = { NoBlending: NoBlending, NormalBlending: NormalBlending, AdditiveBlending: AdditiveBlending, SubtractiveBlending: SubtractiveBlending, MultiplyBlending: MultiplyBlending, CustomBlending: CustomBlending }; var color = new Color(); var textureLoader = new TextureLoader(); var materialLoader = new MaterialLoader(); return function createMaterial( m, texturePath, crossOrigin ) { // convert from old material format var textures = {}; function loadTexture( path, repeat, offset, wrap, anisotropy ) { var fullPath = texturePath + path; var loader = Loader.Handlers.get( fullPath ); var texture; if ( loader !== null ) { texture = loader.load( fullPath ); } else { textureLoader.setCrossOrigin( crossOrigin ); texture = textureLoader.load( fullPath ); } if ( repeat !== undefined ) { texture.repeat.fromArray( repeat ); if ( repeat[ 0 ] !== 1 ) texture.wrapS = RepeatWrapping; if ( repeat[ 1 ] !== 1 ) texture.wrapT = RepeatWrapping; } if ( offset !== undefined ) { texture.offset.fromArray( offset ); } if ( wrap !== undefined ) { if ( wrap[ 0 ] === 'repeat' ) texture.wrapS = RepeatWrapping; if ( wrap[ 0 ] === 'mirror' ) texture.wrapS = MirroredRepeatWrapping; if ( wrap[ 1 ] === 'repeat' ) texture.wrapT = RepeatWrapping; if ( wrap[ 1 ] === 'mirror' ) texture.wrapT = MirroredRepeatWrapping; } if ( anisotropy !== undefined ) { texture.anisotropy = anisotropy; } var uuid = _Math.generateUUID(); textures[ uuid ] = texture; return uuid; } // var json = { uuid: _Math.generateUUID(), type: 'MeshLambertMaterial' }; for ( var name in m ) { var value = m[ name ]; switch ( name ) { case 'DbgColor': case 'DbgIndex': case 'opticalDensity': case 'illumination': break; case 'DbgName': json.name = value; break; case 'blending': json.blending = BlendingMode[ value ]; break; case 'colorAmbient': case 'mapAmbient': console.warn( 'THREE.Loader.createMaterial:', name, 'is no longer supported.' ); break; case 'colorDiffuse': json.color = color.fromArray( value ).getHex(); break; case 'colorSpecular': json.specular = color.fromArray( value ).getHex(); break; case 'colorEmissive': json.emissive = color.fromArray( value ).getHex(); break; case 'specularCoef': json.shininess = value; break; case 'shading': if ( value.toLowerCase() === 'basic' ) json.type = 'MeshBasicMaterial'; if ( value.toLowerCase() === 'phong' ) json.type = 'MeshPhongMaterial'; if ( value.toLowerCase() === 'standard' ) json.type = 'MeshStandardMaterial'; break; case 'mapDiffuse': json.map = loadTexture( value, m.mapDiffuseRepeat, m.mapDiffuseOffset, m.mapDiffuseWrap, m.mapDiffuseAnisotropy ); break; case 'mapDiffuseRepeat': case 'mapDiffuseOffset': case 'mapDiffuseWrap': case 'mapDiffuseAnisotropy': break; case 'mapEmissive': json.emissiveMap = loadTexture( value, m.mapEmissiveRepeat, m.mapEmissiveOffset, m.mapEmissiveWrap, m.mapEmissiveAnisotropy ); break; case 'mapEmissiveRepeat': case 'mapEmissiveOffset': case 'mapEmissiveWrap': case 'mapEmissiveAnisotropy': break; case 'mapLight': json.lightMap = loadTexture( value, m.mapLightRepeat, m.mapLightOffset, m.mapLightWrap, m.mapLightAnisotropy ); break; case 'mapLightRepeat': case 'mapLightOffset': case 'mapLightWrap': case 'mapLightAnisotropy': break; case 'mapAO': json.aoMap = loadTexture( value, m.mapAORepeat, m.mapAOOffset, m.mapAOWrap, m.mapAOAnisotropy ); break; case 'mapAORepeat': case 'mapAOOffset': case 'mapAOWrap': case 'mapAOAnisotropy': break; case 'mapBump': json.bumpMap = loadTexture( value, m.mapBumpRepeat, m.mapBumpOffset, m.mapBumpWrap, m.mapBumpAnisotropy ); break; case 'mapBumpScale': json.bumpScale = value; break; case 'mapBumpRepeat': case 'mapBumpOffset': case 'mapBumpWrap': case 'mapBumpAnisotropy': break; case 'mapNormal': json.normalMap = loadTexture( value, m.mapNormalRepeat, m.mapNormalOffset, m.mapNormalWrap, m.mapNormalAnisotropy ); break; case 'mapNormalFactor': json.normalScale = value; break; case 'mapNormalRepeat': case 'mapNormalOffset': case 'mapNormalWrap': case 'mapNormalAnisotropy': break; case 'mapSpecular': json.specularMap = loadTexture( value, m.mapSpecularRepeat, m.mapSpecularOffset, m.mapSpecularWrap, m.mapSpecularAnisotropy ); break; case 'mapSpecularRepeat': case 'mapSpecularOffset': case 'mapSpecularWrap': case 'mapSpecularAnisotropy': break; case 'mapMetalness': json.metalnessMap = loadTexture( value, m.mapMetalnessRepeat, m.mapMetalnessOffset, m.mapMetalnessWrap, m.mapMetalnessAnisotropy ); break; case 'mapMetalnessRepeat': case 'mapMetalnessOffset': case 'mapMetalnessWrap': case 'mapMetalnessAnisotropy': break; case 'mapRoughness': json.roughnessMap = loadTexture( value, m.mapRoughnessRepeat, m.mapRoughnessOffset, m.mapRoughnessWrap, m.mapRoughnessAnisotropy ); break; case 'mapRoughnessRepeat': case 'mapRoughnessOffset': case 'mapRoughnessWrap': case 'mapRoughnessAnisotropy': break; case 'mapAlpha': json.alphaMap = loadTexture( value, m.mapAlphaRepeat, m.mapAlphaOffset, m.mapAlphaWrap, m.mapAlphaAnisotropy ); break; case 'mapAlphaRepeat': case 'mapAlphaOffset': case 'mapAlphaWrap': case 'mapAlphaAnisotropy': break; case 'flipSided': json.side = BackSide; break; case 'doubleSided': json.side = DoubleSide; break; case 'transparency': console.warn( 'THREE.Loader.createMaterial: transparency has been renamed to opacity' ); json.opacity = value; break; case 'depthTest': case 'depthWrite': case 'colorWrite': case 'opacity': case 'reflectivity': case 'transparent': case 'visible': case 'wireframe': json[ name ] = value; break; case 'vertexColors': if ( value === true ) json.vertexColors = VertexColors; if ( value === 'face' ) json.vertexColors = FaceColors; break; default: console.error( 'THREE.Loader.createMaterial: Unsupported', name, value ); break; } } if ( json.type === 'MeshBasicMaterial' ) delete json.emissive; if ( json.type !== 'MeshPhongMaterial' ) delete json.specular; if ( json.opacity < 1 ) json.transparent = true; materialLoader.setTextures( textures ); return materialLoader.parse( json ); }; } )() } ); /** * @author mrdoob / http://mrdoob.com/ */ var context; var AudioContext = { getContext: function () { if ( context === undefined ) { context = new ( window.AudioContext || window.webkitAudioContext )(); } return context; }, setContext: function ( value ) { context = value; } }; /** * @author Reece Aaron Lecrivain / http://reecenotes.com/ */ function AudioLoader( manager ) { this.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager; } Object.assign( AudioLoader.prototype, { load: function ( url, onLoad, onProgress, onError ) { var loader = new FileLoader( this.manager ); loader.setResponseType( 'arraybuffer' ); loader.setPath( this.path ); loader.load( url, function ( buffer ) { // Create a copy of the buffer. The `decodeAudioData` method // detaches the buffer when complete, preventing reuse. var bufferCopy = buffer.slice( 0 ); var context = AudioContext.getContext(); context.decodeAudioData( bufferCopy, function ( audioBuffer ) { onLoad( audioBuffer ); } ); }, onProgress, onError ); }, setPath: function ( value ) { this.path = value; return this; } } ); /** * @author mrdoob / http://mrdoob.com/ */ function StereoCamera() { this.type = 'StereoCamera'; this.aspect = 1; this.eyeSep = 0.064; this.cameraL = new PerspectiveCamera(); this.cameraL.layers.enable( 1 ); this.cameraL.matrixAutoUpdate = false; this.cameraR = new PerspectiveCamera(); this.cameraR.layers.enable( 2 ); this.cameraR.matrixAutoUpdate = false; } Object.assign( StereoCamera.prototype, { update: ( function () { var instance, focus, fov, aspect, near, far, zoom, eyeSep; var eyeRight = new Matrix4(); var eyeLeft = new Matrix4(); return function update( camera ) { var needsUpdate = instance !== this || focus !== camera.focus || fov !== camera.fov || aspect !== camera.aspect * this.aspect || near !== camera.near || far !== camera.far || zoom !== camera.zoom || eyeSep !== this.eyeSep; if ( needsUpdate ) { instance = this; focus = camera.focus; fov = camera.fov; aspect = camera.aspect * this.aspect; near = camera.near; far = camera.far; zoom = camera.zoom; // Off-axis stereoscopic effect based on // http://paulbourke.net/stereographics/stereorender/ var projectionMatrix = camera.projectionMatrix.clone(); eyeSep = this.eyeSep / 2; var eyeSepOnProjection = eyeSep * near / focus; var ymax = ( near * Math.tan( _Math.DEG2RAD * fov * 0.5 ) ) / zoom; var xmin, xmax; // translate xOffset eyeLeft.elements[ 12 ] = - eyeSep; eyeRight.elements[ 12 ] = eyeSep; // for left eye xmin = - ymax * aspect + eyeSepOnProjection; xmax = ymax * aspect + eyeSepOnProjection; projectionMatrix.elements[ 0 ] = 2 * near / ( xmax - xmin ); projectionMatrix.elements[ 8 ] = ( xmax + xmin ) / ( xmax - xmin ); this.cameraL.projectionMatrix.copy( projectionMatrix ); // for right eye xmin = - ymax * aspect - eyeSepOnProjection; xmax = ymax * aspect - eyeSepOnProjection; projectionMatrix.elements[ 0 ] = 2 * near / ( xmax - xmin ); projectionMatrix.elements[ 8 ] = ( xmax + xmin ) / ( xmax - xmin ); this.cameraR.projectionMatrix.copy( projectionMatrix ); } this.cameraL.matrixWorld.copy( camera.matrixWorld ).multiply( eyeLeft ); this.cameraR.matrixWorld.copy( camera.matrixWorld ).multiply( eyeRight ); }; } )() } ); /** * Camera for rendering cube maps * - renders scene into axis-aligned cube * * @author alteredq / http://alteredqualia.com/ */ function CubeCamera( near, far, cubeResolution, options ) { Object3D.call( this ); this.type = 'CubeCamera'; var fov = 90, aspect = 1; var cameraPX = new PerspectiveCamera( fov, aspect, near, far ); cameraPX.up.set( 0, - 1, 0 ); cameraPX.lookAt( new Vector3( 1, 0, 0 ) ); this.add( cameraPX ); var cameraNX = new PerspectiveCamera( fov, aspect, near, far ); cameraNX.up.set( 0, - 1, 0 ); cameraNX.lookAt( new Vector3( - 1, 0, 0 ) ); this.add( cameraNX ); var cameraPY = new PerspectiveCamera( fov, aspect, near, far ); cameraPY.up.set( 0, 0, 1 ); cameraPY.lookAt( new Vector3( 0, 1, 0 ) ); this.add( cameraPY ); var cameraNY = new PerspectiveCamera( fov, aspect, near, far ); cameraNY.up.set( 0, 0, - 1 ); cameraNY.lookAt( new Vector3( 0, - 1, 0 ) ); this.add( cameraNY ); var cameraPZ = new PerspectiveCamera( fov, aspect, near, far ); cameraPZ.up.set( 0, - 1, 0 ); cameraPZ.lookAt( new Vector3( 0, 0, 1 ) ); this.add( cameraPZ ); var cameraNZ = new PerspectiveCamera( fov, aspect, near, far ); cameraNZ.up.set( 0, - 1, 0 ); cameraNZ.lookAt( new Vector3( 0, 0, - 1 ) ); this.add( cameraNZ ); options = options || { format: RGBFormat, magFilter: LinearFilter, minFilter: LinearFilter }; this.renderTarget = new WebGLRenderTargetCube( cubeResolution, cubeResolution, options ); this.renderTarget.texture.name = \"CubeCamera\"; this.update = function ( renderer, scene ) { if ( this.parent === null ) this.updateMatrixWorld(); var currentRenderTarget = renderer.getRenderTarget(); var renderTarget = this.renderTarget; var generateMipmaps = renderTarget.texture.generateMipmaps; renderTarget.texture.generateMipmaps = false; renderTarget.activeCubeFace = 0; renderer.setRenderTarget( renderTarget ); renderer.render( scene, cameraPX ); renderTarget.activeCubeFace = 1; renderer.render( scene, cameraNX ); renderTarget.activeCubeFace = 2; renderer.render( scene, cameraPY ); renderTarget.activeCubeFace = 3; renderer.render( scene, cameraNY ); renderTarget.activeCubeFace = 4; renderer.render( scene, cameraPZ ); renderTarget.texture.generateMipmaps = generateMipmaps; renderTarget.activeCubeFace = 5; renderer.render( scene, cameraNZ ); renderer.setRenderTarget( currentRenderTarget ); }; this.clear = function ( renderer, color, depth, stencil ) { var currentRenderTarget = renderer.getRenderTarget(); var renderTarget = this.renderTarget; for ( var i = 0; i < 6; i ++ ) { renderTarget.activeCubeFace = i; renderer.setRenderTarget( renderTarget ); renderer.clear( color, depth, stencil ); } renderer.setRenderTarget( currentRenderTarget ); }; } CubeCamera.prototype = Object.create( Object3D.prototype ); CubeCamera.prototype.constructor = CubeCamera; /** * @author alteredq / http://alteredqualia.com/ */ function Clock( autoStart ) { this.autoStart = ( autoStart !== undefined ) ? autoStart : true; this.startTime = 0; this.oldTime = 0; this.elapsedTime = 0; this.running = false; } Object.assign( Clock.prototype, { start: function () { this.startTime = ( typeof performance === 'undefined' ? Date : performance ).now(); // see #10732 this.oldTime = this.startTime; this.elapsedTime = 0; this.running = true; }, stop: function () { this.getElapsedTime(); this.running = false; this.autoStart = false; }, getElapsedTime: function () { this.getDelta(); return this.elapsedTime; }, getDelta: function () { var diff = 0; if ( this.autoStart && ! this.running ) { this.start(); return 0; } if ( this.running ) { var newTime = ( typeof performance === 'undefined' ? Date : performance ).now(); diff = ( newTime - this.oldTime ) / 1000; this.oldTime = newTime; this.elapsedTime += diff; } return diff; } } ); /** * @author mrdoob / http://mrdoob.com/ */ function AudioListener() { Object3D.call( this ); this.type = 'AudioListener'; this.context = AudioContext.getContext(); this.gain = this.context.createGain(); this.gain.connect( this.context.destination ); this.filter = null; this.timeDelta = 0; } AudioListener.prototype = Object.assign( Object.create( Object3D.prototype ), { constructor: AudioListener, getInput: function () { return this.gain; }, removeFilter: function ( ) { if ( this.filter !== null ) { this.gain.disconnect( this.filter ); this.filter.disconnect( this.context.destination ); this.gain.connect( this.context.destination ); this.filter = null; } return this; }, getFilter: function () { return this.filter; }, setFilter: function ( value ) { if ( this.filter !== null ) { this.gain.disconnect( this.filter ); this.filter.disconnect( this.context.destination ); } else { this.gain.disconnect( this.context.destination ); } this.filter = value; this.gain.connect( this.filter ); this.filter.connect( this.context.destination ); return this; }, getMasterVolume: function () { return this.gain.gain.value; }, setMasterVolume: function ( value ) { this.gain.gain.setTargetAtTime( value, this.context.currentTime, 0.01 ); return this; }, updateMatrixWorld: ( function () { var position = new Vector3(); var quaternion = new Quaternion(); var scale = new Vector3(); var orientation = new Vector3(); var clock = new Clock(); return function updateMatrixWorld( force ) { Object3D.prototype.updateMatrixWorld.call( this, force ); var listener = this.context.listener; var up = this.up; this.timeDelta = clock.getDelta(); this.matrixWorld.decompose( position, quaternion, scale ); orientation.set( 0, 0, - 1 ).applyQuaternion( quaternion ); if ( listener.positionX ) { // code path for Chrome (see #14393) var endTime = this.context.currentTime + this.timeDelta; listener.positionX.linearRampToValueAtTime( position.x, endTime ); listener.positionY.linearRampToValueAtTime( position.y, endTime ); listener.positionZ.linearRampToValueAtTime( position.z, endTime ); listener.forwardX.linearRampToValueAtTime( orientation.x, endTime ); listener.forwardY.linearRampToValueAtTime( orientation.y, endTime ); listener.forwardZ.linearRampToValueAtTime( orientation.z, endTime ); listener.upX.linearRampToValueAtTime( up.x, endTime ); listener.upY.linearRampToValueAtTime( up.y, endTime ); listener.upZ.linearRampToValueAtTime( up.z, endTime ); } else { listener.setPosition( position.x, position.y, position.z ); listener.setOrientation( orientation.x, orientation.y, orientation.z, up.x, up.y, up.z ); } }; } )() } ); /** * @author mrdoob / http://mrdoob.com/ * @author Reece Aaron Lecrivain / http://reecenotes.com/ */ function Audio( listener ) { Object3D.call( this ); this.type = 'Audio'; this.listener = listener; this.context = listener.context; this.gain = this.context.createGain(); this.gain.connect( listener.getInput() ); this.autoplay = false; this.buffer = null; this.detune = 0; this.loop = false; this.startTime = 0; this.offset = 0; this.playbackRate = 1; this.isPlaying = false; this.hasPlaybackControl = true; this.sourceType = 'empty'; this.filters = []; } Audio.prototype = Object.assign( Object.create( Object3D.prototype ), { constructor: Audio, getOutput: function () { return this.gain; }, setNodeSource: function ( audioNode ) { this.hasPlaybackControl = false; this.sourceType = 'audioNode'; this.source = audioNode; this.connect(); return this; }, setMediaElementSource: function ( mediaElement ) { this.hasPlaybackControl = false; this.sourceType = 'mediaNode'; this.source = this.context.createMediaElementSource( mediaElement ); this.connect(); return this; }, setBuffer: function ( audioBuffer ) { this.buffer = audioBuffer; this.sourceType = 'buffer'; if ( this.autoplay ) this.play(); return this; }, play: function () { if ( this.isPlaying === true ) { console.warn( 'THREE.Audio: Audio is already playing.' ); return; } if ( this.hasPlaybackControl === false ) { console.warn( 'THREE.Audio: this Audio has no playback control.' ); return; } var source = this.context.createBufferSource(); source.buffer = this.buffer; source.loop = this.loop; source.onended = this.onEnded.bind( this ); this.startTime = this.context.currentTime; source.start( this.startTime, this.offset ); this.isPlaying = true; this.source = source; this.setDetune( this.detune ); this.setPlaybackRate( this.playbackRate ); return this.connect(); }, pause: function () { if ( this.hasPlaybackControl === false ) { console.warn( 'THREE.Audio: this Audio has no playback control.' ); return; } if ( this.isPlaying === true ) { this.source.stop(); this.source.onended = null; this.offset += ( this.context.currentTime - this.startTime ) * this.playbackRate; this.isPlaying = false; } return this; }, stop: function () { if ( this.hasPlaybackControl === false ) { console.warn( 'THREE.Audio: this Audio has no playback control.' ); return; } this.source.stop(); this.source.onended = null; this.offset = 0; this.isPlaying = false; return this; }, connect: function () { if ( this.filters.length > 0 ) { this.source.connect( this.filters[ 0 ] ); for ( var i = 1, l = this.filters.length; i < l; i ++ ) { this.filters[ i - 1 ].connect( this.filters[ i ] ); } this.filters[ this.filters.length - 1 ].connect( this.getOutput() ); } else { this.source.connect( this.getOutput() ); } return this; }, disconnect: function () { if ( this.filters.length > 0 ) { this.source.disconnect( this.filters[ 0 ] ); for ( var i = 1, l = this.filters.length; i < l; i ++ ) { this.filters[ i - 1 ].disconnect( this.filters[ i ] ); } this.filters[ this.filters.length - 1 ].disconnect( this.getOutput() ); } else { this.source.disconnect( this.getOutput() ); } return this; }, getFilters: function () { return this.filters; }, setFilters: function ( value ) { if ( ! value ) value = []; if ( this.isPlaying === true ) { this.disconnect(); this.filters = value; this.connect(); } else { this.filters = value; } return this; }, setDetune: function ( value ) { this.detune = value; if ( this.source.detune === undefined ) return; // only set detune when available if ( this.isPlaying === true ) { this.source.detune.setTargetAtTime( this.detune, this.context.currentTime, 0.01 ); } return this; }, getDetune: function () { return this.detune; }, getFilter: function () { return this.getFilters()[ 0 ]; }, setFilter: function ( filter ) { return this.setFilters( filter ? [ filter ] : [] ); }, setPlaybackRate: function ( value ) { if ( this.hasPlaybackControl === false ) { console.warn( 'THREE.Audio: this Audio has no playback control.' ); return; } this.playbackRate = value; if ( this.isPlaying === true ) { this.source.playbackRate.setTargetAtTime( this.playbackRate, this.context.currentTime, 0.01 ); } return this; }, getPlaybackRate: function () { return this.playbackRate; }, onEnded: function () { this.isPlaying = false; }, getLoop: function () { if ( this.hasPlaybackControl === false ) { console.warn( 'THREE.Audio: this Audio has no playback control.' ); return false; } return this.loop; }, setLoop: function ( value ) { if ( this.hasPlaybackControl === false ) { console.warn( 'THREE.Audio: this Audio has no playback control.' ); return; } this.loop = value; if ( this.isPlaying === true ) { this.source.loop = this.loop; } return this; }, getVolume: function () { return this.gain.gain.value; }, setVolume: function ( value ) { this.gain.gain.setTargetAtTime( value, this.context.currentTime, 0.01 ); return this; } } ); /** * @author mrdoob / http://mrdoob.com/ */ function PositionalAudio( listener ) { Audio.call( this, listener ); this.panner = this.context.createPanner(); this.panner.connect( this.gain ); } PositionalAudio.prototype = Object.assign( Object.create( Audio.prototype ), { constructor: PositionalAudio, getOutput: function () { return this.panner; }, getRefDistance: function () { return this.panner.refDistance; }, setRefDistance: function ( value ) { this.panner.refDistance = value; return this; }, getRolloffFactor: function () { return this.panner.rolloffFactor; }, setRolloffFactor: function ( value ) { this.panner.rolloffFactor = value; return this; }, getDistanceModel: function () { return this.panner.distanceModel; }, setDistanceModel: function ( value ) { this.panner.distanceModel = value; return this; }, getMaxDistance: function () { return this.panner.maxDistance; }, setMaxDistance: function ( value ) { this.panner.maxDistance = value; return this; }, setDirectionalCone: function ( coneInnerAngle, coneOuterAngle, coneOuterGain ) { this.panner.coneInnerAngle = coneInnerAngle; this.panner.coneOuterAngle = coneOuterAngle; this.panner.coneOuterGain = coneOuterGain; return this; }, updateMatrixWorld: ( function () { var position = new Vector3(); var quaternion = new Quaternion(); var scale = new Vector3(); var orientation = new Vector3(); return function updateMatrixWorld( force ) { Object3D.prototype.updateMatrixWorld.call( this, force ); if ( this.hasPlaybackControl === true && this.isPlaying === false ) return; this.matrixWorld.decompose( position, quaternion, scale ); orientation.set( 0, 0, 1 ).applyQuaternion( quaternion ); var panner = this.panner; if ( panner.positionX ) { // code path for Chrome and Firefox (see #14393) var endTime = this.context.currentTime + this.listener.timeDelta; panner.positionX.linearRampToValueAtTime( position.x, endTime ); panner.positionY.linearRampToValueAtTime( position.y, endTime ); panner.positionZ.linearRampToValueAtTime( position.z, endTime ); panner.orientationX.linearRampToValueAtTime( orientation.x, endTime ); panner.orientationY.linearRampToValueAtTime( orientation.y, endTime ); panner.orientationZ.linearRampToValueAtTime( orientation.z, endTime ); } else { panner.setPosition( position.x, position.y, position.z ); panner.setOrientation( orientation.x, orientation.y, orientation.z ); } }; } )() } ); /** * @author mrdoob / http://mrdoob.com/ */ function AudioAnalyser( audio, fftSize ) { this.analyser = audio.context.createAnalyser(); this.analyser.fftSize = fftSize !== undefined ? fftSize : 2048; this.data = new Uint8Array( this.analyser.frequencyBinCount ); audio.getOutput().connect( this.analyser ); } Object.assign( AudioAnalyser.prototype, { getFrequencyData: function () { this.analyser.getByteFrequencyData( this.data ); return this.data; }, getAverageFrequency: function () { var value = 0, data = this.getFrequencyData(); for ( var i = 0; i < data.length; i ++ ) { value += data[ i ]; } return value / data.length; } } ); /** * * Buffered scene graph property that allows weighted accumulation. * * * @author Ben Houston / http://clara.io/ * @author David Sarno / http://lighthaus.us/ * @author tschw */ function PropertyMixer( binding, typeName, valueSize ) { this.binding = binding; this.valueSize = valueSize; var bufferType = Float64Array, mixFunction; switch ( typeName ) { case 'quaternion': mixFunction = this._slerp; break; case 'string': case 'bool': bufferType = Array; mixFunction = this._select; break; default: mixFunction = this._lerp; } this.buffer = new bufferType( valueSize * 4 ); // layout: [ incoming | accu0 | accu1 | orig ] // // interpolators can use .buffer as their .result // the data then goes to 'incoming' // // 'accu0' and 'accu1' are used frame-interleaved for // the cumulative result and are compared to detect // changes // // 'orig' stores the original state of the property this._mixBufferRegion = mixFunction; this.cumulativeWeight = 0; this.useCount = 0; this.referenceCount = 0; } Object.assign( PropertyMixer.prototype, { // accumulate data in the 'incoming' region into 'accu' accumulate: function ( accuIndex, weight ) { // note: happily accumulating nothing when weight = 0, the caller knows // the weight and shouldn't have made the call in the first place var buffer = this.buffer, stride = this.valueSize, offset = accuIndex * stride + stride, currentWeight = this.cumulativeWeight; if ( currentWeight === 0 ) { // accuN := incoming * weight for ( var i = 0; i !== stride; ++ i ) { buffer[ offset + i ] = buffer[ i ]; } currentWeight = weight; } else { // accuN := accuN + incoming * weight currentWeight += weight; var mix = weight / currentWeight; this._mixBufferRegion( buffer, offset, 0, mix, stride ); } this.cumulativeWeight = currentWeight; }, // apply the state of 'accu' to the binding when accus differ apply: function ( accuIndex ) { var stride = this.valueSize, buffer = this.buffer, offset = accuIndex * stride + stride, weight = this.cumulativeWeight, binding = this.binding; this.cumulativeWeight = 0; if ( weight < 1 ) { // accuN := accuN + original * ( 1 - cumulativeWeight ) var originalValueOffset = stride * 3; this._mixBufferRegion( buffer, offset, originalValueOffset, 1 - weight, stride ); } for ( var i = stride, e = stride + stride; i !== e; ++ i ) { if ( buffer[ i ] !== buffer[ i + stride ] ) { // value has changed -> update scene graph binding.setValue( buffer, offset ); break; } } }, // remember the state of the bound property and copy it to both accus saveOriginalState: function () { var binding = this.binding; var buffer = this.buffer, stride = this.valueSize, originalValueOffset = stride * 3; binding.getValue( buffer, originalValueOffset ); // accu[0..1] := orig -- initially detect changes against the original for ( var i = stride, e = originalValueOffset; i !== e; ++ i ) { buffer[ i ] = buffer[ originalValueOffset + ( i % stride ) ]; } this.cumulativeWeight = 0; }, // apply the state previously taken via 'saveOriginalState' to the binding restoreOriginalState: function () { var originalValueOffset = this.valueSize * 3; this.binding.setValue( this.buffer, originalValueOffset ); }, // mix functions _select: function ( buffer, dstOffset, srcOffset, t, stride ) { if ( t >= 0.5 ) { for ( var i = 0; i !== stride; ++ i ) { buffer[ dstOffset + i ] = buffer[ srcOffset + i ]; } } }, _slerp: function ( buffer, dstOffset, srcOffset, t ) { Quaternion.slerpFlat( buffer, dstOffset, buffer, dstOffset, buffer, srcOffset, t ); }, _lerp: function ( buffer, dstOffset, srcOffset, t, stride ) { var s = 1 - t; for ( var i = 0; i !== stride; ++ i ) { var j = dstOffset + i; buffer[ j ] = buffer[ j ] * s + buffer[ srcOffset + i ] * t; } } } ); /** * * A reference to a real property in the scene graph. * * * @author Ben Houston / http://clara.io/ * @author David Sarno / http://lighthaus.us/ * @author tschw */ // Characters [].:/ are reserved for track binding syntax. var RESERVED_CHARS_RE = '\\\\[\\\\]\\\\.:\\\\/'; function Composite( targetGroup, path, optionalParsedPath ) { var parsedPath = optionalParsedPath || PropertyBinding.parseTrackName( path ); this._targetGroup = targetGroup; this._bindings = targetGroup.subscribe_( path, parsedPath ); } Object.assign( Composite.prototype, { getValue: function ( array, offset ) { this.bind(); // bind all binding var firstValidIndex = this._targetGroup.nCachedObjects_, binding = this._bindings[ firstValidIndex ]; // and only call .getValue on the first if ( binding !== undefined ) binding.getValue( array, offset ); }, setValue: function ( array, offset ) { var bindings = this._bindings; for ( var i = this._targetGroup.nCachedObjects_, n = bindings.length; i !== n; ++ i ) { bindings[ i ].setValue( array, offset ); } }, bind: function () { var bindings = this._bindings; for ( var i = this._targetGroup.nCachedObjects_, n = bindings.length; i !== n; ++ i ) { bindings[ i ].bind(); } }, unbind: function () { var bindings = this._bindings; for ( var i = this._targetGroup.nCachedObjects_, n = bindings.length; i !== n; ++ i ) { bindings[ i ].unbind(); } } } ); function PropertyBinding( rootNode, path, parsedPath ) { this.path = path; this.parsedPath = parsedPath || PropertyBinding.parseTrackName( path ); this.node = PropertyBinding.findNode( rootNode, this.parsedPath.nodeName ) || rootNode; this.rootNode = rootNode; } Object.assign( PropertyBinding, { Composite: Composite, create: function ( root, path, parsedPath ) { if ( ! ( root && root.isAnimationObjectGroup ) ) { return new PropertyBinding( root, path, parsedPath ); } else { return new PropertyBinding.Composite( root, path, parsedPath ); } }, /** * Replaces spaces with underscores and removes unsupported characters from * node names, to ensure compatibility with parseTrackName(). * * @param {string} name Node name to be sanitized. * @return {string} */ sanitizeNodeName: ( function () { var reservedRe = new RegExp( '[' + RESERVED_CHARS_RE + ']', 'g' ); return function sanitizeNodeName( name ) { return name.replace( /\\s/g, '_' ).replace( reservedRe, '' ); }; }() ), parseTrackName: function () { // Attempts to allow node names from any language. ES5's `\\w` regexp matches // only latin characters, and the unicode \\p{L} is not yet supported. So // instead, we exclude reserved characters and match everything else. var wordChar = '[^' + RESERVED_CHARS_RE + ']'; var wordCharOrDot = '[^' + RESERVED_CHARS_RE.replace( '\\\\.', '' ) + ']'; // Parent directories, delimited by '/' or ':'. Currently unused, but must // be matched to parse the rest of the track name. var directoryRe = /((?:WC+[\\/:])*)/.source.replace( 'WC', wordChar ); // Target node. May contain word characters (a-zA-Z0-9_) and '.' or '-'. var nodeRe = /(WCOD+)?/.source.replace( 'WCOD', wordCharOrDot ); // Object on target node, and accessor. May not contain reserved // characters. Accessor may contain any character except closing bracket. var objectRe = /(?:\\.(WC+)(?:\\[(.+)\\])?)?/.source.replace( 'WC', wordChar ); // Property and accessor. May not contain reserved characters. Accessor may // contain any non-bracket characters. var propertyRe = /\\.(WC+)(?:\\[(.+)\\])?/.source.replace( 'WC', wordChar ); var trackRe = new RegExp( '' + '^' + directoryRe + nodeRe + objectRe + propertyRe + '$' ); var supportedObjectNames = [ 'material', 'materials', 'bones' ]; return function parseTrackName( trackName ) { var matches = trackRe.exec( trackName ); if ( ! matches ) { throw new Error( 'PropertyBinding: Cannot parse trackName: ' + trackName ); } var results = { // directoryName: matches[ 1 ], // (tschw) currently unused nodeName: matches[ 2 ], objectName: matches[ 3 ], objectIndex: matches[ 4 ], propertyName: matches[ 5 ], // required propertyIndex: matches[ 6 ] }; var lastDot = results.nodeName && results.nodeName.lastIndexOf( '.' ); if ( lastDot !== undefined && lastDot !== - 1 ) { var objectName = results.nodeName.substring( lastDot + 1 ); // Object names must be checked against a whitelist. Otherwise, there // is no way to parse 'foo.bar.baz': 'baz' must be a property, but // 'bar' could be the objectName, or part of a nodeName (which can // include '.' characters). if ( supportedObjectNames.indexOf( objectName ) !== - 1 ) { results.nodeName = results.nodeName.substring( 0, lastDot ); results.objectName = objectName; } } if ( results.propertyName === null || results.propertyName.length === 0 ) { throw new Error( 'PropertyBinding: can not parse propertyName from trackName: ' + trackName ); } return results; }; }(), findNode: function ( root, nodeName ) { if ( ! nodeName || nodeName === \"\" || nodeName === \"root\" || nodeName === \".\" || nodeName === - 1 || nodeName === root.name || nodeName === root.uuid ) { return root; } // search into skeleton bones. if ( root.skeleton ) { var bone = root.skeleton.getBoneByName( nodeName ); if ( bone !== undefined ) { return bone; } } // search into node subtree. if ( root.children ) { var searchNodeSubtree = function ( children ) { for ( var i = 0; i < children.length; i ++ ) { var childNode = children[ i ]; if ( childNode.name === nodeName || childNode.uuid === nodeName ) { return childNode; } var result = searchNodeSubtree( childNode.children ); if ( result ) return result; } return null; }; var subTreeNode = searchNodeSubtree( root.children ); if ( subTreeNode ) { return subTreeNode; } } return null; } } ); Object.assign( PropertyBinding.prototype, { // prototype, continued // these are used to \"bind\" a nonexistent property _getValue_unavailable: function () {}, _setValue_unavailable: function () {}, BindingType: { Direct: 0, EntireArray: 1, ArrayElement: 2, HasFromToArray: 3 }, Versioning: { None: 0, NeedsUpdate: 1, MatrixWorldNeedsUpdate: 2 }, GetterByBindingType: [ function getValue_direct( buffer, offset ) { buffer[ offset ] = this.node[ this.propertyName ]; }, function getValue_array( buffer, offset ) { var source = this.resolvedProperty; for ( var i = 0, n = source.length; i !== n; ++ i ) { buffer[ offset ++ ] = source[ i ]; } }, function getValue_arrayElement( buffer, offset ) { buffer[ offset ] = this.resolvedProperty[ this.propertyIndex ]; }, function getValue_toArray( buffer, offset ) { this.resolvedProperty.toArray( buffer, offset ); } ], SetterByBindingTypeAndVersioning: [ [ // Direct function setValue_direct( buffer, offset ) { this.targetObject[ this.propertyName ] = buffer[ offset ]; }, function setValue_direct_setNeedsUpdate( buffer, offset ) { this.targetObject[ this.propertyName ] = buffer[ offset ]; this.targetObject.needsUpdate = true; }, function setValue_direct_setMatrixWorldNeedsUpdate( buffer, offset ) { this.targetObject[ this.propertyName ] = buffer[ offset ]; this.targetObject.matrixWorldNeedsUpdate = true; } ], [ // EntireArray function setValue_array( buffer, offset ) { var dest = this.resolvedProperty; for ( var i = 0, n = dest.length; i !== n; ++ i ) { dest[ i ] = buffer[ offset ++ ]; } }, function setValue_array_setNeedsUpdate( buffer, offset ) { var dest = this.resolvedProperty; for ( var i = 0, n = dest.length; i !== n; ++ i ) { dest[ i ] = buffer[ offset ++ ]; } this.targetObject.needsUpdate = true; }, function setValue_array_setMatrixWorldNeedsUpdate( buffer, offset ) { var dest = this.resolvedProperty; for ( var i = 0, n = dest.length; i !== n; ++ i ) { dest[ i ] = buffer[ offset ++ ]; } this.targetObject.matrixWorldNeedsUpdate = true; } ], [ // ArrayElement function setValue_arrayElement( buffer, offset ) { this.resolvedProperty[ this.propertyIndex ] = buffer[ offset ]; }, function setValue_arrayElement_setNeedsUpdate( buffer, offset ) { this.resolvedProperty[ this.propertyIndex ] = buffer[ offset ]; this.targetObject.needsUpdate = true; }, function setValue_arrayElement_setMatrixWorldNeedsUpdate( buffer, offset ) { this.resolvedProperty[ this.propertyIndex ] = buffer[ offset ]; this.targetObject.matrixWorldNeedsUpdate = true; } ], [ // HasToFromArray function setValue_fromArray( buffer, offset ) { this.resolvedProperty.fromArray( buffer, offset ); }, function setValue_fromArray_setNeedsUpdate( buffer, offset ) { this.resolvedProperty.fromArray( buffer, offset ); this.targetObject.needsUpdate = true; }, function setValue_fromArray_setMatrixWorldNeedsUpdate( buffer, offset ) { this.resolvedProperty.fromArray( buffer, offset ); this.targetObject.matrixWorldNeedsUpdate = true; } ] ], getValue: function getValue_unbound( targetArray, offset ) { this.bind(); this.getValue( targetArray, offset ); // Note: This class uses a State pattern on a per-method basis: // 'bind' sets 'this.getValue' / 'setValue' and shadows the // prototype version of these methods with one that represents // the bound state. When the property is not found, the methods // become no-ops. }, setValue: function getValue_unbound( sourceArray, offset ) { this.bind(); this.setValue( sourceArray, offset ); }, // create getter / setter pair for a property in the scene graph bind: function () { var targetObject = this.node, parsedPath = this.parsedPath, objectName = parsedPath.objectName, propertyName = parsedPath.propertyName, propertyIndex = parsedPath.propertyIndex; if ( ! targetObject ) { targetObject = PropertyBinding.findNode( this.rootNode, parsedPath.nodeName ) || this.rootNode; this.node = targetObject; } // set fail state so we can just 'return' on error this.getValue = this._getValue_unavailable; this.setValue = this._setValue_unavailable; // ensure there is a value node if ( ! targetObject ) { console.error( 'THREE.PropertyBinding: Trying to update node for track: ' + this.path + ' but it wasn\\'t found.' ); return; } if ( objectName ) { var objectIndex = parsedPath.objectIndex; // special cases were we need to reach deeper into the hierarchy to get the face materials.... switch ( objectName ) { case 'materials': if ( ! targetObject.material ) { console.error( 'THREE.PropertyBinding: Can not bind to material as node does not have a material.', this ); return; } if ( ! targetObject.material.materials ) { console.error( 'THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.', this ); return; } targetObject = targetObject.material.materials; break; case 'bones': if ( ! targetObject.skeleton ) { console.error( 'THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.', this ); return; } // potential future optimization: skip this if propertyIndex is already an integer // and convert the integer string to a true integer. targetObject = targetObject.skeleton.bones; // support resolving morphTarget names into indices. for ( var i = 0; i < targetObject.length; i ++ ) { if ( targetObject[ i ].name === objectIndex ) { objectIndex = i; break; } } break; default: if ( targetObject[ objectName ] === undefined ) { console.error( 'THREE.PropertyBinding: Can not bind to objectName of node undefined.', this ); return; } targetObject = targetObject[ objectName ]; } if ( objectIndex !== undefined ) { if ( targetObject[ objectIndex ] === undefined ) { console.error( 'THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.', this, targetObject ); return; } targetObject = targetObject[ objectIndex ]; } } // resolve property var nodeProperty = targetObject[ propertyName ]; if ( nodeProperty === undefined ) { var nodeName = parsedPath.nodeName; console.error( 'THREE.PropertyBinding: Trying to update property for track: ' + nodeName + '.' + propertyName + ' but it wasn\\'t found.', targetObject ); return; } // determine versioning scheme var versioning = this.Versioning.None; this.targetObject = targetObject; if ( targetObject.needsUpdate !== undefined ) { // material versioning = this.Versioning.NeedsUpdate; } else if ( targetObject.matrixWorldNeedsUpdate !== undefined ) { // node transform versioning = this.Versioning.MatrixWorldNeedsUpdate; } // determine how the property gets bound var bindingType = this.BindingType.Direct; if ( propertyIndex !== undefined ) { // access a sub element of the property array (only primitives are supported right now) if ( propertyName === \"morphTargetInfluences\" ) { // potential optimization, skip this if propertyIndex is already an integer, and convert the integer string to a true integer. // support resolving morphTarget names into indices. if ( ! targetObject.geometry ) { console.error( 'THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.', this ); return; } if ( targetObject.geometry.isBufferGeometry ) { if ( ! targetObject.geometry.morphAttributes ) { console.error( 'THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.', this ); return; } for ( var i = 0; i < this.node.geometry.morphAttributes.position.length; i ++ ) { if ( targetObject.geometry.morphAttributes.position[ i ].name === propertyIndex ) { propertyIndex = i; break; } } } else { if ( ! targetObject.geometry.morphTargets ) { console.error( 'THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphTargets.', this ); return; } for ( var i = 0; i < this.node.geometry.morphTargets.length; i ++ ) { if ( targetObject.geometry.morphTargets[ i ].name === propertyIndex ) { propertyIndex = i; break; } } } } bindingType = this.BindingType.ArrayElement; this.resolvedProperty = nodeProperty; this.propertyIndex = propertyIndex; } else if ( nodeProperty.fromArray !== undefined && nodeProperty.toArray !== undefined ) { // must use copy for Object3D.Euler/Quaternion bindingType = this.BindingType.HasFromToArray; this.resolvedProperty = nodeProperty; } else if ( Array.isArray( nodeProperty ) ) { bindingType = this.BindingType.EntireArray; this.resolvedProperty = nodeProperty; } else { this.propertyName = propertyName; } // select getter / setter this.getValue = this.GetterByBindingType[ bindingType ]; this.setValue = this.SetterByBindingTypeAndVersioning[ bindingType ][ versioning ]; }, unbind: function () { this.node = null; // back to the prototype version of getValue / setValue // note: avoiding to mutate the shape of 'this' via 'delete' this.getValue = this._getValue_unbound; this.setValue = this._setValue_unbound; } } ); //!\\ DECLARE ALIAS AFTER assign prototype ! Object.assign( PropertyBinding.prototype, { // initial state of these methods that calls 'bind' _getValue_unbound: PropertyBinding.prototype.getValue, _setValue_unbound: PropertyBinding.prototype.setValue, } ); /** * * A group of objects that receives a shared animation state. * * Usage: * * - Add objects you would otherwise pass as 'root' to the * constructor or the .clipAction method of AnimationMixer. * * - Instead pass this object as 'root'. * * - You can also add and remove objects later when the mixer * is running. * * Note: * * Objects of this class appear as one object to the mixer, * so cache control of the individual objects must be done * on the group. * * Limitation: * * - The animated properties must be compatible among the * all objects in the group. * * - A single property can either be controlled through a * target group or directly, but not both. * * @author tschw */ function AnimationObjectGroup() { this.uuid = _Math.generateUUID(); // cached objects followed by the active ones this._objects = Array.prototype.slice.call( arguments ); this.nCachedObjects_ = 0; // threshold // note: read by PropertyBinding.Composite var indices = {}; this._indicesByUUID = indices; // for bookkeeping for ( var i = 0, n = arguments.length; i !== n; ++ i ) { indices[ arguments[ i ].uuid ] = i; } this._paths = []; // inside: string this._parsedPaths = []; // inside: { we don't care, here } this._bindings = []; // inside: Array< PropertyBinding > this._bindingsIndicesByPath = {}; // inside: indices in these arrays var scope = this; this.stats = { objects: { get total() { return scope._objects.length; }, get inUse() { return this.total - scope.nCachedObjects_; } }, get bindingsPerObject() { return scope._bindings.length; } }; } Object.assign( AnimationObjectGroup.prototype, { isAnimationObjectGroup: true, add: function () { var objects = this._objects, nObjects = objects.length, nCachedObjects = this.nCachedObjects_, indicesByUUID = this._indicesByUUID, paths = this._paths, parsedPaths = this._parsedPaths, bindings = this._bindings, nBindings = bindings.length, knownObject = undefined; for ( var i = 0, n = arguments.length; i !== n; ++ i ) { var object = arguments[ i ], uuid = object.uuid, index = indicesByUUID[ uuid ]; if ( index === undefined ) { // unknown object -> add it to the ACTIVE region index = nObjects ++; indicesByUUID[ uuid ] = index; objects.push( object ); // accounting is done, now do the same for all bindings for ( var j = 0, m = nBindings; j !== m; ++ j ) { bindings[ j ].push( new PropertyBinding( object, paths[ j ], parsedPaths[ j ] ) ); } } else if ( index < nCachedObjects ) { knownObject = objects[ index ]; // move existing object to the ACTIVE region var firstActiveIndex = -- nCachedObjects, lastCachedObject = objects[ firstActiveIndex ]; indicesByUUID[ lastCachedObject.uuid ] = index; objects[ index ] = lastCachedObject; indicesByUUID[ uuid ] = firstActiveIndex; objects[ firstActiveIndex ] = object; // accounting is done, now do the same for all bindings for ( var j = 0, m = nBindings; j !== m; ++ j ) { var bindingsForPath = bindings[ j ], lastCached = bindingsForPath[ firstActiveIndex ], binding = bindingsForPath[ index ]; bindingsForPath[ index ] = lastCached; if ( binding === undefined ) { // since we do not bother to create new bindings // for objects that are cached, the binding may // or may not exist binding = new PropertyBinding( object, paths[ j ], parsedPaths[ j ] ); } bindingsForPath[ firstActiveIndex ] = binding; } } else if ( objects[ index ] !== knownObject ) { console.error( 'THREE.AnimationObjectGroup: Different objects with the same UUID ' + 'detected. Clean the caches or recreate your infrastructure when reloading scenes.' ); } // else the object is already where we want it to be } // for arguments this.nCachedObjects_ = nCachedObjects; }, remove: function () { var objects = this._objects, nCachedObjects = this.nCachedObjects_, indicesByUUID = this._indicesByUUID, bindings = this._bindings, nBindings = bindings.length; for ( var i = 0, n = arguments.length; i !== n; ++ i ) { var object = arguments[ i ], uuid = object.uuid, index = indicesByUUID[ uuid ]; if ( index !== undefined && index >= nCachedObjects ) { // move existing object into the CACHED region var lastCachedIndex = nCachedObjects ++, firstActiveObject = objects[ lastCachedIndex ]; indicesByUUID[ firstActiveObject.uuid ] = index; objects[ index ] = firstActiveObject; indicesByUUID[ uuid ] = lastCachedIndex; objects[ lastCachedIndex ] = object; // accounting is done, now do the same for all bindings for ( var j = 0, m = nBindings; j !== m; ++ j ) { var bindingsForPath = bindings[ j ], firstActive = bindingsForPath[ lastCachedIndex ], binding = bindingsForPath[ index ]; bindingsForPath[ index ] = firstActive; bindingsForPath[ lastCachedIndex ] = binding; } } } // for arguments this.nCachedObjects_ = nCachedObjects; }, // remove & forget uncache: function () { var objects = this._objects, nObjects = objects.length, nCachedObjects = this.nCachedObjects_, indicesByUUID = this._indicesByUUID, bindings = this._bindings, nBindings = bindings.length; for ( var i = 0, n = arguments.length; i !== n; ++ i ) { var object = arguments[ i ], uuid = object.uuid, index = indicesByUUID[ uuid ]; if ( index !== undefined ) { delete indicesByUUID[ uuid ]; if ( index < nCachedObjects ) { // object is cached, shrink the CACHED region var firstActiveIndex = -- nCachedObjects, lastCachedObject = objects[ firstActiveIndex ], lastIndex = -- nObjects, lastObject = objects[ lastIndex ]; // last cached object takes this object's place indicesByUUID[ lastCachedObject.uuid ] = index; objects[ index ] = lastCachedObject; // last object goes to the activated slot and pop indicesByUUID[ lastObject.uuid ] = firstActiveIndex; objects[ firstActiveIndex ] = lastObject; objects.pop(); // accounting is done, now do the same for all bindings for ( var j = 0, m = nBindings; j !== m; ++ j ) { var bindingsForPath = bindings[ j ], lastCached = bindingsForPath[ firstActiveIndex ], last = bindingsForPath[ lastIndex ]; bindingsForPath[ index ] = lastCached; bindingsForPath[ firstActiveIndex ] = last; bindingsForPath.pop(); } } else { // object is active, just swap with the last and pop var lastIndex = -- nObjects, lastObject = objects[ lastIndex ]; indicesByUUID[ lastObject.uuid ] = index; objects[ index ] = lastObject; objects.pop(); // accounting is done, now do the same for all bindings for ( var j = 0, m = nBindings; j !== m; ++ j ) { var bindingsForPath = bindings[ j ]; bindingsForPath[ index ] = bindingsForPath[ lastIndex ]; bindingsForPath.pop(); } } // cached or active } // if object is known } // for arguments this.nCachedObjects_ = nCachedObjects; }, // Internal interface used by befriended PropertyBinding.Composite: subscribe_: function ( path, parsedPath ) { // returns an array of bindings for the given path that is changed // according to the contained objects in the group var indicesByPath = this._bindingsIndicesByPath, index = indicesByPath[ path ], bindings = this._bindings; if ( index !== undefined ) return bindings[ index ]; var paths = this._paths, parsedPaths = this._parsedPaths, objects = this._objects, nObjects = objects.length, nCachedObjects = this.nCachedObjects_, bindingsForPath = new Array( nObjects ); index = bindings.length; indicesByPath[ path ] = index; paths.push( path ); parsedPaths.push( parsedPath ); bindings.push( bindingsForPath ); for ( var i = nCachedObjects, n = objects.length; i !== n; ++ i ) { var object = objects[ i ]; bindingsForPath[ i ] = new PropertyBinding( object, path, parsedPath ); } return bindingsForPath; }, unsubscribe_: function ( path ) { // tells the group to forget about a property path and no longer // update the array previously obtained with 'subscribe_' var indicesByPath = this._bindingsIndicesByPath, index = indicesByPath[ path ]; if ( index !== undefined ) { var paths = this._paths, parsedPaths = this._parsedPaths, bindings = this._bindings, lastBindingsIndex = bindings.length - 1, lastBindings = bindings[ lastBindingsIndex ], lastBindingsPath = path[ lastBindingsIndex ]; indicesByPath[ lastBindingsPath ] = index; bindings[ index ] = lastBindings; bindings.pop(); parsedPaths[ index ] = parsedPaths[ lastBindingsIndex ]; parsedPaths.pop(); paths[ index ] = paths[ lastBindingsIndex ]; paths.pop(); } } } ); /** * * Action provided by AnimationMixer for scheduling clip playback on specific * objects. * * @author Ben Houston / http://clara.io/ * @author David Sarno / http://lighthaus.us/ * @author tschw * */ function AnimationAction( mixer, clip, localRoot ) { this._mixer = mixer; this._clip = clip; this._localRoot = localRoot || null; var tracks = clip.tracks, nTracks = tracks.length, interpolants = new Array( nTracks ); var interpolantSettings = { endingStart: ZeroCurvatureEnding, endingEnd: ZeroCurvatureEnding }; for ( var i = 0; i !== nTracks; ++ i ) { var interpolant = tracks[ i ].createInterpolant( null ); interpolants[ i ] = interpolant; interpolant.settings = interpolantSettings; } this._interpolantSettings = interpolantSettings; this._interpolants = interpolants; // bound by the mixer // inside: PropertyMixer (managed by the mixer) this._propertyBindings = new Array( nTracks ); this._cacheIndex = null; // for the memory manager this._byClipCacheIndex = null; // for the memory manager this._timeScaleInterpolant = null; this._weightInterpolant = null; this.loop = LoopRepeat; this._loopCount = - 1; // global mixer time when the action is to be started // it's set back to 'null' upon start of the action this._startTime = null; // scaled local time of the action // gets clamped or wrapped to 0..clip.duration according to loop this.time = 0; this.timeScale = 1; this._effectiveTimeScale = 1; this.weight = 1; this._effectiveWeight = 1; this.repetitions = Infinity; // no. of repetitions when looping this.paused = false; // true -> zero effective time scale this.enabled = true; // false -> zero effective weight this.clampWhenFinished = false;// keep feeding the last frame? this.zeroSlopeAtStart = true;// for smooth interpolation w/o separate this.zeroSlopeAtEnd = true;// clips for start, loop and end } Object.assign( AnimationAction.prototype, { // State & Scheduling play: function () { this._mixer._activateAction( this ); return this; }, stop: function () { this._mixer._deactivateAction( this ); return this.reset(); }, reset: function () { this.paused = false; this.enabled = true; this.time = 0; // restart clip this._loopCount = - 1;// forget previous loops this._startTime = null;// forget scheduling return this.stopFading().stopWarping(); }, isRunning: function () { return this.enabled && ! this.paused && this.timeScale !== 0 && this._startTime === null && this._mixer._isActiveAction( this ); }, // return true when play has been called isScheduled: function () { return this._mixer._isActiveAction( this ); }, startAt: function ( time ) { this._startTime = time; return this; }, setLoop: function ( mode, repetitions ) { this.loop = mode; this.repetitions = repetitions; return this; }, // Weight // set the weight stopping any scheduled fading // although .enabled = false yields an effective weight of zero, this // method does *not* change .enabled, because it would be confusing setEffectiveWeight: function ( weight ) { this.weight = weight; // note: same logic as when updated at runtime this._effectiveWeight = this.enabled ? weight : 0; return this.stopFading(); }, // return the weight considering fading and .enabled getEffectiveWeight: function () { return this._effectiveWeight; }, fadeIn: function ( duration ) { return this._scheduleFading( duration, 0, 1 ); }, fadeOut: function ( duration ) { return this._scheduleFading( duration, 1, 0 ); }, crossFadeFrom: function ( fadeOutAction, duration, warp ) { fadeOutAction.fadeOut( duration ); this.fadeIn( duration ); if ( warp ) { var fadeInDuration = this._clip.duration, fadeOutDuration = fadeOutAction._clip.duration, startEndRatio = fadeOutDuration / fadeInDuration, endStartRatio = fadeInDuration / fadeOutDuration; fadeOutAction.warp( 1.0, startEndRatio, duration ); this.warp( endStartRatio, 1.0, duration ); } return this; }, crossFadeTo: function ( fadeInAction, duration, warp ) { return fadeInAction.crossFadeFrom( this, duration, warp ); }, stopFading: function () { var weightInterpolant = this._weightInterpolant; if ( weightInterpolant !== null ) { this._weightInterpolant = null; this._mixer._takeBackControlInterpolant( weightInterpolant ); } return this; }, // Time Scale Control // set the time scale stopping any scheduled warping // although .paused = true yields an effective time scale of zero, this // method does *not* change .paused, because it would be confusing setEffectiveTimeScale: function ( timeScale ) { this.timeScale = timeScale; this._effectiveTimeScale = this.paused ? 0 : timeScale; return this.stopWarping(); }, // return the time scale considering warping and .paused getEffectiveTimeScale: function () { return this._effectiveTimeScale; }, setDuration: function ( duration ) { this.timeScale = this._clip.duration / duration; return this.stopWarping(); }, syncWith: function ( action ) { this.time = action.time; this.timeScale = action.timeScale; return this.stopWarping(); }, halt: function ( duration ) { return this.warp( this._effectiveTimeScale, 0, duration ); }, warp: function ( startTimeScale, endTimeScale, duration ) { var mixer = this._mixer, now = mixer.time, interpolant = this._timeScaleInterpolant, timeScale = this.timeScale; if ( interpolant === null ) { interpolant = mixer._lendControlInterpolant(); this._timeScaleInterpolant = interpolant; } var times = interpolant.parameterPositions, values = interpolant.sampleValues; times[ 0 ] = now; times[ 1 ] = now + duration; values[ 0 ] = startTimeScale / timeScale; values[ 1 ] = endTimeScale / timeScale; return this; }, stopWarping: function () { var timeScaleInterpolant = this._timeScaleInterpolant; if ( timeScaleInterpolant !== null ) { this._timeScaleInterpolant = null; this._mixer._takeBackControlInterpolant( timeScaleInterpolant ); } return this; }, // Object Accessors getMixer: function () { return this._mixer; }, getClip: function () { return this._clip; }, getRoot: function () { return this._localRoot || this._mixer._root; }, // Interna _update: function ( time, deltaTime, timeDirection, accuIndex ) { // called by the mixer if ( ! this.enabled ) { // call ._updateWeight() to update ._effectiveWeight this._updateWeight( time ); return; } var startTime = this._startTime; if ( startTime !== null ) { // check for scheduled start of action var timeRunning = ( time - startTime ) * timeDirection; if ( timeRunning < 0 || timeDirection === 0 ) { return; // yet to come / don't decide when delta = 0 } // start this._startTime = null; // unschedule deltaTime = timeDirection * timeRunning; } // apply time scale and advance time deltaTime *= this._updateTimeScale( time ); var clipTime = this._updateTime( deltaTime ); // note: _updateTime may disable the action resulting in // an effective weight of 0 var weight = this._updateWeight( time ); if ( weight > 0 ) { var interpolants = this._interpolants; var propertyMixers = this._propertyBindings; for ( var j = 0, m = interpolants.length; j !== m; ++ j ) { interpolants[ j ].evaluate( clipTime ); propertyMixers[ j ].accumulate( accuIndex, weight ); } } }, _updateWeight: function ( time ) { var weight = 0; if ( this.enabled ) { weight = this.weight; var interpolant = this._weightInterpolant; if ( interpolant !== null ) { var interpolantValue = interpolant.evaluate( time )[ 0 ]; weight *= interpolantValue; if ( time > interpolant.parameterPositions[ 1 ] ) { this.stopFading(); if ( interpolantValue === 0 ) { // faded out, disable this.enabled = false; } } } } this._effectiveWeight = weight; return weight; }, _updateTimeScale: function ( time ) { var timeScale = 0; if ( ! this.paused ) { timeScale = this.timeScale; var interpolant = this._timeScaleInterpolant; if ( interpolant !== null ) { var interpolantValue = interpolant.evaluate( time )[ 0 ]; timeScale *= interpolantValue; if ( time > interpolant.parameterPositions[ 1 ] ) { this.stopWarping(); if ( timeScale === 0 ) { // motion has halted, pause this.paused = true; } else { // warp done - apply final time scale this.timeScale = timeScale; } } } } this._effectiveTimeScale = timeScale; return timeScale; }, _updateTime: function ( deltaTime ) { var time = this.time + deltaTime; var duration = this._clip.duration; var loop = this.loop; var loopCount = this._loopCount; var pingPong = ( loop === LoopPingPong ); if ( deltaTime === 0 ) { if ( loopCount === - 1 ) return time; return ( pingPong && ( loopCount & 1 ) === 1 ) ? duration - time : time; } if ( loop === LoopOnce ) { if ( loopCount === - 1 ) { // just started this._loopCount = 0; this._setEndings( true, true, false ); } handle_stop: { if ( time >= duration ) { time = duration; } else if ( time < 0 ) { time = 0; } else break handle_stop; if ( this.clampWhenFinished ) this.paused = true; else this.enabled = false; this._mixer.dispatchEvent( { type: 'finished', action: this, direction: deltaTime < 0 ? - 1 : 1 } ); } } else { // repetitive Repeat or PingPong if ( loopCount === - 1 ) { // just started if ( deltaTime >= 0 ) { loopCount = 0; this._setEndings( true, this.repetitions === 0, pingPong ); } else { // when looping in reverse direction, the initial // transition through zero counts as a repetition, // so leave loopCount at -1 this._setEndings( this.repetitions === 0, true, pingPong ); } } if ( time >= duration || time < 0 ) { // wrap around var loopDelta = Math.floor( time / duration ); // signed time -= duration * loopDelta; loopCount += Math.abs( loopDelta ); var pending = this.repetitions - loopCount; if ( pending 0 ? duration : 0; this._mixer.dispatchEvent( { type: 'finished', action: this, direction: deltaTime > 0 ? 1 : - 1 } ); } else { // keep running if ( pending === 1 ) { // entering the last round var atStart = deltaTime < 0; this._setEndings( atStart, ! atStart, pingPong ); } else { this._setEndings( false, false, pingPong ); } this._loopCount = loopCount; this._mixer.dispatchEvent( { type: 'loop', action: this, loopDelta: loopDelta } ); } } if ( pingPong && ( loopCount & 1 ) === 1 ) { // invert time for the \"pong round\" this.time = time; return duration - time; } } this.time = time; return time; }, _setEndings: function ( atStart, atEnd, pingPong ) { var settings = this._interpolantSettings; if ( pingPong ) { settings.endingStart = ZeroSlopeEnding; settings.endingEnd = ZeroSlopeEnding; } else { // assuming for LoopOnce atStart == atEnd == true if ( atStart ) { settings.endingStart = this.zeroSlopeAtStart ? ZeroSlopeEnding : ZeroCurvatureEnding; } else { settings.endingStart = WrapAroundEnding; } if ( atEnd ) { settings.endingEnd = this.zeroSlopeAtEnd ? ZeroSlopeEnding : ZeroCurvatureEnding; } else { settings.endingEnd = WrapAroundEnding; } } }, _scheduleFading: function ( duration, weightNow, weightThen ) { var mixer = this._mixer, now = mixer.time, interpolant = this._weightInterpolant; if ( interpolant === null ) { interpolant = mixer._lendControlInterpolant(); this._weightInterpolant = interpolant; } var times = interpolant.parameterPositions, values = interpolant.sampleValues; times[ 0 ] = now; values[ 0 ] = weightNow; times[ 1 ] = now + duration; values[ 1 ] = weightThen; return this; } } ); /** * * Player for AnimationClips. * * * @author Ben Houston / http://clara.io/ * @author David Sarno / http://lighthaus.us/ * @author tschw */ function AnimationMixer( root ) { this._root = root; this._initMemoryManager(); this._accuIndex = 0; this.time = 0; this.timeScale = 1.0; } AnimationMixer.prototype = Object.assign( Object.create( EventDispatcher.prototype ), { constructor: AnimationMixer, _bindAction: function ( action, prototypeAction ) { var root = action._localRoot || this._root, tracks = action._clip.tracks, nTracks = tracks.length, bindings = action._propertyBindings, interpolants = action._interpolants, rootUuid = root.uuid, bindingsByRoot = this._bindingsByRootAndName, bindingsByName = bindingsByRoot[ rootUuid ]; if ( bindingsByName === undefined ) { bindingsByName = {}; bindingsByRoot[ rootUuid ] = bindingsByName; } for ( var i = 0; i !== nTracks; ++ i ) { var track = tracks[ i ], trackName = track.name, binding = bindingsByName[ trackName ]; if ( binding !== undefined ) { bindings[ i ] = binding; } else { binding = bindings[ i ]; if ( binding !== undefined ) { // existing binding, make sure the cache knows if ( binding._cacheIndex === null ) { ++ binding.referenceCount; this._addInactiveBinding( binding, rootUuid, trackName ); } continue; } var path = prototypeAction && prototypeAction. _propertyBindings[ i ].binding.parsedPath; binding = new PropertyMixer( PropertyBinding.create( root, trackName, path ), track.ValueTypeName, track.getValueSize() ); ++ binding.referenceCount; this._addInactiveBinding( binding, rootUuid, trackName ); bindings[ i ] = binding; } interpolants[ i ].resultBuffer = binding.buffer; } }, _activateAction: function ( action ) { if ( ! this._isActiveAction( action ) ) { if ( action._cacheIndex === null ) { // this action has been forgotten by the cache, but the user // appears to be still using it -> rebind var rootUuid = ( action._localRoot || this._root ).uuid, clipUuid = action._clip.uuid, actionsForClip = this._actionsByClip[ clipUuid ]; this._bindAction( action, actionsForClip && actionsForClip.knownActions[ 0 ] ); this._addInactiveAction( action, clipUuid, rootUuid ); } var bindings = action._propertyBindings; // increment reference counts / sort out state for ( var i = 0, n = bindings.length; i !== n; ++ i ) { var binding = bindings[ i ]; if ( binding.useCount ++ === 0 ) { this._lendBinding( binding ); binding.saveOriginalState(); } } this._lendAction( action ); } }, _deactivateAction: function ( action ) { if ( this._isActiveAction( action ) ) { var bindings = action._propertyBindings; // decrement reference counts / sort out state for ( var i = 0, n = bindings.length; i !== n; ++ i ) { var binding = bindings[ i ]; if ( -- binding.useCount === 0 ) { binding.restoreOriginalState(); this._takeBackBinding( binding ); } } this._takeBackAction( action ); } }, // Memory manager _initMemoryManager: function () { this._actions = []; // 'nActiveActions' followed by inactive ones this._nActiveActions = 0; this._actionsByClip = {}; // inside: // { // knownActions: Array< AnimationAction > - used as prototypes // actionByRoot: AnimationAction - lookup // } this._bindings = []; // 'nActiveBindings' followed by inactive ones this._nActiveBindings = 0; this._bindingsByRootAndName = {}; // inside: Map< name, PropertyMixer > this._controlInterpolants = []; // same game as above this._nActiveControlInterpolants = 0; var scope = this; this.stats = { actions: { get total() { return scope._actions.length; }, get inUse() { return scope._nActiveActions; } }, bindings: { get total() { return scope._bindings.length; }, get inUse() { return scope._nActiveBindings; } }, controlInterpolants: { get total() { return scope._controlInterpolants.length; }, get inUse() { return scope._nActiveControlInterpolants; } } }; }, // Memory management for AnimationAction objects _isActiveAction: function ( action ) { var index = action._cacheIndex; return index !== null && index < this._nActiveActions; }, _addInactiveAction: function ( action, clipUuid, rootUuid ) { var actions = this._actions, actionsByClip = this._actionsByClip, actionsForClip = actionsByClip[ clipUuid ]; if ( actionsForClip === undefined ) { actionsForClip = { knownActions: [ action ], actionByRoot: {} }; action._byClipCacheIndex = 0; actionsByClip[ clipUuid ] = actionsForClip; } else { var knownActions = actionsForClip.knownActions; action._byClipCacheIndex = knownActions.length; knownActions.push( action ); } action._cacheIndex = actions.length; actions.push( action ); actionsForClip.actionByRoot[ rootUuid ] = action; }, _removeInactiveAction: function ( action ) { var actions = this._actions, lastInactiveAction = actions[ actions.length - 1 ], cacheIndex = action._cacheIndex; lastInactiveAction._cacheIndex = cacheIndex; actions[ cacheIndex ] = lastInactiveAction; actions.pop(); action._cacheIndex = null; var clipUuid = action._clip.uuid, actionsByClip = this._actionsByClip, actionsForClip = actionsByClip[ clipUuid ], knownActionsForClip = actionsForClip.knownActions, lastKnownAction = knownActionsForClip[ knownActionsForClip.length - 1 ], byClipCacheIndex = action._byClipCacheIndex; lastKnownAction._byClipCacheIndex = byClipCacheIndex; knownActionsForClip[ byClipCacheIndex ] = lastKnownAction; knownActionsForClip.pop(); action._byClipCacheIndex = null; var actionByRoot = actionsForClip.actionByRoot, rootUuid = ( action._localRoot || this._root ).uuid; delete actionByRoot[ rootUuid ]; if ( knownActionsForClip.length === 0 ) { delete actionsByClip[ clipUuid ]; } this._removeInactiveBindingsForAction( action ); }, _removeInactiveBindingsForAction: function ( action ) { var bindings = action._propertyBindings; for ( var i = 0, n = bindings.length; i !== n; ++ i ) { var binding = bindings[ i ]; if ( -- binding.referenceCount === 0 ) { this._removeInactiveBinding( binding ); } } }, _lendAction: function ( action ) { // [ active actions | inactive actions ] // [ active actions >| inactive actions ] // s a // // a s var actions = this._actions, prevIndex = action._cacheIndex, lastActiveIndex = this._nActiveActions ++, firstInactiveAction = actions[ lastActiveIndex ]; action._cacheIndex = lastActiveIndex; actions[ lastActiveIndex ] = action; firstInactiveAction._cacheIndex = prevIndex; actions[ prevIndex ] = firstInactiveAction; }, _takeBackAction: function ( action ) { // [ active actions | inactive actions ] // [ active actions |< inactive actions ] // a s // // s a var actions = this._actions, prevIndex = action._cacheIndex, firstInactiveIndex = -- this._nActiveActions, lastActiveAction = actions[ firstInactiveIndex ]; action._cacheIndex = firstInactiveIndex; actions[ firstInactiveIndex ] = action; lastActiveAction._cacheIndex = prevIndex; actions[ prevIndex ] = lastActiveAction; }, // Memory management for PropertyMixer objects _addInactiveBinding: function ( binding, rootUuid, trackName ) { var bindingsByRoot = this._bindingsByRootAndName, bindingByName = bindingsByRoot[ rootUuid ], bindings = this._bindings; if ( bindingByName === undefined ) { bindingByName = {}; bindingsByRoot[ rootUuid ] = bindingByName; } bindingByName[ trackName ] = binding; binding._cacheIndex = bindings.length; bindings.push( binding ); }, _removeInactiveBinding: function ( binding ) { var bindings = this._bindings, propBinding = binding.binding, rootUuid = propBinding.rootNode.uuid, trackName = propBinding.path, bindingsByRoot = this._bindingsByRootAndName, bindingByName = bindingsByRoot[ rootUuid ], lastInactiveBinding = bindings[ bindings.length - 1 ], cacheIndex = binding._cacheIndex; lastInactiveBinding._cacheIndex = cacheIndex; bindings[ cacheIndex ] = lastInactiveBinding; bindings.pop(); delete bindingByName[ trackName ]; remove_empty_map: { for ( var _ in bindingByName ) break remove_empty_map; // eslint-disable-line no-unused-vars delete bindingsByRoot[ rootUuid ]; } }, _lendBinding: function ( binding ) { var bindings = this._bindings, prevIndex = binding._cacheIndex, lastActiveIndex = this._nActiveBindings ++, firstInactiveBinding = bindings[ lastActiveIndex ]; binding._cacheIndex = lastActiveIndex; bindings[ lastActiveIndex ] = binding; firstInactiveBinding._cacheIndex = prevIndex; bindings[ prevIndex ] = firstInactiveBinding; }, _takeBackBinding: function ( binding ) { var bindings = this._bindings, prevIndex = binding._cacheIndex, firstInactiveIndex = -- this._nActiveBindings, lastActiveBinding = bindings[ firstInactiveIndex ]; binding._cacheIndex = firstInactiveIndex; bindings[ firstInactiveIndex ] = binding; lastActiveBinding._cacheIndex = prevIndex; bindings[ prevIndex ] = lastActiveBinding; }, // Memory management of Interpolants for weight and time scale _lendControlInterpolant: function () { var interpolants = this._controlInterpolants, lastActiveIndex = this._nActiveControlInterpolants ++, interpolant = interpolants[ lastActiveIndex ]; if ( interpolant === undefined ) { interpolant = new LinearInterpolant( new Float32Array( 2 ), new Float32Array( 2 ), 1, this._controlInterpolantsResultBuffer ); interpolant.__cacheIndex = lastActiveIndex; interpolants[ lastActiveIndex ] = interpolant; } return interpolant; }, _takeBackControlInterpolant: function ( interpolant ) { var interpolants = this._controlInterpolants, prevIndex = interpolant.__cacheIndex, firstInactiveIndex = -- this._nActiveControlInterpolants, lastActiveInterpolant = interpolants[ firstInactiveIndex ]; interpolant.__cacheIndex = firstInactiveIndex; interpolants[ firstInactiveIndex ] = interpolant; lastActiveInterpolant.__cacheIndex = prevIndex; interpolants[ prevIndex ] = lastActiveInterpolant; }, _controlInterpolantsResultBuffer: new Float32Array( 1 ), // return an action for a clip optionally using a custom root target // object (this method allocates a lot of dynamic memory in case a // previously unknown clip/root combination is specified) clipAction: function ( clip, optionalRoot ) { var root = optionalRoot || this._root, rootUuid = root.uuid, clipObject = typeof clip === 'string' ? AnimationClip.findByName( root, clip ) : clip, clipUuid = clipObject !== null ? clipObject.uuid : clip, actionsForClip = this._actionsByClip[ clipUuid ], prototypeAction = null; if ( actionsForClip !== undefined ) { var existingAction = actionsForClip.actionByRoot[ rootUuid ]; if ( existingAction !== undefined ) { return existingAction; } // we know the clip, so we don't have to parse all // the bindings again but can just copy prototypeAction = actionsForClip.knownActions[ 0 ]; // also, take the clip from the prototype action if ( clipObject === null ) clipObject = prototypeAction._clip; } // clip must be known when specified via string if ( clipObject === null ) return null; // allocate all resources required to run it var newAction = new AnimationAction( this, clipObject, optionalRoot ); this._bindAction( newAction, prototypeAction ); // and make the action known to the memory manager this._addInactiveAction( newAction, clipUuid, rootUuid ); return newAction; }, // get an existing action existingAction: function ( clip, optionalRoot ) { var root = optionalRoot || this._root, rootUuid = root.uuid, clipObject = typeof clip === 'string' ? AnimationClip.findByName( root, clip ) : clip, clipUuid = clipObject ? clipObject.uuid : clip, actionsForClip = this._actionsByClip[ clipUuid ]; if ( actionsForClip !== undefined ) { return actionsForClip.actionByRoot[ rootUuid ] || null; } return null; }, // deactivates all previously scheduled actions stopAllAction: function () { var actions = this._actions, nActions = this._nActiveActions, bindings = this._bindings, nBindings = this._nActiveBindings; this._nActiveActions = 0; this._nActiveBindings = 0; for ( var i = 0; i !== nActions; ++ i ) { actions[ i ].reset(); } for ( var i = 0; i !== nBindings; ++ i ) { bindings[ i ].useCount = 0; } return this; }, // advance the time and update apply the animation update: function ( deltaTime ) { deltaTime *= this.timeScale; var actions = this._actions, nActions = this._nActiveActions, time = this.time += deltaTime, timeDirection = Math.sign( deltaTime ), accuIndex = this._accuIndex ^= 1; // run active actions for ( var i = 0; i !== nActions; ++ i ) { var action = actions[ i ]; action._update( time, deltaTime, timeDirection, accuIndex ); } // update scene graph var bindings = this._bindings, nBindings = this._nActiveBindings; for ( var i = 0; i !== nBindings; ++ i ) { bindings[ i ].apply( accuIndex ); } return this; }, // return this mixer's root target object getRoot: function () { return this._root; }, // free all resources specific to a particular clip uncacheClip: function ( clip ) { var actions = this._actions, clipUuid = clip.uuid, actionsByClip = this._actionsByClip, actionsForClip = actionsByClip[ clipUuid ]; if ( actionsForClip !== undefined ) { // note: just calling _removeInactiveAction would mess up the // iteration state and also require updating the state we can // just throw away var actionsToRemove = actionsForClip.knownActions; for ( var i = 0, n = actionsToRemove.length; i !== n; ++ i ) { var action = actionsToRemove[ i ]; this._deactivateAction( action ); var cacheIndex = action._cacheIndex, lastInactiveAction = actions[ actions.length - 1 ]; action._cacheIndex = null; action._byClipCacheIndex = null; lastInactiveAction._cacheIndex = cacheIndex; actions[ cacheIndex ] = lastInactiveAction; actions.pop(); this._removeInactiveBindingsForAction( action ); } delete actionsByClip[ clipUuid ]; } }, // free all resources specific to a particular root target object uncacheRoot: function ( root ) { var rootUuid = root.uuid, actionsByClip = this._actionsByClip; for ( var clipUuid in actionsByClip ) { var actionByRoot = actionsByClip[ clipUuid ].actionByRoot, action = actionByRoot[ rootUuid ]; if ( action !== undefined ) { this._deactivateAction( action ); this._removeInactiveAction( action ); } } var bindingsByRoot = this._bindingsByRootAndName, bindingByName = bindingsByRoot[ rootUuid ]; if ( bindingByName !== undefined ) { for ( var trackName in bindingByName ) { var binding = bindingByName[ trackName ]; binding.restoreOriginalState(); this._removeInactiveBinding( binding ); } } }, // remove a targeted clip from the cache uncacheAction: function ( clip, optionalRoot ) { var action = this.existingAction( clip, optionalRoot ); if ( action !== null ) { this._deactivateAction( action ); this._removeInactiveAction( action ); } } } ); /** * @author mrdoob / http://mrdoob.com/ */ function Uniform( value ) { if ( typeof value === 'string' ) { console.warn( 'THREE.Uniform: Type parameter is no longer needed.' ); value = arguments[ 1 ]; } this.value = value; } Uniform.prototype.clone = function () { return new Uniform( this.value.clone === undefined ? this.value : this.value.clone() ); }; /** * @author benaadams / https://twitter.com/ben_a_adams */ function InstancedBufferGeometry() { BufferGeometry.call( this ); this.type = 'InstancedBufferGeometry'; this.maxInstancedCount = undefined; } InstancedBufferGeometry.prototype = Object.assign( Object.create( BufferGeometry.prototype ), { constructor: InstancedBufferGeometry, isInstancedBufferGeometry: true, copy: function ( source ) { BufferGeometry.prototype.copy.call( this, source ); this.maxInstancedCount = source.maxInstancedCount; return this; }, clone: function () { return new this.constructor().copy( this ); } } ); /** * @author benaadams / https://twitter.com/ben_a_adams */ function InstancedInterleavedBuffer( array, stride, meshPerAttribute ) { InterleavedBuffer.call( this, array, stride ); this.meshPerAttribute = meshPerAttribute || 1; } InstancedInterleavedBuffer.prototype = Object.assign( Object.create( InterleavedBuffer.prototype ), { constructor: InstancedInterleavedBuffer, isInstancedInterleavedBuffer: true, copy: function ( source ) { InterleavedBuffer.prototype.copy.call( this, source ); this.meshPerAttribute = source.meshPerAttribute; return this; } } ); /** * @author benaadams / https://twitter.com/ben_a_adams */ function InstancedBufferAttribute( array, itemSize, normalized, meshPerAttribute ) { if ( typeof ( normalized ) === 'number' ) { meshPerAttribute = normalized; normalized = false; console.error( 'THREE.InstancedBufferAttribute: The constructor now expects normalized as the third argument.' ); } BufferAttribute.call( this, array, itemSize, normalized ); this.meshPerAttribute = meshPerAttribute || 1; } InstancedBufferAttribute.prototype = Object.assign( Object.create( BufferAttribute.prototype ), { constructor: InstancedBufferAttribute, isInstancedBufferAttribute: true, copy: function ( source ) { BufferAttribute.prototype.copy.call( this, source ); this.meshPerAttribute = source.meshPerAttribute; return this; } } ); /** * @author mrdoob / http://mrdoob.com/ * @author bhouston / http://clara.io/ * @author stephomi / http://stephaneginier.com/ */ function Raycaster( origin, direction, near, far ) { this.ray = new Ray( origin, direction ); // direction is assumed to be normalized (for accurate distance calculations) this.near = near || 0; this.far = far || Infinity; this.params = { Mesh: {}, Line: {}, LOD: {}, Points: { threshold: 1 }, Sprite: {} }; Object.defineProperties( this.params, { PointCloud: { get: function () { console.warn( 'THREE.Raycaster: params.PointCloud has been renamed to params.Points.' ); return this.Points; } } } ); } function ascSort( a, b ) { return a.distance - b.distance; } function intersectObject( object, raycaster, intersects, recursive ) { if ( object.visible === false ) return; object.raycast( raycaster, intersects ); if ( recursive === true ) { var children = object.children; for ( var i = 0, l = children.length; i < l; i ++ ) { intersectObject( children[ i ], raycaster, intersects, true ); } } } Object.assign( Raycaster.prototype, { linePrecision: 1, set: function ( origin, direction ) { // direction is assumed to be normalized (for accurate distance calculations) this.ray.set( origin, direction ); }, setFromCamera: function ( coords, camera ) { if ( ( camera && camera.isPerspectiveCamera ) ) { this.ray.origin.setFromMatrixPosition( camera.matrixWorld ); this.ray.direction.set( coords.x, coords.y, 0.5 ).unproject( camera ).sub( this.ray.origin ).normalize(); } else if ( ( camera && camera.isOrthographicCamera ) ) { this.ray.origin.set( coords.x, coords.y, ( camera.near + camera.far ) / ( camera.near - camera.far ) ).unproject( camera ); // set origin in plane of camera this.ray.direction.set( 0, 0, - 1 ).transformDirection( camera.matrixWorld ); } else { console.error( 'THREE.Raycaster: Unsupported camera type.' ); } }, intersectObject: function ( object, recursive, optionalTarget ) { var intersects = optionalTarget || []; intersectObject( object, this, intersects, recursive ); intersects.sort( ascSort ); return intersects; }, intersectObjects: function ( objects, recursive, optionalTarget ) { var intersects = optionalTarget || []; if ( Array.isArray( objects ) === false ) { console.warn( 'THREE.Raycaster.intersectObjects: objects is not an Array.' ); return intersects; } for ( var i = 0, l = objects.length; i < l; i ++ ) { intersectObject( objects[ i ], this, intersects, recursive ); } intersects.sort( ascSort ); return intersects; } } ); /** * @author bhouston / http://clara.io * @author WestLangley / http://github.com/WestLangley * * Ref: https://en.wikipedia.org/wiki/Spherical_coordinate_system * * The polar angle (phi) is measured from the positive y-axis. The positive y-axis is up. * The azimuthal angle (theta) is measured from the positive z-axiz. */ function Spherical( radius, phi, theta ) { this.radius = ( radius !== undefined ) ? radius : 1.0; this.phi = ( phi !== undefined ) ? phi : 0; // polar angle this.theta = ( theta !== undefined ) ? theta : 0; // azimuthal angle return this; } Object.assign( Spherical.prototype, { set: function ( radius, phi, theta ) { this.radius = radius; this.phi = phi; this.theta = theta; return this; }, clone: function () { return new this.constructor().copy( this ); }, copy: function ( other ) { this.radius = other.radius; this.phi = other.phi; this.theta = other.theta; return this; }, // restrict phi to be betwee EPS and PI-EPS makeSafe: function () { var EPS = 0.000001; this.phi = Math.max( EPS, Math.min( Math.PI - EPS, this.phi ) ); return this; }, setFromVector3: function ( v ) { return this.setFromCartesianCoords( v.x, v.y, v.z ); }, setFromCartesianCoords: function ( x, y, z ) { this.radius = Math.sqrt( x * x + y * y + z * z ); if ( this.radius === 0 ) { this.theta = 0; this.phi = 0; } else { this.theta = Math.atan2( x, z ); this.phi = Math.acos( _Math.clamp( y / this.radius, - 1, 1 ) ); } return this; } } ); /** * @author Mugen87 / https://github.com/Mugen87 * * Ref: https://en.wikipedia.org/wiki/Cylindrical_coordinate_system * */ function Cylindrical( radius, theta, y ) { this.radius = ( radius !== undefined ) ? radius : 1.0; // distance from the origin to a point in the x-z plane this.theta = ( theta !== undefined ) ? theta : 0; // counterclockwise angle in the x-z plane measured in radians from the positive z-axis this.y = ( y !== undefined ) ? y : 0; // height above the x-z plane return this; } Object.assign( Cylindrical.prototype, { set: function ( radius, theta, y ) { this.radius = radius; this.theta = theta; this.y = y; return this; }, clone: function () { return new this.constructor().copy( this ); }, copy: function ( other ) { this.radius = other.radius; this.theta = other.theta; this.y = other.y; return this; }, setFromVector3: function ( v ) { return this.setFromCartesianCoords( v.x, v.y, v.z ); }, setFromCartesianCoords: function ( x, y, z ) { this.radius = Math.sqrt( x * x + z * z ); this.theta = Math.atan2( x, z ); this.y = y; return this; } } ); /** * @author bhouston / http://clara.io */ function Box2( min, max ) { this.min = ( min !== undefined ) ? min : new Vector2( + Infinity, + Infinity ); this.max = ( max !== undefined ) ? max : new Vector2( - Infinity, - Infinity ); } Object.assign( Box2.prototype, { set: function ( min, max ) { this.min.copy( min ); this.max.copy( max ); return this; }, setFromPoints: function ( points ) { this.makeEmpty(); for ( var i = 0, il = points.length; i < il; i ++ ) { this.expandByPoint( points[ i ] ); } return this; }, setFromCenterAndSize: function () { var v1 = new Vector2(); return function setFromCenterAndSize( center, size ) { var halfSize = v1.copy( size ).multiplyScalar( 0.5 ); this.min.copy( center ).sub( halfSize ); this.max.copy( center ).add( halfSize ); return this; }; }(), clone: function () { return new this.constructor().copy( this ); }, copy: function ( box ) { this.min.copy( box.min ); this.max.copy( box.max ); return this; }, makeEmpty: function () { this.min.x = this.min.y = + Infinity; this.max.x = this.max.y = - Infinity; return this; }, isEmpty: function () { // this is a more robust check for empty than ( volume this.max.y ? false : true; }, containsBox: function ( box ) { return this.min.x this.max.y ? false : true; }, clampPoint: function ( point, target ) { if ( target === undefined ) { console.warn( 'THREE.Box2: .clampPoint() target is now required' ); target = new Vector2(); } return target.copy( point ).clamp( this.min, this.max ); }, distanceToPoint: function () { var v1 = new Vector2(); return function distanceToPoint( point ) { var clampedPoint = v1.copy( point ).clamp( this.min, this.max ); return clampedPoint.sub( point ).length(); }; }(), intersect: function ( box ) { this.min.max( box.min ); this.max.min( box.max ); return this; }, union: function ( box ) { this.min.min( box.min ); this.max.max( box.max ); return this; }, translate: function ( offset ) { this.min.add( offset ); this.max.add( offset ); return this; }, equals: function ( box ) { return box.min.equals( this.min ) && box.max.equals( this.max ); } } ); /** * @author bhouston / http://clara.io */ function Line3( start, end ) { this.start = ( start !== undefined ) ? start : new Vector3(); this.end = ( end !== undefined ) ? end : new Vector3(); } Object.assign( Line3.prototype, { set: function ( start, end ) { this.start.copy( start ); this.end.copy( end ); return this; }, clone: function () { return new this.constructor().copy( this ); }, copy: function ( line ) { this.start.copy( line.start ); this.end.copy( line.end ); return this; }, getCenter: function ( target ) { if ( target === undefined ) { console.warn( 'THREE.Line3: .getCenter() target is now required' ); target = new Vector3(); } return target.addVectors( this.start, this.end ).multiplyScalar( 0.5 ); }, delta: function ( target ) { if ( target === undefined ) { console.warn( 'THREE.Line3: .delta() target is now required' ); target = new Vector3(); } return target.subVectors( this.end, this.start ); }, distanceSq: function () { return this.start.distanceToSquared( this.end ); }, distance: function () { return this.start.distanceTo( this.end ); }, at: function ( t, target ) { if ( target === undefined ) { console.warn( 'THREE.Line3: .at() target is now required' ); target = new Vector3(); } return this.delta( target ).multiplyScalar( t ).add( this.start ); }, closestPointToPointParameter: function () { var startP = new Vector3(); var startEnd = new Vector3(); return function closestPointToPointParameter( point, clampToLine ) { startP.subVectors( point, this.start ); startEnd.subVectors( this.end, this.start ); var startEnd2 = startEnd.dot( startEnd ); var startEnd_startP = startEnd.dot( startP ); var t = startEnd_startP / startEnd2; if ( clampToLine ) { t = _Math.clamp( t, 0, 1 ); } return t; }; }(), closestPointToPoint: function ( point, clampToLine, target ) { var t = this.closestPointToPointParameter( point, clampToLine ); if ( target === undefined ) { console.warn( 'THREE.Line3: .closestPointToPoint() target is now required' ); target = new Vector3(); } return this.delta( target ).multiplyScalar( t ).add( this.start ); }, applyMatrix4: function ( matrix ) { this.start.applyMatrix4( matrix ); this.end.applyMatrix4( matrix ); return this; }, equals: function ( line ) { return line.start.equals( this.start ) && line.end.equals( this.end ); } } ); /** * @author alteredq / http://alteredqualia.com/ */ function ImmediateRenderObject( material ) { Object3D.call( this ); this.material = material; this.render = function ( /* renderCallback */ ) {}; } ImmediateRenderObject.prototype = Object.create( Object3D.prototype ); ImmediateRenderObject.prototype.constructor = ImmediateRenderObject; ImmediateRenderObject.prototype.isImmediateRenderObject = true; /** * @author mrdoob / http://mrdoob.com/ * @author WestLangley / http://github.com/WestLangley */ function VertexNormalsHelper( object, size, hex, linewidth ) { this.object = object; this.size = ( size !== undefined ) ? size : 1; var color = ( hex !== undefined ) ? hex : 0xff0000; var width = ( linewidth !== undefined ) ? linewidth : 1; // var nNormals = 0; var objGeometry = this.object.geometry; if ( objGeometry && objGeometry.isGeometry ) { nNormals = objGeometry.faces.length * 3; } else if ( objGeometry && objGeometry.isBufferGeometry ) { nNormals = objGeometry.attributes.normal.count; } // var geometry = new BufferGeometry(); var positions = new Float32BufferAttribute( nNormals * 2 * 3, 3 ); geometry.addAttribute( 'position', positions ); LineSegments.call( this, geometry, new LineBasicMaterial( { color: color, linewidth: width } ) ); // this.matrixAutoUpdate = false; this.update(); } VertexNormalsHelper.prototype = Object.create( LineSegments.prototype ); VertexNormalsHelper.prototype.constructor = VertexNormalsHelper; VertexNormalsHelper.prototype.update = ( function () { var v1 = new Vector3(); var v2 = new Vector3(); var normalMatrix = new Matrix3(); return function update() { var keys = [ 'a', 'b', 'c' ]; this.object.updateMatrixWorld( true ); normalMatrix.getNormalMatrix( this.object.matrixWorld ); var matrixWorld = this.object.matrixWorld; var position = this.geometry.attributes.position; // var objGeometry = this.object.geometry; if ( objGeometry && objGeometry.isGeometry ) { var vertices = objGeometry.vertices; var faces = objGeometry.faces; var idx = 0; for ( var i = 0, l = faces.length; i < l; i ++ ) { var face = faces[ i ]; for ( var j = 0, jl = face.vertexNormals.length; j < jl; j ++ ) { var vertex = vertices[ face[ keys[ j ] ] ]; var normal = face.vertexNormals[ j ]; v1.copy( vertex ).applyMatrix4( matrixWorld ); v2.copy( normal ).applyMatrix3( normalMatrix ).normalize().multiplyScalar( this.size ).add( v1 ); position.setXYZ( idx, v1.x, v1.y, v1.z ); idx = idx + 1; position.setXYZ( idx, v2.x, v2.y, v2.z ); idx = idx + 1; } } } else if ( objGeometry && objGeometry.isBufferGeometry ) { var objPos = objGeometry.attributes.position; var objNorm = objGeometry.attributes.normal; var idx = 0; // for simplicity, ignore index and drawcalls, and render every normal for ( var j = 0, jl = objPos.count; j < jl; j ++ ) { v1.set( objPos.getX( j ), objPos.getY( j ), objPos.getZ( j ) ).applyMatrix4( matrixWorld ); v2.set( objNorm.getX( j ), objNorm.getY( j ), objNorm.getZ( j ) ); v2.applyMatrix3( normalMatrix ).normalize().multiplyScalar( this.size ).add( v1 ); position.setXYZ( idx, v1.x, v1.y, v1.z ); idx = idx + 1; position.setXYZ( idx, v2.x, v2.y, v2.z ); idx = idx + 1; } } position.needsUpdate = true; }; }() ); /** * @author alteredq / http://alteredqualia.com/ * @author mrdoob / http://mrdoob.com/ * @author WestLangley / http://github.com/WestLangley */ function SpotLightHelper( light, color ) { Object3D.call( this ); this.light = light; this.light.updateMatrixWorld(); this.matrix = light.matrixWorld; this.matrixAutoUpdate = false; this.color = color; var geometry = new BufferGeometry(); var positions = [ 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, - 1, 0, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, - 1, 1 ]; for ( var i = 0, j = 1, l = 32; i < l; i ++, j ++ ) { var p1 = ( i / l ) * Math.PI * 2; var p2 = ( j / l ) * Math.PI * 2; positions.push( Math.cos( p1 ), Math.sin( p1 ), 1, Math.cos( p2 ), Math.sin( p2 ), 1 ); } geometry.addAttribute( 'position', new Float32BufferAttribute( positions, 3 ) ); var material = new LineBasicMaterial( { fog: false } ); this.cone = new LineSegments( geometry, material ); this.add( this.cone ); this.update(); } SpotLightHelper.prototype = Object.create( Object3D.prototype ); SpotLightHelper.prototype.constructor = SpotLightHelper; SpotLightHelper.prototype.dispose = function () { this.cone.geometry.dispose(); this.cone.material.dispose(); }; SpotLightHelper.prototype.update = function () { var vector = new Vector3(); return function update() { this.light.updateMatrixWorld(); var coneLength = this.light.distance ? this.light.distance : 1000; var coneWidth = coneLength * Math.tan( this.light.angle ); this.cone.scale.set( coneWidth, coneWidth, coneLength ); vector.setFromMatrixPosition( this.light.target.matrixWorld ); this.cone.lookAt( vector ); if ( this.color !== undefined ) { this.cone.material.color.set( this.color ); } else { this.cone.material.color.copy( this.light.color ); } }; }(); /** * @author Sean Griffin / http://twitter.com/sgrif * @author Michael Guerrero / http://realitymeltdown.com * @author mrdoob / http://mrdoob.com/ * @author ikerr / http://verold.com * @author Mugen87 / https://github.com/Mugen87 */ function getBoneList( object ) { var boneList = []; if ( object && object.isBone ) { boneList.push( object ); } for ( var i = 0; i < object.children.length; i ++ ) { boneList.push.apply( boneList, getBoneList( object.children[ i ] ) ); } return boneList; } function SkeletonHelper( object ) { var bones = getBoneList( object ); var geometry = new BufferGeometry(); var vertices = []; var colors = []; var color1 = new Color( 0, 0, 1 ); var color2 = new Color( 0, 1, 0 ); for ( var i = 0; i < bones.length; i ++ ) { var bone = bones[ i ]; if ( bone.parent && bone.parent.isBone ) { vertices.push( 0, 0, 0 ); vertices.push( 0, 0, 0 ); colors.push( color1.r, color1.g, color1.b ); colors.push( color2.r, color2.g, color2.b ); } } geometry.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) ); geometry.addAttribute( 'color', new Float32BufferAttribute( colors, 3 ) ); var material = new LineBasicMaterial( { vertexColors: VertexColors, depthTest: false, depthWrite: false, transparent: true } ); LineSegments.call( this, geometry, material ); this.root = object; this.bones = bones; this.matrix = object.matrixWorld; this.matrixAutoUpdate = false; } SkeletonHelper.prototype = Object.create( LineSegments.prototype ); SkeletonHelper.prototype.constructor = SkeletonHelper; SkeletonHelper.prototype.updateMatrixWorld = function () { var vector = new Vector3(); var boneMatrix = new Matrix4(); var matrixWorldInv = new Matrix4(); return function updateMatrixWorld( force ) { var bones = this.bones; var geometry = this.geometry; var position = geometry.getAttribute( 'position' ); matrixWorldInv.getInverse( this.root.matrixWorld ); for ( var i = 0, j = 0; i < bones.length; i ++ ) { var bone = bones[ i ]; if ( bone.parent && bone.parent.isBone ) { boneMatrix.multiplyMatrices( matrixWorldInv, bone.matrixWorld ); vector.setFromMatrixPosition( boneMatrix ); position.setXYZ( j, vector.x, vector.y, vector.z ); boneMatrix.multiplyMatrices( matrixWorldInv, bone.parent.matrixWorld ); vector.setFromMatrixPosition( boneMatrix ); position.setXYZ( j + 1, vector.x, vector.y, vector.z ); j += 2; } } geometry.getAttribute( 'position' ).needsUpdate = true; Object3D.prototype.updateMatrixWorld.call( this, force ); }; }(); /** * @author alteredq / http://alteredqualia.com/ * @author mrdoob / http://mrdoob.com/ */ function PointLightHelper( light, sphereSize, color ) { this.light = light; this.light.updateMatrixWorld(); this.color = color; var geometry = new SphereBufferGeometry( sphereSize, 4, 2 ); var material = new MeshBasicMaterial( { wireframe: true, fog: false } ); Mesh.call( this, geometry, material ); this.matrix = this.light.matrixWorld; this.matrixAutoUpdate = false; this.update(); /* var distanceGeometry = new THREE.IcosahedronBufferGeometry( 1, 2 ); var distanceMaterial = new THREE.MeshBasicMaterial( { color: hexColor, fog: false, wireframe: true, opacity: 0.1, transparent: true } ); this.lightSphere = new THREE.Mesh( bulbGeometry, bulbMaterial ); this.lightDistance = new THREE.Mesh( distanceGeometry, distanceMaterial ); var d = light.distance; if ( d === 0.0 ) { this.lightDistance.visible = false; } else { this.lightDistance.scale.set( d, d, d ); } this.add( this.lightDistance ); */ } PointLightHelper.prototype = Object.create( Mesh.prototype ); PointLightHelper.prototype.constructor = PointLightHelper; PointLightHelper.prototype.dispose = function () { this.geometry.dispose(); this.material.dispose(); }; PointLightHelper.prototype.update = function () { if ( this.color !== undefined ) { this.material.color.set( this.color ); } else { this.material.color.copy( this.light.color ); } /* var d = this.light.distance; if ( d === 0.0 ) { this.lightDistance.visible = false; } else { this.lightDistance.visible = true; this.lightDistance.scale.set( d, d, d ); } */ }; /** * @author abelnation / http://github.com/abelnation * @author Mugen87 / http://github.com/Mugen87 * @author WestLangley / http://github.com/WestLangley * * This helper must be added as a child of the light */ function RectAreaLightHelper( light, color ) { this.type = 'RectAreaLightHelper'; this.light = light; this.color = color; // optional hardwired color for the helper var positions = [ 1, 1, 0, - 1, 1, 0, - 1, - 1, 0, 1, - 1, 0, 1, 1, 0 ]; var geometry = new BufferGeometry(); geometry.addAttribute( 'position', new Float32BufferAttribute( positions, 3 ) ); geometry.computeBoundingSphere(); var material = new LineBasicMaterial( { fog: false } ); Line.call( this, geometry, material ); // var positions2 = [ 1, 1, 0, - 1, 1, 0, - 1, - 1, 0, 1, 1, 0, - 1, - 1, 0, 1, - 1, 0 ]; var geometry2 = new BufferGeometry(); geometry2.addAttribute( 'position', new Float32BufferAttribute( positions2, 3 ) ); geometry2.computeBoundingSphere(); this.add( new Mesh( geometry2, new MeshBasicMaterial( { side: BackSide, fog: false } ) ) ); this.update(); } RectAreaLightHelper.prototype = Object.create( Line.prototype ); RectAreaLightHelper.prototype.constructor = RectAreaLightHelper; RectAreaLightHelper.prototype.update = function () { this.scale.set( 0.5 * this.light.width, 0.5 * this.light.height, 1 ); if ( this.color !== undefined ) { this.material.color.set( this.color ); this.children[ 0 ].material.color.set( this.color ); } else { this.material.color.copy( this.light.color ).multiplyScalar( this.light.intensity ); // prevent hue shift var c = this.material.color; var max = Math.max( c.r, c.g, c.b ); if ( max > 1 ) c.multiplyScalar( 1 / max ); this.children[ 0 ].material.color.copy( this.material.color ); } }; RectAreaLightHelper.prototype.dispose = function () { this.geometry.dispose(); this.material.dispose(); this.children[ 0 ].geometry.dispose(); this.children[ 0 ].material.dispose(); }; /** * @author alteredq / http://alteredqualia.com/ * @author mrdoob / http://mrdoob.com/ * @author Mugen87 / https://github.com/Mugen87 */ function HemisphereLightHelper( light, size, color ) { Object3D.call( this ); this.light = light; this.light.updateMatrixWorld(); this.matrix = light.matrixWorld; this.matrixAutoUpdate = false; this.color = color; var geometry = new OctahedronBufferGeometry( size ); geometry.rotateY( Math.PI * 0.5 ); this.material = new MeshBasicMaterial( { wireframe: true, fog: false } ); if ( this.color === undefined ) this.material.vertexColors = VertexColors; var position = geometry.getAttribute( 'position' ); var colors = new Float32Array( position.count * 3 ); geometry.addAttribute( 'color', new BufferAttribute( colors, 3 ) ); this.add( new Mesh( geometry, this.material ) ); this.update(); } HemisphereLightHelper.prototype = Object.create( Object3D.prototype ); HemisphereLightHelper.prototype.constructor = HemisphereLightHelper; HemisphereLightHelper.prototype.dispose = function () { this.children[ 0 ].geometry.dispose(); this.children[ 0 ].material.dispose(); }; HemisphereLightHelper.prototype.update = function () { var vector = new Vector3(); var color1 = new Color(); var color2 = new Color(); return function update() { var mesh = this.children[ 0 ]; if ( this.color !== undefined ) { this.material.color.set( this.color ); } else { var colors = mesh.geometry.getAttribute( 'color' ); color1.copy( this.light.color ); color2.copy( this.light.groundColor ); for ( var i = 0, l = colors.count; i < l; i ++ ) { var color = ( i < ( l / 2 ) ) ? color1 : color2; colors.setXYZ( i, color.r, color.g, color.b ); } colors.needsUpdate = true; } mesh.lookAt( vector.setFromMatrixPosition( this.light.matrixWorld ).negate() ); }; }(); /** * @author mrdoob / http://mrdoob.com/ */ function GridHelper( size, divisions, color1, color2 ) { size = size || 10; divisions = divisions || 10; color1 = new Color( color1 !== undefined ? color1 : 0x444444 ); color2 = new Color( color2 !== undefined ? color2 : 0x888888 ); var center = divisions / 2; var step = size / divisions; var halfSize = size / 2; var vertices = [], colors = []; for ( var i = 0, j = 0, k = - halfSize; i","categories":[],"tags":[]},{"title":"","slug":"Three.js移动DecalGeometry/js/three.min","date":"2019-03-17T10:06:35.716Z","updated":"2019-03-17T10:06:35.716Z","comments":true,"path":"2019/03/17/cjtcra7k9000eh1l3h2vj4tz8/","link":"","permalink":"http://www.zcating.tk/2019/03/17/cjtcra7k9000eh1l3h2vj4tz8/","excerpt":"","text":"// threejs.org/license (function(l,ja){\"object\"===typeof exports&&\"undefined\"!==typeof module?ja(exports):\"function\"===typeof define&&define.amd?define([\"exports\"],ja):(l=l||self,ja(l.THREE={}))})(this,function(l){function ja(){}function z(a,b){this.x=a||0;this.y=b||0}function J(){this.elements=[1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1];0b&&(b=a[c]);return b}function D(){Object.defineProperty(this,\"id\",{value:Tf+=2});this.uuid=G.generateUUID();this.name=\"\";this.type=\"BufferGeometry\";this.index=null;this.attributes={};this.morphAttributes={};this.groups=[];this.boundingSphere=this.boundingBox=null;this.drawRange={start:0,count:Infinity}; this.userData={}}function Mb(a,b,c,d,e,f){R.call(this);this.type=\"BoxGeometry\";this.parameters={width:a,height:b,depth:c,widthSegments:d,heightSegments:e,depthSegments:f};this.fromBufferGeometry(new pb(a,b,c,d,e,f));this.mergeVertices()}function pb(a,b,c,d,e,f){function g(a,b,c,d,e,f,g,l,ta,F,da){var r=f/ta,u=g/F,x=f/2,w=g/2,A=l/2;g=ta+1;var I=F+1,y=f=0,N,z,B=new n;for(z=0;z>24&255]).toUpperCase()}}(),clamp:function(a,b,c){return Math.max(b,Math.min(c,a))},euclideanModulo:function(a,b){return(a%b+b)%b},mapLinear:function(a,b,c, d,e){return d+(a-b)*(e-d)/(c-b)},lerp:function(a,b,c){return(1-c)*a+c*b},smoothstep:function(a,b,c){if(a=c)return 1;a=(a-b)/(c-b);return a*a*(3-2*a)},smootherstep:function(a,b,c){if(a=c)return 1;a=(a-b)/(c-b);return a*a*a*(a*(6*a-15)+10)},randInt:function(a,b){return a+Math.floor(Math.random()*(b-a+1))},randFloat:function(a,b){return a+Math.random()*(b-a)},randFloatSpread:function(a){return a*(.5-Math.random())},degToRad:function(a){return a*G.DEG2RAD},radToDeg:function(a){return a* G.RAD2DEG},isPowerOfTwo:function(a){return 0===(a&a-1)&&0!==a},ceilPowerOfTwo:function(a){return Math.pow(2,Math.ceil(Math.log(a)/Math.LN2))},floorPowerOfTwo:function(a){return Math.pow(2,Math.floor(Math.log(a)/Math.LN2))}};Object.defineProperties(z.prototype,{width:{get:function(){return this.x},set:function(a){this.x=a}},height:{get:function(){return this.y},set:function(a){this.y=a}}});Object.assign(z.prototype,{isVector2:!0,set:function(a,b){this.x=a;this.y=b;return this},setScalar:function(a){this.y= this.x=a;return this},setX:function(a){this.x=a;return this},setY:function(a){this.y=a;return this},setComponent:function(a,b){switch(a){case 0:this.x=b;break;case 1:this.y=b;break;default:throw Error(\"index is out of range: \"+a);}return this},getComponent:function(a){switch(a){case 0:return this.x;case 1:return this.y;default:throw Error(\"index is out of range: \"+a);}},clone:function(){return new this.constructor(this.x,this.y)},copy:function(a){this.x=a.x;this.y=a.y;return this},add:function(a, b){if(void 0!==b)return console.warn(\"THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead.\"),this.addVectors(a,b);this.x+=a.x;this.y+=a.y;return this},addScalar:function(a){this.x+=a;this.y+=a;return this},addVectors:function(a,b){this.x=a.x+b.x;this.y=a.y+b.y;return this},addScaledVector:function(a,b){this.x+=a.x*b;this.y+=a.y*b;return this},sub:function(a,b){if(void 0!==b)return console.warn(\"THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.\"), this.subVectors(a,b);this.x-=a.x;this.y-=a.y;return this},subScalar:function(a){this.x-=a;this.y-=a;return this},subVectors:function(a,b){this.x=a.x-b.x;this.y=a.y-b.y;return this},multiply:function(a){this.x*=a.x;this.y*=a.y;return this},multiplyScalar:function(a){this.x*=a;this.y*=a;return this},divide:function(a){this.x/=a.x;this.y/=a.y;return this},divideScalar:function(a){return this.multiplyScalar(1/a)},applyMatrix3:function(a){var b=this.x,c=this.y;a=a.elements;this.x=a[0]*b+a[3]*c+a[6];this.y= a[1]*b+a[4]*c+a[7];return this},min:function(a){this.x=Math.min(this.x,a.x);this.y=Math.min(this.y,a.y);return this},max:function(a){this.x=Math.max(this.x,a.x);this.y=Math.max(this.y,a.y);return this},clamp:function(a,b){this.x=Math.max(a.x,Math.min(b.x,this.x));this.y=Math.max(a.y,Math.min(b.y,this.y));return this},clampScalar:function(){var a=new z,b=new z;return function(c,d){a.set(c,c);b.set(d,d);return this.clamp(a,b)}}(),clampLength:function(a,b){var c=this.length();return this.divideScalar(c|| 1).multiplyScalar(Math.max(a,Math.min(b,c)))},floor:function(){this.x=Math.floor(this.x);this.y=Math.floor(this.y);return this},ceil:function(){this.x=Math.ceil(this.x);this.y=Math.ceil(this.y);return this},round:function(){this.x=Math.round(this.x);this.y=Math.round(this.y);return this},roundToZero:function(){this.x=0>this.x?Math.ceil(this.x):Math.floor(this.x);this.y=0>this.y?Math.ceil(this.y):Math.floor(this.y);return this},negate:function(){this.x=-this.x;this.y=-this.y;return this},dot:function(a){return this.x* a.x+this.y*a.y},cross:function(a){return this.x*a.y-this.y*a.x},lengthSq:function(){return this.x*this.x+this.y*this.y},length:function(){return Math.sqrt(this.x*this.x+this.y*this.y)},manhattanLength:function(){return Math.abs(this.x)+Math.abs(this.y)},normalize:function(){return this.divideScalar(this.length()||1)},angle:function(){var a=Math.atan2(this.y,this.x);0>a&&(a+=2*Math.PI);return a},distanceTo:function(a){return Math.sqrt(this.distanceToSquared(a))},distanceToSquared:function(a){var b= this.x-a.x;a=this.y-a.y;return b*b+a*a},manhattanDistanceTo:function(a){return Math.abs(this.x-a.x)+Math.abs(this.y-a.y)},setLength:function(a){return this.normalize().multiplyScalar(a)},lerp:function(a,b){this.x+=(a.x-this.x)*b;this.y+=(a.y-this.y)*b;return this},lerpVectors:function(a,b,c){return this.subVectors(b,a).multiplyScalar(c).add(a)},equals:function(a){return a.x===this.x&&a.y===this.y},fromArray:function(a,b){void 0===b&&(b=0);this.x=a[b];this.y=a[b+1];return this},toArray:function(a, b){void 0===a&&(a=[]);void 0===b&&(b=0);a[b]=this.x;a[b+1]=this.y;return a},fromBufferAttribute:function(a,b,c){void 0!==c&&console.warn(\"THREE.Vector2: offset has been removed from .fromBufferAttribute().\");this.x=a.getX(b);this.y=a.getY(b);return this},rotateAround:function(a,b){var c=Math.cos(b);b=Math.sin(b);var d=this.x-a.x,e=this.y-a.y;this.x=d*c-e*b+a.x;this.y=d*b+e*c+a.y;return this}});Object.assign(J.prototype,{isMatrix4:!0,set:function(a,b,c,d,e,f,g,h,k,m,q,l,t,v,r,n){var p=this.elements; p[0]=a;p[4]=b;p[8]=c;p[12]=d;p[1]=e;p[5]=f;p[9]=g;p[13]=h;p[2]=k;p[6]=m;p[10]=q;p[14]=l;p[3]=t;p[7]=v;p[11]=r;p[15]=n;return this},identity:function(){this.set(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1);return this},clone:function(){return(new J).fromArray(this.elements)},copy:function(a){var b=this.elements;a=a.elements;b[0]=a[0];b[1]=a[1];b[2]=a[2];b[3]=a[3];b[4]=a[4];b[5]=a[5];b[6]=a[6];b[7]=a[7];b[8]=a[8];b[9]=a[9];b[10]=a[10];b[11]=a[11];b[12]=a[12];b[13]=a[13];b[14]=a[14];b[15]=a[15];return this},copyPosition:function(a){var b= this.elements;a=a.elements;b[12]=a[12];b[13]=a[13];b[14]=a[14];return this},extractBasis:function(a,b,c){a.setFromMatrixColumn(this,0);b.setFromMatrixColumn(this,1);c.setFromMatrixColumn(this,2);return this},makeBasis:function(a,b,c){this.set(a.x,b.x,c.x,0,a.y,b.y,c.y,0,a.z,b.z,c.z,0,0,0,0,1);return this},extractRotation:function(){var a=new n;return function(b){var c=this.elements,d=b.elements,e=1/a.setFromMatrixColumn(b,0).length(),f=1/a.setFromMatrixColumn(b,1).length();b=1/a.setFromMatrixColumn(b, 2).length();c[0]=d[0]*e;c[1]=d[1]*e;c[2]=d[2]*e;c[3]=0;c[4]=d[4]*f;c[5]=d[5]*f;c[6]=d[6]*f;c[7]=0;c[8]=d[8]*b;c[9]=d[9]*b;c[10]=d[10]*b;c[11]=0;c[12]=0;c[13]=0;c[14]=0;c[15]=1;return this}}(),makeRotationFromEuler:function(a){a&&a.isEuler||console.error(\"THREE.Matrix4: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.\");var b=this.elements,c=a.x,d=a.y,e=a.z,f=Math.cos(c);c=Math.sin(c);var g=Math.cos(d);d=Math.sin(d);var h=Math.cos(e);e=Math.sin(e);if(\"XYZ\"===a.order){a= f*h;var k=f*e,m=c*h,q=c*e;b[0]=g*h;b[4]=-g*e;b[8]=d;b[1]=k+m*d;b[5]=a-q*d;b[9]=-c*g;b[2]=q-a*d;b[6]=m+k*d;b[10]=f*g}else\"YXZ\"===a.order?(a=g*h,k=g*e,m=d*h,q=d*e,b[0]=a+q*c,b[4]=m*c-k,b[8]=f*d,b[1]=f*e,b[5]=f*h,b[9]=-c,b[2]=k*c-m,b[6]=q+a*c,b[10]=f*g):\"ZXY\"===a.order?(a=g*h,k=g*e,m=d*h,q=d*e,b[0]=a-q*c,b[4]=-f*e,b[8]=m+k*c,b[1]=k+m*c,b[5]=f*h,b[9]=q-a*c,b[2]=-f*d,b[6]=c,b[10]=f*g):\"ZYX\"===a.order?(a=f*h,k=f*e,m=c*h,q=c*e,b[0]=g*h,b[4]=m*d-k,b[8]=a*d+q,b[1]=g*e,b[5]=q*d+a,b[9]=k*d-m,b[2]=-d,b[6]=c* g,b[10]=f*g):\"YZX\"===a.order?(a=f*g,k=f*d,m=c*g,q=c*d,b[0]=g*h,b[4]=q-a*e,b[8]=m*e+k,b[1]=e,b[5]=f*h,b[9]=-c*h,b[2]=-d*h,b[6]=k*e+m,b[10]=a-q*e):\"XZY\"===a.order&&(a=f*g,k=f*d,m=c*g,q=c*d,b[0]=g*h,b[4]=-e,b[8]=d*h,b[1]=a*e+q,b[5]=f*h,b[9]=k*e-m,b[2]=m*e-k,b[6]=c*h,b[10]=q*e+a);b[3]=0;b[7]=0;b[11]=0;b[12]=0;b[13]=0;b[14]=0;b[15]=1;return this},makeRotationFromQuaternion:function(){var a=new n(0,0,0),b=new n(1,1,1);return function(c){return this.compose(a,c,b)}}(),lookAt:function(){var a=new n,b=new n, c=new n;return function(d,e,f){var g=this.elements;c.subVectors(d,e);0===c.lengthSq()&&(c.z=1);c.normalize();a.crossVectors(f,c);0===a.lengthSq()&&(1===Math.abs(f.z)?c.x+=1E-4:c.z+=1E-4,c.normalize(),a.crossVectors(f,c));a.normalize();b.crossVectors(c,a);g[0]=a.x;g[4]=b.x;g[8]=c.x;g[1]=a.y;g[5]=b.y;g[9]=c.y;g[2]=a.z;g[6]=b.z;g[10]=c.z;return this}}(),multiply:function(a,b){return void 0!==b?(console.warn(\"THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead.\"), this.multiplyMatrices(a,b)):this.multiplyMatrices(this,a)},premultiply:function(a){return this.multiplyMatrices(a,this)},multiplyMatrices:function(a,b){var c=a.elements,d=b.elements;b=this.elements;a=c[0];var e=c[4],f=c[8],g=c[12],h=c[1],k=c[5],m=c[9],q=c[13],l=c[2],t=c[6],v=c[10],r=c[14],n=c[3],x=c[7],A=c[11];c=c[15];var w=d[0],I=d[4],y=d[8],N=d[12],z=d[1],F=d[5],B=d[9],D=d[13],C=d[2],G=d[6],E=d[10],H=d[14],L=d[3],J=d[7],K=d[11];d=d[15];b[0]=a*w+e*z+f*C+g*L;b[4]=a*I+e*F+f*G+g*J;b[8]=a*y+e*B+f*E+ g*K;b[12]=a*N+e*D+f*H+g*d;b[1]=h*w+k*z+m*C+q*L;b[5]=h*I+k*F+m*G+q*J;b[9]=h*y+k*B+m*E+q*K;b[13]=h*N+k*D+m*H+q*d;b[2]=l*w+t*z+v*C+r*L;b[6]=l*I+t*F+v*G+r*J;b[10]=l*y+t*B+v*E+r*K;b[14]=l*N+t*D+v*H+r*d;b[3]=n*w+x*z+A*C+c*L;b[7]=n*I+x*F+A*G+c*J;b[11]=n*y+x*B+A*E+c*K;b[15]=n*N+x*D+A*H+c*d;return this},multiplyScalar:function(a){var b=this.elements;b[0]*=a;b[4]*=a;b[8]*=a;b[12]*=a;b[1]*=a;b[5]*=a;b[9]*=a;b[13]*=a;b[2]*=a;b[6]*=a;b[10]*=a;b[14]*=a;b[3]*=a;b[7]*=a;b[11]*=a;b[15]*=a;return this},applyToBufferAttribute:function(){var a= new n;return function(b){for(var c=0,d=b.count;cthis.determinant()&&(g=-g);c.x=f[12];c.y=f[13];c.z=f[14];b.copy(this);c=1/g;f=1/h;var m=1/k;b.elements[0]*=c;b.elements[1]*=c;b.elements[2]*=c;b.elements[4]*=f;b.elements[5]*=f;b.elements[6]*=f;b.elements[8]*=m;b.elements[9]*=m;b.elements[10]*=m;d.setFromRotationMatrix(b);e.x=g;e.y=h;e.z=k;return this}}(),makePerspective:function(a,b,c,d,e,f){void 0===f&&console.warn(\"THREE.Matrix4: .makePerspective() has been redefined and has a new signature. Please check the docs.\"); var g=this.elements;g[0]=2*e/(b-a);g[4]=0;g[8]=(b+a)/(b-a);g[12]=0;g[1]=0;g[5]=2*e/(c-d);g[9]=(c+d)/(c-d);g[13]=0;g[2]=0;g[6]=0;g[10]=-(f+e)/(f-e);g[14]=-2*f*e/(f-e);g[3]=0;g[7]=0;g[11]=-1;g[15]=0;return this},makeOrthographic:function(a,b,c,d,e,f){var g=this.elements,h=1/(b-a),k=1/(c-d),m=1/(f-e);g[0]=2*h;g[4]=0;g[8]=0;g[12]=-((b+a)*h);g[1]=0;g[5]=2*k;g[9]=0;g[13]=-((c+d)*k);g[2]=0;g[6]=0;g[10]=-2*m;g[14]=-((f+e)*m);g[3]=0;g[7]=0;g[11]=0;g[15]=1;return this},equals:function(a){var b=this.elements; a=a.elements;for(var c=0;16>c;c++)if(b[c]!==a[c])return!1;return!0},fromArray:function(a,b){void 0===b&&(b=0);for(var c=0;16>c;c++)this.elements[c]=a[c+b];return this},toArray:function(a,b){void 0===a&&(a=[]);void 0===b&&(b=0);var c=this.elements;a[b]=c[0];a[b+1]=c[1];a[b+2]=c[2];a[b+3]=c[3];a[b+4]=c[4];a[b+5]=c[5];a[b+6]=c[6];a[b+7]=c[7];a[b+8]=c[8];a[b+9]=c[9];a[b+10]=c[10];a[b+11]=c[11];a[b+12]=c[12];a[b+13]=c[13];a[b+14]=c[14];a[b+15]=c[15];return a}});Object.assign(ka,{slerp:function(a,b,c,d){return c.copy(a).slerp(b, d)},slerpFlat:function(a,b,c,d,e,f,g){var h=c[d+0],k=c[d+1],m=c[d+2];c=c[d+3];d=e[f+0];var l=e[f+1],p=e[f+2];e=e[f+3];if(c!==e||h!==d||k!==l||m!==p){f=1-g;var t=h*d+k*l+m*p+c*e,n=0Number.EPSILON&&(r=Math.sqrt(r),t=Math.atan2(r,t*n),f=Math.sin(f*t)/r,g=Math.sin(g*t)/r);n*=g;h=h*f+d*n;k=k*f+l*n;m=m*f+p*n;c=c*f+e*n;f===1-g&&(g=1/Math.sqrt(h*h+k*k+m*m+c*c),h*=g,k*=g,m*=g,c*=g)}a[b]=h;a[b+1]=k;a[b+2]=m;a[b+3]=c}});Object.defineProperties(ka.prototype,{x:{get:function(){return this._x}, set:function(a){this._x=a;this.onChangeCallback()}},y:{get:function(){return this._y},set:function(a){this._y=a;this.onChangeCallback()}},z:{get:function(){return this._z},set:function(a){this._z=a;this.onChangeCallback()}},w:{get:function(){return this._w},set:function(a){this._w=a;this.onChangeCallback()}}});Object.assign(ka.prototype,{isQuaternion:!0,set:function(a,b,c,d){this._x=a;this._y=b;this._z=c;this._w=d;this.onChangeCallback();return this},clone:function(){return new this.constructor(this._x, this._y,this._z,this._w)},copy:function(a){this._x=a.x;this._y=a.y;this._z=a.z;this._w=a.w;this.onChangeCallback();return this},setFromEuler:function(a,b){if(!a||!a.isEuler)throw Error(\"THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order.\");var c=a._x,d=a._y,e=a._z;a=a.order;var f=Math.cos,g=Math.sin,h=f(c/2),k=f(d/2);f=f(e/2);c=g(c/2);d=g(d/2);e=g(e/2);\"XYZ\"===a?(this._x=c*k*f+h*d*e,this._y=h*d*f-c*k*e,this._z=h*k*e+c*d*f,this._w=h*k*f-c*d*e):\"YXZ\"===a? (this._x=c*k*f+h*d*e,this._y=h*d*f-c*k*e,this._z=h*k*e-c*d*f,this._w=h*k*f+c*d*e):\"ZXY\"===a?(this._x=c*k*f-h*d*e,this._y=h*d*f+c*k*e,this._z=h*k*e+c*d*f,this._w=h*k*f-c*d*e):\"ZYX\"===a?(this._x=c*k*f-h*d*e,this._y=h*d*f+c*k*e,this._z=h*k*e-c*d*f,this._w=h*k*f+c*d*e):\"YZX\"===a?(this._x=c*k*f+h*d*e,this._y=h*d*f+c*k*e,this._z=h*k*e-c*d*f,this._w=h*k*f-c*d*e):\"XZY\"===a&&(this._x=c*k*f-h*d*e,this._y=h*d*f-c*k*e,this._z=h*k*e+c*d*f,this._w=h*k*f+c*d*e);if(!1!==b)this.onChangeCallback();return this},setFromAxisAngle:function(a, b){b/=2;var c=Math.sin(b);this._x=a.x*c;this._y=a.y*c;this._z=a.z*c;this._w=Math.cos(b);this.onChangeCallback();return this},setFromRotationMatrix:function(a){var b=a.elements,c=b[0];a=b[4];var d=b[8],e=b[1],f=b[5],g=b[9],h=b[2],k=b[6];b=b[10];var m=c+f+b;0f&&c>b?(c=2*Math.sqrt(1+c-f-b),this._w=(k-g)/c,this._x=.25*c,this._y=(a+e)/c,this._z=(d+h)/c):f>b?(c=2*Math.sqrt(1+f-c-b),this._w=(d-h)/c,this._x=(a+e)/c,this._y= .25*c,this._z=(g+k)/c):(c=2*Math.sqrt(1+b-c-f),this._w=(e-a)/c,this._x=(d+h)/c,this._y=(g+k)/c,this._z=.25*c);this.onChangeCallback();return this},setFromUnitVectors:function(){var a=new n,b;return function(c,d){void 0===a&&(a=new n);b=c.dot(d)+1;1E-6>b?(b=0,Math.abs(c.x)>Math.abs(c.z)?a.set(-c.y,c.x,0):a.set(0,-c.z,c.y)):a.crossVectors(c,d);this._x=a.x;this._y=a.y;this._z=a.z;this._w=b;return this.normalize()}}(),angleTo:function(a){return 2*Math.acos(Math.abs(G.clamp(this.dot(a),-1,1)))},rotateTowards:function(a, b){var c=this.angleTo(a);if(0===c)return this;this.slerp(a,Math.min(1,b/c));return this},inverse:function(){return this.conjugate()},conjugate:function(){this._x*=-1;this._y*=-1;this._z*=-1;this.onChangeCallback();return this},dot:function(a){return this._x*a._x+this._y*a._y+this._z*a._z+this._w*a._w},lengthSq:function(){return this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w},length:function(){return Math.sqrt(this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w)},normalize:function(){var a= this.length();0===a?(this._z=this._y=this._x=0,this._w=1):(a=1/a,this._x*=a,this._y*=a,this._z*=a,this._w*=a);this.onChangeCallback();return this},multiply:function(a,b){return void 0!==b?(console.warn(\"THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead.\"),this.multiplyQuaternions(a,b)):this.multiplyQuaternions(this,a)},premultiply:function(a){return this.multiplyQuaternions(a,this)},multiplyQuaternions:function(a,b){var c=a._x,d=a._y,e=a._z;a=a._w; var f=b._x,g=b._y,h=b._z;b=b._w;this._x=c*b+a*f+d*h-e*g;this._y=d*b+a*g+e*f-c*h;this._z=e*b+a*h+c*g-d*f;this._w=a*b-c*f-d*g-e*h;this.onChangeCallback();return this},slerp:function(a,b){if(0===b)return this;if(1===b)return this.copy(a);var c=this._x,d=this._y,e=this._z,f=this._w,g=f*a._w+c*a._x+d*a._y+e*a._z;0>g?(this._w=-a._w,this._x=-a._x,this._y=-a._y,this._z=-a._z,g=-g):this.copy(a);if(1","categories":[],"tags":[]},{"title":"","slug":"Three.js移动DecalGeometry/js/three","date":"2019-03-17T10:06:35.712Z","updated":"2019-03-17T10:06:35.712Z","comments":true,"path":"2019/03/17/cjtcra7kn000hh1l3b8legr0w/","link":"","permalink":"http://www.zcating.tk/2019/03/17/cjtcra7kn000hh1l3b8legr0w/","excerpt":"","text":"(function (global, factory) { typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) : typeof define === 'function' && define.amd ? define(['exports'], factory) : (global = global || self, factory(global.THREE = {})); }(this, function (exports) { 'use strict'; // Polyfills if ( Number.EPSILON === undefined ) { Number.EPSILON = Math.pow( 2, - 52 ); } if ( Number.isInteger === undefined ) { // Missing in IE // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/isInteger Number.isInteger = function ( value ) { return typeof value === 'number' && isFinite( value ) && Math.floor( value ) === value; }; } // if ( Math.sign === undefined ) { // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/sign Math.sign = function ( x ) { return ( x < 0 ) ? - 1 : ( x > 0 ) ? 1 : + x; }; } if ( 'name' in Function.prototype === false ) { // Missing in IE // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/name Object.defineProperty( Function.prototype, 'name', { get: function () { return this.toString().match( /^\\s*function\\s*([^\\(\\s]*)/ )[ 1 ]; } } ); } if ( Object.assign === undefined ) { // Missing in IE // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/assign ( function () { Object.assign = function ( target ) { if ( target === undefined || target === null ) { throw new TypeError( 'Cannot convert undefined or null to object' ); } var output = Object( target ); for ( var index = 1; index < arguments.length; index ++ ) { var source = arguments[ index ]; if ( source !== undefined && source !== null ) { for ( var nextKey in source ) { if ( Object.prototype.hasOwnProperty.call( source, nextKey ) ) { output[ nextKey ] = source[ nextKey ]; } } } } return output; }; } )(); } /** * https://github.com/mrdoob/eventdispatcher.js/ */ function EventDispatcher() {} Object.assign( EventDispatcher.prototype, { addEventListener: function ( type, listener ) { if ( this._listeners === undefined ) this._listeners = {}; var listeners = this._listeners; if ( listeners[ type ] === undefined ) { listeners[ type ] = []; } if ( listeners[ type ].indexOf( listener ) === - 1 ) { listeners[ type ].push( listener ); } }, hasEventListener: function ( type, listener ) { if ( this._listeners === undefined ) return false; var listeners = this._listeners; return listeners[ type ] !== undefined && listeners[ type ].indexOf( listener ) !== - 1; }, removeEventListener: function ( type, listener ) { if ( this._listeners === undefined ) return; var listeners = this._listeners; var listenerArray = listeners[ type ]; if ( listenerArray !== undefined ) { var index = listenerArray.indexOf( listener ); if ( index !== - 1 ) { listenerArray.splice( index, 1 ); } } }, dispatchEvent: function ( event ) { if ( this._listeners === undefined ) return; var listeners = this._listeners; var listenerArray = listeners[ event.type ]; if ( listenerArray !== undefined ) { event.target = this; var array = listenerArray.slice( 0 ); for ( var i = 0, l = array.length; i < l; i ++ ) { array[ i ].call( this, event ); } } } } ); var REVISION = '102dev'; var MOUSE = { LEFT: 0, MIDDLE: 1, RIGHT: 2 }; var CullFaceNone = 0; var CullFaceBack = 1; var CullFaceFront = 2; var CullFaceFrontBack = 3; var FrontFaceDirectionCW = 0; var FrontFaceDirectionCCW = 1; var BasicShadowMap = 0; var PCFShadowMap = 1; var PCFSoftShadowMap = 2; var FrontSide = 0; var BackSide = 1; var DoubleSide = 2; var FlatShading = 1; var SmoothShading = 2; var NoColors = 0; var FaceColors = 1; var VertexColors = 2; var NoBlending = 0; var NormalBlending = 1; var AdditiveBlending = 2; var SubtractiveBlending = 3; var MultiplyBlending = 4; var CustomBlending = 5; var AddEquation = 100; var SubtractEquation = 101; var ReverseSubtractEquation = 102; var MinEquation = 103; var MaxEquation = 104; var ZeroFactor = 200; var OneFactor = 201; var SrcColorFactor = 202; var OneMinusSrcColorFactor = 203; var SrcAlphaFactor = 204; var OneMinusSrcAlphaFactor = 205; var DstAlphaFactor = 206; var OneMinusDstAlphaFactor = 207; var DstColorFactor = 208; var OneMinusDstColorFactor = 209; var SrcAlphaSaturateFactor = 210; var NeverDepth = 0; var AlwaysDepth = 1; var LessDepth = 2; var LessEqualDepth = 3; var EqualDepth = 4; var GreaterEqualDepth = 5; var GreaterDepth = 6; var NotEqualDepth = 7; var MultiplyOperation = 0; var MixOperation = 1; var AddOperation = 2; var NoToneMapping = 0; var LinearToneMapping = 1; var ReinhardToneMapping = 2; var Uncharted2ToneMapping = 3; var CineonToneMapping = 4; var ACESFilmicToneMapping = 5; var UVMapping = 300; var CubeReflectionMapping = 301; var CubeRefractionMapping = 302; var EquirectangularReflectionMapping = 303; var EquirectangularRefractionMapping = 304; var SphericalReflectionMapping = 305; var CubeUVReflectionMapping = 306; var CubeUVRefractionMapping = 307; var RepeatWrapping = 1000; var ClampToEdgeWrapping = 1001; var MirroredRepeatWrapping = 1002; var NearestFilter = 1003; var NearestMipMapNearestFilter = 1004; var NearestMipMapLinearFilter = 1005; var LinearFilter = 1006; var LinearMipMapNearestFilter = 1007; var LinearMipMapLinearFilter = 1008; var UnsignedByteType = 1009; var ByteType = 1010; var ShortType = 1011; var UnsignedShortType = 1012; var IntType = 1013; var UnsignedIntType = 1014; var FloatType = 1015; var HalfFloatType = 1016; var UnsignedShort4444Type = 1017; var UnsignedShort5551Type = 1018; var UnsignedShort565Type = 1019; var UnsignedInt248Type = 1020; var AlphaFormat = 1021; var RGBFormat = 1022; var RGBAFormat = 1023; var LuminanceFormat = 1024; var LuminanceAlphaFormat = 1025; var RGBEFormat = RGBAFormat; var DepthFormat = 1026; var DepthStencilFormat = 1027; var RedFormat = 1028; var RGB_S3TC_DXT1_Format = 33776; var RGBA_S3TC_DXT1_Format = 33777; var RGBA_S3TC_DXT3_Format = 33778; var RGBA_S3TC_DXT5_Format = 33779; var RGB_PVRTC_4BPPV1_Format = 35840; var RGB_PVRTC_2BPPV1_Format = 35841; var RGBA_PVRTC_4BPPV1_Format = 35842; var RGBA_PVRTC_2BPPV1_Format = 35843; var RGB_ETC1_Format = 36196; var RGBA_ASTC_4x4_Format = 37808; var RGBA_ASTC_5x4_Format = 37809; var RGBA_ASTC_5x5_Format = 37810; var RGBA_ASTC_6x5_Format = 37811; var RGBA_ASTC_6x6_Format = 37812; var RGBA_ASTC_8x5_Format = 37813; var RGBA_ASTC_8x6_Format = 37814; var RGBA_ASTC_8x8_Format = 37815; var RGBA_ASTC_10x5_Format = 37816; var RGBA_ASTC_10x6_Format = 37817; var RGBA_ASTC_10x8_Format = 37818; var RGBA_ASTC_10x10_Format = 37819; var RGBA_ASTC_12x10_Format = 37820; var RGBA_ASTC_12x12_Format = 37821; var LoopOnce = 2200; var LoopRepeat = 2201; var LoopPingPong = 2202; var InterpolateDiscrete = 2300; var InterpolateLinear = 2301; var InterpolateSmooth = 2302; var ZeroCurvatureEnding = 2400; var ZeroSlopeEnding = 2401; var WrapAroundEnding = 2402; var TrianglesDrawMode = 0; var TriangleStripDrawMode = 1; var TriangleFanDrawMode = 2; var LinearEncoding = 3000; var sRGBEncoding = 3001; var GammaEncoding = 3007; var RGBEEncoding = 3002; var LogLuvEncoding = 3003; var RGBM7Encoding = 3004; var RGBM16Encoding = 3005; var RGBDEncoding = 3006; var BasicDepthPacking = 3200; var RGBADepthPacking = 3201; var TangentSpaceNormalMap = 0; var ObjectSpaceNormalMap = 1; /** * @author alteredq / http://alteredqualia.com/ * @author mrdoob / http://mrdoob.com/ */ var _Math = { DEG2RAD: Math.PI / 180, RAD2DEG: 180 / Math.PI, generateUUID: ( function () { // http://stackoverflow.com/questions/105034/how-to-create-a-guid-uuid-in-javascript/21963136#21963136 var lut = []; for ( var i = 0; i < 256; i ++ ) { lut[ i ] = ( i < 16 ? '0' : '' ) + ( i ).toString( 16 ); } return function generateUUID() { var d0 = Math.random() * 0xffffffff | 0; var d1 = Math.random() * 0xffffffff | 0; var d2 = Math.random() * 0xffffffff | 0; var d3 = Math.random() * 0xffffffff | 0; var uuid = lut[ d0 & 0xff ] + lut[ d0 >> 8 & 0xff ] + lut[ d0 >> 16 & 0xff ] + lut[ d0 >> 24 & 0xff ] + '-' + lut[ d1 & 0xff ] + lut[ d1 >> 8 & 0xff ] + '-' + lut[ d1 >> 16 & 0x0f | 0x40 ] + lut[ d1 >> 24 & 0xff ] + '-' + lut[ d2 & 0x3f | 0x80 ] + lut[ d2 >> 8 & 0xff ] + '-' + lut[ d2 >> 16 & 0xff ] + lut[ d2 >> 24 & 0xff ] + lut[ d3 & 0xff ] + lut[ d3 >> 8 & 0xff ] + lut[ d3 >> 16 & 0xff ] + lut[ d3 >> 24 & 0xff ]; // .toUpperCase() here flattens concatenated strings to save heap memory space. return uuid.toUpperCase(); }; } )(), clamp: function ( value, min, max ) { return Math.max( min, Math.min( max, value ) ); }, // compute euclidian modulo of m % n // https://en.wikipedia.org/wiki/Modulo_operation euclideanModulo: function ( n, m ) { return ( ( n % m ) + m ) % m; }, // Linear mapping from range to range mapLinear: function ( x, a1, a2, b1, b2 ) { return b1 + ( x - a1 ) * ( b2 - b1 ) / ( a2 - a1 ); }, // https://en.wikipedia.org/wiki/Linear_interpolation lerp: function ( x, y, t ) { return ( 1 - t ) * x + t * y; }, // http://en.wikipedia.org/wiki/Smoothstep smoothstep: function ( x, min, max ) { if ( x = max ) return 1; x = ( x - min ) / ( max - min ); return x * x * ( 3 - 2 * x ); }, smootherstep: function ( x, min, max ) { if ( x = max ) return 1; x = ( x - min ) / ( max - min ); return x * x * x * ( x * ( x * 6 - 15 ) + 10 ); }, // Random integer from interval randInt: function ( low, high ) { return low + Math.floor( Math.random() * ( high - low + 1 ) ); }, // Random float from interval randFloat: function ( low, high ) { return low + Math.random() * ( high - low ); }, // Random float from interval randFloatSpread: function ( range ) { return range * ( 0.5 - Math.random() ); }, degToRad: function ( degrees ) { return degrees * _Math.DEG2RAD; }, radToDeg: function ( radians ) { return radians * _Math.RAD2DEG; }, isPowerOfTwo: function ( value ) { return ( value & ( value - 1 ) ) === 0 && value !== 0; }, ceilPowerOfTwo: function ( value ) { return Math.pow( 2, Math.ceil( Math.log( value ) / Math.LN2 ) ); }, floorPowerOfTwo: function ( value ) { return Math.pow( 2, Math.floor( Math.log( value ) / Math.LN2 ) ); } }; /** * @author mrdoob / http://mrdoob.com/ * @author philogb / http://blog.thejit.org/ * @author egraether / http://egraether.com/ * @author zz85 / http://www.lab4games.net/zz85/blog */ function Vector2( x, y ) { this.x = x || 0; this.y = y || 0; } Object.defineProperties( Vector2.prototype, { \"width\": { get: function () { return this.x; }, set: function ( value ) { this.x = value; } }, \"height\": { get: function () { return this.y; }, set: function ( value ) { this.y = value; } } } ); Object.assign( Vector2.prototype, { isVector2: true, set: function ( x, y ) { this.x = x; this.y = y; return this; }, setScalar: function ( scalar ) { this.x = scalar; this.y = scalar; return this; }, setX: function ( x ) { this.x = x; return this; }, setY: function ( y ) { this.y = y; return this; }, setComponent: function ( index, value ) { switch ( index ) { case 0: this.x = value; break; case 1: this.y = value; break; default: throw new Error( 'index is out of range: ' + index ); } return this; }, getComponent: function ( index ) { switch ( index ) { case 0: return this.x; case 1: return this.y; default: throw new Error( 'index is out of range: ' + index ); } }, clone: function () { return new this.constructor( this.x, this.y ); }, copy: function ( v ) { this.x = v.x; this.y = v.y; return this; }, add: function ( v, w ) { if ( w !== undefined ) { console.warn( 'THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead.' ); return this.addVectors( v, w ); } this.x += v.x; this.y += v.y; return this; }, addScalar: function ( s ) { this.x += s; this.y += s; return this; }, addVectors: function ( a, b ) { this.x = a.x + b.x; this.y = a.y + b.y; return this; }, addScaledVector: function ( v, s ) { this.x += v.x * s; this.y += v.y * s; return this; }, sub: function ( v, w ) { if ( w !== undefined ) { console.warn( 'THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.' ); return this.subVectors( v, w ); } this.x -= v.x; this.y -= v.y; return this; }, subScalar: function ( s ) { this.x -= s; this.y -= s; return this; }, subVectors: function ( a, b ) { this.x = a.x - b.x; this.y = a.y - b.y; return this; }, multiply: function ( v ) { this.x *= v.x; this.y *= v.y; return this; }, multiplyScalar: function ( scalar ) { this.x *= scalar; this.y *= scalar; return this; }, divide: function ( v ) { this.x /= v.x; this.y /= v.y; return this; }, divideScalar: function ( scalar ) { return this.multiplyScalar( 1 / scalar ); }, applyMatrix3: function ( m ) { var x = this.x, y = this.y; var e = m.elements; this.x = e[ 0 ] * x + e[ 3 ] * y + e[ 6 ]; this.y = e[ 1 ] * x + e[ 4 ] * y + e[ 7 ]; return this; }, min: function ( v ) { this.x = Math.min( this.x, v.x ); this.y = Math.min( this.y, v.y ); return this; }, max: function ( v ) { this.x = Math.max( this.x, v.x ); this.y = Math.max( this.y, v.y ); return this; }, clamp: function ( min, max ) { // assumes min < max, componentwise this.x = Math.max( min.x, Math.min( max.x, this.x ) ); this.y = Math.max( min.y, Math.min( max.y, this.y ) ); return this; }, clampScalar: function () { var min = new Vector2(); var max = new Vector2(); return function clampScalar( minVal, maxVal ) { min.set( minVal, minVal ); max.set( maxVal, maxVal ); return this.clamp( min, max ); }; }(), clampLength: function ( min, max ) { var length = this.length(); return this.divideScalar( length || 1 ).multiplyScalar( Math.max( min, Math.min( max, length ) ) ); }, floor: function () { this.x = Math.floor( this.x ); this.y = Math.floor( this.y ); return this; }, ceil: function () { this.x = Math.ceil( this.x ); this.y = Math.ceil( this.y ); return this; }, round: function () { this.x = Math.round( this.x ); this.y = Math.round( this.y ); return this; }, roundToZero: function () { this.x = ( this.x < 0 ) ? Math.ceil( this.x ) : Math.floor( this.x ); this.y = ( this.y < 0 ) ? Math.ceil( this.y ) : Math.floor( this.y ); return this; }, negate: function () { this.x = - this.x; this.y = - this.y; return this; }, dot: function ( v ) { return this.x * v.x + this.y * v.y; }, cross: function ( v ) { return this.x * v.y - this.y * v.x; }, lengthSq: function () { return this.x * this.x + this.y * this.y; }, length: function () { return Math.sqrt( this.x * this.x + this.y * this.y ); }, manhattanLength: function () { return Math.abs( this.x ) + Math.abs( this.y ); }, normalize: function () { return this.divideScalar( this.length() || 1 ); }, angle: function () { // computes the angle in radians with respect to the positive x-axis var angle = Math.atan2( this.y, this.x ); if ( angle < 0 ) angle += 2 * Math.PI; return angle; }, distanceTo: function ( v ) { return Math.sqrt( this.distanceToSquared( v ) ); }, distanceToSquared: function ( v ) { var dx = this.x - v.x, dy = this.y - v.y; return dx * dx + dy * dy; }, manhattanDistanceTo: function ( v ) { return Math.abs( this.x - v.x ) + Math.abs( this.y - v.y ); }, setLength: function ( length ) { return this.normalize().multiplyScalar( length ); }, lerp: function ( v, alpha ) { this.x += ( v.x - this.x ) * alpha; this.y += ( v.y - this.y ) * alpha; return this; }, lerpVectors: function ( v1, v2, alpha ) { return this.subVectors( v2, v1 ).multiplyScalar( alpha ).add( v1 ); }, equals: function ( v ) { return ( ( v.x === this.x ) && ( v.y === this.y ) ); }, fromArray: function ( array, offset ) { if ( offset === undefined ) offset = 0; this.x = array[ offset ]; this.y = array[ offset + 1 ]; return this; }, toArray: function ( array, offset ) { if ( array === undefined ) array = []; if ( offset === undefined ) offset = 0; array[ offset ] = this.x; array[ offset + 1 ] = this.y; return array; }, fromBufferAttribute: function ( attribute, index, offset ) { if ( offset !== undefined ) { console.warn( 'THREE.Vector2: offset has been removed from .fromBufferAttribute().' ); } this.x = attribute.getX( index ); this.y = attribute.getY( index ); return this; }, rotateAround: function ( center, angle ) { var c = Math.cos( angle ), s = Math.sin( angle ); var x = this.x - center.x; var y = this.y - center.y; this.x = x * c - y * s + center.x; this.y = x * s + y * c + center.y; return this; } } ); /** * @author mrdoob / http://mrdoob.com/ * @author supereggbert / http://www.paulbrunt.co.uk/ * @author philogb / http://blog.thejit.org/ * @author jordi_ros / http://plattsoft.com * @author D1plo1d / http://github.com/D1plo1d * @author alteredq / http://alteredqualia.com/ * @author mikael emtinger / http://gomo.se/ * @author timknip / http://www.floorplanner.com/ * @author bhouston / http://clara.io * @author WestLangley / http://github.com/WestLangley */ function Matrix4() { this.elements = [ 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1 ]; if ( arguments.length > 0 ) { console.error( 'THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.' ); } } Object.assign( Matrix4.prototype, { isMatrix4: true, set: function ( n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44 ) { var te = this.elements; te[ 0 ] = n11; te[ 4 ] = n12; te[ 8 ] = n13; te[ 12 ] = n14; te[ 1 ] = n21; te[ 5 ] = n22; te[ 9 ] = n23; te[ 13 ] = n24; te[ 2 ] = n31; te[ 6 ] = n32; te[ 10 ] = n33; te[ 14 ] = n34; te[ 3 ] = n41; te[ 7 ] = n42; te[ 11 ] = n43; te[ 15 ] = n44; return this; }, identity: function () { this.set( 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1 ); return this; }, clone: function () { return new Matrix4().fromArray( this.elements ); }, copy: function ( m ) { var te = this.elements; var me = m.elements; te[ 0 ] = me[ 0 ]; te[ 1 ] = me[ 1 ]; te[ 2 ] = me[ 2 ]; te[ 3 ] = me[ 3 ]; te[ 4 ] = me[ 4 ]; te[ 5 ] = me[ 5 ]; te[ 6 ] = me[ 6 ]; te[ 7 ] = me[ 7 ]; te[ 8 ] = me[ 8 ]; te[ 9 ] = me[ 9 ]; te[ 10 ] = me[ 10 ]; te[ 11 ] = me[ 11 ]; te[ 12 ] = me[ 12 ]; te[ 13 ] = me[ 13 ]; te[ 14 ] = me[ 14 ]; te[ 15 ] = me[ 15 ]; return this; }, copyPosition: function ( m ) { var te = this.elements, me = m.elements; te[ 12 ] = me[ 12 ]; te[ 13 ] = me[ 13 ]; te[ 14 ] = me[ 14 ]; return this; }, extractBasis: function ( xAxis, yAxis, zAxis ) { xAxis.setFromMatrixColumn( this, 0 ); yAxis.setFromMatrixColumn( this, 1 ); zAxis.setFromMatrixColumn( this, 2 ); return this; }, makeBasis: function ( xAxis, yAxis, zAxis ) { this.set( xAxis.x, yAxis.x, zAxis.x, 0, xAxis.y, yAxis.y, zAxis.y, 0, xAxis.z, yAxis.z, zAxis.z, 0, 0, 0, 0, 1 ); return this; }, extractRotation: function () { var v1 = new Vector3(); return function extractRotation( m ) { // this method does not support reflection matrices var te = this.elements; var me = m.elements; var scaleX = 1 / v1.setFromMatrixColumn( m, 0 ).length(); var scaleY = 1 / v1.setFromMatrixColumn( m, 1 ).length(); var scaleZ = 1 / v1.setFromMatrixColumn( m, 2 ).length(); te[ 0 ] = me[ 0 ] * scaleX; te[ 1 ] = me[ 1 ] * scaleX; te[ 2 ] = me[ 2 ] * scaleX; te[ 3 ] = 0; te[ 4 ] = me[ 4 ] * scaleY; te[ 5 ] = me[ 5 ] * scaleY; te[ 6 ] = me[ 6 ] * scaleY; te[ 7 ] = 0; te[ 8 ] = me[ 8 ] * scaleZ; te[ 9 ] = me[ 9 ] * scaleZ; te[ 10 ] = me[ 10 ] * scaleZ; te[ 11 ] = 0; te[ 12 ] = 0; te[ 13 ] = 0; te[ 14 ] = 0; te[ 15 ] = 1; return this; }; }(), makeRotationFromEuler: function ( euler ) { if ( ! ( euler && euler.isEuler ) ) { console.error( 'THREE.Matrix4: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.' ); } var te = this.elements; var x = euler.x, y = euler.y, z = euler.z; var a = Math.cos( x ), b = Math.sin( x ); var c = Math.cos( y ), d = Math.sin( y ); var e = Math.cos( z ), f = Math.sin( z ); if ( euler.order === 'XYZ' ) { var ae = a * e, af = a * f, be = b * e, bf = b * f; te[ 0 ] = c * e; te[ 4 ] = - c * f; te[ 8 ] = d; te[ 1 ] = af + be * d; te[ 5 ] = ae - bf * d; te[ 9 ] = - b * c; te[ 2 ] = bf - ae * d; te[ 6 ] = be + af * d; te[ 10 ] = a * c; } else if ( euler.order === 'YXZ' ) { var ce = c * e, cf = c * f, de = d * e, df = d * f; te[ 0 ] = ce + df * b; te[ 4 ] = de * b - cf; te[ 8 ] = a * d; te[ 1 ] = a * f; te[ 5 ] = a * e; te[ 9 ] = - b; te[ 2 ] = cf * b - de; te[ 6 ] = df + ce * b; te[ 10 ] = a * c; } else if ( euler.order === 'ZXY' ) { var ce = c * e, cf = c * f, de = d * e, df = d * f; te[ 0 ] = ce - df * b; te[ 4 ] = - a * f; te[ 8 ] = de + cf * b; te[ 1 ] = cf + de * b; te[ 5 ] = a * e; te[ 9 ] = df - ce * b; te[ 2 ] = - a * d; te[ 6 ] = b; te[ 10 ] = a * c; } else if ( euler.order === 'ZYX' ) { var ae = a * e, af = a * f, be = b * e, bf = b * f; te[ 0 ] = c * e; te[ 4 ] = be * d - af; te[ 8 ] = ae * d + bf; te[ 1 ] = c * f; te[ 5 ] = bf * d + ae; te[ 9 ] = af * d - be; te[ 2 ] = - d; te[ 6 ] = b * c; te[ 10 ] = a * c; } else if ( euler.order === 'YZX' ) { var ac = a * c, ad = a * d, bc = b * c, bd = b * d; te[ 0 ] = c * e; te[ 4 ] = bd - ac * f; te[ 8 ] = bc * f + ad; te[ 1 ] = f; te[ 5 ] = a * e; te[ 9 ] = - b * e; te[ 2 ] = - d * e; te[ 6 ] = ad * f + bc; te[ 10 ] = ac - bd * f; } else if ( euler.order === 'XZY' ) { var ac = a * c, ad = a * d, bc = b * c, bd = b * d; te[ 0 ] = c * e; te[ 4 ] = - f; te[ 8 ] = d * e; te[ 1 ] = ac * f + bd; te[ 5 ] = a * e; te[ 9 ] = ad * f - bc; te[ 2 ] = bc * f - ad; te[ 6 ] = b * e; te[ 10 ] = bd * f + ac; } // bottom row te[ 3 ] = 0; te[ 7 ] = 0; te[ 11 ] = 0; // last column te[ 12 ] = 0; te[ 13 ] = 0; te[ 14 ] = 0; te[ 15 ] = 1; return this; }, makeRotationFromQuaternion: function () { var zero = new Vector3( 0, 0, 0 ); var one = new Vector3( 1, 1, 1 ); return function makeRotationFromQuaternion( q ) { return this.compose( zero, q, one ); }; }(), lookAt: function () { var x = new Vector3(); var y = new Vector3(); var z = new Vector3(); return function lookAt( eye, target, up ) { var te = this.elements; z.subVectors( eye, target ); if ( z.lengthSq() === 0 ) { // eye and target are in the same position z.z = 1; } z.normalize(); x.crossVectors( up, z ); if ( x.lengthSq() === 0 ) { // up and z are parallel if ( Math.abs( up.z ) === 1 ) { z.x += 0.0001; } else { z.z += 0.0001; } z.normalize(); x.crossVectors( up, z ); } x.normalize(); y.crossVectors( z, x ); te[ 0 ] = x.x; te[ 4 ] = y.x; te[ 8 ] = z.x; te[ 1 ] = x.y; te[ 5 ] = y.y; te[ 9 ] = z.y; te[ 2 ] = x.z; te[ 6 ] = y.z; te[ 10 ] = z.z; return this; }; }(), multiply: function ( m, n ) { if ( n !== undefined ) { console.warn( 'THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead.' ); return this.multiplyMatrices( m, n ); } return this.multiplyMatrices( this, m ); }, premultiply: function ( m ) { return this.multiplyMatrices( m, this ); }, multiplyMatrices: function ( a, b ) { var ae = a.elements; var be = b.elements; var te = this.elements; var a11 = ae[ 0 ], a12 = ae[ 4 ], a13 = ae[ 8 ], a14 = ae[ 12 ]; var a21 = ae[ 1 ], a22 = ae[ 5 ], a23 = ae[ 9 ], a24 = ae[ 13 ]; var a31 = ae[ 2 ], a32 = ae[ 6 ], a33 = ae[ 10 ], a34 = ae[ 14 ]; var a41 = ae[ 3 ], a42 = ae[ 7 ], a43 = ae[ 11 ], a44 = ae[ 15 ]; var b11 = be[ 0 ], b12 = be[ 4 ], b13 = be[ 8 ], b14 = be[ 12 ]; var b21 = be[ 1 ], b22 = be[ 5 ], b23 = be[ 9 ], b24 = be[ 13 ]; var b31 = be[ 2 ], b32 = be[ 6 ], b33 = be[ 10 ], b34 = be[ 14 ]; var b41 = be[ 3 ], b42 = be[ 7 ], b43 = be[ 11 ], b44 = be[ 15 ]; te[ 0 ] = a11 * b11 + a12 * b21 + a13 * b31 + a14 * b41; te[ 4 ] = a11 * b12 + a12 * b22 + a13 * b32 + a14 * b42; te[ 8 ] = a11 * b13 + a12 * b23 + a13 * b33 + a14 * b43; te[ 12 ] = a11 * b14 + a12 * b24 + a13 * b34 + a14 * b44; te[ 1 ] = a21 * b11 + a22 * b21 + a23 * b31 + a24 * b41; te[ 5 ] = a21 * b12 + a22 * b22 + a23 * b32 + a24 * b42; te[ 9 ] = a21 * b13 + a22 * b23 + a23 * b33 + a24 * b43; te[ 13 ] = a21 * b14 + a22 * b24 + a23 * b34 + a24 * b44; te[ 2 ] = a31 * b11 + a32 * b21 + a33 * b31 + a34 * b41; te[ 6 ] = a31 * b12 + a32 * b22 + a33 * b32 + a34 * b42; te[ 10 ] = a31 * b13 + a32 * b23 + a33 * b33 + a34 * b43; te[ 14 ] = a31 * b14 + a32 * b24 + a33 * b34 + a34 * b44; te[ 3 ] = a41 * b11 + a42 * b21 + a43 * b31 + a44 * b41; te[ 7 ] = a41 * b12 + a42 * b22 + a43 * b32 + a44 * b42; te[ 11 ] = a41 * b13 + a42 * b23 + a43 * b33 + a44 * b43; te[ 15 ] = a41 * b14 + a42 * b24 + a43 * b34 + a44 * b44; return this; }, multiplyScalar: function ( s ) { var te = this.elements; te[ 0 ] *= s; te[ 4 ] *= s; te[ 8 ] *= s; te[ 12 ] *= s; te[ 1 ] *= s; te[ 5 ] *= s; te[ 9 ] *= s; te[ 13 ] *= s; te[ 2 ] *= s; te[ 6 ] *= s; te[ 10 ] *= s; te[ 14 ] *= s; te[ 3 ] *= s; te[ 7 ] *= s; te[ 11 ] *= s; te[ 15 ] *= s; return this; }, applyToBufferAttribute: function () { var v1 = new Vector3(); return function applyToBufferAttribute( attribute ) { for ( var i = 0, l = attribute.count; i < l; i ++ ) { v1.x = attribute.getX( i ); v1.y = attribute.getY( i ); v1.z = attribute.getZ( i ); v1.applyMatrix4( this ); attribute.setXYZ( i, v1.x, v1.y, v1.z ); } return attribute; }; }(), determinant: function () { var te = this.elements; var n11 = te[ 0 ], n12 = te[ 4 ], n13 = te[ 8 ], n14 = te[ 12 ]; var n21 = te[ 1 ], n22 = te[ 5 ], n23 = te[ 9 ], n24 = te[ 13 ]; var n31 = te[ 2 ], n32 = te[ 6 ], n33 = te[ 10 ], n34 = te[ 14 ]; var n41 = te[ 3 ], n42 = te[ 7 ], n43 = te[ 11 ], n44 = te[ 15 ]; //TODO: make this more efficient //( based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm ) return ( n41 * ( + n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34 ) + n42 * ( + n11 * n23 * n34 - n11 * n24 * n33 + n14 * n21 * n33 - n13 * n21 * n34 + n13 * n24 * n31 - n14 * n23 * n31 ) + n43 * ( + n11 * n24 * n32 - n11 * n22 * n34 - n14 * n21 * n32 + n12 * n21 * n34 + n14 * n22 * n31 - n12 * n24 * n31 ) + n44 * ( - n13 * n22 * n31 - n11 * n23 * n32 + n11 * n22 * n33 + n13 * n21 * n32 - n12 * n21 * n33 + n12 * n23 * n31 ) ); }, transpose: function () { var te = this.elements; var tmp; tmp = te[ 1 ]; te[ 1 ] = te[ 4 ]; te[ 4 ] = tmp; tmp = te[ 2 ]; te[ 2 ] = te[ 8 ]; te[ 8 ] = tmp; tmp = te[ 6 ]; te[ 6 ] = te[ 9 ]; te[ 9 ] = tmp; tmp = te[ 3 ]; te[ 3 ] = te[ 12 ]; te[ 12 ] = tmp; tmp = te[ 7 ]; te[ 7 ] = te[ 13 ]; te[ 13 ] = tmp; tmp = te[ 11 ]; te[ 11 ] = te[ 14 ]; te[ 14 ] = tmp; return this; }, setPosition: function ( v ) { var te = this.elements; te[ 12 ] = v.x; te[ 13 ] = v.y; te[ 14 ] = v.z; return this; }, getInverse: function ( m, throwOnDegenerate ) { // based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm var te = this.elements, me = m.elements, n11 = me[ 0 ], n21 = me[ 1 ], n31 = me[ 2 ], n41 = me[ 3 ], n12 = me[ 4 ], n22 = me[ 5 ], n32 = me[ 6 ], n42 = me[ 7 ], n13 = me[ 8 ], n23 = me[ 9 ], n33 = me[ 10 ], n43 = me[ 11 ], n14 = me[ 12 ], n24 = me[ 13 ], n34 = me[ 14 ], n44 = me[ 15 ], t11 = n23 * n34 * n42 - n24 * n33 * n42 + n24 * n32 * n43 - n22 * n34 * n43 - n23 * n32 * n44 + n22 * n33 * n44, t12 = n14 * n33 * n42 - n13 * n34 * n42 - n14 * n32 * n43 + n12 * n34 * n43 + n13 * n32 * n44 - n12 * n33 * n44, t13 = n13 * n24 * n42 - n14 * n23 * n42 + n14 * n22 * n43 - n12 * n24 * n43 - n13 * n22 * n44 + n12 * n23 * n44, t14 = n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34; var det = n11 * t11 + n21 * t12 + n31 * t13 + n41 * t14; if ( det === 0 ) { var msg = \"THREE.Matrix4: .getInverse() can't invert matrix, determinant is 0\"; if ( throwOnDegenerate === true ) { throw new Error( msg ); } else { console.warn( msg ); } return this.identity(); } var detInv = 1 / det; te[ 0 ] = t11 * detInv; te[ 1 ] = ( n24 * n33 * n41 - n23 * n34 * n41 - n24 * n31 * n43 + n21 * n34 * n43 + n23 * n31 * n44 - n21 * n33 * n44 ) * detInv; te[ 2 ] = ( n22 * n34 * n41 - n24 * n32 * n41 + n24 * n31 * n42 - n21 * n34 * n42 - n22 * n31 * n44 + n21 * n32 * n44 ) * detInv; te[ 3 ] = ( n23 * n32 * n41 - n22 * n33 * n41 - n23 * n31 * n42 + n21 * n33 * n42 + n22 * n31 * n43 - n21 * n32 * n43 ) * detInv; te[ 4 ] = t12 * detInv; te[ 5 ] = ( n13 * n34 * n41 - n14 * n33 * n41 + n14 * n31 * n43 - n11 * n34 * n43 - n13 * n31 * n44 + n11 * n33 * n44 ) * detInv; te[ 6 ] = ( n14 * n32 * n41 - n12 * n34 * n41 - n14 * n31 * n42 + n11 * n34 * n42 + n12 * n31 * n44 - n11 * n32 * n44 ) * detInv; te[ 7 ] = ( n12 * n33 * n41 - n13 * n32 * n41 + n13 * n31 * n42 - n11 * n33 * n42 - n12 * n31 * n43 + n11 * n32 * n43 ) * detInv; te[ 8 ] = t13 * detInv; te[ 9 ] = ( n14 * n23 * n41 - n13 * n24 * n41 - n14 * n21 * n43 + n11 * n24 * n43 + n13 * n21 * n44 - n11 * n23 * n44 ) * detInv; te[ 10 ] = ( n12 * n24 * n41 - n14 * n22 * n41 + n14 * n21 * n42 - n11 * n24 * n42 - n12 * n21 * n44 + n11 * n22 * n44 ) * detInv; te[ 11 ] = ( n13 * n22 * n41 - n12 * n23 * n41 - n13 * n21 * n42 + n11 * n23 * n42 + n12 * n21 * n43 - n11 * n22 * n43 ) * detInv; te[ 12 ] = t14 * detInv; te[ 13 ] = ( n13 * n24 * n31 - n14 * n23 * n31 + n14 * n21 * n33 - n11 * n24 * n33 - n13 * n21 * n34 + n11 * n23 * n34 ) * detInv; te[ 14 ] = ( n14 * n22 * n31 - n12 * n24 * n31 - n14 * n21 * n32 + n11 * n24 * n32 + n12 * n21 * n34 - n11 * n22 * n34 ) * detInv; te[ 15 ] = ( n12 * n23 * n31 - n13 * n22 * n31 + n13 * n21 * n32 - n11 * n23 * n32 - n12 * n21 * n33 + n11 * n22 * n33 ) * detInv; return this; }, scale: function ( v ) { var te = this.elements; var x = v.x, y = v.y, z = v.z; te[ 0 ] *= x; te[ 4 ] *= y; te[ 8 ] *= z; te[ 1 ] *= x; te[ 5 ] *= y; te[ 9 ] *= z; te[ 2 ] *= x; te[ 6 ] *= y; te[ 10 ] *= z; te[ 3 ] *= x; te[ 7 ] *= y; te[ 11 ] *= z; return this; }, getMaxScaleOnAxis: function () { var te = this.elements; var scaleXSq = te[ 0 ] * te[ 0 ] + te[ 1 ] * te[ 1 ] + te[ 2 ] * te[ 2 ]; var scaleYSq = te[ 4 ] * te[ 4 ] + te[ 5 ] * te[ 5 ] + te[ 6 ] * te[ 6 ]; var scaleZSq = te[ 8 ] * te[ 8 ] + te[ 9 ] * te[ 9 ] + te[ 10 ] * te[ 10 ]; return Math.sqrt( Math.max( scaleXSq, scaleYSq, scaleZSq ) ); }, makeTranslation: function ( x, y, z ) { this.set( 1, 0, 0, x, 0, 1, 0, y, 0, 0, 1, z, 0, 0, 0, 1 ); return this; }, makeRotationX: function ( theta ) { var c = Math.cos( theta ), s = Math.sin( theta ); this.set( 1, 0, 0, 0, 0, c, - s, 0, 0, s, c, 0, 0, 0, 0, 1 ); return this; }, makeRotationY: function ( theta ) { var c = Math.cos( theta ), s = Math.sin( theta ); this.set( c, 0, s, 0, 0, 1, 0, 0, - s, 0, c, 0, 0, 0, 0, 1 ); return this; }, makeRotationZ: function ( theta ) { var c = Math.cos( theta ), s = Math.sin( theta ); this.set( c, - s, 0, 0, s, c, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1 ); return this; }, makeRotationAxis: function ( axis, angle ) { // Based on http://www.gamedev.net/reference/articles/article1199.asp var c = Math.cos( angle ); var s = Math.sin( angle ); var t = 1 - c; var x = axis.x, y = axis.y, z = axis.z; var tx = t * x, ty = t * y; this.set( tx * x + c, tx * y - s * z, tx * z + s * y, 0, tx * y + s * z, ty * y + c, ty * z - s * x, 0, tx * z - s * y, ty * z + s * x, t * z * z + c, 0, 0, 0, 0, 1 ); return this; }, makeScale: function ( x, y, z ) { this.set( x, 0, 0, 0, 0, y, 0, 0, 0, 0, z, 0, 0, 0, 0, 1 ); return this; }, makeShear: function ( x, y, z ) { this.set( 1, y, z, 0, x, 1, z, 0, x, y, 1, 0, 0, 0, 0, 1 ); return this; }, compose: function ( position, quaternion, scale ) { var te = this.elements; var x = quaternion._x, y = quaternion._y, z = quaternion._z, w = quaternion._w; var x2 = x + x, y2 = y + y, z2 = z + z; var xx = x * x2, xy = x * y2, xz = x * z2; var yy = y * y2, yz = y * z2, zz = z * z2; var wx = w * x2, wy = w * y2, wz = w * z2; var sx = scale.x, sy = scale.y, sz = scale.z; te[ 0 ] = ( 1 - ( yy + zz ) ) * sx; te[ 1 ] = ( xy + wz ) * sx; te[ 2 ] = ( xz - wy ) * sx; te[ 3 ] = 0; te[ 4 ] = ( xy - wz ) * sy; te[ 5 ] = ( 1 - ( xx + zz ) ) * sy; te[ 6 ] = ( yz + wx ) * sy; te[ 7 ] = 0; te[ 8 ] = ( xz + wy ) * sz; te[ 9 ] = ( yz - wx ) * sz; te[ 10 ] = ( 1 - ( xx + yy ) ) * sz; te[ 11 ] = 0; te[ 12 ] = position.x; te[ 13 ] = position.y; te[ 14 ] = position.z; te[ 15 ] = 1; return this; }, decompose: function () { var vector = new Vector3(); var matrix = new Matrix4(); return function decompose( position, quaternion, scale ) { var te = this.elements; var sx = vector.set( te[ 0 ], te[ 1 ], te[ 2 ] ).length(); var sy = vector.set( te[ 4 ], te[ 5 ], te[ 6 ] ).length(); var sz = vector.set( te[ 8 ], te[ 9 ], te[ 10 ] ).length(); // if determine is negative, we need to invert one scale var det = this.determinant(); if ( det < 0 ) sx = - sx; position.x = te[ 12 ]; position.y = te[ 13 ]; position.z = te[ 14 ]; // scale the rotation part matrix.copy( this ); var invSX = 1 / sx; var invSY = 1 / sy; var invSZ = 1 / sz; matrix.elements[ 0 ] *= invSX; matrix.elements[ 1 ] *= invSX; matrix.elements[ 2 ] *= invSX; matrix.elements[ 4 ] *= invSY; matrix.elements[ 5 ] *= invSY; matrix.elements[ 6 ] *= invSY; matrix.elements[ 8 ] *= invSZ; matrix.elements[ 9 ] *= invSZ; matrix.elements[ 10 ] *= invSZ; quaternion.setFromRotationMatrix( matrix ); scale.x = sx; scale.y = sy; scale.z = sz; return this; }; }(), makePerspective: function ( left, right, top, bottom, near, far ) { if ( far === undefined ) { console.warn( 'THREE.Matrix4: .makePerspective() has been redefined and has a new signature. Please check the docs.' ); } var te = this.elements; var x = 2 * near / ( right - left ); var y = 2 * near / ( top - bottom ); var a = ( right + left ) / ( right - left ); var b = ( top + bottom ) / ( top - bottom ); var c = - ( far + near ) / ( far - near ); var d = - 2 * far * near / ( far - near ); te[ 0 ] = x; te[ 4 ] = 0; te[ 8 ] = a; te[ 12 ] = 0; te[ 1 ] = 0; te[ 5 ] = y; te[ 9 ] = b; te[ 13 ] = 0; te[ 2 ] = 0; te[ 6 ] = 0; te[ 10 ] = c; te[ 14 ] = d; te[ 3 ] = 0; te[ 7 ] = 0; te[ 11 ] = - 1; te[ 15 ] = 0; return this; }, makeOrthographic: function ( left, right, top, bottom, near, far ) { var te = this.elements; var w = 1.0 / ( right - left ); var h = 1.0 / ( top - bottom ); var p = 1.0 / ( far - near ); var x = ( right + left ) * w; var y = ( top + bottom ) * h; var z = ( far + near ) * p; te[ 0 ] = 2 * w; te[ 4 ] = 0; te[ 8 ] = 0; te[ 12 ] = - x; te[ 1 ] = 0; te[ 5 ] = 2 * h; te[ 9 ] = 0; te[ 13 ] = - y; te[ 2 ] = 0; te[ 6 ] = 0; te[ 10 ] = - 2 * p; te[ 14 ] = - z; te[ 3 ] = 0; te[ 7 ] = 0; te[ 11 ] = 0; te[ 15 ] = 1; return this; }, equals: function ( matrix ) { var te = this.elements; var me = matrix.elements; for ( var i = 0; i < 16; i ++ ) { if ( te[ i ] !== me[ i ] ) return false; } return true; }, fromArray: function ( array, offset ) { if ( offset === undefined ) offset = 0; for ( var i = 0; i < 16; i ++ ) { this.elements[ i ] = array[ i + offset ]; } return this; }, toArray: function ( array, offset ) { if ( array === undefined ) array = []; if ( offset === undefined ) offset = 0; var te = this.elements; array[ offset ] = te[ 0 ]; array[ offset + 1 ] = te[ 1 ]; array[ offset + 2 ] = te[ 2 ]; array[ offset + 3 ] = te[ 3 ]; array[ offset + 4 ] = te[ 4 ]; array[ offset + 5 ] = te[ 5 ]; array[ offset + 6 ] = te[ 6 ]; array[ offset + 7 ] = te[ 7 ]; array[ offset + 8 ] = te[ 8 ]; array[ offset + 9 ] = te[ 9 ]; array[ offset + 10 ] = te[ 10 ]; array[ offset + 11 ] = te[ 11 ]; array[ offset + 12 ] = te[ 12 ]; array[ offset + 13 ] = te[ 13 ]; array[ offset + 14 ] = te[ 14 ]; array[ offset + 15 ] = te[ 15 ]; return array; } } ); /** * @author mikael emtinger / http://gomo.se/ * @author alteredq / http://alteredqualia.com/ * @author WestLangley / http://github.com/WestLangley * @author bhouston / http://clara.io */ function Quaternion( x, y, z, w ) { this._x = x || 0; this._y = y || 0; this._z = z || 0; this._w = ( w !== undefined ) ? w : 1; } Object.assign( Quaternion, { slerp: function ( qa, qb, qm, t ) { return qm.copy( qa ).slerp( qb, t ); }, slerpFlat: function ( dst, dstOffset, src0, srcOffset0, src1, srcOffset1, t ) { // fuzz-free, array-based Quaternion SLERP operation var x0 = src0[ srcOffset0 + 0 ], y0 = src0[ srcOffset0 + 1 ], z0 = src0[ srcOffset0 + 2 ], w0 = src0[ srcOffset0 + 3 ], x1 = src1[ srcOffset1 + 0 ], y1 = src1[ srcOffset1 + 1 ], z1 = src1[ srcOffset1 + 2 ], w1 = src1[ srcOffset1 + 3 ]; if ( w0 !== w1 || x0 !== x1 || y0 !== y1 || z0 !== z1 ) { var s = 1 - t, cos = x0 * x1 + y0 * y1 + z0 * z1 + w0 * w1, dir = ( cos >= 0 ? 1 : - 1 ), sqrSin = 1 - cos * cos; // Skip the Slerp for tiny steps to avoid numeric problems: if ( sqrSin > Number.EPSILON ) { var sin = Math.sqrt( sqrSin ), len = Math.atan2( sin, cos * dir ); s = Math.sin( s * len ) / sin; t = Math.sin( t * len ) / sin; } var tDir = t * dir; x0 = x0 * s + x1 * tDir; y0 = y0 * s + y1 * tDir; z0 = z0 * s + z1 * tDir; w0 = w0 * s + w1 * tDir; // Normalize in case we just did a lerp: if ( s === 1 - t ) { var f = 1 / Math.sqrt( x0 * x0 + y0 * y0 + z0 * z0 + w0 * w0 ); x0 *= f; y0 *= f; z0 *= f; w0 *= f; } } dst[ dstOffset ] = x0; dst[ dstOffset + 1 ] = y0; dst[ dstOffset + 2 ] = z0; dst[ dstOffset + 3 ] = w0; } } ); Object.defineProperties( Quaternion.prototype, { x: { get: function () { return this._x; }, set: function ( value ) { this._x = value; this.onChangeCallback(); } }, y: { get: function () { return this._y; }, set: function ( value ) { this._y = value; this.onChangeCallback(); } }, z: { get: function () { return this._z; }, set: function ( value ) { this._z = value; this.onChangeCallback(); } }, w: { get: function () { return this._w; }, set: function ( value ) { this._w = value; this.onChangeCallback(); } } } ); Object.assign( Quaternion.prototype, { isQuaternion: true, set: function ( x, y, z, w ) { this._x = x; this._y = y; this._z = z; this._w = w; this.onChangeCallback(); return this; }, clone: function () { return new this.constructor( this._x, this._y, this._z, this._w ); }, copy: function ( quaternion ) { this._x = quaternion.x; this._y = quaternion.y; this._z = quaternion.z; this._w = quaternion.w; this.onChangeCallback(); return this; }, setFromEuler: function ( euler, update ) { if ( ! ( euler && euler.isEuler ) ) { throw new Error( 'THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order.' ); } var x = euler._x, y = euler._y, z = euler._z, order = euler.order; // http://www.mathworks.com/matlabcentral/fileexchange/ // 20696-function-to-convert-between-dcm-euler-angles-quaternions-and-euler-vectors/ // content/SpinCalc.m var cos = Math.cos; var sin = Math.sin; var c1 = cos( x / 2 ); var c2 = cos( y / 2 ); var c3 = cos( z / 2 ); var s1 = sin( x / 2 ); var s2 = sin( y / 2 ); var s3 = sin( z / 2 ); if ( order === 'XYZ' ) { this._x = s1 * c2 * c3 + c1 * s2 * s3; this._y = c1 * s2 * c3 - s1 * c2 * s3; this._z = c1 * c2 * s3 + s1 * s2 * c3; this._w = c1 * c2 * c3 - s1 * s2 * s3; } else if ( order === 'YXZ' ) { this._x = s1 * c2 * c3 + c1 * s2 * s3; this._y = c1 * s2 * c3 - s1 * c2 * s3; this._z = c1 * c2 * s3 - s1 * s2 * c3; this._w = c1 * c2 * c3 + s1 * s2 * s3; } else if ( order === 'ZXY' ) { this._x = s1 * c2 * c3 - c1 * s2 * s3; this._y = c1 * s2 * c3 + s1 * c2 * s3; this._z = c1 * c2 * s3 + s1 * s2 * c3; this._w = c1 * c2 * c3 - s1 * s2 * s3; } else if ( order === 'ZYX' ) { this._x = s1 * c2 * c3 - c1 * s2 * s3; this._y = c1 * s2 * c3 + s1 * c2 * s3; this._z = c1 * c2 * s3 - s1 * s2 * c3; this._w = c1 * c2 * c3 + s1 * s2 * s3; } else if ( order === 'YZX' ) { this._x = s1 * c2 * c3 + c1 * s2 * s3; this._y = c1 * s2 * c3 + s1 * c2 * s3; this._z = c1 * c2 * s3 - s1 * s2 * c3; this._w = c1 * c2 * c3 - s1 * s2 * s3; } else if ( order === 'XZY' ) { this._x = s1 * c2 * c3 - c1 * s2 * s3; this._y = c1 * s2 * c3 - s1 * c2 * s3; this._z = c1 * c2 * s3 + s1 * s2 * c3; this._w = c1 * c2 * c3 + s1 * s2 * s3; } if ( update !== false ) this.onChangeCallback(); return this; }, setFromAxisAngle: function ( axis, angle ) { // http://www.euclideanspace.com/maths/geometry/rotations/conversions/angleToQuaternion/index.htm // assumes axis is normalized var halfAngle = angle / 2, s = Math.sin( halfAngle ); this._x = axis.x * s; this._y = axis.y * s; this._z = axis.z * s; this._w = Math.cos( halfAngle ); this.onChangeCallback(); return this; }, setFromRotationMatrix: function ( m ) { // http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToQuaternion/index.htm // assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled) var te = m.elements, m11 = te[ 0 ], m12 = te[ 4 ], m13 = te[ 8 ], m21 = te[ 1 ], m22 = te[ 5 ], m23 = te[ 9 ], m31 = te[ 2 ], m32 = te[ 6 ], m33 = te[ 10 ], trace = m11 + m22 + m33, s; if ( trace > 0 ) { s = 0.5 / Math.sqrt( trace + 1.0 ); this._w = 0.25 / s; this._x = ( m32 - m23 ) * s; this._y = ( m13 - m31 ) * s; this._z = ( m21 - m12 ) * s; } else if ( m11 > m22 && m11 > m33 ) { s = 2.0 * Math.sqrt( 1.0 + m11 - m22 - m33 ); this._w = ( m32 - m23 ) / s; this._x = 0.25 * s; this._y = ( m12 + m21 ) / s; this._z = ( m13 + m31 ) / s; } else if ( m22 > m33 ) { s = 2.0 * Math.sqrt( 1.0 + m22 - m11 - m33 ); this._w = ( m13 - m31 ) / s; this._x = ( m12 + m21 ) / s; this._y = 0.25 * s; this._z = ( m23 + m32 ) / s; } else { s = 2.0 * Math.sqrt( 1.0 + m33 - m11 - m22 ); this._w = ( m21 - m12 ) / s; this._x = ( m13 + m31 ) / s; this._y = ( m23 + m32 ) / s; this._z = 0.25 * s; } this.onChangeCallback(); return this; }, setFromUnitVectors: function () { // assumes direction vectors vFrom and vTo are normalized var v1 = new Vector3(); var r; var EPS = 0.000001; return function setFromUnitVectors( vFrom, vTo ) { if ( v1 === undefined ) v1 = new Vector3(); r = vFrom.dot( vTo ) + 1; if ( r < EPS ) { r = 0; if ( Math.abs( vFrom.x ) > Math.abs( vFrom.z ) ) { v1.set( - vFrom.y, vFrom.x, 0 ); } else { v1.set( 0, - vFrom.z, vFrom.y ); } } else { v1.crossVectors( vFrom, vTo ); } this._x = v1.x; this._y = v1.y; this._z = v1.z; this._w = r; return this.normalize(); }; }(), angleTo: function ( q ) { return 2 * Math.acos( Math.abs( _Math.clamp( this.dot( q ), - 1, 1 ) ) ); }, rotateTowards: function ( q, step ) { var angle = this.angleTo( q ); if ( angle === 0 ) return this; var t = Math.min( 1, step / angle ); this.slerp( q, t ); return this; }, inverse: function () { // quaternion is assumed to have unit length return this.conjugate(); }, conjugate: function () { this._x *= - 1; this._y *= - 1; this._z *= - 1; this.onChangeCallback(); return this; }, dot: function ( v ) { return this._x * v._x + this._y * v._y + this._z * v._z + this._w * v._w; }, lengthSq: function () { return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w; }, length: function () { return Math.sqrt( this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w ); }, normalize: function () { var l = this.length(); if ( l === 0 ) { this._x = 0; this._y = 0; this._z = 0; this._w = 1; } else { l = 1 / l; this._x = this._x * l; this._y = this._y * l; this._z = this._z * l; this._w = this._w * l; } this.onChangeCallback(); return this; }, multiply: function ( q, p ) { if ( p !== undefined ) { console.warn( 'THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead.' ); return this.multiplyQuaternions( q, p ); } return this.multiplyQuaternions( this, q ); }, premultiply: function ( q ) { return this.multiplyQuaternions( q, this ); }, multiplyQuaternions: function ( a, b ) { // from http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/code/index.htm var qax = a._x, qay = a._y, qaz = a._z, qaw = a._w; var qbx = b._x, qby = b._y, qbz = b._z, qbw = b._w; this._x = qax * qbw + qaw * qbx + qay * qbz - qaz * qby; this._y = qay * qbw + qaw * qby + qaz * qbx - qax * qbz; this._z = qaz * qbw + qaw * qbz + qax * qby - qay * qbx; this._w = qaw * qbw - qax * qbx - qay * qby - qaz * qbz; this.onChangeCallback(); return this; }, slerp: function ( qb, t ) { if ( t === 0 ) return this; if ( t === 1 ) return this.copy( qb ); var x = this._x, y = this._y, z = this._z, w = this._w; // http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/slerp/ var cosHalfTheta = w * qb._w + x * qb._x + y * qb._y + z * qb._z; if ( cosHalfTheta < 0 ) { this._w = - qb._w; this._x = - qb._x; this._y = - qb._y; this._z = - qb._z; cosHalfTheta = - cosHalfTheta; } else { this.copy( qb ); } if ( cosHalfTheta >= 1.0 ) { this._w = w; this._x = x; this._y = y; this._z = z; return this; } var sqrSinHalfTheta = 1.0 - cosHalfTheta * cosHalfTheta; if ( sqrSinHalfTheta 0 ) { console.error( 'THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.' ); } } Object.assign( Matrix3.prototype, { isMatrix3: true, set: function ( n11, n12, n13, n21, n22, n23, n31, n32, n33 ) { var te = this.elements; te[ 0 ] = n11; te[ 1 ] = n21; te[ 2 ] = n31; te[ 3 ] = n12; te[ 4 ] = n22; te[ 5 ] = n32; te[ 6 ] = n13; te[ 7 ] = n23; te[ 8 ] = n33; return this; }, identity: function () { this.set( 1, 0, 0, 0, 1, 0, 0, 0, 1 ); return this; }, clone: function () { return new this.constructor().fromArray( this.elements ); }, copy: function ( m ) { var te = this.elements; var me = m.elements; te[ 0 ] = me[ 0 ]; te[ 1 ] = me[ 1 ]; te[ 2 ] = me[ 2 ]; te[ 3 ] = me[ 3 ]; te[ 4 ] = me[ 4 ]; te[ 5 ] = me[ 5 ]; te[ 6 ] = me[ 6 ]; te[ 7 ] = me[ 7 ]; te[ 8 ] = me[ 8 ]; return this; }, setFromMatrix4: function ( m ) { var me = m.elements; this.set( me[ 0 ], me[ 4 ], me[ 8 ], me[ 1 ], me[ 5 ], me[ 9 ], me[ 2 ], me[ 6 ], me[ 10 ] ); return this; }, applyToBufferAttribute: function () { var v1 = new Vector3(); return function applyToBufferAttribute( attribute ) { for ( var i = 0, l = attribute.count; i < l; i ++ ) { v1.x = attribute.getX( i ); v1.y = attribute.getY( i ); v1.z = attribute.getZ( i ); v1.applyMatrix3( this ); attribute.setXYZ( i, v1.x, v1.y, v1.z ); } return attribute; }; }(), multiply: function ( m ) { return this.multiplyMatrices( this, m ); }, premultiply: function ( m ) { return this.multiplyMatrices( m, this ); }, multiplyMatrices: function ( a, b ) { var ae = a.elements; var be = b.elements; var te = this.elements; var a11 = ae[ 0 ], a12 = ae[ 3 ], a13 = ae[ 6 ]; var a21 = ae[ 1 ], a22 = ae[ 4 ], a23 = ae[ 7 ]; var a31 = ae[ 2 ], a32 = ae[ 5 ], a33 = ae[ 8 ]; var b11 = be[ 0 ], b12 = be[ 3 ], b13 = be[ 6 ]; var b21 = be[ 1 ], b22 = be[ 4 ], b23 = be[ 7 ]; var b31 = be[ 2 ], b32 = be[ 5 ], b33 = be[ 8 ]; te[ 0 ] = a11 * b11 + a12 * b21 + a13 * b31; te[ 3 ] = a11 * b12 + a12 * b22 + a13 * b32; te[ 6 ] = a11 * b13 + a12 * b23 + a13 * b33; te[ 1 ] = a21 * b11 + a22 * b21 + a23 * b31; te[ 4 ] = a21 * b12 + a22 * b22 + a23 * b32; te[ 7 ] = a21 * b13 + a22 * b23 + a23 * b33; te[ 2 ] = a31 * b11 + a32 * b21 + a33 * b31; te[ 5 ] = a31 * b12 + a32 * b22 + a33 * b32; te[ 8 ] = a31 * b13 + a32 * b23 + a33 * b33; return this; }, multiplyScalar: function ( s ) { var te = this.elements; te[ 0 ] *= s; te[ 3 ] *= s; te[ 6 ] *= s; te[ 1 ] *= s; te[ 4 ] *= s; te[ 7 ] *= s; te[ 2 ] *= s; te[ 5 ] *= s; te[ 8 ] *= s; return this; }, determinant: function () { var te = this.elements; var a = te[ 0 ], b = te[ 1 ], c = te[ 2 ], d = te[ 3 ], e = te[ 4 ], f = te[ 5 ], g = te[ 6 ], h = te[ 7 ], i = te[ 8 ]; return a * e * i - a * f * h - b * d * i + b * f * g + c * d * h - c * e * g; }, getInverse: function ( matrix, throwOnDegenerate ) { if ( matrix && matrix.isMatrix4 ) { console.error( \"THREE.Matrix3: .getInverse() no longer takes a Matrix4 argument.\" ); } var me = matrix.elements, te = this.elements, n11 = me[ 0 ], n21 = me[ 1 ], n31 = me[ 2 ], n12 = me[ 3 ], n22 = me[ 4 ], n32 = me[ 5 ], n13 = me[ 6 ], n23 = me[ 7 ], n33 = me[ 8 ], t11 = n33 * n22 - n32 * n23, t12 = n32 * n13 - n33 * n12, t13 = n23 * n12 - n22 * n13, det = n11 * t11 + n21 * t12 + n31 * t13; if ( det === 0 ) { var msg = \"THREE.Matrix3: .getInverse() can't invert matrix, determinant is 0\"; if ( throwOnDegenerate === true ) { throw new Error( msg ); } else { console.warn( msg ); } return this.identity(); } var detInv = 1 / det; te[ 0 ] = t11 * detInv; te[ 1 ] = ( n31 * n23 - n33 * n21 ) * detInv; te[ 2 ] = ( n32 * n21 - n31 * n22 ) * detInv; te[ 3 ] = t12 * detInv; te[ 4 ] = ( n33 * n11 - n31 * n13 ) * detInv; te[ 5 ] = ( n31 * n12 - n32 * n11 ) * detInv; te[ 6 ] = t13 * detInv; te[ 7 ] = ( n21 * n13 - n23 * n11 ) * detInv; te[ 8 ] = ( n22 * n11 - n21 * n12 ) * detInv; return this; }, transpose: function () { var tmp, m = this.elements; tmp = m[ 1 ]; m[ 1 ] = m[ 3 ]; m[ 3 ] = tmp; tmp = m[ 2 ]; m[ 2 ] = m[ 6 ]; m[ 6 ] = tmp; tmp = m[ 5 ]; m[ 5 ] = m[ 7 ]; m[ 7 ] = tmp; return this; }, getNormalMatrix: function ( matrix4 ) { return this.setFromMatrix4( matrix4 ).getInverse( this ).transpose(); }, transposeIntoArray: function ( r ) { var m = this.elements; r[ 0 ] = m[ 0 ]; r[ 1 ] = m[ 3 ]; r[ 2 ] = m[ 6 ]; r[ 3 ] = m[ 1 ]; r[ 4 ] = m[ 4 ]; r[ 5 ] = m[ 7 ]; r[ 6 ] = m[ 2 ]; r[ 7 ] = m[ 5 ]; r[ 8 ] = m[ 8 ]; return this; }, setUvTransform: function ( tx, ty, sx, sy, rotation, cx, cy ) { var c = Math.cos( rotation ); var s = Math.sin( rotation ); this.set( sx * c, sx * s, - sx * ( c * cx + s * cy ) + cx + tx, - sy * s, sy * c, - sy * ( - s * cx + c * cy ) + cy + ty, 0, 0, 1 ); }, scale: function ( sx, sy ) { var te = this.elements; te[ 0 ] *= sx; te[ 3 ] *= sx; te[ 6 ] *= sx; te[ 1 ] *= sy; te[ 4 ] *= sy; te[ 7 ] *= sy; return this; }, rotate: function ( theta ) { var c = Math.cos( theta ); var s = Math.sin( theta ); var te = this.elements; var a11 = te[ 0 ], a12 = te[ 3 ], a13 = te[ 6 ]; var a21 = te[ 1 ], a22 = te[ 4 ], a23 = te[ 7 ]; te[ 0 ] = c * a11 + s * a21; te[ 3 ] = c * a12 + s * a22; te[ 6 ] = c * a13 + s * a23; te[ 1 ] = - s * a11 + c * a21; te[ 4 ] = - s * a12 + c * a22; te[ 7 ] = - s * a13 + c * a23; return this; }, translate: function ( tx, ty ) { var te = this.elements; te[ 0 ] += tx * te[ 2 ]; te[ 3 ] += tx * te[ 5 ]; te[ 6 ] += tx * te[ 8 ]; te[ 1 ] += ty * te[ 2 ]; te[ 4 ] += ty * te[ 5 ]; te[ 7 ] += ty * te[ 8 ]; return this; }, equals: function ( matrix ) { var te = this.elements; var me = matrix.elements; for ( var i = 0; i < 9; i ++ ) { if ( te[ i ] !== me[ i ] ) return false; } return true; }, fromArray: function ( array, offset ) { if ( offset === undefined ) offset = 0; for ( var i = 0; i < 9; i ++ ) { this.elements[ i ] = array[ i + offset ]; } return this; }, toArray: function ( array, offset ) { if ( array === undefined ) array = []; if ( offset === undefined ) offset = 0; var te = this.elements; array[ offset ] = te[ 0 ]; array[ offset + 1 ] = te[ 1 ]; array[ offset + 2 ] = te[ 2 ]; array[ offset + 3 ] = te[ 3 ]; array[ offset + 4 ] = te[ 4 ]; array[ offset + 5 ] = te[ 5 ]; array[ offset + 6 ] = te[ 6 ]; array[ offset + 7 ] = te[ 7 ]; array[ offset + 8 ] = te[ 8 ]; return array; } } ); /** * @author mrdoob / http://mrdoob.com/ * @author alteredq / http://alteredqualia.com/ * @author szimek / https://github.com/szimek/ */ var _canvas; var ImageUtils = { getDataURL: function ( image ) { var canvas; if ( typeof HTMLCanvasElement == 'undefined' ) { return image.src; } else if ( image instanceof HTMLCanvasElement ) { canvas = image; } else { if ( _canvas === undefined ) _canvas = document.createElementNS( 'http://www.w3.org/1999/xhtml', 'canvas' ); _canvas.width = image.width; _canvas.height = image.height; var context = _canvas.getContext( '2d' ); if ( image instanceof ImageData ) { context.putImageData( image, 0, 0 ); } else { context.drawImage( image, 0, 0, image.width, image.height ); } canvas = _canvas; } if ( canvas.width > 2048 || canvas.height > 2048 ) { return canvas.toDataURL( 'image/jpeg', 0.6 ); } else { return canvas.toDataURL( 'image/png' ); } } }; /** * @author mrdoob / http://mrdoob.com/ * @author alteredq / http://alteredqualia.com/ * @author szimek / https://github.com/szimek/ */ var textureId = 0; function Texture( image, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding ) { Object.defineProperty( this, 'id', { value: textureId ++ } ); this.uuid = _Math.generateUUID(); this.name = ''; this.image = image !== undefined ? image : Texture.DEFAULT_IMAGE; this.mipmaps = []; this.mapping = mapping !== undefined ? mapping : Texture.DEFAULT_MAPPING; this.wrapS = wrapS !== undefined ? wrapS : ClampToEdgeWrapping; this.wrapT = wrapT !== undefined ? wrapT : ClampToEdgeWrapping; this.magFilter = magFilter !== undefined ? magFilter : LinearFilter; this.minFilter = minFilter !== undefined ? minFilter : LinearMipMapLinearFilter; this.anisotropy = anisotropy !== undefined ? anisotropy : 1; this.format = format !== undefined ? format : RGBAFormat; this.type = type !== undefined ? type : UnsignedByteType; this.offset = new Vector2( 0, 0 ); this.repeat = new Vector2( 1, 1 ); this.center = new Vector2( 0, 0 ); this.rotation = 0; this.matrixAutoUpdate = true; this.matrix = new Matrix3(); this.generateMipmaps = true; this.premultiplyAlpha = false; this.flipY = true; this.unpackAlignment = 4; // valid values: 1, 2, 4, 8 (see http://www.khronos.org/opengles/sdk/docs/man/xhtml/glPixelStorei.xml) // Values of encoding !== THREE.LinearEncoding only supported on map, envMap and emissiveMap. // // Also changing the encoding after already used by a Material will not automatically make the Material // update. You need to explicitly call Material.needsUpdate to trigger it to recompile. this.encoding = encoding !== undefined ? encoding : LinearEncoding; this.version = 0; this.onUpdate = null; } Texture.DEFAULT_IMAGE = undefined; Texture.DEFAULT_MAPPING = UVMapping; Texture.prototype = Object.assign( Object.create( EventDispatcher.prototype ), { constructor: Texture, isTexture: true, updateMatrix: function () { this.matrix.setUvTransform( this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y ); }, clone: function () { return new this.constructor().copy( this ); }, copy: function ( source ) { this.name = source.name; this.image = source.image; this.mipmaps = source.mipmaps.slice( 0 ); this.mapping = source.mapping; this.wrapS = source.wrapS; this.wrapT = source.wrapT; this.magFilter = source.magFilter; this.minFilter = source.minFilter; this.anisotropy = source.anisotropy; this.format = source.format; this.type = source.type; this.offset.copy( source.offset ); this.repeat.copy( source.repeat ); this.center.copy( source.center ); this.rotation = source.rotation; this.matrixAutoUpdate = source.matrixAutoUpdate; this.matrix.copy( source.matrix ); this.generateMipmaps = source.generateMipmaps; this.premultiplyAlpha = source.premultiplyAlpha; this.flipY = source.flipY; this.unpackAlignment = source.unpackAlignment; this.encoding = source.encoding; return this; }, toJSON: function ( meta ) { var isRootObject = ( meta === undefined || typeof meta === 'string' ); if ( ! isRootObject && meta.textures[ this.uuid ] !== undefined ) { return meta.textures[ this.uuid ]; } var output = { metadata: { version: 4.5, type: 'Texture', generator: 'Texture.toJSON' }, uuid: this.uuid, name: this.name, mapping: this.mapping, repeat: [ this.repeat.x, this.repeat.y ], offset: [ this.offset.x, this.offset.y ], center: [ this.center.x, this.center.y ], rotation: this.rotation, wrap: [ this.wrapS, this.wrapT ], format: this.format, type: this.type, encoding: this.encoding, minFilter: this.minFilter, magFilter: this.magFilter, anisotropy: this.anisotropy, flipY: this.flipY, premultiplyAlpha: this.premultiplyAlpha, unpackAlignment: this.unpackAlignment }; if ( this.image !== undefined ) { // TODO: Move to THREE.Image var image = this.image; if ( image.uuid === undefined ) { image.uuid = _Math.generateUUID(); // UGH } if ( ! isRootObject && meta.images[ image.uuid ] === undefined ) { var url; if ( Array.isArray( image ) ) { // process array of images e.g. CubeTexture url = []; for ( var i = 0, l = image.length; i < l; i ++ ) { url.push( ImageUtils.getDataURL( image[ i ] ) ); } } else { // process single image url = ImageUtils.getDataURL( image ); } meta.images[ image.uuid ] = { uuid: image.uuid, url: url }; } output.image = image.uuid; } if ( ! isRootObject ) { meta.textures[ this.uuid ] = output; } return output; }, dispose: function () { this.dispatchEvent( { type: 'dispose' } ); }, transformUv: function ( uv ) { if ( this.mapping !== UVMapping ) return uv; uv.applyMatrix3( this.matrix ); if ( uv.x < 0 || uv.x > 1 ) { switch ( this.wrapS ) { case RepeatWrapping: uv.x = uv.x - Math.floor( uv.x ); break; case ClampToEdgeWrapping: uv.x = uv.x < 0 ? 0 : 1; break; case MirroredRepeatWrapping: if ( Math.abs( Math.floor( uv.x ) % 2 ) === 1 ) { uv.x = Math.ceil( uv.x ) - uv.x; } else { uv.x = uv.x - Math.floor( uv.x ); } break; } } if ( uv.y < 0 || uv.y > 1 ) { switch ( this.wrapT ) { case RepeatWrapping: uv.y = uv.y - Math.floor( uv.y ); break; case ClampToEdgeWrapping: uv.y = uv.y < 0 ? 0 : 1; break; case MirroredRepeatWrapping: if ( Math.abs( Math.floor( uv.y ) % 2 ) === 1 ) { uv.y = Math.ceil( uv.y ) - uv.y; } else { uv.y = uv.y - Math.floor( uv.y ); } break; } } if ( this.flipY ) { uv.y = 1 - uv.y; } return uv; } } ); Object.defineProperty( Texture.prototype, \"needsUpdate\", { set: function ( value ) { if ( value === true ) this.version ++; } } ); /** * @author supereggbert / http://www.paulbrunt.co.uk/ * @author philogb / http://blog.thejit.org/ * @author mikael emtinger / http://gomo.se/ * @author egraether / http://egraether.com/ * @author WestLangley / http://github.com/WestLangley */ function Vector4( x, y, z, w ) { this.x = x || 0; this.y = y || 0; this.z = z || 0; this.w = ( w !== undefined ) ? w : 1; } Object.assign( Vector4.prototype, { isVector4: true, set: function ( x, y, z, w ) { this.x = x; this.y = y; this.z = z; this.w = w; return this; }, setScalar: function ( scalar ) { this.x = scalar; this.y = scalar; this.z = scalar; this.w = scalar; return this; }, setX: function ( x ) { this.x = x; return this; }, setY: function ( y ) { this.y = y; return this; }, setZ: function ( z ) { this.z = z; return this; }, setW: function ( w ) { this.w = w; return this; }, setComponent: function ( index, value ) { switch ( index ) { case 0: this.x = value; break; case 1: this.y = value; break; case 2: this.z = value; break; case 3: this.w = value; break; default: throw new Error( 'index is out of range: ' + index ); } return this; }, getComponent: function ( index ) { switch ( index ) { case 0: return this.x; case 1: return this.y; case 2: return this.z; case 3: return this.w; default: throw new Error( 'index is out of range: ' + index ); } }, clone: function () { return new this.constructor( this.x, this.y, this.z, this.w ); }, copy: function ( v ) { this.x = v.x; this.y = v.y; this.z = v.z; this.w = ( v.w !== undefined ) ? v.w : 1; return this; }, add: function ( v, w ) { if ( w !== undefined ) { console.warn( 'THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead.' ); return this.addVectors( v, w ); } this.x += v.x; this.y += v.y; this.z += v.z; this.w += v.w; return this; }, addScalar: function ( s ) { this.x += s; this.y += s; this.z += s; this.w += s; return this; }, addVectors: function ( a, b ) { this.x = a.x + b.x; this.y = a.y + b.y; this.z = a.z + b.z; this.w = a.w + b.w; return this; }, addScaledVector: function ( v, s ) { this.x += v.x * s; this.y += v.y * s; this.z += v.z * s; this.w += v.w * s; return this; }, sub: function ( v, w ) { if ( w !== undefined ) { console.warn( 'THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.' ); return this.subVectors( v, w ); } this.x -= v.x; this.y -= v.y; this.z -= v.z; this.w -= v.w; return this; }, subScalar: function ( s ) { this.x -= s; this.y -= s; this.z -= s; this.w -= s; return this; }, subVectors: function ( a, b ) { this.x = a.x - b.x; this.y = a.y - b.y; this.z = a.z - b.z; this.w = a.w - b.w; return this; }, multiplyScalar: function ( scalar ) { this.x *= scalar; this.y *= scalar; this.z *= scalar; this.w *= scalar; return this; }, applyMatrix4: function ( m ) { var x = this.x, y = this.y, z = this.z, w = this.w; var e = m.elements; this.x = e[ 0 ] * x + e[ 4 ] * y + e[ 8 ] * z + e[ 12 ] * w; this.y = e[ 1 ] * x + e[ 5 ] * y + e[ 9 ] * z + e[ 13 ] * w; this.z = e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z + e[ 14 ] * w; this.w = e[ 3 ] * x + e[ 7 ] * y + e[ 11 ] * z + e[ 15 ] * w; return this; }, divideScalar: function ( scalar ) { return this.multiplyScalar( 1 / scalar ); }, setAxisAngleFromQuaternion: function ( q ) { // http://www.euclideanspace.com/maths/geometry/rotations/conversions/quaternionToAngle/index.htm // q is assumed to be normalized this.w = 2 * Math.acos( q.w ); var s = Math.sqrt( 1 - q.w * q.w ); if ( s < 0.0001 ) { this.x = 1; this.y = 0; this.z = 0; } else { this.x = q.x / s; this.y = q.y / s; this.z = q.z / s; } return this; }, setAxisAngleFromRotationMatrix: function ( m ) { // http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToAngle/index.htm // assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled) var angle, x, y, z, // variables for result epsilon = 0.01, // margin to allow for rounding errors epsilon2 = 0.1, // margin to distinguish between 0 and 180 degrees te = m.elements, m11 = te[ 0 ], m12 = te[ 4 ], m13 = te[ 8 ], m21 = te[ 1 ], m22 = te[ 5 ], m23 = te[ 9 ], m31 = te[ 2 ], m32 = te[ 6 ], m33 = te[ 10 ]; if ( ( Math.abs( m12 - m21 ) < epsilon ) && ( Math.abs( m13 - m31 ) < epsilon ) && ( Math.abs( m23 - m32 ) < epsilon ) ) { // singularity found // first check for identity matrix which must have +1 for all terms // in leading diagonal and zero in other terms if ( ( Math.abs( m12 + m21 ) < epsilon2 ) && ( Math.abs( m13 + m31 ) < epsilon2 ) && ( Math.abs( m23 + m32 ) < epsilon2 ) && ( Math.abs( m11 + m22 + m33 - 3 ) < epsilon2 ) ) { // this singularity is identity matrix so angle = 0 this.set( 1, 0, 0, 0 ); return this; // zero angle, arbitrary axis } // otherwise this singularity is angle = 180 angle = Math.PI; var xx = ( m11 + 1 ) / 2; var yy = ( m22 + 1 ) / 2; var zz = ( m33 + 1 ) / 2; var xy = ( m12 + m21 ) / 4; var xz = ( m13 + m31 ) / 4; var yz = ( m23 + m32 ) / 4; if ( ( xx > yy ) && ( xx > zz ) ) { // m11 is the largest diagonal term if ( xx < epsilon ) { x = 0; y = 0.707106781; z = 0.707106781; } else { x = Math.sqrt( xx ); y = xy / x; z = xz / x; } } else if ( yy > zz ) { // m22 is the largest diagonal term if ( yy < epsilon ) { x = 0.707106781; y = 0; z = 0.707106781; } else { y = Math.sqrt( yy ); x = xy / y; z = yz / y; } } else { // m33 is the largest diagonal term so base result on this if ( zz < epsilon ) { x = 0.707106781; y = 0.707106781; z = 0; } else { z = Math.sqrt( zz ); x = xz / z; y = yz / z; } } this.set( x, y, z, angle ); return this; // return 180 deg rotation } // as we have reached here there are no singularities so we can handle normally var s = Math.sqrt( ( m32 - m23 ) * ( m32 - m23 ) + ( m13 - m31 ) * ( m13 - m31 ) + ( m21 - m12 ) * ( m21 - m12 ) ); // used to normalize if ( Math.abs( s ) < 0.001 ) s = 1; // prevent divide by zero, should not happen if matrix is orthogonal and should be // caught by singularity test above, but I've left it in just in case this.x = ( m32 - m23 ) / s; this.y = ( m13 - m31 ) / s; this.z = ( m21 - m12 ) / s; this.w = Math.acos( ( m11 + m22 + m33 - 1 ) / 2 ); return this; }, min: function ( v ) { this.x = Math.min( this.x, v.x ); this.y = Math.min( this.y, v.y ); this.z = Math.min( this.z, v.z ); this.w = Math.min( this.w, v.w ); return this; }, max: function ( v ) { this.x = Math.max( this.x, v.x ); this.y = Math.max( this.y, v.y ); this.z = Math.max( this.z, v.z ); this.w = Math.max( this.w, v.w ); return this; }, clamp: function ( min, max ) { // assumes min < max, componentwise this.x = Math.max( min.x, Math.min( max.x, this.x ) ); this.y = Math.max( min.y, Math.min( max.y, this.y ) ); this.z = Math.max( min.z, Math.min( max.z, this.z ) ); this.w = Math.max( min.w, Math.min( max.w, this.w ) ); return this; }, clampScalar: function () { var min, max; return function clampScalar( minVal, maxVal ) { if ( min === undefined ) { min = new Vector4(); max = new Vector4(); } min.set( minVal, minVal, minVal, minVal ); max.set( maxVal, maxVal, maxVal, maxVal ); return this.clamp( min, max ); }; }(), clampLength: function ( min, max ) { var length = this.length(); return this.divideScalar( length || 1 ).multiplyScalar( Math.max( min, Math.min( max, length ) ) ); }, floor: function () { this.x = Math.floor( this.x ); this.y = Math.floor( this.y ); this.z = Math.floor( this.z ); this.w = Math.floor( this.w ); return this; }, ceil: function () { this.x = Math.ceil( this.x ); this.y = Math.ceil( this.y ); this.z = Math.ceil( this.z ); this.w = Math.ceil( this.w ); return this; }, round: function () { this.x = Math.round( this.x ); this.y = Math.round( this.y ); this.z = Math.round( this.z ); this.w = Math.round( this.w ); return this; }, roundToZero: function () { this.x = ( this.x < 0 ) ? Math.ceil( this.x ) : Math.floor( this.x ); this.y = ( this.y < 0 ) ? Math.ceil( this.y ) : Math.floor( this.y ); this.z = ( this.z < 0 ) ? Math.ceil( this.z ) : Math.floor( this.z ); this.w = ( this.w < 0 ) ? Math.ceil( this.w ) : Math.floor( this.w ); return this; }, negate: function () { this.x = - this.x; this.y = - this.y; this.z = - this.z; this.w = - this.w; return this; }, dot: function ( v ) { return this.x * v.x + this.y * v.y + this.z * v.z + this.w * v.w; }, lengthSq: function () { return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w; }, length: function () { return Math.sqrt( this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w ); }, manhattanLength: function () { return Math.abs( this.x ) + Math.abs( this.y ) + Math.abs( this.z ) + Math.abs( this.w ); }, normalize: function () { return this.divideScalar( this.length() || 1 ); }, setLength: function ( length ) { return this.normalize().multiplyScalar( length ); }, lerp: function ( v, alpha ) { this.x += ( v.x - this.x ) * alpha; this.y += ( v.y - this.y ) * alpha; this.z += ( v.z - this.z ) * alpha; this.w += ( v.w - this.w ) * alpha; return this; }, lerpVectors: function ( v1, v2, alpha ) { return this.subVectors( v2, v1 ).multiplyScalar( alpha ).add( v1 ); }, equals: function ( v ) { return ( ( v.x === this.x ) && ( v.y === this.y ) && ( v.z === this.z ) && ( v.w === this.w ) ); }, fromArray: function ( array, offset ) { if ( offset === undefined ) offset = 0; this.x = array[ offset ]; this.y = array[ offset + 1 ]; this.z = array[ offset + 2 ]; this.w = array[ offset + 3 ]; return this; }, toArray: function ( array, offset ) { if ( array === undefined ) array = []; if ( offset === undefined ) offset = 0; array[ offset ] = this.x; array[ offset + 1 ] = this.y; array[ offset + 2 ] = this.z; array[ offset + 3 ] = this.w; return array; }, fromBufferAttribute: function ( attribute, index, offset ) { if ( offset !== undefined ) { console.warn( 'THREE.Vector4: offset has been removed from .fromBufferAttribute().' ); } this.x = attribute.getX( index ); this.y = attribute.getY( index ); this.z = attribute.getZ( index ); this.w = attribute.getW( index ); return this; } } ); /** * @author szimek / https://github.com/szimek/ * @author alteredq / http://alteredqualia.com/ * @author Marius Kintel / https://github.com/kintel */ /* In options, we can specify: * Texture parameters for an auto-generated target texture * depthBuffer/stencilBuffer: Booleans to indicate if we should generate these buffers */ function WebGLRenderTarget( width, height, options ) { this.width = width; this.height = height; this.scissor = new Vector4( 0, 0, width, height ); this.scissorTest = false; this.viewport = new Vector4( 0, 0, width, height ); options = options || {}; this.texture = new Texture( undefined, undefined, options.wrapS, options.wrapT, options.magFilter, options.minFilter, options.format, options.type, options.anisotropy, options.encoding ); this.texture.generateMipmaps = options.generateMipmaps !== undefined ? options.generateMipmaps : false; this.texture.minFilter = options.minFilter !== undefined ? options.minFilter : LinearFilter; this.depthBuffer = options.depthBuffer !== undefined ? options.depthBuffer : true; this.stencilBuffer = options.stencilBuffer !== undefined ? options.stencilBuffer : true; this.depthTexture = options.depthTexture !== undefined ? options.depthTexture : null; } WebGLRenderTarget.prototype = Object.assign( Object.create( EventDispatcher.prototype ), { constructor: WebGLRenderTarget, isWebGLRenderTarget: true, setSize: function ( width, height ) { if ( this.width !== width || this.height !== height ) { this.width = width; this.height = height; this.dispose(); } this.viewport.set( 0, 0, width, height ); this.scissor.set( 0, 0, width, height ); }, clone: function () { return new this.constructor().copy( this ); }, copy: function ( source ) { this.width = source.width; this.height = source.height; this.viewport.copy( source.viewport ); this.texture = source.texture.clone(); this.depthBuffer = source.depthBuffer; this.stencilBuffer = source.stencilBuffer; this.depthTexture = source.depthTexture; return this; }, dispose: function () { this.dispatchEvent( { type: 'dispose' } ); } } ); /** * @author Mugen87 / https://github.com/Mugen87 * @author Matt DesLauriers / @mattdesl */ function WebGLMultisampleRenderTarget( width, height, options ) { WebGLRenderTarget.call( this, width, height, options ); this.samples = 4; } WebGLMultisampleRenderTarget.prototype = Object.assign( Object.create( WebGLRenderTarget.prototype ), { constructor: WebGLMultisampleRenderTarget, isWebGLMultisampleRenderTarget: true, copy: function ( source ) { WebGLRenderTarget.prototype.copy.call( this, source ); this.samples = source.samples; return this; } } ); /** * @author alteredq / http://alteredqualia.com */ function WebGLRenderTargetCube( width, height, options ) { WebGLRenderTarget.call( this, width, height, options ); this.activeCubeFace = 0; // PX 0, NX 1, PY 2, NY 3, PZ 4, NZ 5 this.activeMipMapLevel = 0; } WebGLRenderTargetCube.prototype = Object.create( WebGLRenderTarget.prototype ); WebGLRenderTargetCube.prototype.constructor = WebGLRenderTargetCube; WebGLRenderTargetCube.prototype.isWebGLRenderTargetCube = true; /** * @author alteredq / http://alteredqualia.com/ */ function DataTexture( data, width, height, format, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, encoding ) { Texture.call( this, null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding ); this.image = { data: data, width: width, height: height }; this.magFilter = magFilter !== undefined ? magFilter : NearestFilter; this.minFilter = minFilter !== undefined ? minFilter : NearestFilter; this.generateMipmaps = false; this.flipY = false; this.unpackAlignment = 1; } DataTexture.prototype = Object.create( Texture.prototype ); DataTexture.prototype.constructor = DataTexture; DataTexture.prototype.isDataTexture = true; /** * @author bhouston / http://clara.io * @author WestLangley / http://github.com/WestLangley */ function Box3( min, max ) { this.min = ( min !== undefined ) ? min : new Vector3( + Infinity, + Infinity, + Infinity ); this.max = ( max !== undefined ) ? max : new Vector3( - Infinity, - Infinity, - Infinity ); } Object.assign( Box3.prototype, { isBox3: true, set: function ( min, max ) { this.min.copy( min ); this.max.copy( max ); return this; }, setFromArray: function ( array ) { var minX = + Infinity; var minY = + Infinity; var minZ = + Infinity; var maxX = - Infinity; var maxY = - Infinity; var maxZ = - Infinity; for ( var i = 0, l = array.length; i < l; i += 3 ) { var x = array[ i ]; var y = array[ i + 1 ]; var z = array[ i + 2 ]; if ( x < minX ) minX = x; if ( y < minY ) minY = y; if ( z < minZ ) minZ = z; if ( x > maxX ) maxX = x; if ( y > maxY ) maxY = y; if ( z > maxZ ) maxZ = z; } this.min.set( minX, minY, minZ ); this.max.set( maxX, maxY, maxZ ); return this; }, setFromBufferAttribute: function ( attribute ) { var minX = + Infinity; var minY = + Infinity; var minZ = + Infinity; var maxX = - Infinity; var maxY = - Infinity; var maxZ = - Infinity; for ( var i = 0, l = attribute.count; i < l; i ++ ) { var x = attribute.getX( i ); var y = attribute.getY( i ); var z = attribute.getZ( i ); if ( x < minX ) minX = x; if ( y < minY ) minY = y; if ( z < minZ ) minZ = z; if ( x > maxX ) maxX = x; if ( y > maxY ) maxY = y; if ( z > maxZ ) maxZ = z; } this.min.set( minX, minY, minZ ); this.max.set( maxX, maxY, maxZ ); return this; }, setFromPoints: function ( points ) { this.makeEmpty(); for ( var i = 0, il = points.length; i < il; i ++ ) { this.expandByPoint( points[ i ] ); } return this; }, setFromCenterAndSize: function () { var v1 = new Vector3(); return function setFromCenterAndSize( center, size ) { var halfSize = v1.copy( size ).multiplyScalar( 0.5 ); this.min.copy( center ).sub( halfSize ); this.max.copy( center ).add( halfSize ); return this; }; }(), setFromObject: function ( object ) { this.makeEmpty(); return this.expandByObject( object ); }, clone: function () { return new this.constructor().copy( this ); }, copy: function ( box ) { this.min.copy( box.min ); this.max.copy( box.max ); return this; }, makeEmpty: function () { this.min.x = this.min.y = this.min.z = + Infinity; this.max.x = this.max.y = this.max.z = - Infinity; return this; }, isEmpty: function () { // this is a more robust check for empty than ( volume this.max.y || point.z < this.min.z || point.z > this.max.z ? false : true; }, containsBox: function ( box ) { return this.min.x this.max.y || box.max.z < this.min.z || box.min.z > this.max.z ? false : true; }, intersectsSphere: ( function () { var closestPoint = new Vector3(); return function intersectsSphere( sphere ) { // Find the point on the AABB closest to the sphere center. this.clampPoint( sphere.center, closestPoint ); // If that point is inside the sphere, the AABB and sphere intersect. return closestPoint.distanceToSquared( sphere.center ) 0 ) { min = plane.normal.x * this.min.x; max = plane.normal.x * this.max.x; } else { min = plane.normal.x * this.max.x; max = plane.normal.x * this.min.x; } if ( plane.normal.y > 0 ) { min += plane.normal.y * this.min.y; max += plane.normal.y * this.max.y; } else { min += plane.normal.y * this.max.y; max += plane.normal.y * this.min.y; } if ( plane.normal.z > 0 ) { min += plane.normal.z * this.min.z; max += plane.normal.z * this.max.z; } else { min += plane.normal.z * this.max.z; max += plane.normal.z * this.min.z; } return ( min = - plane.constant ); }, intersectsTriangle: ( function () { // triangle centered vertices var v0 = new Vector3(); var v1 = new Vector3(); var v2 = new Vector3(); // triangle edge vectors var f0 = new Vector3(); var f1 = new Vector3(); var f2 = new Vector3(); var testAxis = new Vector3(); var center = new Vector3(); var extents = new Vector3(); var triangleNormal = new Vector3(); function satForAxes( axes ) { var i, j; for ( i = 0, j = axes.length - 3; i r ) { // points of the projected triangle are outside the projected half-length of the aabb // the axis is seperating and we can exit return false; } } return true; } return function intersectsTriangle( triangle ) { if ( this.isEmpty() ) { return false; } // compute box center and extents this.getCenter( center ); extents.subVectors( this.max, center ); // translate triangle to aabb origin v0.subVectors( triangle.a, center ); v1.subVectors( triangle.b, center ); v2.subVectors( triangle.c, center ); // compute edge vectors for triangle f0.subVectors( v1, v0 ); f1.subVectors( v2, v1 ); f2.subVectors( v0, v2 ); // test against axes that are given by cross product combinations of the edges of the triangle and the edges of the aabb // make an axis testing of each of the 3 sides of the aabb against each of the 3 sides of the triangle = 9 axis of separation // axis_ij = u_i x f_j (u0, u1, u2 = face normals of aabb = x,y,z axes vectors since aabb is axis aligned) var axes = [ 0, - f0.z, f0.y, 0, - f1.z, f1.y, 0, - f2.z, f2.y, f0.z, 0, - f0.x, f1.z, 0, - f1.x, f2.z, 0, - f2.x, - f0.y, f0.x, 0, - f1.y, f1.x, 0, - f2.y, f2.x, 0 ]; if ( ! satForAxes( axes ) ) { return false; } // test 3 face normals from the aabb axes = [ 1, 0, 0, 0, 1, 0, 0, 0, 1 ]; if ( ! satForAxes( axes ) ) { return false; } // finally testing the face normal of the triangle // use already existing triangle edge vectors here triangleNormal.crossVectors( f0, f1 ); axes = [ triangleNormal.x, triangleNormal.y, triangleNormal.z ]; return satForAxes( axes ); }; } )(), clampPoint: function ( point, target ) { if ( target === undefined ) { console.warn( 'THREE.Box3: .clampPoint() target is now required' ); target = new Vector3(); } return target.copy( point ).clamp( this.min, this.max ); }, distanceToPoint: function () { var v1 = new Vector3(); return function distanceToPoint( point ) { var clampedPoint = v1.copy( point ).clamp( this.min, this.max ); return clampedPoint.sub( point ).length(); }; }(), getBoundingSphere: function () { var v1 = new Vector3(); return function getBoundingSphere( target ) { if ( target === undefined ) { console.warn( 'THREE.Box3: .getBoundingSphere() target is now required' ); target = new Sphere(); } this.getCenter( target.center ); target.radius = this.getSize( v1 ).length() * 0.5; return target; }; }(), intersect: function ( box ) { this.min.max( box.min ); this.max.min( box.max ); // ensure that if there is no overlap, the result is fully empty, not slightly empty with non-inf/+inf values that will cause subsequence intersects to erroneously return valid values. if ( this.isEmpty() ) this.makeEmpty(); return this; }, union: function ( box ) { this.min.min( box.min ); this.max.max( box.max ); return this; }, applyMatrix4: function () { var points = [ new Vector3(), new Vector3(), new Vector3(), new Vector3(), new Vector3(), new Vector3(), new Vector3(), new Vector3() ]; return function applyMatrix4( matrix ) { // transform of empty box is an empty box. if ( this.isEmpty() ) return this; // NOTE: I am using a binary pattern to specify all 2^3 combinations below points[ 0 ].set( this.min.x, this.min.y, this.min.z ).applyMatrix4( matrix ); // 000 points[ 1 ].set( this.min.x, this.min.y, this.max.z ).applyMatrix4( matrix ); // 001 points[ 2 ].set( this.min.x, this.max.y, this.min.z ).applyMatrix4( matrix ); // 010 points[ 3 ].set( this.min.x, this.max.y, this.max.z ).applyMatrix4( matrix ); // 011 points[ 4 ].set( this.max.x, this.min.y, this.min.z ).applyMatrix4( matrix ); // 100 points[ 5 ].set( this.max.x, this.min.y, this.max.z ).applyMatrix4( matrix ); // 101 points[ 6 ].set( this.max.x, this.max.y, this.min.z ).applyMatrix4( matrix ); // 110 points[ 7 ].set( this.max.x, this.max.y, this.max.z ).applyMatrix4( matrix ); // 111 this.setFromPoints( points ); return this; }; }(), translate: function ( offset ) { this.min.add( offset ); this.max.add( offset ); return this; }, equals: function ( box ) { return box.min.equals( this.min ) && box.max.equals( this.max ); } } ); /** * @author bhouston / http://clara.io * @author mrdoob / http://mrdoob.com/ */ function Sphere( center, radius ) { this.center = ( center !== undefined ) ? center : new Vector3(); this.radius = ( radius !== undefined ) ? radius : 0; } Object.assign( Sphere.prototype, { set: function ( center, radius ) { this.center.copy( center ); this.radius = radius; return this; }, setFromPoints: function () { var box = new Box3(); return function setFromPoints( points, optionalCenter ) { var center = this.center; if ( optionalCenter !== undefined ) { center.copy( optionalCenter ); } else { box.setFromPoints( points ).getCenter( center ); } var maxRadiusSq = 0; for ( var i = 0, il = points.length; i < il; i ++ ) { maxRadiusSq = Math.max( maxRadiusSq, center.distanceToSquared( points[ i ] ) ); } this.radius = Math.sqrt( maxRadiusSq ); return this; }; }(), clone: function () { return new this.constructor().copy( this ); }, copy: function ( sphere ) { this.center.copy( sphere.center ); this.radius = sphere.radius; return this; }, empty: function () { return ( this.radius 1 ) { return undefined; } return target.copy( direction ).multiplyScalar( t ).add( line.start ); }; }(), intersectsLine: function ( line ) { // Note: this tests if a line intersects the plane, not whether it (or its end-points) are coplanar with it. var startSign = this.distanceToPoint( line.start ); var endSign = this.distanceToPoint( line.end ); return ( startSign < 0 && endSign > 0 ) || ( endSign < 0 && startSign > 0 ); }, intersectsBox: function ( box ) { return box.intersectsPlane( this ); }, intersectsSphere: function ( sphere ) { return sphere.intersectsPlane( this ); }, coplanarPoint: function ( target ) { if ( target === undefined ) { console.warn( 'THREE.Plane: .coplanarPoint() target is now required' ); target = new Vector3(); } return target.copy( this.normal ).multiplyScalar( - this.constant ); }, applyMatrix4: function () { var v1 = new Vector3(); var m1 = new Matrix3(); return function applyMatrix4( matrix, optionalNormalMatrix ) { var normalMatrix = optionalNormalMatrix || m1.getNormalMatrix( matrix ); var referencePoint = this.coplanarPoint( v1 ).applyMatrix4( matrix ); var normal = this.normal.applyMatrix3( normalMatrix ).normalize(); this.constant = - referencePoint.dot( normal ); return this; }; }(), translate: function ( offset ) { this.constant -= offset.dot( this.normal ); return this; }, equals: function ( plane ) { return plane.normal.equals( this.normal ) && ( plane.constant === this.constant ); } } ); /** * @author mrdoob / http://mrdoob.com/ * @author alteredq / http://alteredqualia.com/ * @author bhouston / http://clara.io */ function Frustum( p0, p1, p2, p3, p4, p5 ) { this.planes = [ ( p0 !== undefined ) ? p0 : new Plane(), ( p1 !== undefined ) ? p1 : new Plane(), ( p2 !== undefined ) ? p2 : new Plane(), ( p3 !== undefined ) ? p3 : new Plane(), ( p4 !== undefined ) ? p4 : new Plane(), ( p5 !== undefined ) ? p5 : new Plane() ]; } Object.assign( Frustum.prototype, { set: function ( p0, p1, p2, p3, p4, p5 ) { var planes = this.planes; planes[ 0 ].copy( p0 ); planes[ 1 ].copy( p1 ); planes[ 2 ].copy( p2 ); planes[ 3 ].copy( p3 ); planes[ 4 ].copy( p4 ); planes[ 5 ].copy( p5 ); return this; }, clone: function () { return new this.constructor().copy( this ); }, copy: function ( frustum ) { var planes = this.planes; for ( var i = 0; i < 6; i ++ ) { planes[ i ].copy( frustum.planes[ i ] ); } return this; }, setFromMatrix: function ( m ) { var planes = this.planes; var me = m.elements; var me0 = me[ 0 ], me1 = me[ 1 ], me2 = me[ 2 ], me3 = me[ 3 ]; var me4 = me[ 4 ], me5 = me[ 5 ], me6 = me[ 6 ], me7 = me[ 7 ]; var me8 = me[ 8 ], me9 = me[ 9 ], me10 = me[ 10 ], me11 = me[ 11 ]; var me12 = me[ 12 ], me13 = me[ 13 ], me14 = me[ 14 ], me15 = me[ 15 ]; planes[ 0 ].setComponents( me3 - me0, me7 - me4, me11 - me8, me15 - me12 ).normalize(); planes[ 1 ].setComponents( me3 + me0, me7 + me4, me11 + me8, me15 + me12 ).normalize(); planes[ 2 ].setComponents( me3 + me1, me7 + me5, me11 + me9, me15 + me13 ).normalize(); planes[ 3 ].setComponents( me3 - me1, me7 - me5, me11 - me9, me15 - me13 ).normalize(); planes[ 4 ].setComponents( me3 - me2, me7 - me6, me11 - me10, me15 - me14 ).normalize(); planes[ 5 ].setComponents( me3 + me2, me7 + me6, me11 + me10, me15 + me14 ).normalize(); return this; }, intersectsObject: function () { var sphere = new Sphere(); return function intersectsObject( object ) { var geometry = object.geometry; if ( geometry.boundingSphere === null ) geometry.computeBoundingSphere(); sphere.copy( geometry.boundingSphere ) .applyMatrix4( object.matrixWorld ); return this.intersectsSphere( sphere ); }; }(), intersectsSprite: function () { var sphere = new Sphere(); return function intersectsSprite( sprite ) { sphere.center.set( 0, 0, 0 ); sphere.radius = 0.7071067811865476; sphere.applyMatrix4( sprite.matrixWorld ); return this.intersectsSphere( sphere ); }; }(), intersectsSphere: function ( sphere ) { var planes = this.planes; var center = sphere.center; var negRadius = - sphere.radius; for ( var i = 0; i < 6; i ++ ) { var distance = planes[ i ].distanceToPoint( center ); if ( distance < negRadius ) { return false; } } return true; }, intersectsBox: function () { var p = new Vector3(); return function intersectsBox( box ) { var planes = this.planes; for ( var i = 0; i < 6; i ++ ) { var plane = planes[ i ]; // corner at max distance p.x = plane.normal.x > 0 ? box.max.x : box.min.x; p.y = plane.normal.y > 0 ? box.max.y : box.min.y; p.z = plane.normal.z > 0 ? box.max.z : box.min.z; if ( plane.distanceToPoint( p ) < 0 ) { return false; } } return true; }; }(), containsPoint: function ( point ) { var planes = this.planes; for ( var i = 0; i < 6; i ++ ) { if ( planes[ i ].distanceToPoint( point ) < 0 ) { return false; } } return true; } } ); var alphamap_fragment = \"#ifdef USE_ALPHAMAP\\n\\tdiffuseColor.a *= texture2D( alphaMap, vUv ).g;\\n#endif\"; var alphamap_pars_fragment = \"#ifdef USE_ALPHAMAP\\n\\tuniform sampler2D alphaMap;\\n#endif\"; var alphatest_fragment = \"#ifdef ALPHATEST\\n\\tif ( diffuseColor.a < ALPHATEST ) discard;\\n#endif\"; var aomap_fragment = \"#ifdef USE_AOMAP\\n\\tfloat ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\\n\\treflectedLight.indirectDiffuse *= ambientOcclusion;\\n\\t#if defined( USE_ENVMAP ) && defined( PHYSICAL )\\n\\t\\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\\n\\t\\treflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.specularRoughness );\\n\\t#endif\\n#endif\"; var aomap_pars_fragment = \"#ifdef USE_AOMAP\\n\\tuniform sampler2D aoMap;\\n\\tuniform float aoMapIntensity;\\n#endif\"; var begin_vertex = \"vec3 transformed = vec3( position );\"; var beginnormal_vertex = \"vec3 objectNormal = vec3( normal );\"; var bsdfs = \"vec2 integrateSpecularBRDF( const in float dotNV, const in float roughness ) {\\n\\tconst vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\\n\\tconst vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\\n\\tvec4 r = roughness * c0 + c1;\\n\\tfloat a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\\n\\treturn vec2( -1.04, 1.04 ) * a004 + r.zw;\\n}\\nfloat punctualLightIntensityToIrradianceFactor( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\\n#if defined ( PHYSICALLY_CORRECT_LIGHTS )\\n\\tfloat distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\\n\\tif( cutoffDistance > 0.0 ) {\\n\\t\\tdistanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\\n\\t}\\n\\treturn distanceFalloff;\\n#else\\n\\tif( cutoffDistance > 0.0 && decayExponent > 0.0 ) {\\n\\t\\treturn pow( saturate( -lightDistance / cutoffDistance + 1.0 ), decayExponent );\\n\\t}\\n\\treturn 1.0;\\n#endif\\n}\\nvec3 BRDF_Diffuse_Lambert( const in vec3 diffuseColor ) {\\n\\treturn RECIPROCAL_PI * diffuseColor;\\n}\\nvec3 F_Schlick( const in vec3 specularColor, const in float dotLH ) {\\n\\tfloat fresnel = exp2( ( -5.55473 * dotLH - 6.98316 ) * dotLH );\\n\\treturn ( 1.0 - specularColor ) * fresnel + specularColor;\\n}\\nfloat G_GGX_Smith( const in float alpha, const in float dotNL, const in float dotNV ) {\\n\\tfloat a2 = pow2( alpha );\\n\\tfloat gl = dotNL + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\\n\\tfloat gv = dotNV + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\\n\\treturn 1.0 / ( gl * gv );\\n}\\nfloat G_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\\n\\tfloat a2 = pow2( alpha );\\n\\tfloat gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\\n\\tfloat gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\\n\\treturn 0.5 / max( gv + gl, EPSILON );\\n}\\nfloat D_GGX( const in float alpha, const in float dotNH ) {\\n\\tfloat a2 = pow2( alpha );\\n\\tfloat denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\\n\\treturn RECIPROCAL_PI * a2 / pow2( denom );\\n}\\nvec3 BRDF_Specular_GGX( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float roughness ) {\\n\\tfloat alpha = pow2( roughness );\\n\\tvec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\\n\\tfloat dotNL = saturate( dot( geometry.normal, incidentLight.direction ) );\\n\\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\\n\\tfloat dotNH = saturate( dot( geometry.normal, halfDir ) );\\n\\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\\n\\tvec3 F = F_Schlick( specularColor, dotLH );\\n\\tfloat G = G_GGX_SmithCorrelated( alpha, dotNL, dotNV );\\n\\tfloat D = D_GGX( alpha, dotNH );\\n\\treturn F * ( G * D );\\n}\\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\\n\\tconst float LUT_SIZE = 64.0;\\n\\tconst float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\\n\\tconst float LUT_BIAS = 0.5 / LUT_SIZE;\\n\\tfloat dotNV = saturate( dot( N, V ) );\\n\\tvec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );\\n\\tuv = uv * LUT_SCALE + LUT_BIAS;\\n\\treturn uv;\\n}\\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\\n\\tfloat l = length( f );\\n\\treturn max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\\n}\\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\\n\\tfloat x = dot( v1, v2 );\\n\\tfloat y = abs( x );\\n\\tfloat a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;\\n\\tfloat b = 3.4175940 + ( 4.1616724 + y ) * y;\\n\\tfloat v = a / b;\\n\\tfloat theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;\\n\\treturn cross( v1, v2 ) * theta_sintheta;\\n}\\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\\n\\tvec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\\n\\tvec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\\n\\tvec3 lightNormal = cross( v1, v2 );\\n\\tif( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\\n\\tvec3 T1, T2;\\n\\tT1 = normalize( V - N * dot( V, N ) );\\n\\tT2 = - cross( N, T1 );\\n\\tmat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\\n\\tvec3 coords[ 4 ];\\n\\tcoords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\\n\\tcoords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\\n\\tcoords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\\n\\tcoords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\\n\\tcoords[ 0 ] = normalize( coords[ 0 ] );\\n\\tcoords[ 1 ] = normalize( coords[ 1 ] );\\n\\tcoords[ 2 ] = normalize( coords[ 2 ] );\\n\\tcoords[ 3 ] = normalize( coords[ 3 ] );\\n\\tvec3 vectorFormFactor = vec3( 0.0 );\\n\\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\\n\\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\\n\\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\\n\\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\\n\\tfloat result = LTC_ClippedSphereFormFactor( vectorFormFactor );\\n\\treturn vec3( result );\\n}\\nvec3 BRDF_Specular_GGX_Environment( const in GeometricContext geometry, const in vec3 specularColor, const in float roughness ) {\\n\\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\\n\\tvec2 brdf = integrateSpecularBRDF( dotNV, roughness );\\n\\treturn specularColor * brdf.x + brdf.y;\\n}\\nvoid BRDF_Specular_Multiscattering_Environment( const in GeometricContext geometry, const in vec3 specularColor, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\\n\\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\\n\\tvec3 F = F_Schlick( specularColor, dotNV );\\n\\tvec2 brdf = integrateSpecularBRDF( dotNV, roughness );\\n\\tvec3 FssEss = F * brdf.x + brdf.y;\\n\\tfloat Ess = brdf.x + brdf.y;\\n\\tfloat Ems = 1.0 - Ess;\\n\\tvec3 Favg = specularColor + ( 1.0 - specularColor ) * 0.047619;\\tvec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );\\n\\tsingleScatter += FssEss;\\n\\tmultiScatter += Fms * Ems;\\n}\\nfloat G_BlinnPhong_Implicit( ) {\\n\\treturn 0.25;\\n}\\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\\n\\treturn RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\\n}\\nvec3 BRDF_Specular_BlinnPhong( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float shininess ) {\\n\\tvec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\\n\\tfloat dotNH = saturate( dot( geometry.normal, halfDir ) );\\n\\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\\n\\tvec3 F = F_Schlick( specularColor, dotLH );\\n\\tfloat G = G_BlinnPhong_Implicit( );\\n\\tfloat D = D_BlinnPhong( shininess, dotNH );\\n\\treturn F * ( G * D );\\n}\\nfloat GGXRoughnessToBlinnExponent( const in float ggxRoughness ) {\\n\\treturn ( 2.0 / pow2( ggxRoughness + 0.0001 ) - 2.0 );\\n}\\nfloat BlinnExponentToGGXRoughness( const in float blinnExponent ) {\\n\\treturn sqrt( 2.0 / ( blinnExponent + 2.0 ) );\\n}\"; var bumpmap_pars_fragment = \"#ifdef USE_BUMPMAP\\n\\tuniform sampler2D bumpMap;\\n\\tuniform float bumpScale;\\n\\tvec2 dHdxy_fwd() {\\n\\t\\tvec2 dSTdx = dFdx( vUv );\\n\\t\\tvec2 dSTdy = dFdy( vUv );\\n\\t\\tfloat Hll = bumpScale * texture2D( bumpMap, vUv ).x;\\n\\t\\tfloat dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\\n\\t\\tfloat dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\\n\\t\\treturn vec2( dBx, dBy );\\n\\t}\\n\\tvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy ) {\\n\\t\\tvec3 vSigmaX = vec3( dFdx( surf_pos.x ), dFdx( surf_pos.y ), dFdx( surf_pos.z ) );\\n\\t\\tvec3 vSigmaY = vec3( dFdy( surf_pos.x ), dFdy( surf_pos.y ), dFdy( surf_pos.z ) );\\n\\t\\tvec3 vN = surf_norm;\\n\\t\\tvec3 R1 = cross( vSigmaY, vN );\\n\\t\\tvec3 R2 = cross( vN, vSigmaX );\\n\\t\\tfloat fDet = dot( vSigmaX, R1 );\\n\\t\\tfDet *= ( float( gl_FrontFacing ) * 2.0 - 1.0 );\\n\\t\\tvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\\n\\t\\treturn normalize( abs( fDet ) * surf_norm - vGrad );\\n\\t}\\n#endif\"; var clipping_planes_fragment = \"#if NUM_CLIPPING_PLANES > 0\\n\\tvec4 plane;\\n\\t#pragma unroll_loop\\n\\tfor ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\\n\\t\\tplane = clippingPlanes[ i ];\\n\\t\\tif ( dot( vViewPosition, plane.xyz ) > plane.w ) discard;\\n\\t}\\n\\t#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\\n\\t\\tbool clipped = true;\\n\\t\\t#pragma unroll_loop\\n\\t\\tfor ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\\n\\t\\t\\tplane = clippingPlanes[ i ];\\n\\t\\t\\tclipped = ( dot( vViewPosition, plane.xyz ) > plane.w ) && clipped;\\n\\t\\t}\\n\\t\\tif ( clipped ) discard;\\n\\t#endif\\n#endif\"; var clipping_planes_pars_fragment = \"#if NUM_CLIPPING_PLANES > 0\\n\\t#if ! defined( PHYSICAL ) && ! defined( PHONG ) && ! defined( MATCAP )\\n\\t\\tvarying vec3 vViewPosition;\\n\\t#endif\\n\\tuniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\\n#endif\"; var clipping_planes_pars_vertex = \"#if NUM_CLIPPING_PLANES > 0 && ! defined( PHYSICAL ) && ! defined( PHONG ) && ! defined( MATCAP )\\n\\tvarying vec3 vViewPosition;\\n#endif\"; var clipping_planes_vertex = \"#if NUM_CLIPPING_PLANES > 0 && ! defined( PHYSICAL ) && ! defined( PHONG ) && ! defined( MATCAP )\\n\\tvViewPosition = - mvPosition.xyz;\\n#endif\"; var color_fragment = \"#ifdef USE_COLOR\\n\\tdiffuseColor.rgb *= vColor;\\n#endif\"; var color_pars_fragment = \"#ifdef USE_COLOR\\n\\tvarying vec3 vColor;\\n#endif\"; var color_pars_vertex = \"#ifdef USE_COLOR\\n\\tvarying vec3 vColor;\\n#endif\"; var color_vertex = \"#ifdef USE_COLOR\\n\\tvColor.xyz = color.xyz;\\n#endif\"; var common = \"#define PI 3.14159265359\\n#define PI2 6.28318530718\\n#define PI_HALF 1.5707963267949\\n#define RECIPROCAL_PI 0.31830988618\\n#define RECIPROCAL_PI2 0.15915494\\n#define LOG2 1.442695\\n#define EPSILON 1e-6\\n#define saturate(a) clamp( a, 0.0, 1.0 )\\n#define whiteCompliment(a) ( 1.0 - saturate( a ) )\\nfloat pow2( const in float x ) { return x*x; }\\nfloat pow3( const in float x ) { return x*x*x; }\\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\\nfloat average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }\\nhighp float rand( const in vec2 uv ) {\\n\\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\\n\\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\\n\\treturn fract(sin(sn) * c);\\n}\\nstruct IncidentLight {\\n\\tvec3 color;\\n\\tvec3 direction;\\n\\tbool visible;\\n};\\nstruct ReflectedLight {\\n\\tvec3 directDiffuse;\\n\\tvec3 directSpecular;\\n\\tvec3 indirectDiffuse;\\n\\tvec3 indirectSpecular;\\n};\\nstruct GeometricContext {\\n\\tvec3 position;\\n\\tvec3 normal;\\n\\tvec3 viewDir;\\n};\\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\\n\\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\\n}\\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\\n\\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\\n}\\nvec3 projectOnPlane(in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\\n\\tfloat distance = dot( planeNormal, point - pointOnPlane );\\n\\treturn - distance * planeNormal + point;\\n}\\nfloat sideOfPlane( in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\\n\\treturn sign( dot( point - pointOnPlane, planeNormal ) );\\n}\\nvec3 linePlaneIntersect( in vec3 pointOnLine, in vec3 lineDirection, in vec3 pointOnPlane, in vec3 planeNormal ) {\\n\\treturn lineDirection * ( dot( planeNormal, pointOnPlane - pointOnLine ) / dot( planeNormal, lineDirection ) ) + pointOnLine;\\n}\\nmat3 transposeMat3( const in mat3 m ) {\\n\\tmat3 tmp;\\n\\ttmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\\n\\ttmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\\n\\ttmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\\n\\treturn tmp;\\n}\\nfloat linearToRelativeLuminance( const in vec3 color ) {\\n\\tvec3 weights = vec3( 0.2126, 0.7152, 0.0722 );\\n\\treturn dot( weights, color.rgb );\\n}\"; var cube_uv_reflection_fragment = \"#ifdef ENVMAP_TYPE_CUBE_UV\\n#define cubeUV_textureSize (1024.0)\\nint getFaceFromDirection(vec3 direction) {\\n\\tvec3 absDirection = abs(direction);\\n\\tint face = -1;\\n\\tif( absDirection.x > absDirection.z ) {\\n\\t\\tif(absDirection.x > absDirection.y )\\n\\t\\t\\tface = direction.x > 0.0 ? 0 : 3;\\n\\t\\telse\\n\\t\\t\\tface = direction.y > 0.0 ? 1 : 4;\\n\\t}\\n\\telse {\\n\\t\\tif(absDirection.z > absDirection.y )\\n\\t\\t\\tface = direction.z > 0.0 ? 2 : 5;\\n\\t\\telse\\n\\t\\t\\tface = direction.y > 0.0 ? 1 : 4;\\n\\t}\\n\\treturn face;\\n}\\n#define cubeUV_maxLods1 (log2(cubeUV_textureSize*0.25) - 1.0)\\n#define cubeUV_rangeClamp (exp2((6.0 - 1.0) * 2.0))\\nvec2 MipLevelInfo( vec3 vec, float roughnessLevel, float roughness ) {\\n\\tfloat scale = exp2(cubeUV_maxLods1 - roughnessLevel);\\n\\tfloat dxRoughness = dFdx(roughness);\\n\\tfloat dyRoughness = dFdy(roughness);\\n\\tvec3 dx = dFdx( vec * scale * dxRoughness );\\n\\tvec3 dy = dFdy( vec * scale * dyRoughness );\\n\\tfloat d = max( dot( dx, dx ), dot( dy, dy ) );\\n\\td = clamp(d, 1.0, cubeUV_rangeClamp);\\n\\tfloat mipLevel = 0.5 * log2(d);\\n\\treturn vec2(floor(mipLevel), fract(mipLevel));\\n}\\n#define cubeUV_maxLods2 (log2(cubeUV_textureSize*0.25) - 2.0)\\n#define cubeUV_rcpTextureSize (1.0 / cubeUV_textureSize)\\nvec2 getCubeUV(vec3 direction, float roughnessLevel, float mipLevel) {\\n\\tmipLevel = roughnessLevel > cubeUV_maxLods2 - 3.0 ? 0.0 : mipLevel;\\n\\tfloat a = 16.0 * cubeUV_rcpTextureSize;\\n\\tvec2 exp2_packed = exp2( vec2( roughnessLevel, mipLevel ) );\\n\\tvec2 rcp_exp2_packed = vec2( 1.0 ) / exp2_packed;\\n\\tfloat powScale = exp2_packed.x * exp2_packed.y;\\n\\tfloat scale = rcp_exp2_packed.x * rcp_exp2_packed.y * 0.25;\\n\\tfloat mipOffset = 0.75*(1.0 - rcp_exp2_packed.y) * rcp_exp2_packed.x;\\n\\tbool bRes = mipLevel == 0.0;\\n\\tscale = bRes && (scale < a) ? a : scale;\\n\\tvec3 r;\\n\\tvec2 offset;\\n\\tint face = getFaceFromDirection(direction);\\n\\tfloat rcpPowScale = 1.0 / powScale;\\n\\tif( face == 0) {\\n\\t\\tr = vec3(direction.x, -direction.z, direction.y);\\n\\t\\toffset = vec2(0.0+mipOffset,0.75 * rcpPowScale);\\n\\t\\toffset.y = bRes && (offset.y < 2.0*a) ? a : offset.y;\\n\\t}\\n\\telse if( face == 1) {\\n\\t\\tr = vec3(direction.y, direction.x, direction.z);\\n\\t\\toffset = vec2(scale+mipOffset, 0.75 * rcpPowScale);\\n\\t\\toffset.y = bRes && (offset.y < 2.0*a) ? a : offset.y;\\n\\t}\\n\\telse if( face == 2) {\\n\\t\\tr = vec3(direction.z, direction.x, direction.y);\\n\\t\\toffset = vec2(2.0*scale+mipOffset, 0.75 * rcpPowScale);\\n\\t\\toffset.y = bRes && (offset.y < 2.0*a) ? a : offset.y;\\n\\t}\\n\\telse if( face == 3) {\\n\\t\\tr = vec3(direction.x, direction.z, direction.y);\\n\\t\\toffset = vec2(0.0+mipOffset,0.5 * rcpPowScale);\\n\\t\\toffset.y = bRes && (offset.y < 2.0*a) ? 0.0 : offset.y;\\n\\t}\\n\\telse if( face == 4) {\\n\\t\\tr = vec3(direction.y, direction.x, -direction.z);\\n\\t\\toffset = vec2(scale+mipOffset, 0.5 * rcpPowScale);\\n\\t\\toffset.y = bRes && (offset.y < 2.0*a) ? 0.0 : offset.y;\\n\\t}\\n\\telse {\\n\\t\\tr = vec3(direction.z, -direction.x, direction.y);\\n\\t\\toffset = vec2(2.0*scale+mipOffset, 0.5 * rcpPowScale);\\n\\t\\toffset.y = bRes && (offset.y < 2.0*a) ? 0.0 : offset.y;\\n\\t}\\n\\tr = normalize(r);\\n\\tfloat texelOffset = 0.5 * cubeUV_rcpTextureSize;\\n\\tvec2 s = ( r.yz / abs( r.x ) + vec2( 1.0 ) ) * 0.5;\\n\\tvec2 base = offset + vec2( texelOffset );\\n\\treturn base + s * ( scale - 2.0 * texelOffset );\\n}\\n#define cubeUV_maxLods3 (log2(cubeUV_textureSize*0.25) - 3.0)\\nvec4 textureCubeUV( sampler2D envMap, vec3 reflectedDirection, float roughness ) {\\n\\tfloat roughnessVal = roughness* cubeUV_maxLods3;\\n\\tfloat r1 = floor(roughnessVal);\\n\\tfloat r2 = r1 + 1.0;\\n\\tfloat t = fract(roughnessVal);\\n\\tvec2 mipInfo = MipLevelInfo(reflectedDirection, r1, roughness);\\n\\tfloat s = mipInfo.y;\\n\\tfloat level0 = mipInfo.x;\\n\\tfloat level1 = level0 + 1.0;\\n\\tlevel1 = level1 > 5.0 ? 5.0 : level1;\\n\\tlevel0 += min( floor( s + 0.5 ), 5.0 );\\n\\tvec2 uv_10 = getCubeUV(reflectedDirection, r1, level0);\\n\\tvec4 color10 = envMapTexelToLinear(texture2D(envMap, uv_10));\\n\\tvec2 uv_20 = getCubeUV(reflectedDirection, r2, level0);\\n\\tvec4 color20 = envMapTexelToLinear(texture2D(envMap, uv_20));\\n\\tvec4 result = mix(color10, color20, t);\\n\\treturn vec4(result.rgb, 1.0);\\n}\\n#endif\"; var defaultnormal_vertex = \"vec3 transformedNormal = normalMatrix * objectNormal;\\n#ifdef FLIP_SIDED\\n\\ttransformedNormal = - transformedNormal;\\n#endif\"; var displacementmap_pars_vertex = \"#ifdef USE_DISPLACEMENTMAP\\n\\tuniform sampler2D displacementMap;\\n\\tuniform float displacementScale;\\n\\tuniform float displacementBias;\\n#endif\"; var displacementmap_vertex = \"#ifdef USE_DISPLACEMENTMAP\\n\\ttransformed += normalize( objectNormal ) * ( texture2D( displacementMap, uv ).x * displacementScale + displacementBias );\\n#endif\"; var emissivemap_fragment = \"#ifdef USE_EMISSIVEMAP\\n\\tvec4 emissiveColor = texture2D( emissiveMap, vUv );\\n\\temissiveColor.rgb = emissiveMapTexelToLinear( emissiveColor ).rgb;\\n\\ttotalEmissiveRadiance *= emissiveColor.rgb;\\n#endif\"; var emissivemap_pars_fragment = \"#ifdef USE_EMISSIVEMAP\\n\\tuniform sampler2D emissiveMap;\\n#endif\"; var encodings_fragment = \"gl_FragColor = linearToOutputTexel( gl_FragColor );\"; var encodings_pars_fragment = \"\\nvec4 LinearToLinear( in vec4 value ) {\\n\\treturn value;\\n}\\nvec4 GammaToLinear( in vec4 value, in float gammaFactor ) {\\n\\treturn vec4( pow( value.rgb, vec3( gammaFactor ) ), value.a );\\n}\\nvec4 LinearToGamma( in vec4 value, in float gammaFactor ) {\\n\\treturn vec4( pow( value.rgb, vec3( 1.0 / gammaFactor ) ), value.a );\\n}\\nvec4 sRGBToLinear( in vec4 value ) {\\n\\treturn vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.a );\\n}\\nvec4 LinearTosRGB( in vec4 value ) {\\n\\treturn vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );\\n}\\nvec4 RGBEToLinear( in vec4 value ) {\\n\\treturn vec4( value.rgb * exp2( value.a * 255.0 - 128.0 ), 1.0 );\\n}\\nvec4 LinearToRGBE( in vec4 value ) {\\n\\tfloat maxComponent = max( max( value.r, value.g ), value.b );\\n\\tfloat fExp = clamp( ceil( log2( maxComponent ) ), -128.0, 127.0 );\\n\\treturn vec4( value.rgb / exp2( fExp ), ( fExp + 128.0 ) / 255.0 );\\n}\\nvec4 RGBMToLinear( in vec4 value, in float maxRange ) {\\n\\treturn vec4( value.rgb * value.a * maxRange, 1.0 );\\n}\\nvec4 LinearToRGBM( in vec4 value, in float maxRange ) {\\n\\tfloat maxRGB = max( value.r, max( value.g, value.b ) );\\n\\tfloat M = clamp( maxRGB / maxRange, 0.0, 1.0 );\\n\\tM = ceil( M * 255.0 ) / 255.0;\\n\\treturn vec4( value.rgb / ( M * maxRange ), M );\\n}\\nvec4 RGBDToLinear( in vec4 value, in float maxRange ) {\\n\\treturn vec4( value.rgb * ( ( maxRange / 255.0 ) / value.a ), 1.0 );\\n}\\nvec4 LinearToRGBD( in vec4 value, in float maxRange ) {\\n\\tfloat maxRGB = max( value.r, max( value.g, value.b ) );\\n\\tfloat D = max( maxRange / maxRGB, 1.0 );\\n\\tD = min( floor( D ) / 255.0, 1.0 );\\n\\treturn vec4( value.rgb * ( D * ( 255.0 / maxRange ) ), D );\\n}\\nconst mat3 cLogLuvM = mat3( 0.2209, 0.3390, 0.4184, 0.1138, 0.6780, 0.7319, 0.0102, 0.1130, 0.2969 );\\nvec4 LinearToLogLuv( in vec4 value ) {\\n\\tvec3 Xp_Y_XYZp = cLogLuvM * value.rgb;\\n\\tXp_Y_XYZp = max( Xp_Y_XYZp, vec3( 1e-6, 1e-6, 1e-6 ) );\\n\\tvec4 vResult;\\n\\tvResult.xy = Xp_Y_XYZp.xy / Xp_Y_XYZp.z;\\n\\tfloat Le = 2.0 * log2(Xp_Y_XYZp.y) + 127.0;\\n\\tvResult.w = fract( Le );\\n\\tvResult.z = ( Le - ( floor( vResult.w * 255.0 ) ) / 255.0 ) / 255.0;\\n\\treturn vResult;\\n}\\nconst mat3 cLogLuvInverseM = mat3( 6.0014, -2.7008, -1.7996, -1.3320, 3.1029, -5.7721, 0.3008, -1.0882, 5.6268 );\\nvec4 LogLuvToLinear( in vec4 value ) {\\n\\tfloat Le = value.z * 255.0 + value.w;\\n\\tvec3 Xp_Y_XYZp;\\n\\tXp_Y_XYZp.y = exp2( ( Le - 127.0 ) / 2.0 );\\n\\tXp_Y_XYZp.z = Xp_Y_XYZp.y / value.y;\\n\\tXp_Y_XYZp.x = value.x * Xp_Y_XYZp.z;\\n\\tvec3 vRGB = cLogLuvInverseM * Xp_Y_XYZp.rgb;\\n\\treturn vec4( max( vRGB, 0.0 ), 1.0 );\\n}\"; var envmap_fragment = \"#ifdef USE_ENVMAP\\n\\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\\n\\t\\tvec3 cameraToVertex = normalize( vWorldPosition - cameraPosition );\\n\\t\\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\\n\\t\\t#ifdef ENVMAP_MODE_REFLECTION\\n\\t\\t\\tvec3 reflectVec = reflect( cameraToVertex, worldNormal );\\n\\t\\t#else\\n\\t\\t\\tvec3 reflectVec = refract( cameraToVertex, worldNormal, refractionRatio );\\n\\t\\t#endif\\n\\t#else\\n\\t\\tvec3 reflectVec = vReflect;\\n\\t#endif\\n\\t#ifdef ENVMAP_TYPE_CUBE\\n\\t\\tvec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\\n\\t#elif defined( ENVMAP_TYPE_EQUIREC )\\n\\t\\tvec2 sampleUV;\\n\\t\\treflectVec = normalize( reflectVec );\\n\\t\\tsampleUV.y = asin( clamp( reflectVec.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\\n\\t\\tsampleUV.x = atan( reflectVec.z, reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\\n\\t\\tvec4 envColor = texture2D( envMap, sampleUV );\\n\\t#elif defined( ENVMAP_TYPE_SPHERE )\\n\\t\\treflectVec = normalize( reflectVec );\\n\\t\\tvec3 reflectView = normalize( ( viewMatrix * vec4( reflectVec, 0.0 ) ).xyz + vec3( 0.0, 0.0, 1.0 ) );\\n\\t\\tvec4 envColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5 );\\n\\t#else\\n\\t\\tvec4 envColor = vec4( 0.0 );\\n\\t#endif\\n\\tenvColor = envMapTexelToLinear( envColor );\\n\\t#ifdef ENVMAP_BLENDING_MULTIPLY\\n\\t\\toutgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\\n\\t#elif defined( ENVMAP_BLENDING_MIX )\\n\\t\\toutgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\\n\\t#elif defined( ENVMAP_BLENDING_ADD )\\n\\t\\toutgoingLight += envColor.xyz * specularStrength * reflectivity;\\n\\t#endif\\n#endif\"; var envmap_pars_fragment = \"#if defined( USE_ENVMAP ) || defined( PHYSICAL )\\n\\tuniform float reflectivity;\\n\\tuniform float envMapIntensity;\\n#endif\\n#ifdef USE_ENVMAP\\n\\t#if ! defined( PHYSICAL ) && ( defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) )\\n\\t\\tvarying vec3 vWorldPosition;\\n\\t#endif\\n\\t#ifdef ENVMAP_TYPE_CUBE\\n\\t\\tuniform samplerCube envMap;\\n\\t#else\\n\\t\\tuniform sampler2D envMap;\\n\\t#endif\\n\\tuniform float flipEnvMap;\\n\\tuniform int maxMipLevel;\\n\\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( PHYSICAL )\\n\\t\\tuniform float refractionRatio;\\n\\t#else\\n\\t\\tvarying vec3 vReflect;\\n\\t#endif\\n#endif\"; var envmap_pars_vertex = \"#ifdef USE_ENVMAP\\n\\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\\n\\t\\tvarying vec3 vWorldPosition;\\n\\t#else\\n\\t\\tvarying vec3 vReflect;\\n\\t\\tuniform float refractionRatio;\\n\\t#endif\\n#endif\"; var envmap_vertex = \"#ifdef USE_ENVMAP\\n\\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\\n\\t\\tvWorldPosition = worldPosition.xyz;\\n\\t#else\\n\\t\\tvec3 cameraToVertex = normalize( worldPosition.xyz - cameraPosition );\\n\\t\\tvec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\\n\\t\\t#ifdef ENVMAP_MODE_REFLECTION\\n\\t\\t\\tvReflect = reflect( cameraToVertex, worldNormal );\\n\\t\\t#else\\n\\t\\t\\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\\n\\t\\t#endif\\n\\t#endif\\n#endif\"; var fog_vertex = \"#ifdef USE_FOG\\n\\tfogDepth = -mvPosition.z;\\n#endif\"; var fog_pars_vertex = \"#ifdef USE_FOG\\n\\tvarying float fogDepth;\\n#endif\"; var fog_fragment = \"#ifdef USE_FOG\\n\\t#ifdef FOG_EXP2\\n\\t\\tfloat fogFactor = whiteCompliment( exp2( - fogDensity * fogDensity * fogDepth * fogDepth * LOG2 ) );\\n\\t#else\\n\\t\\tfloat fogFactor = smoothstep( fogNear, fogFar, fogDepth );\\n\\t#endif\\n\\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\\n#endif\"; var fog_pars_fragment = \"#ifdef USE_FOG\\n\\tuniform vec3 fogColor;\\n\\tvarying float fogDepth;\\n\\t#ifdef FOG_EXP2\\n\\t\\tuniform float fogDensity;\\n\\t#else\\n\\t\\tuniform float fogNear;\\n\\t\\tuniform float fogFar;\\n\\t#endif\\n#endif\"; var gradientmap_pars_fragment = \"#ifdef TOON\\n\\tuniform sampler2D gradientMap;\\n\\tvec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\\n\\t\\tfloat dotNL = dot( normal, lightDirection );\\n\\t\\tvec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\\n\\t\\t#ifdef USE_GRADIENTMAP\\n\\t\\t\\treturn texture2D( gradientMap, coord ).rgb;\\n\\t\\t#else\\n\\t\\t\\treturn ( coord.x < 0.7 ) ? vec3( 0.7 ) : vec3( 1.0 );\\n\\t\\t#endif\\n\\t}\\n#endif\"; var lightmap_fragment = \"#ifdef USE_LIGHTMAP\\n\\treflectedLight.indirectDiffuse += PI * texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\\n#endif\"; var lightmap_pars_fragment = \"#ifdef USE_LIGHTMAP\\n\\tuniform sampler2D lightMap;\\n\\tuniform float lightMapIntensity;\\n#endif\"; var lights_lambert_vertex = \"vec3 diffuse = vec3( 1.0 );\\nGeometricContext geometry;\\ngeometry.position = mvPosition.xyz;\\ngeometry.normal = normalize( transformedNormal );\\ngeometry.viewDir = normalize( -mvPosition.xyz );\\nGeometricContext backGeometry;\\nbackGeometry.position = geometry.position;\\nbackGeometry.normal = -geometry.normal;\\nbackGeometry.viewDir = geometry.viewDir;\\nvLightFront = vec3( 0.0 );\\nvIndirectFront = vec3( 0.0 );\\n#ifdef DOUBLE_SIDED\\n\\tvLightBack = vec3( 0.0 );\\n\\tvIndirectBack = vec3( 0.0 );\\n#endif\\nIncidentLight directLight;\\nfloat dotNL;\\nvec3 directLightColor_Diffuse;\\n#if NUM_POINT_LIGHTS > 0\\n\\t#pragma unroll_loop\\n\\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\\n\\t\\tgetPointDirectLightIrradiance( pointLights[ i ], geometry, directLight );\\n\\t\\tdotNL = dot( geometry.normal, directLight.direction );\\n\\t\\tdirectLightColor_Diffuse = PI * directLight.color;\\n\\t\\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\\n\\t\\t#ifdef DOUBLE_SIDED\\n\\t\\t\\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\\n\\t\\t#endif\\n\\t}\\n#endif\\n#if NUM_SPOT_LIGHTS > 0\\n\\t#pragma unroll_loop\\n\\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\\n\\t\\tgetSpotDirectLightIrradiance( spotLights[ i ], geometry, directLight );\\n\\t\\tdotNL = dot( geometry.normal, directLight.direction );\\n\\t\\tdirectLightColor_Diffuse = PI * directLight.color;\\n\\t\\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\\n\\t\\t#ifdef DOUBLE_SIDED\\n\\t\\t\\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\\n\\t\\t#endif\\n\\t}\\n#endif\\n#if NUM_DIR_LIGHTS > 0\\n\\t#pragma unroll_loop\\n\\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\\n\\t\\tgetDirectionalDirectLightIrradiance( directionalLights[ i ], geometry, directLight );\\n\\t\\tdotNL = dot( geometry.normal, directLight.direction );\\n\\t\\tdirectLightColor_Diffuse = PI * directLight.color;\\n\\t\\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\\n\\t\\t#ifdef DOUBLE_SIDED\\n\\t\\t\\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\\n\\t\\t#endif\\n\\t}\\n#endif\\n#if NUM_HEMI_LIGHTS > 0\\n\\t#pragma unroll_loop\\n\\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\\n\\t\\tvIndirectFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\\n\\t\\t#ifdef DOUBLE_SIDED\\n\\t\\t\\tvIndirectBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry );\\n\\t\\t#endif\\n\\t}\\n#endif\"; var lights_pars_begin = \"uniform vec3 ambientLightColor;\\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\\n\\tvec3 irradiance = ambientLightColor;\\n\\t#ifndef PHYSICALLY_CORRECT_LIGHTS\\n\\t\\tirradiance *= PI;\\n\\t#endif\\n\\treturn irradiance;\\n}\\n#if NUM_DIR_LIGHTS > 0\\n\\tstruct DirectionalLight {\\n\\t\\tvec3 direction;\\n\\t\\tvec3 color;\\n\\t\\tint shadow;\\n\\t\\tfloat shadowBias;\\n\\t\\tfloat shadowRadius;\\n\\t\\tvec2 shadowMapSize;\\n\\t};\\n\\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\\n\\tvoid getDirectionalDirectLightIrradiance( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight directLight ) {\\n\\t\\tdirectLight.color = directionalLight.color;\\n\\t\\tdirectLight.direction = directionalLight.direction;\\n\\t\\tdirectLight.visible = true;\\n\\t}\\n#endif\\n#if NUM_POINT_LIGHTS > 0\\n\\tstruct PointLight {\\n\\t\\tvec3 position;\\n\\t\\tvec3 color;\\n\\t\\tfloat distance;\\n\\t\\tfloat decay;\\n\\t\\tint shadow;\\n\\t\\tfloat shadowBias;\\n\\t\\tfloat shadowRadius;\\n\\t\\tvec2 shadowMapSize;\\n\\t\\tfloat shadowCameraNear;\\n\\t\\tfloat shadowCameraFar;\\n\\t};\\n\\tuniform PointLight pointLights[ NUM_POINT_LIGHTS ];\\n\\tvoid getPointDirectLightIrradiance( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight directLight ) {\\n\\t\\tvec3 lVector = pointLight.position - geometry.position;\\n\\t\\tdirectLight.direction = normalize( lVector );\\n\\t\\tfloat lightDistance = length( lVector );\\n\\t\\tdirectLight.color = pointLight.color;\\n\\t\\tdirectLight.color *= punctualLightIntensityToIrradianceFactor( lightDistance, pointLight.distance, pointLight.decay );\\n\\t\\tdirectLight.visible = ( directLight.color != vec3( 0.0 ) );\\n\\t}\\n#endif\\n#if NUM_SPOT_LIGHTS > 0\\n\\tstruct SpotLight {\\n\\t\\tvec3 position;\\n\\t\\tvec3 direction;\\n\\t\\tvec3 color;\\n\\t\\tfloat distance;\\n\\t\\tfloat decay;\\n\\t\\tfloat coneCos;\\n\\t\\tfloat penumbraCos;\\n\\t\\tint shadow;\\n\\t\\tfloat shadowBias;\\n\\t\\tfloat shadowRadius;\\n\\t\\tvec2 shadowMapSize;\\n\\t};\\n\\tuniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\\n\\tvoid getSpotDirectLightIrradiance( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight directLight ) {\\n\\t\\tvec3 lVector = spotLight.position - geometry.position;\\n\\t\\tdirectLight.direction = normalize( lVector );\\n\\t\\tfloat lightDistance = length( lVector );\\n\\t\\tfloat angleCos = dot( directLight.direction, spotLight.direction );\\n\\t\\tif ( angleCos > spotLight.coneCos ) {\\n\\t\\t\\tfloat spotEffect = smoothstep( spotLight.coneCos, spotLight.penumbraCos, angleCos );\\n\\t\\t\\tdirectLight.color = spotLight.color;\\n\\t\\t\\tdirectLight.color *= spotEffect * punctualLightIntensityToIrradianceFactor( lightDistance, spotLight.distance, spotLight.decay );\\n\\t\\t\\tdirectLight.visible = true;\\n\\t\\t} else {\\n\\t\\t\\tdirectLight.color = vec3( 0.0 );\\n\\t\\t\\tdirectLight.visible = false;\\n\\t\\t}\\n\\t}\\n#endif\\n#if NUM_RECT_AREA_LIGHTS > 0\\n\\tstruct RectAreaLight {\\n\\t\\tvec3 color;\\n\\t\\tvec3 position;\\n\\t\\tvec3 halfWidth;\\n\\t\\tvec3 halfHeight;\\n\\t};\\n\\tuniform sampler2D ltc_1;\\tuniform sampler2D ltc_2;\\n\\tuniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\\n#endif\\n#if NUM_HEMI_LIGHTS > 0\\n\\tstruct HemisphereLight {\\n\\t\\tvec3 direction;\\n\\t\\tvec3 skyColor;\\n\\t\\tvec3 groundColor;\\n\\t};\\n\\tuniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\\n\\tvec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in GeometricContext geometry ) {\\n\\t\\tfloat dotNL = dot( geometry.normal, hemiLight.direction );\\n\\t\\tfloat hemiDiffuseWeight = 0.5 * dotNL + 0.5;\\n\\t\\tvec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\\n\\t\\t#ifndef PHYSICALLY_CORRECT_LIGHTS\\n\\t\\t\\tirradiance *= PI;\\n\\t\\t#endif\\n\\t\\treturn irradiance;\\n\\t}\\n#endif\"; var envmap_physical_pars_fragment = \"#if defined( USE_ENVMAP ) && defined( PHYSICAL )\\n\\tvec3 getLightProbeIndirectIrradiance( const in GeometricContext geometry, const in int maxMIPLevel ) {\\n\\t\\tvec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\\n\\t\\t#ifdef ENVMAP_TYPE_CUBE\\n\\t\\t\\tvec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\\n\\t\\t\\t#ifdef TEXTURE_LOD_EXT\\n\\t\\t\\t\\tvec4 envMapColor = textureCubeLodEXT( envMap, queryVec, float( maxMIPLevel ) );\\n\\t\\t\\t#else\\n\\t\\t\\t\\tvec4 envMapColor = textureCube( envMap, queryVec, float( maxMIPLevel ) );\\n\\t\\t\\t#endif\\n\\t\\t\\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\\n\\t\\t#elif defined( ENVMAP_TYPE_CUBE_UV )\\n\\t\\t\\tvec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\\n\\t\\t\\tvec4 envMapColor = textureCubeUV( envMap, queryVec, 1.0 );\\n\\t\\t#else\\n\\t\\t\\tvec4 envMapColor = vec4( 0.0 );\\n\\t\\t#endif\\n\\t\\treturn PI * envMapColor.rgb * envMapIntensity;\\n\\t}\\n\\tfloat getSpecularMIPLevel( const in float blinnShininessExponent, const in int maxMIPLevel ) {\\n\\t\\tfloat maxMIPLevelScalar = float( maxMIPLevel );\\n\\t\\tfloat desiredMIPLevel = maxMIPLevelScalar + 0.79248 - 0.5 * log2( pow2( blinnShininessExponent ) + 1.0 );\\n\\t\\treturn clamp( desiredMIPLevel, 0.0, maxMIPLevelScalar );\\n\\t}\\n\\tvec3 getLightProbeIndirectRadiance( const in GeometricContext geometry, const in float blinnShininessExponent, const in int maxMIPLevel ) {\\n\\t\\t#ifdef ENVMAP_MODE_REFLECTION\\n\\t\\t\\tvec3 reflectVec = reflect( -geometry.viewDir, geometry.normal );\\n\\t\\t#else\\n\\t\\t\\tvec3 reflectVec = refract( -geometry.viewDir, geometry.normal, refractionRatio );\\n\\t\\t#endif\\n\\t\\treflectVec = inverseTransformDirection( reflectVec, viewMatrix );\\n\\t\\tfloat specularMIPLevel = getSpecularMIPLevel( blinnShininessExponent, maxMIPLevel );\\n\\t\\t#ifdef ENVMAP_TYPE_CUBE\\n\\t\\t\\tvec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\\n\\t\\t\\t#ifdef TEXTURE_LOD_EXT\\n\\t\\t\\t\\tvec4 envMapColor = textureCubeLodEXT( envMap, queryReflectVec, specularMIPLevel );\\n\\t\\t\\t#else\\n\\t\\t\\t\\tvec4 envMapColor = textureCube( envMap, queryReflectVec, specularMIPLevel );\\n\\t\\t\\t#endif\\n\\t\\t\\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\\n\\t\\t#elif defined( ENVMAP_TYPE_CUBE_UV )\\n\\t\\t\\tvec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\\n\\t\\t\\tvec4 envMapColor = textureCubeUV( envMap, queryReflectVec, BlinnExponentToGGXRoughness(blinnShininessExponent ));\\n\\t\\t#elif defined( ENVMAP_TYPE_EQUIREC )\\n\\t\\t\\tvec2 sampleUV;\\n\\t\\t\\tsampleUV.y = asin( clamp( reflectVec.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\\n\\t\\t\\tsampleUV.x = atan( reflectVec.z, reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\\n\\t\\t\\t#ifdef TEXTURE_LOD_EXT\\n\\t\\t\\t\\tvec4 envMapColor = texture2DLodEXT( envMap, sampleUV, specularMIPLevel );\\n\\t\\t\\t#else\\n\\t\\t\\t\\tvec4 envMapColor = texture2D( envMap, sampleUV, specularMIPLevel );\\n\\t\\t\\t#endif\\n\\t\\t\\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\\n\\t\\t#elif defined( ENVMAP_TYPE_SPHERE )\\n\\t\\t\\tvec3 reflectView = normalize( ( viewMatrix * vec4( reflectVec, 0.0 ) ).xyz + vec3( 0.0,0.0,1.0 ) );\\n\\t\\t\\t#ifdef TEXTURE_LOD_EXT\\n\\t\\t\\t\\tvec4 envMapColor = texture2DLodEXT( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );\\n\\t\\t\\t#else\\n\\t\\t\\t\\tvec4 envMapColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );\\n\\t\\t\\t#endif\\n\\t\\t\\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\\n\\t\\t#endif\\n\\t\\treturn envMapColor.rgb * envMapIntensity;\\n\\t}\\n#endif\"; var lights_phong_fragment = \"BlinnPhongMaterial material;\\nmaterial.diffuseColor = diffuseColor.rgb;\\nmaterial.specularColor = specular;\\nmaterial.specularShininess = shininess;\\nmaterial.specularStrength = specularStrength;\"; var lights_phong_pars_fragment = \"varying vec3 vViewPosition;\\n#ifndef FLAT_SHADED\\n\\tvarying vec3 vNormal;\\n#endif\\nstruct BlinnPhongMaterial {\\n\\tvec3\\tdiffuseColor;\\n\\tvec3\\tspecularColor;\\n\\tfloat\\tspecularShininess;\\n\\tfloat\\tspecularStrength;\\n};\\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\\n\\t#ifdef TOON\\n\\t\\tvec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;\\n\\t#else\\n\\t\\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\\n\\t\\tvec3 irradiance = dotNL * directLight.color;\\n\\t#endif\\n\\t#ifndef PHYSICALLY_CORRECT_LIGHTS\\n\\t\\tirradiance *= PI;\\n\\t#endif\\n\\treflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\\n\\treflectedLight.directSpecular += irradiance * BRDF_Specular_BlinnPhong( directLight, geometry, material.specularColor, material.specularShininess ) * material.specularStrength;\\n}\\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\\n\\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\\n}\\n#define RE_Direct\\t\\t\\t\\tRE_Direct_BlinnPhong\\n#define RE_IndirectDiffuse\\t\\tRE_IndirectDiffuse_BlinnPhong\\n#define Material_LightProbeLOD( material )\\t(0)\"; var lights_physical_fragment = \"PhysicalMaterial material;\\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\\nmaterial.specularRoughness = clamp( roughnessFactor, 0.04, 1.0 );\\n#ifdef STANDARD\\n\\tmaterial.specularColor = mix( vec3( DEFAULT_SPECULAR_COEFFICIENT ), diffuseColor.rgb, metalnessFactor );\\n#else\\n\\tmaterial.specularColor = mix( vec3( MAXIMUM_SPECULAR_COEFFICIENT * pow2( reflectivity ) ), diffuseColor.rgb, metalnessFactor );\\n\\tmaterial.clearCoat = saturate( clearCoat );\\tmaterial.clearCoatRoughness = clamp( clearCoatRoughness, 0.04, 1.0 );\\n#endif\"; var lights_physical_pars_fragment = \"struct PhysicalMaterial {\\n\\tvec3\\tdiffuseColor;\\n\\tfloat\\tspecularRoughness;\\n\\tvec3\\tspecularColor;\\n\\t#ifndef STANDARD\\n\\t\\tfloat clearCoat;\\n\\t\\tfloat clearCoatRoughness;\\n\\t#endif\\n};\\n#define MAXIMUM_SPECULAR_COEFFICIENT 0.16\\n#define DEFAULT_SPECULAR_COEFFICIENT 0.04\\nfloat clearCoatDHRApprox( const in float roughness, const in float dotNL ) {\\n\\treturn DEFAULT_SPECULAR_COEFFICIENT + ( 1.0 - DEFAULT_SPECULAR_COEFFICIENT ) * ( pow( 1.0 - dotNL, 5.0 ) * pow( 1.0 - roughness, 2.0 ) );\\n}\\n#if NUM_RECT_AREA_LIGHTS > 0\\n\\tvoid RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\\n\\t\\tvec3 normal = geometry.normal;\\n\\t\\tvec3 viewDir = geometry.viewDir;\\n\\t\\tvec3 position = geometry.position;\\n\\t\\tvec3 lightPos = rectAreaLight.position;\\n\\t\\tvec3 halfWidth = rectAreaLight.halfWidth;\\n\\t\\tvec3 halfHeight = rectAreaLight.halfHeight;\\n\\t\\tvec3 lightColor = rectAreaLight.color;\\n\\t\\tfloat roughness = material.specularRoughness;\\n\\t\\tvec3 rectCoords[ 4 ];\\n\\t\\trectCoords[ 0 ] = lightPos + halfWidth - halfHeight;\\t\\trectCoords[ 1 ] = lightPos - halfWidth - halfHeight;\\n\\t\\trectCoords[ 2 ] = lightPos - halfWidth + halfHeight;\\n\\t\\trectCoords[ 3 ] = lightPos + halfWidth + halfHeight;\\n\\t\\tvec2 uv = LTC_Uv( normal, viewDir, roughness );\\n\\t\\tvec4 t1 = texture2D( ltc_1, uv );\\n\\t\\tvec4 t2 = texture2D( ltc_2, uv );\\n\\t\\tmat3 mInv = mat3(\\n\\t\\t\\tvec3( t1.x, 0, t1.y ),\\n\\t\\t\\tvec3( 0, 1, 0 ),\\n\\t\\t\\tvec3( t1.z, 0, t1.w )\\n\\t\\t);\\n\\t\\tvec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );\\n\\t\\treflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\\n\\t\\treflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );\\n\\t}\\n#endif\\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\\n\\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\\n\\tvec3 irradiance = dotNL * directLight.color;\\n\\t#ifndef PHYSICALLY_CORRECT_LIGHTS\\n\\t\\tirradiance *= PI;\\n\\t#endif\\n\\t#ifndef STANDARD\\n\\t\\tfloat clearCoatDHR = material.clearCoat * clearCoatDHRApprox( material.clearCoatRoughness, dotNL );\\n\\t#else\\n\\t\\tfloat clearCoatDHR = 0.0;\\n\\t#endif\\n\\treflectedLight.directSpecular += ( 1.0 - clearCoatDHR ) * irradiance * BRDF_Specular_GGX( directLight, geometry, material.specularColor, material.specularRoughness );\\n\\treflectedLight.directDiffuse += ( 1.0 - clearCoatDHR ) * irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\\n\\t#ifndef STANDARD\\n\\t\\treflectedLight.directSpecular += irradiance * material.clearCoat * BRDF_Specular_GGX( directLight, geometry, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearCoatRoughness );\\n\\t#endif\\n}\\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\\n\\t#ifndef ENVMAP_TYPE_CUBE_UV\\n\\t\\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\\n\\t#endif\\n}\\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearCoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {\\n\\t#ifndef STANDARD\\n\\t\\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\\n\\t\\tfloat dotNL = dotNV;\\n\\t\\tfloat clearCoatDHR = material.clearCoat * clearCoatDHRApprox( material.clearCoatRoughness, dotNL );\\n\\t#else\\n\\t\\tfloat clearCoatDHR = 0.0;\\n\\t#endif\\n\\tfloat clearCoatInv = 1.0 - clearCoatDHR;\\n\\t#if defined( ENVMAP_TYPE_CUBE_UV )\\n\\t\\tvec3 singleScattering = vec3( 0.0 );\\n\\t\\tvec3 multiScattering = vec3( 0.0 );\\n\\t\\tvec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;\\n\\t\\tBRDF_Specular_Multiscattering_Environment( geometry, material.specularColor, material.specularRoughness, singleScattering, multiScattering );\\n\\t\\tvec3 diffuse = material.diffuseColor;\\n\\t\\treflectedLight.indirectSpecular += clearCoatInv * radiance * singleScattering;\\n\\t\\treflectedLight.indirectDiffuse += multiScattering * cosineWeightedIrradiance;\\n\\t\\treflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;\\n\\t#else\\n\\t\\treflectedLight.indirectSpecular += clearCoatInv * radiance * BRDF_Specular_GGX_Environment( geometry, material.specularColor, material.specularRoughness );\\n\\t#endif\\n\\t#ifndef STANDARD\\n\\t\\treflectedLight.indirectSpecular += clearCoatRadiance * material.clearCoat * BRDF_Specular_GGX_Environment( geometry, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearCoatRoughness );\\n\\t#endif\\n}\\n#define RE_Direct\\t\\t\\t\\tRE_Direct_Physical\\n#define RE_Direct_RectArea\\t\\tRE_Direct_RectArea_Physical\\n#define RE_IndirectDiffuse\\t\\tRE_IndirectDiffuse_Physical\\n#define RE_IndirectSpecular\\t\\tRE_IndirectSpecular_Physical\\n#define Material_BlinnShininessExponent( material ) GGXRoughnessToBlinnExponent( material.specularRoughness )\\n#define Material_ClearCoat_BlinnShininessExponent( material ) GGXRoughnessToBlinnExponent( material.clearCoatRoughness )\\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\\n\\treturn saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\\n}\"; var lights_fragment_begin = \"\\nGeometricContext geometry;\\ngeometry.position = - vViewPosition;\\ngeometry.normal = normal;\\ngeometry.viewDir = normalize( vViewPosition );\\nIncidentLight directLight;\\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\\n\\tPointLight pointLight;\\n\\t#pragma unroll_loop\\n\\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\\n\\t\\tpointLight = pointLights[ i ];\\n\\t\\tgetPointDirectLightIrradiance( pointLight, geometry, directLight );\\n\\t\\t#ifdef USE_SHADOWMAP\\n\\t\\tdirectLight.color *= all( bvec2( pointLight.shadow, directLight.visible ) ) ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\\n\\t\\t#endif\\n\\t\\tRE_Direct( directLight, geometry, material, reflectedLight );\\n\\t}\\n#endif\\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\\n\\tSpotLight spotLight;\\n\\t#pragma unroll_loop\\n\\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\\n\\t\\tspotLight = spotLights[ i ];\\n\\t\\tgetSpotDirectLightIrradiance( spotLight, geometry, directLight );\\n\\t\\t#ifdef USE_SHADOWMAP\\n\\t\\tdirectLight.color *= all( bvec2( spotLight.shadow, directLight.visible ) ) ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\\n\\t\\t#endif\\n\\t\\tRE_Direct( directLight, geometry, material, reflectedLight );\\n\\t}\\n#endif\\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\\n\\tDirectionalLight directionalLight;\\n\\t#pragma unroll_loop\\n\\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\\n\\t\\tdirectionalLight = directionalLights[ i ];\\n\\t\\tgetDirectionalDirectLightIrradiance( directionalLight, geometry, directLight );\\n\\t\\t#ifdef USE_SHADOWMAP\\n\\t\\tdirectLight.color *= all( bvec2( directionalLight.shadow, directLight.visible ) ) ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\\n\\t\\t#endif\\n\\t\\tRE_Direct( directLight, geometry, material, reflectedLight );\\n\\t}\\n#endif\\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\\n\\tRectAreaLight rectAreaLight;\\n\\t#pragma unroll_loop\\n\\tfor ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\\n\\t\\trectAreaLight = rectAreaLights[ i ];\\n\\t\\tRE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );\\n\\t}\\n#endif\\n#if defined( RE_IndirectDiffuse )\\n\\tvec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\\n\\t#if ( NUM_HEMI_LIGHTS > 0 )\\n\\t\\t#pragma unroll_loop\\n\\t\\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\\n\\t\\t\\tirradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\\n\\t\\t}\\n\\t#endif\\n#endif\\n#if defined( RE_IndirectSpecular )\\n\\tvec3 radiance = vec3( 0.0 );\\n\\tvec3 clearCoatRadiance = vec3( 0.0 );\\n#endif\"; var lights_fragment_maps = \"#if defined( RE_IndirectDiffuse )\\n\\t#ifdef USE_LIGHTMAP\\n\\t\\tvec3 lightMapIrradiance = texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\\n\\t\\t#ifndef PHYSICALLY_CORRECT_LIGHTS\\n\\t\\t\\tlightMapIrradiance *= PI;\\n\\t\\t#endif\\n\\t\\tirradiance += lightMapIrradiance;\\n\\t#endif\\n\\t#if defined( USE_ENVMAP ) && defined( PHYSICAL ) && defined( ENVMAP_TYPE_CUBE_UV )\\n\\t\\tirradiance += getLightProbeIndirectIrradiance( geometry, maxMipLevel );\\n\\t#endif\\n#endif\\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\\n\\tradiance += getLightProbeIndirectRadiance( geometry, Material_BlinnShininessExponent( material ), maxMipLevel );\\n\\t#ifndef STANDARD\\n\\t\\tclearCoatRadiance += getLightProbeIndirectRadiance( geometry, Material_ClearCoat_BlinnShininessExponent( material ), maxMipLevel );\\n\\t#endif\\n#endif\"; var lights_fragment_end = \"#if defined( RE_IndirectDiffuse )\\n\\tRE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\\n#endif\\n#if defined( RE_IndirectSpecular )\\n\\tRE_IndirectSpecular( radiance, irradiance, clearCoatRadiance, geometry, material, reflectedLight );\\n#endif\"; var logdepthbuf_fragment = \"#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\\n\\tgl_FragDepthEXT = log2( vFragDepth ) * logDepthBufFC * 0.5;\\n#endif\"; var logdepthbuf_pars_fragment = \"#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\\n\\tuniform float logDepthBufFC;\\n\\tvarying float vFragDepth;\\n#endif\"; var logdepthbuf_pars_vertex = \"#ifdef USE_LOGDEPTHBUF\\n\\t#ifdef USE_LOGDEPTHBUF_EXT\\n\\t\\tvarying float vFragDepth;\\n\\t#else\\n\\t\\tuniform float logDepthBufFC;\\n\\t#endif\\n#endif\"; var logdepthbuf_vertex = \"#ifdef USE_LOGDEPTHBUF\\n\\t#ifdef USE_LOGDEPTHBUF_EXT\\n\\t\\tvFragDepth = 1.0 + gl_Position.w;\\n\\t#else\\n\\t\\tgl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;\\n\\t\\tgl_Position.z *= gl_Position.w;\\n\\t#endif\\n#endif\"; var map_fragment = \"#ifdef USE_MAP\\n\\tvec4 texelColor = texture2D( map, vUv );\\n\\ttexelColor = mapTexelToLinear( texelColor );\\n\\tdiffuseColor *= texelColor;\\n#endif\"; var map_pars_fragment = \"#ifdef USE_MAP\\n\\tuniform sampler2D map;\\n#endif\"; var map_particle_fragment = \"#ifdef USE_MAP\\n\\tvec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;\\n\\tvec4 mapTexel = texture2D( map, uv );\\n\\tdiffuseColor *= mapTexelToLinear( mapTexel );\\n#endif\"; var map_particle_pars_fragment = \"#ifdef USE_MAP\\n\\tuniform mat3 uvTransform;\\n\\tuniform sampler2D map;\\n#endif\"; var metalnessmap_fragment = \"float metalnessFactor = metalness;\\n#ifdef USE_METALNESSMAP\\n\\tvec4 texelMetalness = texture2D( metalnessMap, vUv );\\n\\tmetalnessFactor *= texelMetalness.b;\\n#endif\"; var metalnessmap_pars_fragment = \"#ifdef USE_METALNESSMAP\\n\\tuniform sampler2D metalnessMap;\\n#endif\"; var morphnormal_vertex = \"#ifdef USE_MORPHNORMALS\\n\\tobjectNormal += ( morphNormal0 - normal ) * morphTargetInfluences[ 0 ];\\n\\tobjectNormal += ( morphNormal1 - normal ) * morphTargetInfluences[ 1 ];\\n\\tobjectNormal += ( morphNormal2 - normal ) * morphTargetInfluences[ 2 ];\\n\\tobjectNormal += ( morphNormal3 - normal ) * morphTargetInfluences[ 3 ];\\n#endif\"; var morphtarget_pars_vertex = \"#ifdef USE_MORPHTARGETS\\n\\t#ifndef USE_MORPHNORMALS\\n\\tuniform float morphTargetInfluences[ 8 ];\\n\\t#else\\n\\tuniform float morphTargetInfluences[ 4 ];\\n\\t#endif\\n#endif\"; var morphtarget_vertex = \"#ifdef USE_MORPHTARGETS\\n\\ttransformed += ( morphTarget0 - position ) * morphTargetInfluences[ 0 ];\\n\\ttransformed += ( morphTarget1 - position ) * morphTargetInfluences[ 1 ];\\n\\ttransformed += ( morphTarget2 - position ) * morphTargetInfluences[ 2 ];\\n\\ttransformed += ( morphTarget3 - position ) * morphTargetInfluences[ 3 ];\\n\\t#ifndef USE_MORPHNORMALS\\n\\ttransformed += ( morphTarget4 - position ) * morphTargetInfluences[ 4 ];\\n\\ttransformed += ( morphTarget5 - position ) * morphTargetInfluences[ 5 ];\\n\\ttransformed += ( morphTarget6 - position ) * morphTargetInfluences[ 6 ];\\n\\ttransformed += ( morphTarget7 - position ) * morphTargetInfluences[ 7 ];\\n\\t#endif\\n#endif\"; var normal_fragment_begin = \"#ifdef FLAT_SHADED\\n\\tvec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );\\n\\tvec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );\\n\\tvec3 normal = normalize( cross( fdx, fdy ) );\\n#else\\n\\tvec3 normal = normalize( vNormal );\\n\\t#ifdef DOUBLE_SIDED\\n\\t\\tnormal = normal * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\\n\\t#endif\\n#endif\"; var normal_fragment_maps = \"#ifdef USE_NORMALMAP\\n\\t#ifdef OBJECTSPACE_NORMALMAP\\n\\t\\tnormal = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\\n\\t\\t#ifdef FLIP_SIDED\\n\\t\\t\\tnormal = - normal;\\n\\t\\t#endif\\n\\t\\t#ifdef DOUBLE_SIDED\\n\\t\\t\\tnormal = normal * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\\n\\t\\t#endif\\n\\t\\tnormal = normalize( normalMatrix * normal );\\n\\t#else\\n\\t\\tnormal = perturbNormal2Arb( -vViewPosition, normal );\\n\\t#endif\\n#elif defined( USE_BUMPMAP )\\n\\tnormal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd() );\\n#endif\"; var normalmap_pars_fragment = \"#ifdef USE_NORMALMAP\\n\\tuniform sampler2D normalMap;\\n\\tuniform vec2 normalScale;\\n\\t#ifdef OBJECTSPACE_NORMALMAP\\n\\t\\tuniform mat3 normalMatrix;\\n\\t#else\\n\\t\\tvec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm ) {\\n\\t\\t\\tvec3 q0 = vec3( dFdx( eye_pos.x ), dFdx( eye_pos.y ), dFdx( eye_pos.z ) );\\n\\t\\t\\tvec3 q1 = vec3( dFdy( eye_pos.x ), dFdy( eye_pos.y ), dFdy( eye_pos.z ) );\\n\\t\\t\\tvec2 st0 = dFdx( vUv.st );\\n\\t\\t\\tvec2 st1 = dFdy( vUv.st );\\n\\t\\t\\tfloat scale = sign( st1.t * st0.s - st0.t * st1.s );\\n\\t\\t\\tvec3 S = normalize( ( q0 * st1.t - q1 * st0.t ) * scale );\\n\\t\\t\\tvec3 T = normalize( ( - q0 * st1.s + q1 * st0.s ) * scale );\\n\\t\\t\\tvec3 N = normalize( surf_norm );\\n\\t\\t\\tmat3 tsn = mat3( S, T, N );\\n\\t\\t\\tvec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\\n\\t\\t\\tmapN.xy *= normalScale;\\n\\t\\t\\tmapN.xy *= ( float( gl_FrontFacing ) * 2.0 - 1.0 );\\n\\t\\t\\treturn normalize( tsn * mapN );\\n\\t\\t}\\n\\t#endif\\n#endif\"; var packing = \"vec3 packNormalToRGB( const in vec3 normal ) {\\n\\treturn normalize( normal ) * 0.5 + 0.5;\\n}\\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\\n\\treturn 2.0 * rgb.xyz - 1.0;\\n}\\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );\\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\\nconst float ShiftRight8 = 1. / 256.;\\nvec4 packDepthToRGBA( const in float v ) {\\n\\tvec4 r = vec4( fract( v * PackFactors ), v );\\n\\tr.yzw -= r.xyz * ShiftRight8;\\treturn r * PackUpscale;\\n}\\nfloat unpackRGBAToDepth( const in vec4 v ) {\\n\\treturn dot( v, UnpackFactors );\\n}\\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\\n\\treturn ( viewZ + near ) / ( near - far );\\n}\\nfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\\n\\treturn linearClipZ * ( near - far ) - near;\\n}\\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\\n\\treturn (( near + viewZ ) * far ) / (( far - near ) * viewZ );\\n}\\nfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\\n\\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\\n}\"; var premultiplied_alpha_fragment = \"#ifdef PREMULTIPLIED_ALPHA\\n\\tgl_FragColor.rgb *= gl_FragColor.a;\\n#endif\"; var project_vertex = \"vec4 mvPosition = modelViewMatrix * vec4( transformed, 1.0 );\\ngl_Position = projectionMatrix * mvPosition;\"; var dithering_fragment = \"#if defined( DITHERING )\\n\\tgl_FragColor.rgb = dithering( gl_FragColor.rgb );\\n#endif\"; var dithering_pars_fragment = \"#if defined( DITHERING )\\n\\tvec3 dithering( vec3 color ) {\\n\\t\\tfloat grid_position = rand( gl_FragCoord.xy );\\n\\t\\tvec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\\n\\t\\tdither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\\n\\t\\treturn color + dither_shift_RGB;\\n\\t}\\n#endif\"; var roughnessmap_fragment = \"float roughnessFactor = roughness;\\n#ifdef USE_ROUGHNESSMAP\\n\\tvec4 texelRoughness = texture2D( roughnessMap, vUv );\\n\\troughnessFactor *= texelRoughness.g;\\n#endif\"; var roughnessmap_pars_fragment = \"#ifdef USE_ROUGHNESSMAP\\n\\tuniform sampler2D roughnessMap;\\n#endif\"; var shadowmap_pars_fragment = \"#ifdef USE_SHADOWMAP\\n\\t#if NUM_DIR_LIGHTS > 0\\n\\t\\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHTS ];\\n\\t\\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\\n\\t#endif\\n\\t#if NUM_SPOT_LIGHTS > 0\\n\\t\\tuniform sampler2D spotShadowMap[ NUM_SPOT_LIGHTS ];\\n\\t\\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHTS ];\\n\\t#endif\\n\\t#if NUM_POINT_LIGHTS > 0\\n\\t\\tuniform sampler2D pointShadowMap[ NUM_POINT_LIGHTS ];\\n\\t\\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHTS ];\\n\\t#endif\\n\\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\\n\\t\\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\\n\\t}\\n\\tfloat texture2DShadowLerp( sampler2D depths, vec2 size, vec2 uv, float compare ) {\\n\\t\\tconst vec2 offset = vec2( 0.0, 1.0 );\\n\\t\\tvec2 texelSize = vec2( 1.0 ) / size;\\n\\t\\tvec2 centroidUV = floor( uv * size + 0.5 ) / size;\\n\\t\\tfloat lb = texture2DCompare( depths, centroidUV + texelSize * offset.xx, compare );\\n\\t\\tfloat lt = texture2DCompare( depths, centroidUV + texelSize * offset.xy, compare );\\n\\t\\tfloat rb = texture2DCompare( depths, centroidUV + texelSize * offset.yx, compare );\\n\\t\\tfloat rt = texture2DCompare( depths, centroidUV + texelSize * offset.yy, compare );\\n\\t\\tvec2 f = fract( uv * size + 0.5 );\\n\\t\\tfloat a = mix( lb, lt, f.y );\\n\\t\\tfloat b = mix( rb, rt, f.y );\\n\\t\\tfloat c = mix( a, b, f.x );\\n\\t\\treturn c;\\n\\t}\\n\\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\\n\\t\\tfloat shadow = 1.0;\\n\\t\\tshadowCoord.xyz /= shadowCoord.w;\\n\\t\\tshadowCoord.z += shadowBias;\\n\\t\\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x = 0.0, shadowCoord.y 0.0 )\\n\\t\\t\\t\\tplanar.x = 4.0 - v.x;\\n\\t\\t} else if ( absV.x >= almostOne ) {\\n\\t\\t\\tfloat signX = sign( v.x );\\n\\t\\t\\tplanar.x = v.z * signX + 2.0 * signX;\\n\\t\\t} else if ( absV.y >= almostOne ) {\\n\\t\\t\\tfloat signY = sign( v.y );\\n\\t\\t\\tplanar.x = v.x + 2.0 * signY + 2.0;\\n\\t\\t\\tplanar.y = v.z * signY - 2.0;\\n\\t\\t}\\n\\t\\treturn vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\\n\\t}\\n\\tfloat getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\\n\\t\\tvec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\\n\\t\\tvec3 lightToPosition = shadowCoord.xyz;\\n\\t\\tfloat dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );\\t\\tdp += shadowBias;\\n\\t\\tvec3 bd3D = normalize( lightToPosition );\\n\\t\\t#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT )\\n\\t\\t\\tvec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\\n\\t\\t\\treturn (\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\\n\\t\\t\\t) * ( 1.0 / 9.0 );\\n\\t\\t#else\\n\\t\\t\\treturn texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\\n\\t\\t#endif\\n\\t}\\n#endif\"; var shadowmap_pars_vertex = \"#ifdef USE_SHADOWMAP\\n\\t#if NUM_DIR_LIGHTS > 0\\n\\t\\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHTS ];\\n\\t\\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\\n\\t#endif\\n\\t#if NUM_SPOT_LIGHTS > 0\\n\\t\\tuniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHTS ];\\n\\t\\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHTS ];\\n\\t#endif\\n\\t#if NUM_POINT_LIGHTS > 0\\n\\t\\tuniform mat4 pointShadowMatrix[ NUM_POINT_LIGHTS ];\\n\\t\\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHTS ];\\n\\t#endif\\n#endif\"; var shadowmap_vertex = \"#ifdef USE_SHADOWMAP\\n\\t#if NUM_DIR_LIGHTS > 0\\n\\t#pragma unroll_loop\\n\\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\\n\\t\\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * worldPosition;\\n\\t}\\n\\t#endif\\n\\t#if NUM_SPOT_LIGHTS > 0\\n\\t#pragma unroll_loop\\n\\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\\n\\t\\tvSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * worldPosition;\\n\\t}\\n\\t#endif\\n\\t#if NUM_POINT_LIGHTS > 0\\n\\t#pragma unroll_loop\\n\\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\\n\\t\\tvPointShadowCoord[ i ] = pointShadowMatrix[ i ] * worldPosition;\\n\\t}\\n\\t#endif\\n#endif\"; var shadowmask_pars_fragment = \"float getShadowMask() {\\n\\tfloat shadow = 1.0;\\n\\t#ifdef USE_SHADOWMAP\\n\\t#if NUM_DIR_LIGHTS > 0\\n\\tDirectionalLight directionalLight;\\n\\t#pragma unroll_loop\\n\\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\\n\\t\\tdirectionalLight = directionalLights[ i ];\\n\\t\\tshadow *= bool( directionalLight.shadow ) ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\\n\\t}\\n\\t#endif\\n\\t#if NUM_SPOT_LIGHTS > 0\\n\\tSpotLight spotLight;\\n\\t#pragma unroll_loop\\n\\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\\n\\t\\tspotLight = spotLights[ i ];\\n\\t\\tshadow *= bool( spotLight.shadow ) ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\\n\\t}\\n\\t#endif\\n\\t#if NUM_POINT_LIGHTS > 0\\n\\tPointLight pointLight;\\n\\t#pragma unroll_loop\\n\\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\\n\\t\\tpointLight = pointLights[ i ];\\n\\t\\tshadow *= bool( pointLight.shadow ) ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\\n\\t}\\n\\t#endif\\n\\t#endif\\n\\treturn shadow;\\n}\"; var skinbase_vertex = \"#ifdef USE_SKINNING\\n\\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\\n\\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\\n\\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\\n\\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\\n#endif\"; var skinning_pars_vertex = \"#ifdef USE_SKINNING\\n\\tuniform mat4 bindMatrix;\\n\\tuniform mat4 bindMatrixInverse;\\n\\t#ifdef BONE_TEXTURE\\n\\t\\tuniform sampler2D boneTexture;\\n\\t\\tuniform int boneTextureSize;\\n\\t\\tmat4 getBoneMatrix( const in float i ) {\\n\\t\\t\\tfloat j = i * 4.0;\\n\\t\\t\\tfloat x = mod( j, float( boneTextureSize ) );\\n\\t\\t\\tfloat y = floor( j / float( boneTextureSize ) );\\n\\t\\t\\tfloat dx = 1.0 / float( boneTextureSize );\\n\\t\\t\\tfloat dy = 1.0 / float( boneTextureSize );\\n\\t\\t\\ty = dy * ( y + 0.5 );\\n\\t\\t\\tvec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\\n\\t\\t\\tvec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\\n\\t\\t\\tvec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\\n\\t\\t\\tvec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\\n\\t\\t\\tmat4 bone = mat4( v1, v2, v3, v4 );\\n\\t\\t\\treturn bone;\\n\\t\\t}\\n\\t#else\\n\\t\\tuniform mat4 boneMatrices[ MAX_BONES ];\\n\\t\\tmat4 getBoneMatrix( const in float i ) {\\n\\t\\t\\tmat4 bone = boneMatrices[ int(i) ];\\n\\t\\t\\treturn bone;\\n\\t\\t}\\n\\t#endif\\n#endif\"; var skinning_vertex = \"#ifdef USE_SKINNING\\n\\tvec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\\n\\tvec4 skinned = vec4( 0.0 );\\n\\tskinned += boneMatX * skinVertex * skinWeight.x;\\n\\tskinned += boneMatY * skinVertex * skinWeight.y;\\n\\tskinned += boneMatZ * skinVertex * skinWeight.z;\\n\\tskinned += boneMatW * skinVertex * skinWeight.w;\\n\\ttransformed = ( bindMatrixInverse * skinned ).xyz;\\n#endif\"; var skinnormal_vertex = \"#ifdef USE_SKINNING\\n\\tmat4 skinMatrix = mat4( 0.0 );\\n\\tskinMatrix += skinWeight.x * boneMatX;\\n\\tskinMatrix += skinWeight.y * boneMatY;\\n\\tskinMatrix += skinWeight.z * boneMatZ;\\n\\tskinMatrix += skinWeight.w * boneMatW;\\n\\tskinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;\\n\\tobjectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\\n#endif\"; var specularmap_fragment = \"float specularStrength;\\n#ifdef USE_SPECULARMAP\\n\\tvec4 texelSpecular = texture2D( specularMap, vUv );\\n\\tspecularStrength = texelSpecular.r;\\n#else\\n\\tspecularStrength = 1.0;\\n#endif\"; var specularmap_pars_fragment = \"#ifdef USE_SPECULARMAP\\n\\tuniform sampler2D specularMap;\\n#endif\"; var tonemapping_fragment = \"#if defined( TONE_MAPPING )\\n\\tgl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\\n#endif\"; var tonemapping_pars_fragment = \"#ifndef saturate\\n\\t#define saturate(a) clamp( a, 0.0, 1.0 )\\n#endif\\nuniform float toneMappingExposure;\\nuniform float toneMappingWhitePoint;\\nvec3 LinearToneMapping( vec3 color ) {\\n\\treturn toneMappingExposure * color;\\n}\\nvec3 ReinhardToneMapping( vec3 color ) {\\n\\tcolor *= toneMappingExposure;\\n\\treturn saturate( color / ( vec3( 1.0 ) + color ) );\\n}\\n#define Uncharted2Helper( x ) max( ( ( x * ( 0.15 * x + 0.10 * 0.50 ) + 0.20 * 0.02 ) / ( x * ( 0.15 * x + 0.50 ) + 0.20 * 0.30 ) ) - 0.02 / 0.30, vec3( 0.0 ) )\\nvec3 Uncharted2ToneMapping( vec3 color ) {\\n\\tcolor *= toneMappingExposure;\\n\\treturn saturate( Uncharted2Helper( color ) / Uncharted2Helper( vec3( toneMappingWhitePoint ) ) );\\n}\\nvec3 OptimizedCineonToneMapping( vec3 color ) {\\n\\tcolor *= toneMappingExposure;\\n\\tcolor = max( vec3( 0.0 ), color - 0.004 );\\n\\treturn pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\\n}\\nvec3 ACESFilmicToneMapping( vec3 color ) {\\n\\tcolor *= toneMappingExposure;\\n\\treturn saturate( ( color * ( 2.51 * color + 0.03 ) ) / ( color * ( 2.43 * color + 0.59 ) + 0.14 ) );\\n}\"; var uv_pars_fragment = \"#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\\n\\tvarying vec2 vUv;\\n#endif\"; var uv_pars_vertex = \"#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\\n\\tvarying vec2 vUv;\\n\\tuniform mat3 uvTransform;\\n#endif\"; var uv_vertex = \"#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\\n\\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\\n#endif\"; var uv2_pars_fragment = \"#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\\n\\tvarying vec2 vUv2;\\n#endif\"; var uv2_pars_vertex = \"#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\\n\\tattribute vec2 uv2;\\n\\tvarying vec2 vUv2;\\n#endif\"; var uv2_vertex = \"#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\\n\\tvUv2 = uv2;\\n#endif\"; var worldpos_vertex = \"#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP )\\n\\tvec4 worldPosition = modelMatrix * vec4( transformed, 1.0 );\\n#endif\"; var background_frag = \"uniform sampler2D t2D;\\nvarying vec2 vUv;\\nvoid main() {\\n\\tvec4 texColor = texture2D( t2D, vUv );\\n\\tgl_FragColor = mapTexelToLinear( texColor );\\n\\t#include \\n\\t#include \\n}\"; var background_vert = \"varying vec2 vUv;\\nuniform mat3 uvTransform;\\nvoid main() {\\n\\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\\n\\tgl_Position = vec4( position.xy, 1.0, 1.0 );\\n}\"; var cube_frag = \"uniform samplerCube tCube;\\nuniform float tFlip;\\nuniform float opacity;\\nvarying vec3 vWorldDirection;\\nvoid main() {\\n\\tvec4 texColor = textureCube( tCube, vec3( tFlip * vWorldDirection.x, vWorldDirection.yz ) );\\n\\tgl_FragColor = mapTexelToLinear( texColor );\\n\\tgl_FragColor.a *= opacity;\\n\\t#include \\n\\t#include \\n}\"; var cube_vert = \"varying vec3 vWorldDirection;\\n#include \\nvoid main() {\\n\\tvWorldDirection = transformDirection( position, modelMatrix );\\n\\t#include \\n\\t#include \\n\\tgl_Position.z = gl_Position.w;\\n}\"; var depth_frag = \"#if DEPTH_PACKING == 3200\\n\\tuniform float opacity;\\n#endif\\n#include \\n#include \\n#include \\n#include \\n#include \\n#include \\n#include \\nvoid main() {\\n\\t#include \\n\\tvec4 diffuseColor = vec4( 1.0 );\\n\\t#if DEPTH_PACKING == 3200\\n\\t\\tdiffuseColor.a = opacity;\\n\\t#endif\\n\\t#include \\n\\t#include \\n\\t#include \\n\\t#include \\n\\t#if DEPTH_PACKING == 3200\\n\\t\\tgl_FragColor = vec4( vec3( 1.0 - gl_FragCoord.z ), opacity );\\n\\t#elif DEPTH_PACKING == 3201\\n\\t\\tgl_FragColor = packDepthToRGBA( gl_FragCoord.z );\\n\\t#endif\\n}\"; var depth_vert = \"#include \\n#include \\n#include \\n#include \\n#include \\n#include \\n#include \\nvoid main() {\\n\\t#include \\n\\t#include \\n\\t#ifdef USE_DISPLACEMENTMAP\\n\\t\\t#include \\n\\t\\t#include \\n\\t\\t#include \\n\\t#endif\\n\\t#include \\n\\t#include \\n\\t#include \\n\\t#include \\n\\t#include \\n\\t#include \\n\\t#include \\n}\"; var distanceRGBA_frag = \"#define DISTANCE\\nuniform vec3 referencePosition;\\nuniform float nearDistance;\\nuniform float farDistance;\\nvarying vec3 vWorldPosition;\\n#include \\n#include \\n#include \\n#include \\n#include \\n#include \\nvoid main () {\\n\\t#include \\n\\tvec4 diffuseColor = vec4( 1.0 );\\n\\t#include \\n\\t#include \\n\\t#include \\n\\tfloat dist = length( vWorldPosition - referencePosition );\\n\\tdist = ( dist - nearDistance ) / ( farDistance - nearDistance );\\n\\tdist = saturate( dist );\\n\\tgl_FragColor = packDepthToRGBA( dist );\\n}\"; var distanceRGBA_vert = \"#define DISTANCE\\nvarying vec3 vWorldPosition;\\n#include \\n#include \\n#include \\n#include \\n#include \\n#include \\nvoid main() {\\n\\t#include \\n\\t#include \\n\\t#ifdef USE_DISPLACEMENTMAP\\n\\t\\t#include \\n\\t\\t#include \\n\\t\\t#include \\n\\t#endif\\n\\t#include \\n\\t#include \\n\\t#include \\n\\t#include \\n\\t#include \\n\\t#include \\n\\t#include \\n\\tvWorldPosition = worldPosition.xyz;\\n}\"; var equirect_frag = \"uniform sampler2D tEquirect;\\nvarying vec3 vWorldDirection;\\n#include \\nvoid main() {\\n\\tvec3 direction = normalize( vWorldDirection );\\n\\tvec2 sampleUV;\\n\\tsampleUV.y = asin( clamp( direction.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\\n\\tsampleUV.x = atan( direction.z, direction.x ) * RECIPROCAL_PI2 + 0.5;\\n\\tvec4 texColor = texture2D( tEquirect, sampleUV );\\n\\tgl_FragColor = mapTexelToLinear( texColor );\\n\\t#include \\n\\t#include \\n}\"; var equirect_vert = \"varying vec3 vWorldDirection;\\n#include \\nvoid main() {\\n\\tvWorldDirection = transformDirection( position, modelMatrix );\\n\\t#include \\n\\t#include \\n}\"; var linedashed_frag = \"uniform vec3 diffuse;\\nuniform float opacity;\\nuniform float dashSize;\\nuniform float totalSize;\\nvarying float vLineDistance;\\n#include \\n#include \\n#include \\n#include \\n#include \\nvoid main() {\\n\\t#include \\n\\tif ( mod( vLineDistance, totalSize ) > dashSize ) {\\n\\t\\tdiscard;\\n\\t}\\n\\tvec3 outgoingLight = vec3( 0.0 );\\n\\tvec4 diffuseColor = vec4( diffuse, opacity );\\n\\t#include \\n\\t#include \\n\\toutgoingLight = diffuseColor.rgb;\\n\\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\\n\\t#include \\n\\t#include \\n\\t#include \\n\\t#include \\n}\"; var linedashed_vert = \"uniform float scale;\\nattribute float lineDistance;\\nvarying float vLineDistance;\\n#include \\n#include \\n#include \\n#include \\n#include \\nvoid main() {\\n\\t#include \\n\\tvLineDistance = scale * lineDistance;\\n\\tvec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\\n\\tgl_Position = projectionMatrix * mvPosition;\\n\\t#include \\n\\t#include \\n\\t#include \\n}\"; var meshbasic_frag = \"uniform vec3 diffuse;\\nuniform float opacity;\\n#ifndef FLAT_SHADED\\n\\tvarying vec3 vNormal;\\n#endif\\n#include \\n#include \\n#include \\n#include \\n#include \\n#include \\n#include \\n#include \\n#include \\n#include \\n#include \\n#include \\n#include \\nvoid main() {\\n\\t#include \\n\\tvec4 diffuseColor = vec4( diffuse, opacity );\\n\\t#include \\n\\t#include \\n\\t#include \\n\\t#include \\n\\t#include \\n\\t#include \\n\\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\\n\\t#ifdef USE_LIGHTMAP\\n\\t\\treflectedLight.indirectDiffuse += texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\\n\\t#else\\n\\t\\treflectedLight.indirectDiffuse += vec3( 1.0 );\\n\\t#endif\\n\\t#include \\n\\treflectedLight.indirectDiffuse *= diffuseColor.rgb;\\n\\tvec3 outgoingLight = reflectedLight.indirectDiffuse;\\n\\t#include \\n\\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\\n\\t#include \\n\\t#include \\n\\t#include \\n\\t#include \\n}\"; var meshbasic_vert = \"#include \\n#include \\n#include \\n#include \\n#include \\n#include \\n#include \\n#include \\n#include \\n#include \\nvoid main() {\\n\\t#include \\n\\t#include \\n\\t#include \\n\\t#include \\n\\t#ifdef USE_ENVMAP\\n\\t#include \\n\\t#include \\n\\t#include \\n\\t#include \\n\\t#endif\\n\\t#include \\n\\t#include \\n\\t#include \\n\\t#include \\n\\t#include \\n\\t#include \\n\\t#include \\n\\t#include \\n\\t#include \\n}\"; var meshlambert_frag = \"uniform vec3 diffuse;\\nuniform vec3 emissive;\\nuniform float opacity;\\nvarying vec3 vLightFront;\\nvarying vec3 vIndirectFront;\\n#ifdef DOUBLE_SIDED\\n\\tvarying vec3 vLightBack;\\n\\tvarying vec3 vIndirectBack;\\n#endif\\n#include \\n#include \\n#include \\n#include \\n#include \\n#include \\n#include \\n#include \\n#include \\n#include \\n#include \\n#include \\n#include \\n#include \\n#include \\n#include \\n#include \\n#include \\n#include \\n#include \\nvoid main() {\\n\\t#include \\n\\tvec4 diffuseColor = vec4( diffuse, opacity );\\n\\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\\n\\tvec3 totalEmissiveRadiance = emissive;\\n\\t#include \\n\\t#include \\n\\t#include \\n\\t#include \\n\\t#include \\n\\t#include \\n\\t#include \\n\\treflectedLight.indirectDiffuse = getAmbientLightIrradiance( ambientLightColor );\\n\\t#ifdef DOUBLE_SIDED\\n\\t\\treflectedLight.indirectDiffuse += ( gl_FrontFacing ) ? vIndirectFront : vIndirectBack;\\n\\t#else\\n\\t\\treflectedLight.indirectDiffuse += vIndirectFront;\\n\\t#endif\\n\\t#include \\n\\treflectedLight.indirectDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb );\\n\\t#ifdef DOUBLE_SIDED\\n\\t\\treflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;\\n\\t#else\\n\\t\\treflectedLight.directDiffuse = vLightFront;\\n\\t#endif\\n\\treflectedLight.directDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb ) * getShadowMask();\\n\\t#include \\n\\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\\n\\t#include \\n\\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\\n\\t#include \\n\\t#include \\n\\t#include \\n\\t#include \\n\\t#include \\n}\"; var meshlambert_vert = \"#define LAMBERT\\nvarying vec3 vLightFront;\\nvarying vec3 vIndirectFront;\\n#ifdef DOUBLE_SIDED\\n\\tvarying vec3 vLightBack;\\n\\tvarying vec3 vIndirectBack;\\n#endif\\n#include \\n#include \\n#include \\n#include \\n#include \\n#include \\n#include \\n#include \\n#include \\n#include \\n#include \\n#include \\n#include \\nvoid main() {\\n\\t#include \\n\\t#include \\n\\t#include \\n\\t#include \\n\\t#include \\n\\t#include \\n\\t#include \\n\\t#include \\n\\t#include \\n\\t#include \\n\\t#include \\n\\t#include \\n\\t#include \\n\\t#include \\n\\t#include \\n\\t#include \\n\\t#include \\n\\t#include \\n\\t#include \\n}\"; var meshmatcap_frag = \"#define MATCAP\\nuniform vec3 diffuse;\\nuniform float opacity;\\nuniform sampler2D matcap;\\nvarying vec3 vViewPosition;\\n#ifndef FLAT_SHADED\\n\\tvarying vec3 vNormal;\\n#endif\\n#include \\n#include \\n#include \\n#include \\n#include \\n#include \\n#include \\n#include \\n#include \\nvoid main() {\\n\\t#include \\n\\tvec4 diffuseColor = vec4( diffuse, opacity );\\n\\t#include \\n\\t#include \\n\\t#include \\n\\t#include \\n\\t#include \\n\\t#include \\n\\tvec3 viewDir = normalize( vViewPosition );\\n\\tvec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );\\n\\tvec3 y = cross( viewDir, x );\\n\\tvec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;\\n\\t#ifdef USE_MATCAP\\n\\t\\tvec4 matcapColor = texture2D( matcap, uv );\\n\\t\\tmatcapColor = matcapTexelToLinear( matcapColor );\\n\\t#else\\n\\t\\tvec4 matcapColor = vec4( 1.0 );\\n\\t#endif\\n\\tvec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;\\n\\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\\n\\t#include \\n\\t#include \\n\\t#include \\n\\t#include \\n}\"; var meshmatcap_vert = \"#define MATCAP\\nvarying vec3 vViewPosition;\\n#ifndef FLAT_SHADED\\n\\tvarying vec3 vNormal;\\n#endif\\n#include \\n#include \\n#include \\n#include \\n#include \\n#include \\n#include \\n#include \\nvoid main() {\\n\\t#include \\n\\t#include \\n\\t#include \\n\\t#include \\n\\t#include \\n\\t#include \\n\\t#ifndef FLAT_SHADED\\n\\t\\tvNormal = normalize( transformedNormal );\\n\\t#endif\\n\\t#include \\n\\t#include \\n\\t#include \\n\\t#include \\n\\t#include \\n\\t#include \\n\\t#include \\n\\t#include \\n\\tvViewPosition = - mvPosition.xyz;\\n}\"; var meshphong_frag = \"#define PHONG\\nuniform vec3 diffuse;\\nuniform vec3 emissive;\\nuniform vec3 specular;\\nuniform float shininess;\\nuniform float opacity;\\n#include \\n#include \\n#include \\n#include \\n#include \\n#include \\n#include \\n#include \\n#include \\n#include \\n#include \\n#include \\n#include \\n#include \\n#include \\n#include \\n#include \\n#include \\n#include \\n#include \\n#include \\n#include \\n#include \\nvoid main() {\\n\\t#include \\n\\tvec4 diffuseColor = vec4( diffuse, opacity );\\n\\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\\n\\tvec3 totalEmissiveRadiance = emissive;\\n\\t#include \\n\\t#include \\n\\t#include \\n\\t#include \\n\\t#include \\n\\t#include \\n\\t#include \\n\\t#include \\n\\t#include \\n\\t#include \\n\\t#include \\n\\t#include \\n\\t#include \\n\\t#include \\n\\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\\n\\t#include \\n\\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\\n\\t#include \\n\\t#include \\n\\t#include \\n\\t#include \\n\\t#include \\n}\"; var meshphong_vert = \"#define PHONG\\nvarying vec3 vViewPosition;\\n#ifndef FLAT_SHADED\\n\\tvarying vec3 vNormal;\\n#endif\\n#include \\n#include \\n#include \\n#include \\n#include \\n#include \\n#include \\n#include \\n#include \\n#include \\n#include \\n#include \\nvoid main() {\\n\\t#include \\n\\t#include \\n\\t#include \\n\\t#include \\n\\t#include \\n\\t#include \\n\\t#include \\n\\t#include \\n#ifndef FLAT_SHADED\\n\\tvNormal = normalize( transformedNormal );\\n#endif\\n\\t#include \\n\\t#include \\n\\t#include \\n\\t#include \\n\\t#include \\n\\t#include \\n\\t#include \\n\\tvViewPosition = - mvPosition.xyz;\\n\\t#include \\n\\t#include \\n\\t#include \\n\\t#include \\n}\"; var meshphysical_frag = \"#define PHYSICAL\\nuniform vec3 diffuse;\\nuniform vec3 emissive;\\nuniform float roughness;\\nuniform float metalness;\\nuniform float opacity;\\n#ifndef STANDARD\\n\\tuniform float clearCoat;\\n\\tuniform float clearCoatRoughness;\\n#endif\\nvarying vec3 vViewPosition;\\n#ifndef FLAT_SHADED\\n\\tvarying vec3 vNormal;\\n#endif\\n#include \\n#include \\n#include \\n#include \\n#include \\n#include \\n#include \\n#include \\n#include \\n#include \\n#include \\n#include \\n#include \\n#include \\n#include \\n#include \\n#include \\n#include \\n#include \\n#include \\n#include \\n#include \\n#include \\n#include \\n#include \\nvoid main() {\\n\\t#include \\n\\tvec4 diffuseColor = vec4( diffuse, opacity );\\n\\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\\n\\tvec3 totalEmissiveRadiance = emissive;\\n\\t#include \\n\\t#include \\n\\t#include \\n\\t#include \\n\\t#include \\n\\t#include \\n\\t#include \\n\\t#include \\n\\t#include \\n\\t#include \\n\\t#include \\n\\t#include \\n\\t#include \\n\\t#include \\n\\t#include \\n\\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\\n\\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\\n\\t#include \\n\\t#include \\n\\t#include \\n\\t#include \\n\\t#include \\n}\"; var meshphysical_vert = \"#define PHYSICAL\\nvarying vec3 vViewPosition;\\n#ifndef FLAT_SHADED\\n\\tvarying vec3 vNormal;\\n#endif\\n#include \\n#include \\n#include \\n#include \\n#include \\n#include \\n#include \\n#include \\n#include \\n#include \\n#include \\nvoid main() {\\n\\t#include \\n\\t#include \\n\\t#include \\n\\t#include \\n\\t#include \\n\\t#include \\n\\t#include \\n\\t#include \\n#ifndef FLAT_SHADED\\n\\tvNormal = normalize( transformedNormal );\\n#endif\\n\\t#include \\n\\t#include \\n\\t#include \\n\\t#include \\n\\t#include \\n\\t#include \\n\\t#include \\n\\tvViewPosition = - mvPosition.xyz;\\n\\t#include \\n\\t#include \\n\\t#include \\n}\"; var normal_frag = \"#define NORMAL\\nuniform float opacity;\\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || ( defined( USE_NORMALMAP ) && ! defined( OBJECTSPACE_NORMALMAP ) )\\n\\tvarying vec3 vViewPosition;\\n#endif\\n#ifndef FLAT_SHADED\\n\\tvarying vec3 vNormal;\\n#endif\\n#include \\n#include \\n#include \\n#include \\n#include \\nvoid main() {\\n\\t#include \\n\\t#include \\n\\t#include \\n\\tgl_FragColor = vec4( packNormalToRGB( normal ), opacity );\\n}\"; var normal_vert = \"#define NORMAL\\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || ( defined( USE_NORMALMAP ) && ! defined( OBJECTSPACE_NORMALMAP ) )\\n\\tvarying vec3 vViewPosition;\\n#endif\\n#ifndef FLAT_SHADED\\n\\tvarying vec3 vNormal;\\n#endif\\n#include \\n#include \\n#include \\n#include \\n#include \\nvoid main() {\\n\\t#include \\n\\t#include \\n\\t#include \\n\\t#include \\n\\t#include \\n\\t#include \\n#ifndef FLAT_SHADED\\n\\tvNormal = normalize( transformedNormal );\\n#endif\\n\\t#include \\n\\t#include \\n\\t#include \\n\\t#include \\n\\t#include \\n\\t#include \\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || ( defined( USE_NORMALMAP ) && ! defined( OBJECTSPACE_NORMALMAP ) )\\n\\tvViewPosition = - mvPosition.xyz;\\n#endif\\n}\"; var points_frag = \"uniform vec3 diffuse;\\nuniform float opacity;\\n#include \\n#include \\n#include \\n#include \\n#include \\n#include \\nvoid main() {\\n\\t#include \\n\\tvec3 outgoingLight = vec3( 0.0 );\\n\\tvec4 diffuseColor = vec4( diffuse, opacity );\\n\\t#include \\n\\t#include \\n\\t#include \\n\\t#include \\n\\toutgoingLight = diffuseColor.rgb;\\n\\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\\n\\t#include \\n\\t#include \\n\\t#include \\n\\t#include \\n}\"; var points_vert = \"uniform float size;\\nuniform float scale;\\n#include \\n#include \\n#include \\n#include \\n#include \\n#include \\nvoid main() {\\n\\t#include \\n\\t#include \\n\\t#include \\n\\t#include \\n\\tgl_PointSize = size;\\n\\t#ifdef USE_SIZEATTENUATION\\n\\t\\tbool isPerspective = ( projectionMatrix[ 2 ][ 3 ] == - 1.0 );\\n\\t\\tif ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );\\n\\t#endif\\n\\t#include \\n\\t#include \\n\\t#include \\n\\t#include \\n}\"; var shadow_frag = \"uniform vec3 color;\\nuniform float opacity;\\n#include \\n#include \\n#include \\n#include \\n#include \\n#include \\n#include \\nvoid main() {\\n\\tgl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );\\n\\t#include \\n}\"; var shadow_vert = \"#include \\n#include \\nvoid main() {\\n\\t#include \\n\\t#include \\n\\t#include \\n\\t#include \\n\\t#include \\n}\"; var sprite_frag = \"uniform vec3 diffuse;\\nuniform float opacity;\\n#include \\n#include \\n#include \\n#include \\n#include \\n#include \\nvoid main() {\\n\\t#include \\n\\tvec3 outgoingLight = vec3( 0.0 );\\n\\tvec4 diffuseColor = vec4( diffuse, opacity );\\n\\t#include \\n\\t#include \\n\\t#include \\n\\toutgoingLight = diffuseColor.rgb;\\n\\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\\n\\t#include \\n\\t#include \\n\\t#include \\n}\"; var sprite_vert = \"uniform float rotation;\\nuniform vec2 center;\\n#include \\n#include \\n#include \\n#include \\n#include \\nvoid main() {\\n\\t#include \\n\\tvec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );\\n\\tvec2 scale;\\n\\tscale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );\\n\\tscale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );\\n\\t#ifndef USE_SIZEATTENUATION\\n\\t\\tbool isPerspective = ( projectionMatrix[ 2 ][ 3 ] == - 1.0 );\\n\\t\\tif ( isPerspective ) scale *= - mvPosition.z;\\n\\t#endif\\n\\tvec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;\\n\\tvec2 rotatedPosition;\\n\\trotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\\n\\trotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\\n\\tmvPosition.xy += rotatedPosition;\\n\\tgl_Position = projectionMatrix * mvPosition;\\n\\t#include \\n\\t#include \\n\\t#include \\n}\"; var ShaderChunk = { alphamap_fragment: alphamap_fragment, alphamap_pars_fragment: alphamap_pars_fragment, alphatest_fragment: alphatest_fragment, aomap_fragment: aomap_fragment, aomap_pars_fragment: aomap_pars_fragment, begin_vertex: begin_vertex, beginnormal_vertex: beginnormal_vertex, bsdfs: bsdfs, bumpmap_pars_fragment: bumpmap_pars_fragment, clipping_planes_fragment: clipping_planes_fragment, clipping_planes_pars_fragment: clipping_planes_pars_fragment, clipping_planes_pars_vertex: clipping_planes_pars_vertex, clipping_planes_vertex: clipping_planes_vertex, color_fragment: color_fragment, color_pars_fragment: color_pars_fragment, color_pars_vertex: color_pars_vertex, color_vertex: color_vertex, common: common, cube_uv_reflection_fragment: cube_uv_reflection_fragment, defaultnormal_vertex: defaultnormal_vertex, displacementmap_pars_vertex: displacementmap_pars_vertex, displacementmap_vertex: displacementmap_vertex, emissivemap_fragment: emissivemap_fragment, emissivemap_pars_fragment: emissivemap_pars_fragment, encodings_fragment: encodings_fragment, encodings_pars_fragment: encodings_pars_fragment, envmap_fragment: envmap_fragment, envmap_pars_fragment: envmap_pars_fragment, envmap_pars_vertex: envmap_pars_vertex, envmap_physical_pars_fragment: envmap_physical_pars_fragment, envmap_vertex: envmap_vertex, fog_vertex: fog_vertex, fog_pars_vertex: fog_pars_vertex, fog_fragment: fog_fragment, fog_pars_fragment: fog_pars_fragment, gradientmap_pars_fragment: gradientmap_pars_fragment, lightmap_fragment: lightmap_fragment, lightmap_pars_fragment: lightmap_pars_fragment, lights_lambert_vertex: lights_lambert_vertex, lights_pars_begin: lights_pars_begin, lights_phong_fragment: lights_phong_fragment, lights_phong_pars_fragment: lights_phong_pars_fragment, lights_physical_fragment: lights_physical_fragment, lights_physical_pars_fragment: lights_physical_pars_fragment, lights_fragment_begin: lights_fragment_begin, lights_fragment_maps: lights_fragment_maps, lights_fragment_end: lights_fragment_end, logdepthbuf_fragment: logdepthbuf_fragment, logdepthbuf_pars_fragment: logdepthbuf_pars_fragment, logdepthbuf_pars_vertex: logdepthbuf_pars_vertex, logdepthbuf_vertex: logdepthbuf_vertex, map_fragment: map_fragment, map_pars_fragment: map_pars_fragment, map_particle_fragment: map_particle_fragment, map_particle_pars_fragment: map_particle_pars_fragment, metalnessmap_fragment: metalnessmap_fragment, metalnessmap_pars_fragment: metalnessmap_pars_fragment, morphnormal_vertex: morphnormal_vertex, morphtarget_pars_vertex: morphtarget_pars_vertex, morphtarget_vertex: morphtarget_vertex, normal_fragment_begin: normal_fragment_begin, normal_fragment_maps: normal_fragment_maps, normalmap_pars_fragment: normalmap_pars_fragment, packing: packing, premultiplied_alpha_fragment: premultiplied_alpha_fragment, project_vertex: project_vertex, dithering_fragment: dithering_fragment, dithering_pars_fragment: dithering_pars_fragment, roughnessmap_fragment: roughnessmap_fragment, roughnessmap_pars_fragment: roughnessmap_pars_fragment, shadowmap_pars_fragment: shadowmap_pars_fragment, shadowmap_pars_vertex: shadowmap_pars_vertex, shadowmap_vertex: shadowmap_vertex, shadowmask_pars_fragment: shadowmask_pars_fragment, skinbase_vertex: skinbase_vertex, skinning_pars_vertex: skinning_pars_vertex, skinning_vertex: skinning_vertex, skinnormal_vertex: skinnormal_vertex, specularmap_fragment: specularmap_fragment, specularmap_pars_fragment: specularmap_pars_fragment, tonemapping_fragment: tonemapping_fragment, tonemapping_pars_fragment: tonemapping_pars_fragment, uv_pars_fragment: uv_pars_fragment, uv_pars_vertex: uv_pars_vertex, uv_vertex: uv_vertex, uv2_pars_fragment: uv2_pars_fragment, uv2_pars_vertex: uv2_pars_vertex, uv2_vertex: uv2_vertex, worldpos_vertex: worldpos_vertex, background_frag: background_frag, background_vert: background_vert, cube_frag: cube_frag, cube_vert: cube_vert, depth_frag: depth_frag, depth_vert: depth_vert, distanceRGBA_frag: distanceRGBA_frag, distanceRGBA_vert: distanceRGBA_vert, equirect_frag: equirect_frag, equirect_vert: equirect_vert, linedashed_frag: linedashed_frag, linedashed_vert: linedashed_vert, meshbasic_frag: meshbasic_frag, meshbasic_vert: meshbasic_vert, meshlambert_frag: meshlambert_frag, meshlambert_vert: meshlambert_vert, meshmatcap_frag: meshmatcap_frag, meshmatcap_vert: meshmatcap_vert, meshphong_frag: meshphong_frag, meshphong_vert: meshphong_vert, meshphysical_frag: meshphysical_frag, meshphysical_vert: meshphysical_vert, normal_frag: normal_frag, normal_vert: normal_vert, points_frag: points_frag, points_vert: points_vert, shadow_frag: shadow_frag, shadow_vert: shadow_vert, sprite_frag: sprite_frag, sprite_vert: sprite_vert }; /** * Uniform Utilities */ function cloneUniforms( src ) { var dst = {}; for ( var u in src ) { dst[ u ] = {}; for ( var p in src[ u ] ) { var property = src[ u ][ p ]; if ( property && ( property.isColor || property.isMatrix3 || property.isMatrix4 || property.isVector2 || property.isVector3 || property.isVector4 || property.isTexture ) ) { dst[ u ][ p ] = property.clone(); } else if ( Array.isArray( property ) ) { dst[ u ][ p ] = property.slice(); } else { dst[ u ][ p ] = property; } } } return dst; } function mergeUniforms( uniforms ) { var merged = {}; for ( var u = 0; u < uniforms.length; u ++ ) { var tmp = cloneUniforms( uniforms[ u ] ); for ( var p in tmp ) { merged[ p ] = tmp[ p ]; } } return merged; } // Legacy var UniformsUtils = { clone: cloneUniforms, merge: mergeUniforms }; /** * @author mrdoob / http://mrdoob.com/ */ var ColorKeywords = { 'aliceblue': 0xF0F8FF, 'antiquewhite': 0xFAEBD7, 'aqua': 0x00FFFF, 'aquamarine': 0x7FFFD4, 'azure': 0xF0FFFF, 'beige': 0xF5F5DC, 'bisque': 0xFFE4C4, 'black': 0x000000, 'blanchedalmond': 0xFFEBCD, 'blue': 0x0000FF, 'blueviolet': 0x8A2BE2, 'brown': 0xA52A2A, 'burlywood': 0xDEB887, 'cadetblue': 0x5F9EA0, 'chartreuse': 0x7FFF00, 'chocolate': 0xD2691E, 'coral': 0xFF7F50, 'cornflowerblue': 0x6495ED, 'cornsilk': 0xFFF8DC, 'crimson': 0xDC143C, 'cyan': 0x00FFFF, 'darkblue': 0x00008B, 'darkcyan': 0x008B8B, 'darkgoldenrod': 0xB8860B, 'darkgray': 0xA9A9A9, 'darkgreen': 0x006400, 'darkgrey': 0xA9A9A9, 'darkkhaki': 0xBDB76B, 'darkmagenta': 0x8B008B, 'darkolivegreen': 0x556B2F, 'darkorange': 0xFF8C00, 'darkorchid': 0x9932CC, 'darkred': 0x8B0000, 'darksalmon': 0xE9967A, 'darkseagreen': 0x8FBC8F, 'darkslateblue': 0x483D8B, 'darkslategray': 0x2F4F4F, 'darkslategrey': 0x2F4F4F, 'darkturquoise': 0x00CED1, 'darkviolet': 0x9400D3, 'deeppink': 0xFF1493, 'deepskyblue': 0x00BFFF, 'dimgray': 0x696969, 'dimgrey': 0x696969, 'dodgerblue': 0x1E90FF, 'firebrick': 0xB22222, 'floralwhite': 0xFFFAF0, 'forestgreen': 0x228B22, 'fuchsia': 0xFF00FF, 'gainsboro': 0xDCDCDC, 'ghostwhite': 0xF8F8FF, 'gold': 0xFFD700, 'goldenrod': 0xDAA520, 'gray': 0x808080, 'green': 0x008000, 'greenyellow': 0xADFF2F, 'grey': 0x808080, 'honeydew': 0xF0FFF0, 'hotpink': 0xFF69B4, 'indianred': 0xCD5C5C, 'indigo': 0x4B0082, 'ivory': 0xFFFFF0, 'khaki': 0xF0E68C, 'lavender': 0xE6E6FA, 'lavenderblush': 0xFFF0F5, 'lawngreen': 0x7CFC00, 'lemonchiffon': 0xFFFACD, 'lightblue': 0xADD8E6, 'lightcoral': 0xF08080, 'lightcyan': 0xE0FFFF, 'lightgoldenrodyellow': 0xFAFAD2, 'lightgray': 0xD3D3D3, 'lightgreen': 0x90EE90, 'lightgrey': 0xD3D3D3, 'lightpink': 0xFFB6C1, 'lightsalmon': 0xFFA07A, 'lightseagreen': 0x20B2AA, 'lightskyblue': 0x87CEFA, 'lightslategray': 0x778899, 'lightslategrey': 0x778899, 'lightsteelblue': 0xB0C4DE, 'lightyellow': 0xFFFFE0, 'lime': 0x00FF00, 'limegreen': 0x32CD32, 'linen': 0xFAF0E6, 'magenta': 0xFF00FF, 'maroon': 0x800000, 'mediumaquamarine': 0x66CDAA, 'mediumblue': 0x0000CD, 'mediumorchid': 0xBA55D3, 'mediumpurple': 0x9370DB, 'mediumseagreen': 0x3CB371, 'mediumslateblue': 0x7B68EE, 'mediumspringgreen': 0x00FA9A, 'mediumturquoise': 0x48D1CC, 'mediumvioletred': 0xC71585, 'midnightblue': 0x191970, 'mintcream': 0xF5FFFA, 'mistyrose': 0xFFE4E1, 'moccasin': 0xFFE4B5, 'navajowhite': 0xFFDEAD, 'navy': 0x000080, 'oldlace': 0xFDF5E6, 'olive': 0x808000, 'olivedrab': 0x6B8E23, 'orange': 0xFFA500, 'orangered': 0xFF4500, 'orchid': 0xDA70D6, 'palegoldenrod': 0xEEE8AA, 'palegreen': 0x98FB98, 'paleturquoise': 0xAFEEEE, 'palevioletred': 0xDB7093, 'papayawhip': 0xFFEFD5, 'peachpuff': 0xFFDAB9, 'peru': 0xCD853F, 'pink': 0xFFC0CB, 'plum': 0xDDA0DD, 'powderblue': 0xB0E0E6, 'purple': 0x800080, 'rebeccapurple': 0x663399, 'red': 0xFF0000, 'rosybrown': 0xBC8F8F, 'royalblue': 0x4169E1, 'saddlebrown': 0x8B4513, 'salmon': 0xFA8072, 'sandybrown': 0xF4A460, 'seagreen': 0x2E8B57, 'seashell': 0xFFF5EE, 'sienna': 0xA0522D, 'silver': 0xC0C0C0, 'skyblue': 0x87CEEB, 'slateblue': 0x6A5ACD, 'slategray': 0x708090, 'slategrey': 0x708090, 'snow': 0xFFFAFA, 'springgreen': 0x00FF7F, 'steelblue': 0x4682B4, 'tan': 0xD2B48C, 'teal': 0x008080, 'thistle': 0xD8BFD8, 'tomato': 0xFF6347, 'turquoise': 0x40E0D0, 'violet': 0xEE82EE, 'wheat': 0xF5DEB3, 'white': 0xFFFFFF, 'whitesmoke': 0xF5F5F5, 'yellow': 0xFFFF00, 'yellowgreen': 0x9ACD32 }; function Color( r, g, b ) { if ( g === undefined && b === undefined ) { // r is THREE.Color, hex or string return this.set( r ); } return this.setRGB( r, g, b ); } Object.assign( Color.prototype, { isColor: true, r: 1, g: 1, b: 1, set: function ( value ) { if ( value && value.isColor ) { this.copy( value ); } else if ( typeof value === 'number' ) { this.setHex( value ); } else if ( typeof value === 'string' ) { this.setStyle( value ); } return this; }, setScalar: function ( scalar ) { this.r = scalar; this.g = scalar; this.b = scalar; return this; }, setHex: function ( hex ) { hex = Math.floor( hex ); this.r = ( hex >> 16 & 255 ) / 255; this.g = ( hex >> 8 & 255 ) / 255; this.b = ( hex & 255 ) / 255; return this; }, setRGB: function ( r, g, b ) { this.r = r; this.g = g; this.b = b; return this; }, setHSL: function () { function hue2rgb( p, q, t ) { if ( t < 0 ) t += 1; if ( t > 1 ) t -= 1; if ( t < 1 / 6 ) return p + ( q - p ) * 6 * t; if ( t < 1 / 2 ) return q; if ( t < 2 / 3 ) return p + ( q - p ) * 6 * ( 2 / 3 - t ); return p; } return function setHSL( h, s, l ) { // h,s,l ranges are in 0.0 - 1.0 h = _Math.euclideanModulo( h, 1 ); s = _Math.clamp( s, 0, 1 ); l = _Math.clamp( l, 0, 1 ); if ( s === 0 ) { this.r = this.g = this.b = l; } else { var p = l 0; } else if ( geometry && geometry.isGeometry ) { useMorphing = geometry.morphTargets && geometry.morphTargets.length > 0; } } if ( object.isSkinnedMesh && material.skinning === false ) { console.warn( 'THREE.WebGLShadowMap: THREE.SkinnedMesh with material.skinning set to false:', object ); } var useSkinning = object.isSkinnedMesh && material.skinning; var variantIndex = 0; if ( useMorphing ) variantIndex |= _MorphingFlag; if ( useSkinning ) variantIndex |= _SkinningFlag; result = materialVariants[ variantIndex ]; } else { result = customMaterial; } if ( _renderer.localClippingEnabled && material.clipShadows === true && material.clippingPlanes.length !== 0 ) { // in this case we need a unique material instance reflecting the // appropriate state var keyA = result.uuid, keyB = material.uuid; var materialsForVariant = _materialCache[ keyA ]; if ( materialsForVariant === undefined ) { materialsForVariant = {}; _materialCache[ keyA ] = materialsForVariant; } var cachedMaterial = materialsForVariant[ keyB ]; if ( cachedMaterial === undefined ) { cachedMaterial = result.clone(); materialsForVariant[ keyB ] = cachedMaterial; } result = cachedMaterial; } result.visible = material.visible; result.wireframe = material.wireframe; result.side = ( material.shadowSide != null ) ? material.shadowSide : shadowSide[ material.side ]; result.clipShadows = material.clipShadows; result.clippingPlanes = material.clippingPlanes; result.clipIntersection = material.clipIntersection; result.wireframeLinewidth = material.wireframeLinewidth; result.linewidth = material.linewidth; if ( isPointLight && result.isMeshDistanceMaterial ) { result.referencePosition.copy( lightPositionWorld ); result.nearDistance = shadowCameraNear; result.farDistance = shadowCameraFar; } return result; } function renderObject( object, camera, shadowCamera, isPointLight ) { if ( object.visible === false ) return; var visible = object.layers.test( camera.layers ); if ( visible && ( object.isMesh || object.isLine || object.isPoints ) ) { if ( object.castShadow && ( ! object.frustumCulled || _frustum.intersectsObject( object ) ) ) { object.modelViewMatrix.multiplyMatrices( shadowCamera.matrixWorldInverse, object.matrixWorld ); var geometry = _objects.update( object ); var material = object.material; if ( Array.isArray( material ) ) { var groups = geometry.groups; for ( var k = 0, kl = groups.length; k < kl; k ++ ) { var group = groups[ k ]; var groupMaterial = material[ group.materialIndex ]; if ( groupMaterial && groupMaterial.visible ) { var depthMaterial = getDepthMaterial( object, groupMaterial, isPointLight, _lightPositionWorld, shadowCamera.near, shadowCamera.far ); _renderer.renderBufferDirect( shadowCamera, null, geometry, depthMaterial, object, group ); } } } else if ( material.visible ) { var depthMaterial = getDepthMaterial( object, material, isPointLight, _lightPositionWorld, shadowCamera.near, shadowCamera.far ); _renderer.renderBufferDirect( shadowCamera, null, geometry, depthMaterial, object, null ); } } } var children = object.children; for ( var i = 0, l = children.length; i < l; i ++ ) { renderObject( children[ i ], camera, shadowCamera, isPointLight ); } } } /** * @author mrdoob / http://mrdoob.com/ */ function WebGLState( gl, extensions, utils, capabilities ) { function ColorBuffer() { var locked = false; var color = new Vector4(); var currentColorMask = null; var currentColorClear = new Vector4( 0, 0, 0, 0 ); return { setMask: function ( colorMask ) { if ( currentColorMask !== colorMask && ! locked ) { gl.colorMask( colorMask, colorMask, colorMask, colorMask ); currentColorMask = colorMask; } }, setLocked: function ( lock ) { locked = lock; }, setClear: function ( r, g, b, a, premultipliedAlpha ) { if ( premultipliedAlpha === true ) { r *= a; g *= a; b *= a; } color.set( r, g, b, a ); if ( currentColorClear.equals( color ) === false ) { gl.clearColor( r, g, b, a ); currentColorClear.copy( color ); } }, reset: function () { locked = false; currentColorMask = null; currentColorClear.set( - 1, 0, 0, 0 ); // set to invalid state } }; } function DepthBuffer() { var locked = false; var currentDepthMask = null; var currentDepthFunc = null; var currentDepthClear = null; return { setTest: function ( depthTest ) { if ( depthTest ) { enable( 2929 ); } else { disable( 2929 ); } }, setMask: function ( depthMask ) { if ( currentDepthMask !== depthMask && ! locked ) { gl.depthMask( depthMask ); currentDepthMask = depthMask; } }, setFunc: function ( depthFunc ) { if ( currentDepthFunc !== depthFunc ) { if ( depthFunc ) { switch ( depthFunc ) { case NeverDepth: gl.depthFunc( 512 ); break; case AlwaysDepth: gl.depthFunc( 519 ); break; case LessDepth: gl.depthFunc( 513 ); break; case LessEqualDepth: gl.depthFunc( 515 ); break; case EqualDepth: gl.depthFunc( 514 ); break; case GreaterEqualDepth: gl.depthFunc( 518 ); break; case GreaterDepth: gl.depthFunc( 516 ); break; case NotEqualDepth: gl.depthFunc( 517 ); break; default: gl.depthFunc( 515 ); } } else { gl.depthFunc( 515 ); } currentDepthFunc = depthFunc; } }, setLocked: function ( lock ) { locked = lock; }, setClear: function ( depth ) { if ( currentDepthClear !== depth ) { gl.clearDepth( depth ); currentDepthClear = depth; } }, reset: function () { locked = false; currentDepthMask = null; currentDepthFunc = null; currentDepthClear = null; } }; } function StencilBuffer() { var locked = false; var currentStencilMask = null; var currentStencilFunc = null; var currentStencilRef = null; var currentStencilFuncMask = null; var currentStencilFail = null; var currentStencilZFail = null; var currentStencilZPass = null; var currentStencilClear = null; return { setTest: function ( stencilTest ) { if ( stencilTest ) { enable( 2960 ); } else { disable( 2960 ); } }, setMask: function ( stencilMask ) { if ( currentStencilMask !== stencilMask && ! locked ) { gl.stencilMask( stencilMask ); currentStencilMask = stencilMask; } }, setFunc: function ( stencilFunc, stencilRef, stencilMask ) { if ( currentStencilFunc !== stencilFunc || currentStencilRef !== stencilRef || currentStencilFuncMask !== stencilMask ) { gl.stencilFunc( stencilFunc, stencilRef, stencilMask ); currentStencilFunc = stencilFunc; currentStencilRef = stencilRef; currentStencilFuncMask = stencilMask; } }, setOp: function ( stencilFail, stencilZFail, stencilZPass ) { if ( currentStencilFail !== stencilFail || currentStencilZFail !== stencilZFail || currentStencilZPass !== stencilZPass ) { gl.stencilOp( stencilFail, stencilZFail, stencilZPass ); currentStencilFail = stencilFail; currentStencilZFail = stencilZFail; currentStencilZPass = stencilZPass; } }, setLocked: function ( lock ) { locked = lock; }, setClear: function ( stencil ) { if ( currentStencilClear !== stencil ) { gl.clearStencil( stencil ); currentStencilClear = stencil; } }, reset: function () { locked = false; currentStencilMask = null; currentStencilFunc = null; currentStencilRef = null; currentStencilFuncMask = null; currentStencilFail = null; currentStencilZFail = null; currentStencilZPass = null; currentStencilClear = null; } }; } // var colorBuffer = new ColorBuffer(); var depthBuffer = new DepthBuffer(); var stencilBuffer = new StencilBuffer(); var maxVertexAttributes = gl.getParameter( 34921 ); var newAttributes = new Uint8Array( maxVertexAttributes ); var enabledAttributes = new Uint8Array( maxVertexAttributes ); var attributeDivisors = new Uint8Array( maxVertexAttributes ); var enabledCapabilities = {}; var compressedTextureFormats = null; var currentProgram = null; var currentBlendingEnabled = null; var currentBlending = null; var currentBlendEquation = null; var currentBlendSrc = null; var currentBlendDst = null; var currentBlendEquationAlpha = null; var currentBlendSrcAlpha = null; var currentBlendDstAlpha = null; var currentPremultipledAlpha = false; var currentFlipSided = null; var currentCullFace = null; var currentLineWidth = null; var currentPolygonOffsetFactor = null; var currentPolygonOffsetUnits = null; var maxTextures = gl.getParameter( 35661 ); var lineWidthAvailable = false; var version = 0; var glVersion = gl.getParameter( 7938 ); if ( glVersion.indexOf( 'WebGL' ) !== - 1 ) { version = parseFloat( /^WebGL\\ ([0-9])/.exec( glVersion )[ 1 ] ); lineWidthAvailable = ( version >= 1.0 ); } else if ( glVersion.indexOf( 'OpenGL ES' ) !== - 1 ) { version = parseFloat( /^OpenGL\\ ES\\ ([0-9])/.exec( glVersion )[ 1 ] ); lineWidthAvailable = ( version >= 2.0 ); } var currentTextureSlot = null; var currentBoundTextures = {}; var currentScissor = new Vector4(); var currentViewport = new Vector4(); function createTexture( type, target, count ) { var data = new Uint8Array( 4 ); // 4 is required to match default unpack alignment of 4. var texture = gl.createTexture(); gl.bindTexture( type, texture ); gl.texParameteri( type, 10241, 9728 ); gl.texParameteri( type, 10240, 9728 ); for ( var i = 0; i < count; i ++ ) { gl.texImage2D( target + i, 0, 6408, 1, 1, 0, 6408, 5121, data ); } return texture; } var emptyTextures = {}; emptyTextures[ 3553 ] = createTexture( 3553, 3553, 1 ); emptyTextures[ 34067 ] = createTexture( 34067, 34069, 6 ); // init colorBuffer.setClear( 0, 0, 0, 1 ); depthBuffer.setClear( 1 ); stencilBuffer.setClear( 0 ); enable( 2929 ); depthBuffer.setFunc( LessEqualDepth ); setFlipSided( false ); setCullFace( CullFaceBack ); enable( 2884 ); setBlending( NoBlending ); // function initAttributes() { for ( var i = 0, l = newAttributes.length; i < l; i ++ ) { newAttributes[ i ] = 0; } } function enableAttribute( attribute ) { enableAttributeAndDivisor( attribute, 0 ); } function enableAttributeAndDivisor( attribute, meshPerAttribute ) { newAttributes[ attribute ] = 1; if ( enabledAttributes[ attribute ] === 0 ) { gl.enableVertexAttribArray( attribute ); enabledAttributes[ attribute ] = 1; } if ( attributeDivisors[ attribute ] !== meshPerAttribute ) { var extension = capabilities.isWebGL2 ? gl : extensions.get( 'ANGLE_instanced_arrays' ); extension[ capabilities.isWebGL2 ? 'vertexAttribDivisor' : 'vertexAttribDivisorANGLE' ]( attribute, meshPerAttribute ); attributeDivisors[ attribute ] = meshPerAttribute; } } function disableUnusedAttributes() { for ( var i = 0, l = enabledAttributes.length; i !== l; ++ i ) { if ( enabledAttributes[ i ] !== newAttributes[ i ] ) { gl.disableVertexAttribArray( i ); enabledAttributes[ i ] = 0; } } } function enable( id ) { if ( enabledCapabilities[ id ] !== true ) { gl.enable( id ); enabledCapabilities[ id ] = true; } } function disable( id ) { if ( enabledCapabilities[ id ] !== false ) { gl.disable( id ); enabledCapabilities[ id ] = false; } } function getCompressedTextureFormats() { if ( compressedTextureFormats === null ) { compressedTextureFormats = []; if ( extensions.get( 'WEBGL_compressed_texture_pvrtc' ) || extensions.get( 'WEBGL_compressed_texture_s3tc' ) || extensions.get( 'WEBGL_compressed_texture_etc1' ) || extensions.get( 'WEBGL_compressed_texture_astc' ) ) { var formats = gl.getParameter( 34467 ); for ( var i = 0; i < formats.length; i ++ ) { compressedTextureFormats.push( formats[ i ] ); } } } return compressedTextureFormats; } function useProgram( program ) { if ( currentProgram !== program ) { gl.useProgram( program ); currentProgram = program; return true; } return false; } function setBlending( blending, blendEquation, blendSrc, blendDst, blendEquationAlpha, blendSrcAlpha, blendDstAlpha, premultipliedAlpha ) { if ( blending === NoBlending ) { if ( currentBlendingEnabled ) { disable( 3042 ); currentBlendingEnabled = false; } return; } if ( ! currentBlendingEnabled ) { enable( 3042 ); currentBlendingEnabled = true; } if ( blending !== CustomBlending ) { if ( blending !== currentBlending || premultipliedAlpha !== currentPremultipledAlpha ) { if ( currentBlendEquation !== AddEquation || currentBlendEquationAlpha !== AddEquation ) { gl.blendEquation( 32774 ); currentBlendEquation = AddEquation; currentBlendEquationAlpha = AddEquation; } if ( premultipliedAlpha ) { switch ( blending ) { case NormalBlending: gl.blendFuncSeparate( 1, 771, 1, 771 ); break; case AdditiveBlending: gl.blendFunc( 1, 1 ); break; case SubtractiveBlending: gl.blendFuncSeparate( 0, 0, 769, 771 ); break; case MultiplyBlending: gl.blendFuncSeparate( 0, 768, 0, 770 ); break; default: console.error( 'THREE.WebGLState: Invalid blending: ', blending ); break; } } else { switch ( blending ) { case NormalBlending: gl.blendFuncSeparate( 770, 771, 1, 771 ); break; case AdditiveBlending: gl.blendFunc( 770, 1 ); break; case SubtractiveBlending: gl.blendFunc( 0, 769 ); break; case MultiplyBlending: gl.blendFunc( 0, 768 ); break; default: console.error( 'THREE.WebGLState: Invalid blending: ', blending ); break; } } currentBlendSrc = null; currentBlendDst = null; currentBlendSrcAlpha = null; currentBlendDstAlpha = null; currentBlending = blending; currentPremultipledAlpha = premultipliedAlpha; } return; } // custom blending blendEquationAlpha = blendEquationAlpha || blendEquation; blendSrcAlpha = blendSrcAlpha || blendSrc; blendDstAlpha = blendDstAlpha || blendDst; if ( blendEquation !== currentBlendEquation || blendEquationAlpha !== currentBlendEquationAlpha ) { gl.blendEquationSeparate( utils.convert( blendEquation ), utils.convert( blendEquationAlpha ) ); currentBlendEquation = blendEquation; currentBlendEquationAlpha = blendEquationAlpha; } if ( blendSrc !== currentBlendSrc || blendDst !== currentBlendDst || blendSrcAlpha !== currentBlendSrcAlpha || blendDstAlpha !== currentBlendDstAlpha ) { gl.blendFuncSeparate( utils.convert( blendSrc ), utils.convert( blendDst ), utils.convert( blendSrcAlpha ), utils.convert( blendDstAlpha ) ); currentBlendSrc = blendSrc; currentBlendDst = blendDst; currentBlendSrcAlpha = blendSrcAlpha; currentBlendDstAlpha = blendDstAlpha; } currentBlending = blending; currentPremultipledAlpha = null; } function setMaterial( material, frontFaceCW ) { material.side === DoubleSide ? disable( 2884 ) : enable( 2884 ); var flipSided = ( material.side === BackSide ); if ( frontFaceCW ) flipSided = ! flipSided; setFlipSided( flipSided ); ( material.blending === NormalBlending && material.transparent === false ) ? setBlending( NoBlending ) : setBlending( material.blending, material.blendEquation, material.blendSrc, material.blendDst, material.blendEquationAlpha, material.blendSrcAlpha, material.blendDstAlpha, material.premultipliedAlpha ); depthBuffer.setFunc( material.depthFunc ); depthBuffer.setTest( material.depthTest ); depthBuffer.setMask( material.depthWrite ); colorBuffer.setMask( material.colorWrite ); setPolygonOffset( material.polygonOffset, material.polygonOffsetFactor, material.polygonOffsetUnits ); } // function setFlipSided( flipSided ) { if ( currentFlipSided !== flipSided ) { if ( flipSided ) { gl.frontFace( 2304 ); } else { gl.frontFace( 2305 ); } currentFlipSided = flipSided; } } function setCullFace( cullFace ) { if ( cullFace !== CullFaceNone ) { enable( 2884 ); if ( cullFace !== currentCullFace ) { if ( cullFace === CullFaceBack ) { gl.cullFace( 1029 ); } else if ( cullFace === CullFaceFront ) { gl.cullFace( 1028 ); } else { gl.cullFace( 1032 ); } } } else { disable( 2884 ); } currentCullFace = cullFace; } function setLineWidth( width ) { if ( width !== currentLineWidth ) { if ( lineWidthAvailable ) gl.lineWidth( width ); currentLineWidth = width; } } function setPolygonOffset( polygonOffset, factor, units ) { if ( polygonOffset ) { enable( 32823 ); if ( currentPolygonOffsetFactor !== factor || currentPolygonOffsetUnits !== units ) { gl.polygonOffset( factor, units ); currentPolygonOffsetFactor = factor; currentPolygonOffsetUnits = units; } } else { disable( 32823 ); } } function setScissorTest( scissorTest ) { if ( scissorTest ) { enable( 3089 ); } else { disable( 3089 ); } } // texture function activeTexture( webglSlot ) { if ( webglSlot === undefined ) webglSlot = 33984 + maxTextures - 1; if ( currentTextureSlot !== webglSlot ) { gl.activeTexture( webglSlot ); currentTextureSlot = webglSlot; } } function bindTexture( webglType, webglTexture ) { if ( currentTextureSlot === null ) { activeTexture(); } var boundTexture = currentBoundTextures[ currentTextureSlot ]; if ( boundTexture === undefined ) { boundTexture = { type: undefined, texture: undefined }; currentBoundTextures[ currentTextureSlot ] = boundTexture; } if ( boundTexture.type !== webglType || boundTexture.texture !== webglTexture ) { gl.bindTexture( webglType, webglTexture || emptyTextures[ webglType ] ); boundTexture.type = webglType; boundTexture.texture = webglTexture; } } function compressedTexImage2D() { try { gl.compressedTexImage2D.apply( gl, arguments ); } catch ( error ) { console.error( 'THREE.WebGLState:', error ); } } function texImage2D() { try { gl.texImage2D.apply( gl, arguments ); } catch ( error ) { console.error( 'THREE.WebGLState:', error ); } } function texImage3D() { try { gl.texImage3D.apply( gl, arguments ); } catch ( error ) { console.error( 'THREE.WebGLState:', error ); } } // function scissor( scissor ) { if ( currentScissor.equals( scissor ) === false ) { gl.scissor( scissor.x, scissor.y, scissor.z, scissor.w ); currentScissor.copy( scissor ); } } function viewport( viewport ) { if ( currentViewport.equals( viewport ) === false ) { gl.viewport( viewport.x, viewport.y, viewport.z, viewport.w ); currentViewport.copy( viewport ); } } // function reset() { for ( var i = 0; i < enabledAttributes.length; i ++ ) { if ( enabledAttributes[ i ] === 1 ) { gl.disableVertexAttribArray( i ); enabledAttributes[ i ] = 0; } } enabledCapabilities = {}; compressedTextureFormats = null; currentTextureSlot = null; currentBoundTextures = {}; currentProgram = null; currentBlending = null; currentFlipSided = null; currentCullFace = null; colorBuffer.reset(); depthBuffer.reset(); stencilBuffer.reset(); } return { buffers: { color: colorBuffer, depth: depthBuffer, stencil: stencilBuffer }, initAttributes: initAttributes, enableAttribute: enableAttribute, enableAttributeAndDivisor: enableAttributeAndDivisor, disableUnusedAttributes: disableUnusedAttributes, enable: enable, disable: disable, getCompressedTextureFormats: getCompressedTextureFormats, useProgram: useProgram, setBlending: setBlending, setMaterial: setMaterial, setFlipSided: setFlipSided, setCullFace: setCullFace, setLineWidth: setLineWidth, setPolygonOffset: setPolygonOffset, setScissorTest: setScissorTest, activeTexture: activeTexture, bindTexture: bindTexture, compressedTexImage2D: compressedTexImage2D, texImage2D: texImage2D, texImage3D: texImage3D, scissor: scissor, viewport: viewport, reset: reset }; } /** * @author mrdoob / http://mrdoob.com/ */ function WebGLTextures( _gl, extensions, state, properties, capabilities, utils, info ) { var _videoTextures = {}; var _canvas; // function resizeImage( image, needsPowerOfTwo, needsNewCanvas, maxSize ) { var scale = 1; // handle case if texture exceeds max size if ( image.width > maxSize || image.height > maxSize ) { scale = maxSize / Math.max( image.width, image.height ); } // only perform resize if necessary if ( scale < 1 || needsPowerOfTwo === true ) { // only perform resize for certain image types if ( image instanceof HTMLImageElement || image instanceof HTMLCanvasElement || image instanceof ImageBitmap ) { if ( _canvas === undefined ) _canvas = document.createElementNS( 'http://www.w3.org/1999/xhtml', 'canvas' ); // cube textures can't reuse the same canvas var canvas = needsNewCanvas ? document.createElementNS( 'http://www.w3.org/1999/xhtml', 'canvas' ) : _canvas; var floor = needsPowerOfTwo ? _Math.floorPowerOfTwo : Math.floor; canvas.width = floor( scale * image.width ); canvas.height = floor( scale * image.height ); var context = canvas.getContext( '2d' ); context.drawImage( image, 0, 0, canvas.width, canvas.height ); console.warn( 'THREE.WebGLRenderer: Texture has been resized from (' + image.width + 'x' + image.height + ') to (' + canvas.width + 'x' + canvas.height + ').' ); return canvas; } else { if ( 'data' in image ) { console.warn( 'THREE.WebGLRenderer: Image in DataTexture is too big (' + image.width + 'x' + image.height + ').' ); } return image; } } return image; } function isPowerOfTwo( image ) { return _Math.isPowerOfTwo( image.width ) && _Math.isPowerOfTwo( image.height ); } function textureNeedsPowerOfTwo( texture ) { if ( capabilities.isWebGL2 ) return false; return ( texture.wrapS !== ClampToEdgeWrapping || texture.wrapT !== ClampToEdgeWrapping ) || ( texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter ); } function textureNeedsGenerateMipmaps( texture, supportsMips ) { return texture.generateMipmaps && supportsMips && texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter; } function generateMipmap( target, texture, width, height ) { _gl.generateMipmap( target ); var textureProperties = properties.get( texture ); // Note: Math.log( x ) * Math.LOG2E used instead of Math.log2( x ) which is not supported by IE11 textureProperties.__maxMipLevel = Math.log( Math.max( width, height ) ) * Math.LOG2E; } function getInternalFormat( glFormat, glType ) { if ( ! capabilities.isWebGL2 ) return glFormat; var internalFormat = glFormat; if ( glFormat === 6403 ) { if ( glType === 5126 ) internalFormat = 33326; if ( glType === 5131 ) internalFormat = 33325; if ( glType === 5121 ) internalFormat = 33321; } if ( glFormat === 6407 ) { if ( glType === 5126 ) internalFormat = 34837; if ( glType === 5131 ) internalFormat = 34843; if ( glType === 5121 ) internalFormat = 32849; } if ( glFormat === 6408 ) { if ( glType === 5126 ) internalFormat = 34836; if ( glType === 5131 ) internalFormat = 34842; if ( glType === 5121 ) internalFormat = 32856; } if ( internalFormat === 33325 || internalFormat === 33326 || internalFormat === 34842 || internalFormat === 34836 ) { extensions.get( 'EXT_color_buffer_float' ); } else if ( internalFormat === 34843 || internalFormat === 34837 ) { console.warn( 'THREE.WebGLRenderer: Floating point textures with RGB format not supported. Please use RGBA instead.' ); } return internalFormat; } // Fallback filters for non-power-of-2 textures function filterFallback( f ) { if ( f === NearestFilter || f === NearestMipMapNearestFilter || f === NearestMipMapLinearFilter ) { return 9728; } return 9729; } // function onTextureDispose( event ) { var texture = event.target; texture.removeEventListener( 'dispose', onTextureDispose ); deallocateTexture( texture ); if ( texture.isVideoTexture ) { delete _videoTextures[ texture.id ]; } info.memory.textures --; } function onRenderTargetDispose( event ) { var renderTarget = event.target; renderTarget.removeEventListener( 'dispose', onRenderTargetDispose ); deallocateRenderTarget( renderTarget ); info.memory.textures --; } // function deallocateTexture( texture ) { var textureProperties = properties.get( texture ); if ( textureProperties.__webglInit === undefined ) return; _gl.deleteTexture( textureProperties.__webglTexture ); properties.remove( texture ); } function deallocateRenderTarget( renderTarget ) { var renderTargetProperties = properties.get( renderTarget ); var textureProperties = properties.get( renderTarget.texture ); if ( ! renderTarget ) return; if ( textureProperties.__webglTexture !== undefined ) { _gl.deleteTexture( textureProperties.__webglTexture ); } if ( renderTarget.depthTexture ) { renderTarget.depthTexture.dispose(); } if ( renderTarget.isWebGLRenderTargetCube ) { for ( var i = 0; i < 6; i ++ ) { _gl.deleteFramebuffer( renderTargetProperties.__webglFramebuffer[ i ] ); if ( renderTargetProperties.__webglDepthbuffer ) _gl.deleteRenderbuffer( renderTargetProperties.__webglDepthbuffer[ i ] ); } } else { _gl.deleteFramebuffer( renderTargetProperties.__webglFramebuffer ); if ( renderTargetProperties.__webglDepthbuffer ) _gl.deleteRenderbuffer( renderTargetProperties.__webglDepthbuffer ); } properties.remove( renderTarget.texture ); properties.remove( renderTarget ); } // function setTexture2D( texture, slot ) { var textureProperties = properties.get( texture ); if ( texture.isVideoTexture ) updateVideoTexture( texture ); if ( texture.version > 0 && textureProperties.__version !== texture.version ) { var image = texture.image; if ( image === undefined ) { console.warn( 'THREE.WebGLRenderer: Texture marked for update but image is undefined' ); } else if ( image.complete === false ) { console.warn( 'THREE.WebGLRenderer: Texture marked for update but image is incomplete' ); } else { uploadTexture( textureProperties, texture, slot ); return; } } state.activeTexture( 33984 + slot ); state.bindTexture( 3553, textureProperties.__webglTexture ); } function setTexture3D( texture, slot ) { var textureProperties = properties.get( texture ); if ( texture.version > 0 && textureProperties.__version !== texture.version ) { uploadTexture( textureProperties, texture, slot ); return; } state.activeTexture( 33984 + slot ); state.bindTexture( 32879, textureProperties.__webglTexture ); } function setTextureCube( texture, slot ) { var textureProperties = properties.get( texture ); if ( texture.image.length === 6 ) { if ( texture.version > 0 && textureProperties.__version !== texture.version ) { initTexture( textureProperties, texture ); state.activeTexture( 33984 + slot ); state.bindTexture( 34067, textureProperties.__webglTexture ); _gl.pixelStorei( 37440, texture.flipY ); var isCompressed = ( texture && texture.isCompressedTexture ); var isDataTexture = ( texture.image[ 0 ] && texture.image[ 0 ].isDataTexture ); var cubeImage = []; for ( var i = 0; i < 6; i ++ ) { if ( ! isCompressed && ! isDataTexture ) { cubeImage[ i ] = resizeImage( texture.image[ i ], false, true, capabilities.maxCubemapSize ); } else { cubeImage[ i ] = isDataTexture ? texture.image[ i ].image : texture.image[ i ]; } } var image = cubeImage[ 0 ], supportsMips = isPowerOfTwo( image ) || capabilities.isWebGL2, glFormat = utils.convert( texture.format ), glType = utils.convert( texture.type ), glInternalFormat = getInternalFormat( glFormat, glType ); setTextureParameters( 34067, texture, supportsMips ); for ( var i = 0; i < 6; i ++ ) { if ( ! isCompressed ) { if ( isDataTexture ) { state.texImage2D( 34069 + i, 0, glInternalFormat, cubeImage[ i ].width, cubeImage[ i ].height, 0, glFormat, glType, cubeImage[ i ].data ); } else { state.texImage2D( 34069 + i, 0, glInternalFormat, glFormat, glType, cubeImage[ i ] ); } } else { var mipmap, mipmaps = cubeImage[ i ].mipmaps; for ( var j = 0, jl = mipmaps.length; j < jl; j ++ ) { mipmap = mipmaps[ j ]; if ( texture.format !== RGBAFormat && texture.format !== RGBFormat ) { if ( state.getCompressedTextureFormats().indexOf( glFormat ) > - 1 ) { state.compressedTexImage2D( 34069 + i, j, glInternalFormat, mipmap.width, mipmap.height, 0, mipmap.data ); } else { console.warn( 'THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()' ); } } else { state.texImage2D( 34069 + i, j, glInternalFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data ); } } } } if ( ! isCompressed ) { textureProperties.__maxMipLevel = 0; } else { textureProperties.__maxMipLevel = mipmaps.length - 1; } if ( textureNeedsGenerateMipmaps( texture, supportsMips ) ) { // We assume images for cube map have the same size. generateMipmap( 34067, texture, image.width, image.height ); } textureProperties.__version = texture.version; if ( texture.onUpdate ) texture.onUpdate( texture ); } else { state.activeTexture( 33984 + slot ); state.bindTexture( 34067, textureProperties.__webglTexture ); } } } function setTextureCubeDynamic( texture, slot ) { state.activeTexture( 33984 + slot ); state.bindTexture( 34067, properties.get( texture ).__webglTexture ); } function setTextureParameters( textureType, texture, supportsMips ) { var extension; if ( supportsMips ) { _gl.texParameteri( textureType, 10242, utils.convert( texture.wrapS ) ); _gl.texParameteri( textureType, 10243, utils.convert( texture.wrapT ) ); if ( textureType === 32879 ) { _gl.texParameteri( textureType, 32882, utils.convert( texture.wrapR ) ); } _gl.texParameteri( textureType, 10240, utils.convert( texture.magFilter ) ); _gl.texParameteri( textureType, 10241, utils.convert( texture.minFilter ) ); } else { _gl.texParameteri( textureType, 10242, 33071 ); _gl.texParameteri( textureType, 10243, 33071 ); if ( textureType === 32879 ) { _gl.texParameteri( textureType, 32882, 33071 ); } if ( texture.wrapS !== ClampToEdgeWrapping || texture.wrapT !== ClampToEdgeWrapping ) { console.warn( 'THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping.' ); } _gl.texParameteri( textureType, 10240, filterFallback( texture.magFilter ) ); _gl.texParameteri( textureType, 10241, filterFallback( texture.minFilter ) ); if ( texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter ) { console.warn( 'THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.' ); } } extension = extensions.get( 'EXT_texture_filter_anisotropic' ); if ( extension ) { if ( texture.type === FloatType && extensions.get( 'OES_texture_float_linear' ) === null ) return; if ( texture.type === HalfFloatType && ( capabilities.isWebGL2 || extensions.get( 'OES_texture_half_float_linear' ) ) === null ) return; if ( texture.anisotropy > 1 || properties.get( texture ).__currentAnisotropy ) { _gl.texParameterf( textureType, extension.TEXTURE_MAX_ANISOTROPY_EXT, Math.min( texture.anisotropy, capabilities.getMaxAnisotropy() ) ); properties.get( texture ).__currentAnisotropy = texture.anisotropy; } } } function initTexture( textureProperties, texture ) { if ( textureProperties.__webglInit === undefined ) { textureProperties.__webglInit = true; texture.addEventListener( 'dispose', onTextureDispose ); textureProperties.__webglTexture = _gl.createTexture(); info.memory.textures ++; } } function uploadTexture( textureProperties, texture, slot ) { var textureType = ( texture.isDataTexture3D ) ? 32879 : 3553; initTexture( textureProperties, texture ); state.activeTexture( 33984 + slot ); state.bindTexture( textureType, textureProperties.__webglTexture ); _gl.pixelStorei( 37440, texture.flipY ); _gl.pixelStorei( 37441, texture.premultiplyAlpha ); _gl.pixelStorei( 3317, texture.unpackAlignment ); var needsPowerOfTwo = textureNeedsPowerOfTwo( texture ) && isPowerOfTwo( texture.image ) === false; var image = resizeImage( texture.image, needsPowerOfTwo, false, capabilities.maxTextureSize ); var supportsMips = isPowerOfTwo( image ) || capabilities.isWebGL2, glFormat = utils.convert( texture.format ), glType = utils.convert( texture.type ), glInternalFormat = getInternalFormat( glFormat, glType ); setTextureParameters( textureType, texture, supportsMips ); var mipmap, mipmaps = texture.mipmaps; if ( texture.isDepthTexture ) { // populate depth texture with dummy data glInternalFormat = 6402; if ( texture.type === FloatType ) { if ( ! capabilities.isWebGL2 ) throw new Error( 'Float Depth Texture only supported in WebGL2.0' ); glInternalFormat = 36012; } else if ( capabilities.isWebGL2 ) { // WebGL 2.0 requires signed internalformat for glTexImage2D glInternalFormat = 33189; } if ( texture.format === DepthFormat && glInternalFormat === 6402 ) { // The error INVALID_OPERATION is generated by texImage2D if format and internalformat are // DEPTH_COMPONENT and type is not UNSIGNED_SHORT or UNSIGNED_INT // (https://www.khronos.org/registry/webgl/extensions/WEBGL_depth_texture/) if ( texture.type !== UnsignedShortType && texture.type !== UnsignedIntType ) { console.warn( 'THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture.' ); texture.type = UnsignedShortType; glType = utils.convert( texture.type ); } } // Depth stencil textures need the DEPTH_STENCIL internal format // (https://www.khronos.org/registry/webgl/extensions/WEBGL_depth_texture/) if ( texture.format === DepthStencilFormat ) { glInternalFormat = 34041; // The error INVALID_OPERATION is generated by texImage2D if format and internalformat are // DEPTH_STENCIL and type is not UNSIGNED_INT_24_8_WEBGL. // (https://www.khronos.org/registry/webgl/extensions/WEBGL_depth_texture/) if ( texture.type !== UnsignedInt248Type ) { console.warn( 'THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture.' ); texture.type = UnsignedInt248Type; glType = utils.convert( texture.type ); } } state.texImage2D( 3553, 0, glInternalFormat, image.width, image.height, 0, glFormat, glType, null ); } else if ( texture.isDataTexture ) { // use manually created mipmaps if available // if there are no manual mipmaps // set 0 level mipmap and then use GL to generate other mipmap levels if ( mipmaps.length > 0 && supportsMips ) { for ( var i = 0, il = mipmaps.length; i < il; i ++ ) { mipmap = mipmaps[ i ]; state.texImage2D( 3553, i, glInternalFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data ); } texture.generateMipmaps = false; textureProperties.__maxMipLevel = mipmaps.length - 1; } else { state.texImage2D( 3553, 0, glInternalFormat, image.width, image.height, 0, glFormat, glType, image.data ); textureProperties.__maxMipLevel = 0; } } else if ( texture.isCompressedTexture ) { for ( var i = 0, il = mipmaps.length; i < il; i ++ ) { mipmap = mipmaps[ i ]; if ( texture.format !== RGBAFormat && texture.format !== RGBFormat ) { if ( state.getCompressedTextureFormats().indexOf( glFormat ) > - 1 ) { state.compressedTexImage2D( 3553, i, glInternalFormat, mipmap.width, mipmap.height, 0, mipmap.data ); } else { console.warn( 'THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()' ); } } else { state.texImage2D( 3553, i, glInternalFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data ); } } textureProperties.__maxMipLevel = mipmaps.length - 1; } else if ( texture.isDataTexture3D ) { state.texImage3D( 32879, 0, glInternalFormat, image.width, image.height, image.depth, 0, glFormat, glType, image.data ); textureProperties.__maxMipLevel = 0; } else { // regular Texture (image, video, canvas) // use manually created mipmaps if available // if there are no manual mipmaps // set 0 level mipmap and then use GL to generate other mipmap levels if ( mipmaps.length > 0 && supportsMips ) { for ( var i = 0, il = mipmaps.length; i < il; i ++ ) { mipmap = mipmaps[ i ]; state.texImage2D( 3553, i, glInternalFormat, glFormat, glType, mipmap ); } texture.generateMipmaps = false; textureProperties.__maxMipLevel = mipmaps.length - 1; } else { state.texImage2D( 3553, 0, glInternalFormat, glFormat, glType, image ); textureProperties.__maxMipLevel = 0; } } if ( textureNeedsGenerateMipmaps( texture, supportsMips ) ) { generateMipmap( 3553, texture, image.width, image.height ); } textureProperties.__version = texture.version; if ( texture.onUpdate ) texture.onUpdate( texture ); } // Render targets // Setup storage for target texture and bind it to correct framebuffer function setupFrameBufferTexture( framebuffer, renderTarget, attachment, textureTarget ) { var glFormat = utils.convert( renderTarget.texture.format ); var glType = utils.convert( renderTarget.texture.type ); var glInternalFormat = getInternalFormat( glFormat, glType ); state.texImage2D( textureTarget, 0, glInternalFormat, renderTarget.width, renderTarget.height, 0, glFormat, glType, null ); _gl.bindFramebuffer( 36160, framebuffer ); _gl.framebufferTexture2D( 36160, attachment, textureTarget, properties.get( renderTarget.texture ).__webglTexture, 0 ); _gl.bindFramebuffer( 36160, null ); } // Setup storage for internal depth/stencil buffers and bind to correct framebuffer function setupRenderBufferStorage( renderbuffer, renderTarget, isMultisample ) { _gl.bindRenderbuffer( 36161, renderbuffer ); if ( renderTarget.depthBuffer && ! renderTarget.stencilBuffer ) { if ( isMultisample ) { var samples = getRenderTargetSamples( renderTarget ); _gl.renderbufferStorageMultisample( 36161, samples, 33189, renderTarget.width, renderTarget.height ); } else { _gl.renderbufferStorage( 36161, 33189, renderTarget.width, renderTarget.height ); } _gl.framebufferRenderbuffer( 36160, 36096, 36161, renderbuffer ); } else if ( renderTarget.depthBuffer && renderTarget.stencilBuffer ) { if ( isMultisample ) { var samples = getRenderTargetSamples( renderTarget ); _gl.renderbufferStorageMultisample( 36161, samples, 34041, renderTarget.width, renderTarget.height ); } else { _gl.renderbufferStorage( 36161, 34041, renderTarget.width, renderTarget.height ); } _gl.framebufferRenderbuffer( 36160, 33306, 36161, renderbuffer ); } else { var glFormat = utils.convert( renderTarget.texture.format ); var glType = utils.convert( renderTarget.texture.type ); var glInternalFormat = getInternalFormat( glFormat, glType ); if ( isMultisample ) { var samples = getRenderTargetSamples( renderTarget ); _gl.renderbufferStorageMultisample( 36161, samples, glInternalFormat, renderTarget.width, renderTarget.height ); } else { _gl.renderbufferStorage( 36161, glInternalFormat, renderTarget.width, renderTarget.height ); } } _gl.bindRenderbuffer( 36161, null ); } // Setup resources for a Depth Texture for a FBO (needs an extension) function setupDepthTexture( framebuffer, renderTarget ) { var isCube = ( renderTarget && renderTarget.isWebGLRenderTargetCube ); if ( isCube ) throw new Error( 'Depth Texture with cube render targets is not supported' ); _gl.bindFramebuffer( 36160, framebuffer ); if ( ! ( renderTarget.depthTexture && renderTarget.depthTexture.isDepthTexture ) ) { throw new Error( 'renderTarget.depthTexture must be an instance of THREE.DepthTexture' ); } // upload an empty depth texture with framebuffer size if ( ! properties.get( renderTarget.depthTexture ).__webglTexture || renderTarget.depthTexture.image.width !== renderTarget.width || renderTarget.depthTexture.image.height !== renderTarget.height ) { renderTarget.depthTexture.image.width = renderTarget.width; renderTarget.depthTexture.image.height = renderTarget.height; renderTarget.depthTexture.needsUpdate = true; } setTexture2D( renderTarget.depthTexture, 0 ); var webglDepthTexture = properties.get( renderTarget.depthTexture ).__webglTexture; if ( renderTarget.depthTexture.format === DepthFormat ) { _gl.framebufferTexture2D( 36160, 36096, 3553, webglDepthTexture, 0 ); } else if ( renderTarget.depthTexture.format === DepthStencilFormat ) { _gl.framebufferTexture2D( 36160, 33306, 3553, webglDepthTexture, 0 ); } else { throw new Error( 'Unknown depthTexture format' ); } } // Setup GL resources for a non-texture depth buffer function setupDepthRenderbuffer( renderTarget ) { var renderTargetProperties = properties.get( renderTarget ); var isCube = ( renderTarget.isWebGLRenderTargetCube === true ); if ( renderTarget.depthTexture ) { if ( isCube ) throw new Error( 'target.depthTexture not supported in Cube render targets' ); setupDepthTexture( renderTargetProperties.__webglFramebuffer, renderTarget ); } else { if ( isCube ) { renderTargetProperties.__webglDepthbuffer = []; for ( var i = 0; i < 6; i ++ ) { _gl.bindFramebuffer( 36160, renderTargetProperties.__webglFramebuffer[ i ] ); renderTargetProperties.__webglDepthbuffer[ i ] = _gl.createRenderbuffer(); setupRenderBufferStorage( renderTargetProperties.__webglDepthbuffer[ i ], renderTarget ); } } else { _gl.bindFramebuffer( 36160, renderTargetProperties.__webglFramebuffer ); renderTargetProperties.__webglDepthbuffer = _gl.createRenderbuffer(); setupRenderBufferStorage( renderTargetProperties.__webglDepthbuffer, renderTarget ); } } _gl.bindFramebuffer( 36160, null ); } // Set up GL resources for the render target function setupRenderTarget( renderTarget ) { var renderTargetProperties = properties.get( renderTarget ); var textureProperties = properties.get( renderTarget.texture ); renderTarget.addEventListener( 'dispose', onRenderTargetDispose ); textureProperties.__webglTexture = _gl.createTexture(); info.memory.textures ++; var isCube = ( renderTarget.isWebGLRenderTargetCube === true ); var isMultisample = ( renderTarget.isWebGLMultisampleRenderTarget === true ); var supportsMips = isPowerOfTwo( renderTarget ) || capabilities.isWebGL2; // Setup framebuffer if ( isCube ) { renderTargetProperties.__webglFramebuffer = []; for ( var i = 0; i < 6; i ++ ) { renderTargetProperties.__webglFramebuffer[ i ] = _gl.createFramebuffer(); } } else { renderTargetProperties.__webglFramebuffer = _gl.createFramebuffer(); if ( isMultisample ) { if ( capabilities.isWebGL2 ) { renderTargetProperties.__webglMultisampledFramebuffer = _gl.createFramebuffer(); renderTargetProperties.__webglColorRenderbuffer = _gl.createRenderbuffer(); _gl.bindRenderbuffer( 36161, renderTargetProperties.__webglColorRenderbuffer ); var glFormat = utils.convert( renderTarget.texture.format ); var glType = utils.convert( renderTarget.texture.type ); var glInternalFormat = getInternalFormat( glFormat, glType ); var samples = getRenderTargetSamples( renderTarget ); _gl.renderbufferStorageMultisample( 36161, samples, glInternalFormat, renderTarget.width, renderTarget.height ); _gl.bindFramebuffer( 36160, renderTargetProperties.__webglMultisampledFramebuffer ); _gl.framebufferRenderbuffer( 36160, 36064, 36161, renderTargetProperties.__webglColorRenderbuffer ); _gl.bindRenderbuffer( 36161, null ); if ( renderTarget.depthBuffer ) { renderTargetProperties.__webglDepthRenderbuffer = _gl.createRenderbuffer(); setupRenderBufferStorage( renderTargetProperties.__webglDepthRenderbuffer, renderTarget, true ); } _gl.bindFramebuffer( 36160, null ); } else { console.warn( 'THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.' ); } } } // Setup color buffer if ( isCube ) { state.bindTexture( 34067, textureProperties.__webglTexture ); setTextureParameters( 34067, renderTarget.texture, supportsMips ); for ( var i = 0; i < 6; i ++ ) { setupFrameBufferTexture( renderTargetProperties.__webglFramebuffer[ i ], renderTarget, 36064, 34069 + i ); } if ( textureNeedsGenerateMipmaps( renderTarget.texture, supportsMips ) ) { generateMipmap( 34067, renderTarget.texture, renderTarget.width, renderTarget.height ); } state.bindTexture( 34067, null ); } else { state.bindTexture( 3553, textureProperties.__webglTexture ); setTextureParameters( 3553, renderTarget.texture, supportsMips ); setupFrameBufferTexture( renderTargetProperties.__webglFramebuffer, renderTarget, 36064, 3553 ); if ( textureNeedsGenerateMipmaps( renderTarget.texture, supportsMips ) ) { generateMipmap( 3553, renderTarget.texture, renderTarget.width, renderTarget.height ); } state.bindTexture( 3553, null ); } // Setup depth and stencil buffers if ( renderTarget.depthBuffer ) { setupDepthRenderbuffer( renderTarget ); } } function updateRenderTargetMipmap( renderTarget ) { var texture = renderTarget.texture; var supportsMips = isPowerOfTwo( renderTarget ) || capabilities.isWebGL2; if ( textureNeedsGenerateMipmaps( texture, supportsMips ) ) { var target = renderTarget.isWebGLRenderTargetCube ? 34067 : 3553; var webglTexture = properties.get( texture ).__webglTexture; state.bindTexture( target, webglTexture ); generateMipmap( target, texture, renderTarget.width, renderTarget.height ); state.bindTexture( target, null ); } } function updateMultisampleRenderTarget( renderTarget ) { if ( renderTarget.isWebGLMultisampleRenderTarget ) { if ( capabilities.isWebGL2 ) { var renderTargetProperties = properties.get( renderTarget ); _gl.bindFramebuffer( 36008, renderTargetProperties.__webglMultisampledFramebuffer ); _gl.bindFramebuffer( 36009, renderTargetProperties.__webglFramebuffer ); var width = renderTarget.width; var height = renderTarget.height; var mask = 16384; if ( renderTarget.depthBuffer ) mask |= 256; if ( renderTarget.stencilBuffer ) mask |= 1024; _gl.blitFramebuffer( 0, 0, width, height, 0, 0, width, height, mask, 9728 ); } else { console.warn( 'THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.' ); } } } function getRenderTargetSamples( renderTarget ) { return ( capabilities.isWebGL2 && renderTarget.isWebGLMultisampleRenderTarget ) ? Math.min( capabilities.maxSamples, renderTarget.samples ) : 0; } function updateVideoTexture( texture ) { var id = texture.id; var frame = info.render.frame; // Check the last frame we updated the VideoTexture if ( _videoTextures[ id ] !== frame ) { _videoTextures[ id ] = frame; texture.update(); } } this.setTexture2D = setTexture2D; this.setTexture3D = setTexture3D; this.setTextureCube = setTextureCube; this.setTextureCubeDynamic = setTextureCubeDynamic; this.setupRenderTarget = setupRenderTarget; this.updateRenderTargetMipmap = updateRenderTargetMipmap; this.updateMultisampleRenderTarget = updateMultisampleRenderTarget; } /** * @author thespite / http://www.twitter.com/thespite */ function WebGLUtils( gl, extensions, capabilities ) { function convert( p ) { var extension; if ( p === RepeatWrapping ) return 10497; if ( p === ClampToEdgeWrapping ) return 33071; if ( p === MirroredRepeatWrapping ) return 33648; if ( p === NearestFilter ) return 9728; if ( p === NearestMipMapNearestFilter ) return 9984; if ( p === NearestMipMapLinearFilter ) return 9986; if ( p === LinearFilter ) return 9729; if ( p === LinearMipMapNearestFilter ) return 9985; if ( p === LinearMipMapLinearFilter ) return 9987; if ( p === UnsignedByteType ) return 5121; if ( p === UnsignedShort4444Type ) return 32819; if ( p === UnsignedShort5551Type ) return 32820; if ( p === UnsignedShort565Type ) return 33635; if ( p === ByteType ) return 5120; if ( p === ShortType ) return 5122; if ( p === UnsignedShortType ) return 5123; if ( p === IntType ) return 5124; if ( p === UnsignedIntType ) return 5125; if ( p === FloatType ) return 5126; if ( p === HalfFloatType ) { if ( capabilities.isWebGL2 ) return 5131; extension = extensions.get( 'OES_texture_half_float' ); if ( extension !== null ) return extension.HALF_FLOAT_OES; } if ( p === AlphaFormat ) return 6406; if ( p === RGBFormat ) return 6407; if ( p === RGBAFormat ) return 6408; if ( p === LuminanceFormat ) return 6409; if ( p === LuminanceAlphaFormat ) return 6410; if ( p === DepthFormat ) return 6402; if ( p === DepthStencilFormat ) return 34041; if ( p === RedFormat ) return 6403; if ( p === AddEquation ) return 32774; if ( p === SubtractEquation ) return 32778; if ( p === ReverseSubtractEquation ) return 32779; if ( p === ZeroFactor ) return 0; if ( p === OneFactor ) return 1; if ( p === SrcColorFactor ) return 768; if ( p === OneMinusSrcColorFactor ) return 769; if ( p === SrcAlphaFactor ) return 770; if ( p === OneMinusSrcAlphaFactor ) return 771; if ( p === DstAlphaFactor ) return 772; if ( p === OneMinusDstAlphaFactor ) return 773; if ( p === DstColorFactor ) return 774; if ( p === OneMinusDstColorFactor ) return 775; if ( p === SrcAlphaSaturateFactor ) return 776; if ( p === RGB_S3TC_DXT1_Format || p === RGBA_S3TC_DXT1_Format || p === RGBA_S3TC_DXT3_Format || p === RGBA_S3TC_DXT5_Format ) { extension = extensions.get( 'WEBGL_compressed_texture_s3tc' ); if ( extension !== null ) { if ( p === RGB_S3TC_DXT1_Format ) return extension.COMPRESSED_RGB_S3TC_DXT1_EXT; if ( p === RGBA_S3TC_DXT1_Format ) return extension.COMPRESSED_RGBA_S3TC_DXT1_EXT; if ( p === RGBA_S3TC_DXT3_Format ) return extension.COMPRESSED_RGBA_S3TC_DXT3_EXT; if ( p === RGBA_S3TC_DXT5_Format ) return extension.COMPRESSED_RGBA_S3TC_DXT5_EXT; } } if ( p === RGB_PVRTC_4BPPV1_Format || p === RGB_PVRTC_2BPPV1_Format || p === RGBA_PVRTC_4BPPV1_Format || p === RGBA_PVRTC_2BPPV1_Format ) { extension = extensions.get( 'WEBGL_compressed_texture_pvrtc' ); if ( extension !== null ) { if ( p === RGB_PVRTC_4BPPV1_Format ) return extension.COMPRESSED_RGB_PVRTC_4BPPV1_IMG; if ( p === RGB_PVRTC_2BPPV1_Format ) return extension.COMPRESSED_RGB_PVRTC_2BPPV1_IMG; if ( p === RGBA_PVRTC_4BPPV1_Format ) return extension.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG; if ( p === RGBA_PVRTC_2BPPV1_Format ) return extension.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG; } } if ( p === RGB_ETC1_Format ) { extension = extensions.get( 'WEBGL_compressed_texture_etc1' ); if ( extension !== null ) return extension.COMPRESSED_RGB_ETC1_WEBGL; } if ( p === RGBA_ASTC_4x4_Format || p === RGBA_ASTC_5x4_Format || p === RGBA_ASTC_5x5_Format || p === RGBA_ASTC_6x5_Format || p === RGBA_ASTC_6x6_Format || p === RGBA_ASTC_8x5_Format || p === RGBA_ASTC_8x6_Format || p === RGBA_ASTC_8x8_Format || p === RGBA_ASTC_10x5_Format || p === RGBA_ASTC_10x6_Format || p === RGBA_ASTC_10x8_Format || p === RGBA_ASTC_10x10_Format || p === RGBA_ASTC_12x10_Format || p === RGBA_ASTC_12x12_Format ) { extension = extensions.get( 'WEBGL_compressed_texture_astc' ); if ( extension !== null ) { return p; } } if ( p === MinEquation || p === MaxEquation ) { if ( capabilities.isWebGL2 ) { if ( p === MinEquation ) return 32775; if ( p === MaxEquation ) return 32776; } extension = extensions.get( 'EXT_blend_minmax' ); if ( extension !== null ) { if ( p === MinEquation ) return extension.MIN_EXT; if ( p === MaxEquation ) return extension.MAX_EXT; } } if ( p === UnsignedInt248Type ) { if ( capabilities.isWebGL2 ) return 34042; extension = extensions.get( 'WEBGL_depth_texture' ); if ( extension !== null ) return extension.UNSIGNED_INT_24_8_WEBGL; } return 0; } return { convert: convert }; } /** * @author mrdoob / http://mrdoob.com/ */ function Group() { Object3D.call( this ); this.type = 'Group'; } Group.prototype = Object.assign( Object.create( Object3D.prototype ), { constructor: Group, isGroup: true } ); /** * @author mrdoob / http://mrdoob.com/ * @author mikael emtinger / http://gomo.se/ * @author WestLangley / http://github.com/WestLangley */ function Camera() { Object3D.call( this ); this.type = 'Camera'; this.matrixWorldInverse = new Matrix4(); this.projectionMatrix = new Matrix4(); this.projectionMatrixInverse = new Matrix4(); } Camera.prototype = Object.assign( Object.create( Object3D.prototype ), { constructor: Camera, isCamera: true, copy: function ( source, recursive ) { Object3D.prototype.copy.call( this, source, recursive ); this.matrixWorldInverse.copy( source.matrixWorldInverse ); this.projectionMatrix.copy( source.projectionMatrix ); this.projectionMatrixInverse.copy( source.projectionMatrixInverse ); return this; }, getWorldDirection: function ( target ) { if ( target === undefined ) { console.warn( 'THREE.Camera: .getWorldDirection() target is now required' ); target = new Vector3(); } this.updateMatrixWorld( true ); var e = this.matrixWorld.elements; return target.set( - e[ 8 ], - e[ 9 ], - e[ 10 ] ).normalize(); }, updateMatrixWorld: function ( force ) { Object3D.prototype.updateMatrixWorld.call( this, force ); this.matrixWorldInverse.getInverse( this.matrixWorld ); }, clone: function () { return new this.constructor().copy( this ); } } ); /** * @author mrdoob / http://mrdoob.com/ * @author greggman / http://games.greggman.com/ * @author zz85 / http://www.lab4games.net/zz85/blog * @author tschw */ function PerspectiveCamera( fov, aspect, near, far ) { Camera.call( this ); this.type = 'PerspectiveCamera'; this.fov = fov !== undefined ? fov : 50; this.zoom = 1; this.near = near !== undefined ? near : 0.1; this.far = far !== undefined ? far : 2000; this.focus = 10; this.aspect = aspect !== undefined ? aspect : 1; this.view = null; this.filmGauge = 35; // width of the film (default in millimeters) this.filmOffset = 0; // horizontal film offset (same unit as gauge) this.updateProjectionMatrix(); } PerspectiveCamera.prototype = Object.assign( Object.create( Camera.prototype ), { constructor: PerspectiveCamera, isPerspectiveCamera: true, copy: function ( source, recursive ) { Camera.prototype.copy.call( this, source, recursive ); this.fov = source.fov; this.zoom = source.zoom; this.near = source.near; this.far = source.far; this.focus = source.focus; this.aspect = source.aspect; this.view = source.view === null ? null : Object.assign( {}, source.view ); this.filmGauge = source.filmGauge; this.filmOffset = source.filmOffset; return this; }, /** * Sets the FOV by focal length in respect to the current .filmGauge. * * The default film gauge is 35, so that the focal length can be specified for * a 35mm (full frame) camera. * * Values for focal length and film gauge must have the same unit. */ setFocalLength: function ( focalLength ) { // see http://www.bobatkins.com/photography/technical/field_of_view.html var vExtentSlope = 0.5 * this.getFilmHeight() / focalLength; this.fov = _Math.RAD2DEG * 2 * Math.atan( vExtentSlope ); this.updateProjectionMatrix(); }, /** * Calculates the focal length from the current .fov and .filmGauge. */ getFocalLength: function () { var vExtentSlope = Math.tan( _Math.DEG2RAD * 0.5 * this.fov ); return 0.5 * this.getFilmHeight() / vExtentSlope; }, getEffectiveFOV: function () { return _Math.RAD2DEG * 2 * Math.atan( Math.tan( _Math.DEG2RAD * 0.5 * this.fov ) / this.zoom ); }, getFilmWidth: function () { // film not completely covered in portrait format (aspect < 1) return this.filmGauge * Math.min( this.aspect, 1 ); }, getFilmHeight: function () { // film not completely covered in landscape format (aspect > 1) return this.filmGauge / Math.max( this.aspect, 1 ); }, /** * Sets an offset in a larger frustum. This is useful for multi-window or * multi-monitor/multi-machine setups. * * For example, if you have 3x2 monitors and each monitor is 1920x1080 and * the monitors are in grid like this * * +---+---+---+ * | A | B | C | * +---+---+---+ * | D | E | F | * +---+---+---+ * * then for each monitor you would call it like this * * var w = 1920; * var h = 1080; * var fullWidth = w * 3; * var fullHeight = h * 2; * * --A-- * camera.setOffset( fullWidth, fullHeight, w * 0, h * 0, w, h ); * --B-- * camera.setOffset( fullWidth, fullHeight, w * 1, h * 0, w, h ); * --C-- * camera.setOffset( fullWidth, fullHeight, w * 2, h * 0, w, h ); * --D-- * camera.setOffset( fullWidth, fullHeight, w * 0, h * 1, w, h ); * --E-- * camera.setOffset( fullWidth, fullHeight, w * 1, h * 1, w, h ); * --F-- * camera.setOffset( fullWidth, fullHeight, w * 2, h * 1, w, h ); * * Note there is no reason monitors have to be the same size or in a grid. */ setViewOffset: function ( fullWidth, fullHeight, x, y, width, height ) { this.aspect = fullWidth / fullHeight; if ( this.view === null ) { this.view = { enabled: true, fullWidth: 1, fullHeight: 1, offsetX: 0, offsetY: 0, width: 1, height: 1 }; } this.view.enabled = true; this.view.fullWidth = fullWidth; this.view.fullHeight = fullHeight; this.view.offsetX = x; this.view.offsetY = y; this.view.width = width; this.view.height = height; this.updateProjectionMatrix(); }, clearViewOffset: function () { if ( this.view !== null ) { this.view.enabled = false; } this.updateProjectionMatrix(); }, updateProjectionMatrix: function () { var near = this.near, top = near * Math.tan( _Math.DEG2RAD * 0.5 * this.fov ) / this.zoom, height = 2 * top, width = this.aspect * height, left = - 0.5 * width, view = this.view; if ( this.view !== null && this.view.enabled ) { var fullWidth = view.fullWidth, fullHeight = view.fullHeight; left += view.offsetX * width / fullWidth; top -= view.offsetY * height / fullHeight; width *= view.width / fullWidth; height *= view.height / fullHeight; } var skew = this.filmOffset; if ( skew !== 0 ) left += near * skew / this.getFilmWidth(); this.projectionMatrix.makePerspective( left, left + width, top, top - height, near, this.far ); this.projectionMatrixInverse.getInverse( this.projectionMatrix ); }, toJSON: function ( meta ) { var data = Object3D.prototype.toJSON.call( this, meta ); data.object.fov = this.fov; data.object.zoom = this.zoom; data.object.near = this.near; data.object.far = this.far; data.object.focus = this.focus; data.object.aspect = this.aspect; if ( this.view !== null ) data.object.view = Object.assign( {}, this.view ); data.object.filmGauge = this.filmGauge; data.object.filmOffset = this.filmOffset; return data; } } ); /** * @author mrdoob / http://mrdoob.com/ */ function ArrayCamera( array ) { PerspectiveCamera.call( this ); this.cameras = array || []; } ArrayCamera.prototype = Object.assign( Object.create( PerspectiveCamera.prototype ), { constructor: ArrayCamera, isArrayCamera: true } ); /** * @author jsantell / https://www.jsantell.com/ * @author mrdoob / http://mrdoob.com/ */ var cameraLPos = new Vector3(); var cameraRPos = new Vector3(); /** * Assumes 2 cameras that are parallel and share an X-axis, and that * the cameras' projection and world matrices have already been set. * And that near and far planes are identical for both cameras. * Visualization of this technique: https://computergraphics.stackexchange.com/a/4765 */ function setProjectionFromUnion( camera, cameraL, cameraR ) { cameraLPos.setFromMatrixPosition( cameraL.matrixWorld ); cameraRPos.setFromMatrixPosition( cameraR.matrixWorld ); var ipd = cameraLPos.distanceTo( cameraRPos ); var projL = cameraL.projectionMatrix.elements; var projR = cameraR.projectionMatrix.elements; // VR systems will have identical far and near planes, and // most likely identical top and bottom frustum extents. // Use the left camera for these values. var near = projL[ 14 ] / ( projL[ 10 ] - 1 ); var far = projL[ 14 ] / ( projL[ 10 ] + 1 ); var topFov = ( projL[ 9 ] + 1 ) / projL[ 5 ]; var bottomFov = ( projL[ 9 ] - 1 ) / projL[ 5 ]; var leftFov = ( projL[ 8 ] - 1 ) / projL[ 0 ]; var rightFov = ( projR[ 8 ] + 1 ) / projR[ 0 ]; var left = near * leftFov; var right = near * rightFov; // Calculate the new camera's position offset from the // left camera. xOffset should be roughly half `ipd`. var zOffset = ipd / ( - leftFov + rightFov ); var xOffset = zOffset * - leftFov; // TODO: Better way to apply this offset? cameraL.matrixWorld.decompose( camera.position, camera.quaternion, camera.scale ); camera.translateX( xOffset ); camera.translateZ( zOffset ); camera.matrixWorld.compose( camera.position, camera.quaternion, camera.scale ); camera.matrixWorldInverse.getInverse( camera.matrixWorld ); // Find the union of the frustum values of the cameras and scale // the values so that the near plane's position does not change in world space, // although must now be relative to the new union camera. var near2 = near + zOffset; var far2 = far + zOffset; var left2 = left - xOffset; var right2 = right + ( ipd - xOffset ); var top2 = topFov * far / far2 * near2; var bottom2 = bottomFov * far / far2 * near2; camera.projectionMatrix.makePerspective( left2, right2, top2, bottom2, near2, far2 ); } /** * @author mrdoob / http://mrdoob.com/ */ function WebVRManager( renderer ) { var scope = this; var device = null; var frameData = null; var poseTarget = null; var controllers = []; var standingMatrix = new Matrix4(); var standingMatrixInverse = new Matrix4(); var framebufferScaleFactor = 1.0; var frameOfReferenceType = 'stage'; if ( typeof window !== 'undefined' && 'VRFrameData' in window ) { frameData = new window.VRFrameData(); window.addEventListener( 'vrdisplaypresentchange', onVRDisplayPresentChange, false ); } var matrixWorldInverse = new Matrix4(); var tempQuaternion = new Quaternion(); var tempPosition = new Vector3(); var cameraL = new PerspectiveCamera(); cameraL.bounds = new Vector4( 0.0, 0.0, 0.5, 1.0 ); cameraL.layers.enable( 1 ); var cameraR = new PerspectiveCamera(); cameraR.bounds = new Vector4( 0.5, 0.0, 0.5, 1.0 ); cameraR.layers.enable( 2 ); var cameraVR = new ArrayCamera( [ cameraL, cameraR ] ); cameraVR.layers.enable( 1 ); cameraVR.layers.enable( 2 ); // function isPresenting() { return device !== null && device.isPresenting === true; } var currentSize, currentPixelRatio; function onVRDisplayPresentChange() { if ( isPresenting() ) { var eyeParameters = device.getEyeParameters( 'left' ); var renderWidth = eyeParameters.renderWidth * framebufferScaleFactor; var renderHeight = eyeParameters.renderHeight * framebufferScaleFactor; currentPixelRatio = renderer.getPixelRatio(); currentSize = renderer.getSize(); renderer.setDrawingBufferSize( renderWidth * 2, renderHeight, 1 ); animation.start(); } else { if ( scope.enabled ) { renderer.setDrawingBufferSize( currentSize.width, currentSize.height, currentPixelRatio ); } animation.stop(); } } // var triggers = []; function findGamepad( id ) { var gamepads = navigator.getGamepads && navigator.getGamepads(); for ( var i = 0, j = 0, l = gamepads.length; i < l; i ++ ) { var gamepad = gamepads[ i ]; if ( gamepad && ( gamepad.id === 'Daydream Controller' || gamepad.id === 'Gear VR Controller' || gamepad.id === 'Oculus Go Controller' || gamepad.id === 'OpenVR Gamepad' || gamepad.id.startsWith( 'Oculus Touch' ) || gamepad.id.startsWith( 'Spatial Controller' ) ) ) { if ( j === id ) return gamepad; j ++; } } } function updateControllers() { for ( var i = 0; i < controllers.length; i ++ ) { var controller = controllers[ i ]; var gamepad = findGamepad( i ); if ( gamepad !== undefined && gamepad.pose !== undefined ) { if ( gamepad.pose === null ) return; // Pose var pose = gamepad.pose; if ( pose.hasPosition === false ) controller.position.set( 0.2, - 0.6, - 0.05 ); if ( pose.position !== null ) controller.position.fromArray( pose.position ); if ( pose.orientation !== null ) controller.quaternion.fromArray( pose.orientation ); controller.matrix.compose( controller.position, controller.quaternion, controller.scale ); controller.matrix.premultiply( standingMatrix ); controller.matrix.decompose( controller.position, controller.quaternion, controller.scale ); controller.matrixWorldNeedsUpdate = true; controller.visible = true; // Trigger var buttonId = gamepad.id === 'Daydream Controller' ? 0 : 1; if ( triggers[ i ] !== gamepad.buttons[ buttonId ].pressed ) { triggers[ i ] = gamepad.buttons[ buttonId ].pressed; if ( triggers[ i ] === true ) { controller.dispatchEvent( { type: 'selectstart' } ); } else { controller.dispatchEvent( { type: 'selectend' } ); controller.dispatchEvent( { type: 'select' } ); } } } else { controller.visible = false; } } } // this.enabled = false; this.getController = function ( id ) { var controller = controllers[ id ]; if ( controller === undefined ) { controller = new Group(); controller.matrixAutoUpdate = false; controller.visible = false; controllers[ id ] = controller; } return controller; }; this.getDevice = function () { return device; }; this.setDevice = function ( value ) { if ( value !== undefined ) device = value; animation.setContext( value ); }; this.setFramebufferScaleFactor = function ( value ) { framebufferScaleFactor = value; }; this.setFrameOfReferenceType = function ( value ) { frameOfReferenceType = value; }; this.setPoseTarget = function ( object ) { if ( object !== undefined ) poseTarget = object; }; this.getCamera = function ( camera ) { var userHeight = frameOfReferenceType === 'stage' ? 1.6 : 0; if ( device === null ) { camera.position.set( 0, userHeight, 0 ); return camera; } device.depthNear = camera.near; device.depthFar = camera.far; device.getFrameData( frameData ); // if ( frameOfReferenceType === 'stage' ) { var stageParameters = device.stageParameters; if ( stageParameters ) { standingMatrix.fromArray( stageParameters.sittingToStandingTransform ); } else { standingMatrix.makeTranslation( 0, userHeight, 0 ); } } var pose = frameData.pose; var poseObject = poseTarget !== null ? poseTarget : camera; // We want to manipulate poseObject by its position and quaternion components since users may rely on them. poseObject.matrix.copy( standingMatrix ); poseObject.matrix.decompose( poseObject.position, poseObject.quaternion, poseObject.scale ); if ( pose.orientation !== null ) { tempQuaternion.fromArray( pose.orientation ); poseObject.quaternion.multiply( tempQuaternion ); } if ( pose.position !== null ) { tempQuaternion.setFromRotationMatrix( standingMatrix ); tempPosition.fromArray( pose.position ); tempPosition.applyQuaternion( tempQuaternion ); poseObject.position.add( tempPosition ); } poseObject.updateMatrixWorld(); if ( device.isPresenting === false ) return camera; // cameraL.near = camera.near; cameraR.near = camera.near; cameraL.far = camera.far; cameraR.far = camera.far; cameraL.matrixWorldInverse.fromArray( frameData.leftViewMatrix ); cameraR.matrixWorldInverse.fromArray( frameData.rightViewMatrix ); // TODO (mrdoob) Double check this code standingMatrixInverse.getInverse( standingMatrix ); if ( frameOfReferenceType === 'stage' ) { cameraL.matrixWorldInverse.multiply( standingMatrixInverse ); cameraR.matrixWorldInverse.multiply( standingMatrixInverse ); } var parent = poseObject.parent; if ( parent !== null ) { matrixWorldInverse.getInverse( parent.matrixWorld ); cameraL.matrixWorldInverse.multiply( matrixWorldInverse ); cameraR.matrixWorldInverse.multiply( matrixWorldInverse ); } // envMap and Mirror needs camera.matrixWorld cameraL.matrixWorld.getInverse( cameraL.matrixWorldInverse ); cameraR.matrixWorld.getInverse( cameraR.matrixWorldInverse ); cameraL.projectionMatrix.fromArray( frameData.leftProjectionMatrix ); cameraR.projectionMatrix.fromArray( frameData.rightProjectionMatrix ); setProjectionFromUnion( cameraVR, cameraL, cameraR ); // var layers = device.getLayers(); if ( layers.length ) { var layer = layers[ 0 ]; if ( layer.leftBounds !== null && layer.leftBounds.length === 4 ) { cameraL.bounds.fromArray( layer.leftBounds ); } if ( layer.rightBounds !== null && layer.rightBounds.length === 4 ) { cameraR.bounds.fromArray( layer.rightBounds ); } } updateControllers(); return cameraVR; }; this.getStandingMatrix = function () { return standingMatrix; }; this.isPresenting = isPresenting; // Animation Loop var animation = new WebGLAnimation(); this.setAnimationLoop = function ( callback ) { animation.setAnimationLoop( callback ); }; this.submitFrame = function () { if ( isPresenting() ) device.submitFrame(); }; this.dispose = function () { if ( typeof window !== 'undefined' ) { window.removeEventListener( 'vrdisplaypresentchange', onVRDisplayPresentChange ); } }; } /** * @author mrdoob / http://mrdoob.com/ */ function WebXRManager( renderer ) { var gl = renderer.context; var device = null; var session = null; var framebufferScaleFactor = 1.0; var frameOfReference = null; var frameOfReferenceType = 'stage'; var pose = null; var controllers = []; var inputSources = []; function isPresenting() { return session !== null && frameOfReference !== null; } // var cameraL = new PerspectiveCamera(); cameraL.layers.enable( 1 ); cameraL.viewport = new Vector4(); var cameraR = new PerspectiveCamera(); cameraR.layers.enable( 2 ); cameraR.viewport = new Vector4(); var cameraVR = new ArrayCamera( [ cameraL, cameraR ] ); cameraVR.layers.enable( 1 ); cameraVR.layers.enable( 2 ); // this.enabled = false; this.getController = function ( id ) { var controller = controllers[ id ]; if ( controller === undefined ) { controller = new Group(); controller.matrixAutoUpdate = false; controller.visible = false; controllers[ id ] = controller; } return controller; }; this.getDevice = function () { return device; }; this.setDevice = function ( value ) { if ( value !== undefined ) device = value; if ( value instanceof XRDevice ) gl.setCompatibleXRDevice( value ); }; // function onSessionEvent( event ) { var controller = controllers[ inputSources.indexOf( event.inputSource ) ]; if ( controller ) controller.dispatchEvent( { type: event.type } ); } function onSessionEnd() { renderer.setFramebuffer( null ); animation.stop(); } this.setFramebufferScaleFactor = function ( value ) { framebufferScaleFactor = value; }; this.setFrameOfReferenceType = function ( value ) { frameOfReferenceType = value; }; this.setSession = function ( value ) { session = value; if ( session !== null ) { session.addEventListener( 'select', onSessionEvent ); session.addEventListener( 'selectstart', onSessionEvent ); session.addEventListener( 'selectend', onSessionEvent ); session.addEventListener( 'end', onSessionEnd ); session.baseLayer = new XRWebGLLayer( session, gl, { framebufferScaleFactor: framebufferScaleFactor } ); session.requestFrameOfReference( frameOfReferenceType ).then( function ( value ) { frameOfReference = value; renderer.setFramebuffer( session.baseLayer.framebuffer ); animation.setContext( session ); animation.start(); } ); // inputSources = session.getInputSources(); session.addEventListener( 'inputsourceschange', function () { inputSources = session.getInputSources(); console.log( inputSources ); for ( var i = 0; i < controllers.length; i ++ ) { var controller = controllers[ i ]; controller.userData.inputSource = inputSources[ i ]; } } ); } }; function updateCamera( camera, parent ) { if ( parent === null ) { camera.matrixWorld.copy( camera.matrix ); } else { camera.matrixWorld.multiplyMatrices( parent.matrixWorld, camera.matrix ); } camera.matrixWorldInverse.getInverse( camera.matrixWorld ); } this.getCamera = function ( camera ) { if ( isPresenting() ) { var parent = camera.parent; var cameras = cameraVR.cameras; updateCamera( cameraVR, parent ); for ( var i = 0; i < cameras.length; i ++ ) { updateCamera( cameras[ i ], parent ); } // update camera and its children camera.matrixWorld.copy( cameraVR.matrixWorld ); var children = camera.children; for ( var i = 0, l = children.length; i < l; i ++ ) { children[ i ].updateMatrixWorld( true ); } setProjectionFromUnion( cameraVR, cameraL, cameraR ); return cameraVR; } return camera; }; this.isPresenting = isPresenting; // Animation Loop var onAnimationFrameCallback = null; function onAnimationFrame( time, frame ) { pose = frame.getDevicePose( frameOfReference ); if ( pose !== null ) { var layer = session.baseLayer; var views = frame.views; for ( var i = 0; i < views.length; i ++ ) { var view = views[ i ]; var viewport = layer.getViewport( view ); var viewMatrix = pose.getViewMatrix( view ); var camera = cameraVR.cameras[ i ]; camera.matrix.fromArray( viewMatrix ).getInverse( camera.matrix ); camera.projectionMatrix.fromArray( view.projectionMatrix ); camera.viewport.set( viewport.x, viewport.y, viewport.width, viewport.height ); if ( i === 0 ) { cameraVR.matrix.copy( camera.matrix ); } } } // for ( var i = 0; i < controllers.length; i ++ ) { var controller = controllers[ i ]; var inputSource = inputSources[ i ]; if ( inputSource ) { var inputPose = frame.getInputPose( inputSource, frameOfReference ); if ( inputPose !== null ) { if ( 'targetRay' in inputPose ) { controller.matrix.elements = inputPose.targetRay.transformMatrix; } else if ( 'pointerMatrix' in inputPose ) { // DEPRECATED controller.matrix.elements = inputPose.pointerMatrix; } controller.matrix.decompose( controller.position, controller.rotation, controller.scale ); controller.visible = true; continue; } } controller.visible = false; } if ( onAnimationFrameCallback ) onAnimationFrameCallback( time ); } var animation = new WebGLAnimation(); animation.setAnimationLoop( onAnimationFrame ); this.setAnimationLoop = function ( callback ) { onAnimationFrameCallback = callback; }; this.dispose = function () {}; // DEPRECATED this.getStandingMatrix = function () { console.warn( 'THREE.WebXRManager: getStandingMatrix() is no longer needed.' ); return new THREE.Matrix4(); }; this.submitFrame = function () {}; } /** * @author supereggbert / http://www.paulbrunt.co.uk/ * @author mrdoob / http://mrdoob.com/ * @author alteredq / http://alteredqualia.com/ * @author szimek / https://github.com/szimek/ * @author tschw */ function WebGLRenderer( parameters ) { console.log( 'THREE.WebGLRenderer', REVISION ); parameters = parameters || {}; var _canvas = parameters.canvas !== undefined ? parameters.canvas : document.createElementNS( 'http://www.w3.org/1999/xhtml', 'canvas' ), _context = parameters.context !== undefined ? parameters.context : null, _alpha = parameters.alpha !== undefined ? parameters.alpha : false, _depth = parameters.depth !== undefined ? parameters.depth : true, _stencil = parameters.stencil !== undefined ? parameters.stencil : true, _antialias = parameters.antialias !== undefined ? parameters.antialias : false, _premultipliedAlpha = parameters.premultipliedAlpha !== undefined ? parameters.premultipliedAlpha : true, _preserveDrawingBuffer = parameters.preserveDrawingBuffer !== undefined ? parameters.preserveDrawingBuffer : false, _powerPreference = parameters.powerPreference !== undefined ? parameters.powerPreference : 'default'; var currentRenderList = null; var currentRenderState = null; // public properties this.domElement = _canvas; this.context = null; // clearing this.autoClear = true; this.autoClearColor = true; this.autoClearDepth = true; this.autoClearStencil = true; // scene graph this.sortObjects = true; // user-defined clipping this.clippingPlanes = []; this.localClippingEnabled = false; // physically based shading this.gammaFactor = 2.0; // for backwards compatibility this.gammaInput = false; this.gammaOutput = false; // physical lights this.physicallyCorrectLights = false; // tone mapping this.toneMapping = LinearToneMapping; this.toneMappingExposure = 1.0; this.toneMappingWhitePoint = 1.0; // morphs this.maxMorphTargets = 8; this.maxMorphNormals = 4; // internal properties var _this = this, _isContextLost = false, // internal state cache _framebuffer = null, _currentRenderTarget = null, _currentFramebuffer = null, _currentMaterialId = - 1, // geometry and program caching _currentGeometryProgram = { geometry: null, program: null, wireframe: false }, _currentCamera = null, _currentArrayCamera = null, _currentViewport = new Vector4(), _currentScissor = new Vector4(), _currentScissorTest = null, // _usedTextureUnits = 0, // _width = _canvas.width, _height = _canvas.height, _pixelRatio = 1, _viewport = new Vector4( 0, 0, _width, _height ), _scissor = new Vector4( 0, 0, _width, _height ), _scissorTest = false, // frustum _frustum = new Frustum(), // clipping _clipping = new WebGLClipping(), _clippingEnabled = false, _localClippingEnabled = false, // camera matrices cache _projScreenMatrix = new Matrix4(), _vector3 = new Vector3(); function getTargetPixelRatio() { return _currentRenderTarget === null ? _pixelRatio : 1; } // initialize var _gl; try { var contextAttributes = { alpha: _alpha, depth: _depth, stencil: _stencil, antialias: _antialias, premultipliedAlpha: _premultipliedAlpha, preserveDrawingBuffer: _preserveDrawingBuffer, powerPreference: _powerPreference }; // event listeners must be registered before WebGL context is created, see #12753 _canvas.addEventListener( 'webglcontextlost', onContextLost, false ); _canvas.addEventListener( 'webglcontextrestored', onContextRestore, false ); _gl = _context || _canvas.getContext( 'webgl', contextAttributes ) || _canvas.getContext( 'experimental-webgl', contextAttributes ); if ( _gl === null ) { if ( _canvas.getContext( 'webgl' ) !== null ) { throw new Error( 'Error creating WebGL context with your selected attributes.' ); } else { throw new Error( 'Error creating WebGL context.' ); } } // Some experimental-webgl implementations do not have getShaderPrecisionFormat if ( _gl.getShaderPrecisionFormat === undefined ) { _gl.getShaderPrecisionFormat = function () { return { 'rangeMin': 1, 'rangeMax': 1, 'precision': 1 }; }; } } catch ( error ) { console.error( 'THREE.WebGLRenderer: ' + error.message ); } var extensions, capabilities, state, info; var properties, textures, attributes, geometries, objects; var programCache, renderLists, renderStates; var background, morphtargets, bufferRenderer, indexedBufferRenderer; var utils; function initGLContext() { extensions = new WebGLExtensions( _gl ); capabilities = new WebGLCapabilities( _gl, extensions, parameters ); if ( ! capabilities.isWebGL2 ) { extensions.get( 'WEBGL_depth_texture' ); extensions.get( 'OES_texture_float' ); extensions.get( 'OES_texture_half_float' ); extensions.get( 'OES_texture_half_float_linear' ); extensions.get( 'OES_standard_derivatives' ); extensions.get( 'OES_element_index_uint' ); extensions.get( 'ANGLE_instanced_arrays' ); } extensions.get( 'OES_texture_float_linear' ); utils = new WebGLUtils( _gl, extensions, capabilities ); state = new WebGLState( _gl, extensions, utils, capabilities ); state.scissor( _currentScissor.copy( _scissor ).multiplyScalar( _pixelRatio ) ); state.viewport( _currentViewport.copy( _viewport ).multiplyScalar( _pixelRatio ) ); info = new WebGLInfo( _gl ); properties = new WebGLProperties(); textures = new WebGLTextures( _gl, extensions, state, properties, capabilities, utils, info ); attributes = new WebGLAttributes( _gl ); geometries = new WebGLGeometries( _gl, attributes, info ); objects = new WebGLObjects( geometries, info ); morphtargets = new WebGLMorphtargets( _gl ); programCache = new WebGLPrograms( _this, extensions, capabilities ); renderLists = new WebGLRenderLists(); renderStates = new WebGLRenderStates(); background = new WebGLBackground( _this, state, objects, _premultipliedAlpha ); bufferRenderer = new WebGLBufferRenderer( _gl, extensions, info, capabilities ); indexedBufferRenderer = new WebGLIndexedBufferRenderer( _gl, extensions, info, capabilities ); info.programs = programCache.programs; _this.context = _gl; _this.capabilities = capabilities; _this.extensions = extensions; _this.properties = properties; _this.renderLists = renderLists; _this.state = state; _this.info = info; } initGLContext(); // vr var vr = null; if ( typeof navigator !== 'undefined' ) { vr = ( 'xr' in navigator ) ? new WebXRManager( _this ) : new WebVRManager( _this ); } this.vr = vr; // shadow map var shadowMap = new WebGLShadowMap( _this, objects, capabilities.maxTextureSize ); this.shadowMap = shadowMap; // API this.getContext = function () { return _gl; }; this.getContextAttributes = function () { return _gl.getContextAttributes(); }; this.forceContextLoss = function () { var extension = extensions.get( 'WEBGL_lose_context' ); if ( extension ) extension.loseContext(); }; this.forceContextRestore = function () { var extension = extensions.get( 'WEBGL_lose_context' ); if ( extension ) extension.restoreContext(); }; this.getPixelRatio = function () { return _pixelRatio; }; this.setPixelRatio = function ( value ) { if ( value === undefined ) return; _pixelRatio = value; this.setSize( _width, _height, false ); }; this.getSize = function () { return { width: _width, height: _height }; }; this.setSize = function ( width, height, updateStyle ) { if ( vr.isPresenting() ) { console.warn( 'THREE.WebGLRenderer: Can\\'t change size while VR device is presenting.' ); return; } _width = width; _height = height; _canvas.width = width * _pixelRatio; _canvas.height = height * _pixelRatio; if ( updateStyle !== false ) { _canvas.style.width = width + 'px'; _canvas.style.height = height + 'px'; } this.setViewport( 0, 0, width, height ); }; this.getDrawingBufferSize = function () { return { width: _width * _pixelRatio, height: _height * _pixelRatio }; }; this.setDrawingBufferSize = function ( width, height, pixelRatio ) { _width = width; _height = height; _pixelRatio = pixelRatio; _canvas.width = width * pixelRatio; _canvas.height = height * pixelRatio; this.setViewport( 0, 0, width, height ); }; this.getCurrentViewport = function () { return _currentViewport; }; this.setViewport = function ( x, y, width, height ) { _viewport.set( x, _height - y - height, width, height ); state.viewport( _currentViewport.copy( _viewport ).multiplyScalar( _pixelRatio ) ); }; this.setScissor = function ( x, y, width, height ) { _scissor.set( x, _height - y - height, width, height ); state.scissor( _currentScissor.copy( _scissor ).multiplyScalar( _pixelRatio ) ); }; this.setScissorTest = function ( boolean ) { state.setScissorTest( _scissorTest = boolean ); }; // Clearing this.getClearColor = function () { return background.getClearColor(); }; this.setClearColor = function () { background.setClearColor.apply( background, arguments ); }; this.getClearAlpha = function () { return background.getClearAlpha(); }; this.setClearAlpha = function () { background.setClearAlpha.apply( background, arguments ); }; this.clear = function ( color, depth, stencil ) { var bits = 0; if ( color === undefined || color ) bits |= 16384; if ( depth === undefined || depth ) bits |= 256; if ( stencil === undefined || stencil ) bits |= 1024; _gl.clear( bits ); }; this.clearColor = function () { this.clear( true, false, false ); }; this.clearDepth = function () { this.clear( false, true, false ); }; this.clearStencil = function () { this.clear( false, false, true ); }; // this.dispose = function () { _canvas.removeEventListener( 'webglcontextlost', onContextLost, false ); _canvas.removeEventListener( 'webglcontextrestored', onContextRestore, false ); renderLists.dispose(); renderStates.dispose(); properties.dispose(); objects.dispose(); vr.dispose(); animation.stop(); }; // Events function onContextLost( event ) { event.preventDefault(); console.log( 'THREE.WebGLRenderer: Context Lost.' ); _isContextLost = true; } function onContextRestore( /* event */ ) { console.log( 'THREE.WebGLRenderer: Context Restored.' ); _isContextLost = false; initGLContext(); } function onMaterialDispose( event ) { var material = event.target; material.removeEventListener( 'dispose', onMaterialDispose ); deallocateMaterial( material ); } // Buffer deallocation function deallocateMaterial( material ) { releaseMaterialProgramReference( material ); properties.remove( material ); } function releaseMaterialProgramReference( material ) { var programInfo = properties.get( material ).program; material.program = undefined; if ( programInfo !== undefined ) { programCache.releaseProgram( programInfo ); } } // Buffer rendering function renderObjectImmediate( object, program ) { object.render( function ( object ) { _this.renderBufferImmediate( object, program ); } ); } this.renderBufferImmediate = function ( object, program ) { state.initAttributes(); var buffers = properties.get( object ); if ( object.hasPositions && ! buffers.position ) buffers.position = _gl.createBuffer(); if ( object.hasNormals && ! buffers.normal ) buffers.normal = _gl.createBuffer(); if ( object.hasUvs && ! buffers.uv ) buffers.uv = _gl.createBuffer(); if ( object.hasColors && ! buffers.color ) buffers.color = _gl.createBuffer(); var programAttributes = program.getAttributes(); if ( object.hasPositions ) { _gl.bindBuffer( 34962, buffers.position ); _gl.bufferData( 34962, object.positionArray, 35048 ); state.enableAttribute( programAttributes.position ); _gl.vertexAttribPointer( programAttributes.position, 3, 5126, false, 0, 0 ); } if ( object.hasNormals ) { _gl.bindBuffer( 34962, buffers.normal ); _gl.bufferData( 34962, object.normalArray, 35048 ); state.enableAttribute( programAttributes.normal ); _gl.vertexAttribPointer( programAttributes.normal, 3, 5126, false, 0, 0 ); } if ( object.hasUvs ) { _gl.bindBuffer( 34962, buffers.uv ); _gl.bufferData( 34962, object.uvArray, 35048 ); state.enableAttribute( programAttributes.uv ); _gl.vertexAttribPointer( programAttributes.uv, 2, 5126, false, 0, 0 ); } if ( object.hasColors ) { _gl.bindBuffer( 34962, buffers.color ); _gl.bufferData( 34962, object.colorArray, 35048 ); state.enableAttribute( programAttributes.color ); _gl.vertexAttribPointer( programAttributes.color, 3, 5126, false, 0, 0 ); } state.disableUnusedAttributes(); _gl.drawArrays( 4, 0, object.count ); object.count = 0; }; this.renderBufferDirect = function ( camera, fog, geometry, material, object, group ) { var frontFaceCW = ( object.isMesh && object.normalMatrix.determinant() < 0 ); state.setMaterial( material, frontFaceCW ); var program = setProgram( camera, fog, material, object ); var updateBuffers = false; if ( _currentGeometryProgram.geometry !== geometry.id || _currentGeometryProgram.program !== program.id || _currentGeometryProgram.wireframe !== ( material.wireframe === true ) ) { _currentGeometryProgram.geometry = geometry.id; _currentGeometryProgram.program = program.id; _currentGeometryProgram.wireframe = material.wireframe === true; updateBuffers = true; } if ( object.morphTargetInfluences ) { morphtargets.update( object, geometry, material, program ); updateBuffers = true; } // var index = geometry.index; var position = geometry.attributes.position; var rangeFactor = 1; if ( material.wireframe === true ) { index = geometries.getWireframeAttribute( geometry ); rangeFactor = 2; } var attribute; var renderer = bufferRenderer; if ( index !== null ) { attribute = attributes.get( index ); renderer = indexedBufferRenderer; renderer.setIndex( attribute ); } if ( updateBuffers ) { setupVertexAttributes( material, program, geometry ); if ( index !== null ) { _gl.bindBuffer( 34963, attribute.buffer ); } } // var dataCount = Infinity; if ( index !== null ) { dataCount = index.count; } else if ( position !== undefined ) { dataCount = position.count; } var rangeStart = geometry.drawRange.start * rangeFactor; var rangeCount = geometry.drawRange.count * rangeFactor; var groupStart = group !== null ? group.start * rangeFactor : 0; var groupCount = group !== null ? group.count * rangeFactor : Infinity; var drawStart = Math.max( rangeStart, groupStart ); var drawEnd = Math.min( dataCount, rangeStart + rangeCount, groupStart + groupCount ) - 1; var drawCount = Math.max( 0, drawEnd - drawStart + 1 ); if ( drawCount === 0 ) return; // if ( object.isMesh ) { if ( material.wireframe === true ) { state.setLineWidth( material.wireframeLinewidth * getTargetPixelRatio() ); renderer.setMode( 1 ); } else { switch ( object.drawMode ) { case TrianglesDrawMode: renderer.setMode( 4 ); break; case TriangleStripDrawMode: renderer.setMode( 5 ); break; case TriangleFanDrawMode: renderer.setMode( 6 ); break; } } } else if ( object.isLine ) { var lineWidth = material.linewidth; if ( lineWidth === undefined ) lineWidth = 1; // Not using Line*Material state.setLineWidth( lineWidth * getTargetPixelRatio() ); if ( object.isLineSegments ) { renderer.setMode( 1 ); } else if ( object.isLineLoop ) { renderer.setMode( 2 ); } else { renderer.setMode( 3 ); } } else if ( object.isPoints ) { renderer.setMode( 0 ); } else if ( object.isSprite ) { renderer.setMode( 4 ); } if ( geometry && geometry.isInstancedBufferGeometry ) { if ( geometry.maxInstancedCount > 0 ) { renderer.renderInstances( geometry, drawStart, drawCount ); } } else { renderer.render( drawStart, drawCount ); } }; function setupVertexAttributes( material, program, geometry ) { if ( geometry && geometry.isInstancedBufferGeometry && ! capabilities.isWebGL2 ) { if ( extensions.get( 'ANGLE_instanced_arrays' ) === null ) { console.error( 'THREE.WebGLRenderer.setupVertexAttributes: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.' ); return; } } state.initAttributes(); var geometryAttributes = geometry.attributes; var programAttributes = program.getAttributes(); var materialDefaultAttributeValues = material.defaultAttributeValues; for ( var name in programAttributes ) { var programAttribute = programAttributes[ name ]; if ( programAttribute >= 0 ) { var geometryAttribute = geometryAttributes[ name ]; if ( geometryAttribute !== undefined ) { var normalized = geometryAttribute.normalized; var size = geometryAttribute.itemSize; var attribute = attributes.get( geometryAttribute ); // TODO Attribute may not be available on context restore if ( attribute === undefined ) continue; var buffer = attribute.buffer; var type = attribute.type; var bytesPerElement = attribute.bytesPerElement; if ( geometryAttribute.isInterleavedBufferAttribute ) { var data = geometryAttribute.data; var stride = data.stride; var offset = geometryAttribute.offset; if ( data && data.isInstancedInterleavedBuffer ) { state.enableAttributeAndDivisor( programAttribute, data.meshPerAttribute ); if ( geometry.maxInstancedCount === undefined ) { geometry.maxInstancedCount = data.meshPerAttribute * data.count; } } else { state.enableAttribute( programAttribute ); } _gl.bindBuffer( 34962, buffer ); _gl.vertexAttribPointer( programAttribute, size, type, normalized, stride * bytesPerElement, offset * bytesPerElement ); } else { if ( geometryAttribute.isInstancedBufferAttribute ) { state.enableAttributeAndDivisor( programAttribute, geometryAttribute.meshPerAttribute ); if ( geometry.maxInstancedCount === undefined ) { geometry.maxInstancedCount = geometryAttribute.meshPerAttribute * geometryAttribute.count; } } else { state.enableAttribute( programAttribute ); } _gl.bindBuffer( 34962, buffer ); _gl.vertexAttribPointer( programAttribute, size, type, normalized, 0, 0 ); } } else if ( materialDefaultAttributeValues !== undefined ) { var value = materialDefaultAttributeValues[ name ]; if ( value !== undefined ) { switch ( value.length ) { case 2: _gl.vertexAttrib2fv( programAttribute, value ); break; case 3: _gl.vertexAttrib3fv( programAttribute, value ); break; case 4: _gl.vertexAttrib4fv( programAttribute, value ); break; default: _gl.vertexAttrib1fv( programAttribute, value ); } } } } } state.disableUnusedAttributes(); } // Compile this.compile = function ( scene, camera ) { currentRenderState = renderStates.get( scene, camera ); currentRenderState.init(); scene.traverse( function ( object ) { if ( object.isLight ) { currentRenderState.pushLight( object ); if ( object.castShadow ) { currentRenderState.pushShadow( object ); } } } ); currentRenderState.setupLights( camera ); scene.traverse( function ( object ) { if ( object.material ) { if ( Array.isArray( object.material ) ) { for ( var i = 0; i < object.material.length; i ++ ) { initMaterial( object.material[ i ], scene.fog, object ); } } else { initMaterial( object.material, scene.fog, object ); } } } ); }; // Animation Loop var onAnimationFrameCallback = null; function onAnimationFrame( time ) { if ( vr.isPresenting() ) return; if ( onAnimationFrameCallback ) onAnimationFrameCallback( time ); } var animation = new WebGLAnimation(); animation.setAnimationLoop( onAnimationFrame ); if ( typeof window !== 'undefined' ) animation.setContext( window ); this.setAnimationLoop = function ( callback ) { onAnimationFrameCallback = callback; vr.setAnimationLoop( callback ); animation.start(); }; // Rendering this.render = function ( scene, camera ) { var renderTarget, forceClear; if ( arguments[ 2 ] !== undefined ) { console.warn( 'THREE.WebGLRenderer.render(): the renderTarget argument has been removed. Use .setRenderTarget() instead.' ); renderTarget = arguments[ 2 ]; } if ( arguments[ 3 ] !== undefined ) { console.warn( 'THREE.WebGLRenderer.render(): the forceClear argument has been removed. Use .clear() instead.' ); forceClear = arguments[ 3 ]; } if ( ! ( camera && camera.isCamera ) ) { console.error( 'THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.' ); return; } if ( _isContextLost ) return; // reset caching for this frame _currentGeometryProgram.geometry = null; _currentGeometryProgram.program = null; _currentGeometryProgram.wireframe = false; _currentMaterialId = - 1; _currentCamera = null; // update scene graph if ( scene.autoUpdate === true ) scene.updateMatrixWorld(); // update camera matrices and frustum if ( camera.parent === null ) camera.updateMatrixWorld(); if ( vr.enabled ) { camera = vr.getCamera( camera ); } // currentRenderState = renderStates.get( scene, camera ); currentRenderState.init(); scene.onBeforeRender( _this, scene, camera, renderTarget ); _projScreenMatrix.multiplyMatrices( camera.projectionMatrix, camera.matrixWorldInverse ); _frustum.setFromMatrix( _projScreenMatrix ); _localClippingEnabled = this.localClippingEnabled; _clippingEnabled = _clipping.init( this.clippingPlanes, _localClippingEnabled, camera ); currentRenderList = renderLists.get( scene, camera ); currentRenderList.init(); projectObject( scene, camera, 0, _this.sortObjects ); if ( _this.sortObjects === true ) { currentRenderList.sort(); } // if ( _clippingEnabled ) _clipping.beginShadows(); var shadowsArray = currentRenderState.state.shadowsArray; shadowMap.render( shadowsArray, scene, camera ); currentRenderState.setupLights( camera ); if ( _clippingEnabled ) _clipping.endShadows(); // if ( this.info.autoReset ) this.info.reset(); if ( renderTarget !== undefined ) { this.setRenderTarget( renderTarget ); } // background.render( currentRenderList, scene, camera, forceClear ); // render scene var opaqueObjects = currentRenderList.opaque; var transparentObjects = currentRenderList.transparent; if ( scene.overrideMaterial ) { var overrideMaterial = scene.overrideMaterial; if ( opaqueObjects.length ) renderObjects( opaqueObjects, scene, camera, overrideMaterial ); if ( transparentObjects.length ) renderObjects( transparentObjects, scene, camera, overrideMaterial ); } else { // opaque pass (front-to-back order) if ( opaqueObjects.length ) renderObjects( opaqueObjects, scene, camera ); // transparent pass (back-to-front order) if ( transparentObjects.length ) renderObjects( transparentObjects, scene, camera ); } // if ( renderTarget ) { // Generate mipmap if we're using any kind of mipmap filtering textures.updateRenderTargetMipmap( renderTarget ); // resolve multisample renderbuffers to a single-sample texture if necessary textures.updateMultisampleRenderTarget( renderTarget ); } // Ensure depth buffer writing is enabled so it can be cleared on next render state.buffers.depth.setTest( true ); state.buffers.depth.setMask( true ); state.buffers.color.setMask( true ); state.setPolygonOffset( false ); scene.onAfterRender( _this, scene, camera ); if ( vr.enabled ) { vr.submitFrame(); } // _gl.finish(); currentRenderList = null; currentRenderState = null; }; function projectObject( object, camera, groupOrder, sortObjects ) { if ( object.visible === false ) return; var visible = object.layers.test( camera.layers ); if ( visible ) { if ( object.isGroup ) { groupOrder = object.renderOrder; } else if ( object.isLight ) { currentRenderState.pushLight( object ); if ( object.castShadow ) { currentRenderState.pushShadow( object ); } } else if ( object.isSprite ) { if ( ! object.frustumCulled || _frustum.intersectsSprite( object ) ) { if ( sortObjects ) { _vector3.setFromMatrixPosition( object.matrixWorld ) .applyMatrix4( _projScreenMatrix ); } var geometry = objects.update( object ); var material = object.material; currentRenderList.push( object, geometry, material, groupOrder, _vector3.z, null ); } } else if ( object.isImmediateRenderObject ) { if ( sortObjects ) { _vector3.setFromMatrixPosition( object.matrixWorld ) .applyMatrix4( _projScreenMatrix ); } currentRenderList.push( object, null, object.material, groupOrder, _vector3.z, null ); } else if ( object.isMesh || object.isLine || object.isPoints ) { if ( object.isSkinnedMesh ) { object.skeleton.update(); } if ( ! object.frustumCulled || _frustum.intersectsObject( object ) ) { if ( sortObjects ) { _vector3.setFromMatrixPosition( object.matrixWorld ) .applyMatrix4( _projScreenMatrix ); } var geometry = objects.update( object ); var material = object.material; if ( Array.isArray( material ) ) { var groups = geometry.groups; for ( var i = 0, l = groups.length; i < l; i ++ ) { var group = groups[ i ]; var groupMaterial = material[ group.materialIndex ]; if ( groupMaterial && groupMaterial.visible ) { currentRenderList.push( object, geometry, groupMaterial, groupOrder, _vector3.z, group ); } } } else if ( material.visible ) { currentRenderList.push( object, geometry, material, groupOrder, _vector3.z, null ); } } } } var children = object.children; for ( var i = 0, l = children.length; i < l; i ++ ) { projectObject( children[ i ], camera, groupOrder, sortObjects ); } } function renderObjects( renderList, scene, camera, overrideMaterial ) { for ( var i = 0, l = renderList.length; i < l; i ++ ) { var renderItem = renderList[ i ]; var object = renderItem.object; var geometry = renderItem.geometry; var material = overrideMaterial === undefined ? renderItem.material : overrideMaterial; var group = renderItem.group; if ( camera.isArrayCamera ) { _currentArrayCamera = camera; var cameras = camera.cameras; for ( var j = 0, jl = cameras.length; j < jl; j ++ ) { var camera2 = cameras[ j ]; if ( object.layers.test( camera2.layers ) ) { if ( 'viewport' in camera2 ) { // XR state.viewport( _currentViewport.copy( camera2.viewport ) ); } else { var bounds = camera2.bounds; var x = bounds.x * _width; var y = bounds.y * _height; var width = bounds.z * _width; var height = bounds.w * _height; state.viewport( _currentViewport.set( x, y, width, height ).multiplyScalar( _pixelRatio ) ); } currentRenderState.setupLights( camera2 ); renderObject( object, scene, camera2, geometry, material, group ); } } } else { _currentArrayCamera = null; renderObject( object, scene, camera, geometry, material, group ); } } } function renderObject( object, scene, camera, geometry, material, group ) { object.onBeforeRender( _this, scene, camera, geometry, material, group ); currentRenderState = renderStates.get( scene, _currentArrayCamera || camera ); object.modelViewMatrix.multiplyMatrices( camera.matrixWorldInverse, object.matrixWorld ); object.normalMatrix.getNormalMatrix( object.modelViewMatrix ); if ( object.isImmediateRenderObject ) { state.setMaterial( material ); var program = setProgram( camera, scene.fog, material, object ); _currentGeometryProgram.geometry = null; _currentGeometryProgram.program = null; _currentGeometryProgram.wireframe = false; renderObjectImmediate( object, program ); } else { _this.renderBufferDirect( camera, scene.fog, geometry, material, object, group ); } object.onAfterRender( _this, scene, camera, geometry, material, group ); currentRenderState = renderStates.get( scene, _currentArrayCamera || camera ); } function initMaterial( material, fog, object ) { var materialProperties = properties.get( material ); var lights = currentRenderState.state.lights; var shadowsArray = currentRenderState.state.shadowsArray; var lightsHash = materialProperties.lightsHash; var lightsStateHash = lights.state.hash; var parameters = programCache.getParameters( material, lights.state, shadowsArray, fog, _clipping.numPlanes, _clipping.numIntersection, object ); var code = programCache.getProgramCode( material, parameters ); var program = materialProperties.program; var programChange = true; if ( program === undefined ) { // new material material.addEventListener( 'dispose', onMaterialDispose ); } else if ( program.code !== code ) { // changed glsl or parameters releaseMaterialProgramReference( material ); } else if ( lightsHash.stateID !== lightsStateHash.stateID || lightsHash.directionalLength !== lightsStateHash.directionalLength || lightsHash.pointLength !== lightsStateHash.pointLength || lightsHash.spotLength !== lightsStateHash.spotLength || lightsHash.rectAreaLength !== lightsStateHash.rectAreaLength || lightsHash.hemiLength !== lightsStateHash.hemiLength || lightsHash.shadowsLength !== lightsStateHash.shadowsLength ) { lightsHash.stateID = lightsStateHash.stateID; lightsHash.directionalLength = lightsStateHash.directionalLength; lightsHash.pointLength = lightsStateHash.pointLength; lightsHash.spotLength = lightsStateHash.spotLength; lightsHash.rectAreaLength = lightsStateHash.rectAreaLength; lightsHash.hemiLength = lightsStateHash.hemiLength; lightsHash.shadowsLength = lightsStateHash.shadowsLength; programChange = false; } else if ( parameters.shaderID !== undefined ) { // same glsl and uniform list return; } else { // only rebuild uniform list programChange = false; } if ( programChange ) { if ( parameters.shaderID ) { var shader = ShaderLib[ parameters.shaderID ]; materialProperties.shader = { name: material.type, uniforms: cloneUniforms( shader.uniforms ), vertexShader: shader.vertexShader, fragmentShader: shader.fragmentShader }; } else { materialProperties.shader = { name: material.type, uniforms: material.uniforms, vertexShader: material.vertexShader, fragmentShader: material.fragmentShader }; } material.onBeforeCompile( materialProperties.shader, _this ); // Computing code again as onBeforeCompile may have changed the shaders code = programCache.getProgramCode( material, parameters ); program = programCache.acquireProgram( material, materialProperties.shader, parameters, code ); materialProperties.program = program; material.program = program; } var programAttributes = program.getAttributes(); if ( material.morphTargets ) { material.numSupportedMorphTargets = 0; for ( var i = 0; i < _this.maxMorphTargets; i ++ ) { if ( programAttributes[ 'morphTarget' + i ] >= 0 ) { material.numSupportedMorphTargets ++; } } } if ( material.morphNormals ) { material.numSupportedMorphNormals = 0; for ( var i = 0; i < _this.maxMorphNormals; i ++ ) { if ( programAttributes[ 'morphNormal' + i ] >= 0 ) { material.numSupportedMorphNormals ++; } } } var uniforms = materialProperties.shader.uniforms; if ( ! material.isShaderMaterial && ! material.isRawShaderMaterial || material.clipping === true ) { materialProperties.numClippingPlanes = _clipping.numPlanes; materialProperties.numIntersection = _clipping.numIntersection; uniforms.clippingPlanes = _clipping.uniform; } materialProperties.fog = fog; // store the light setup it was created for if ( lightsHash === undefined ) { materialProperties.lightsHash = lightsHash = {}; } lightsHash.stateID = lightsStateHash.stateID; lightsHash.directionalLength = lightsStateHash.directionalLength; lightsHash.pointLength = lightsStateHash.pointLength; lightsHash.spotLength = lightsStateHash.spotLength; lightsHash.rectAreaLength = lightsStateHash.rectAreaLength; lightsHash.hemiLength = lightsStateHash.hemiLength; lightsHash.shadowsLength = lightsStateHash.shadowsLength; if ( material.lights ) { // wire up the material to this renderer's lighting state uniforms.ambientLightColor.value = lights.state.ambient; uniforms.directionalLights.value = lights.state.directional; uniforms.spotLights.value = lights.state.spot; uniforms.rectAreaLights.value = lights.state.rectArea; uniforms.pointLights.value = lights.state.point; uniforms.hemisphereLights.value = lights.state.hemi; uniforms.directionalShadowMap.value = lights.state.directionalShadowMap; uniforms.directionalShadowMatrix.value = lights.state.directionalShadowMatrix; uniforms.spotShadowMap.value = lights.state.spotShadowMap; uniforms.spotShadowMatrix.value = lights.state.spotShadowMatrix; uniforms.pointShadowMap.value = lights.state.pointShadowMap; uniforms.pointShadowMatrix.value = lights.state.pointShadowMatrix; // TODO (abelnation): add area lights shadow info to uniforms } var progUniforms = materialProperties.program.getUniforms(), uniformsList = WebGLUniforms.seqWithValue( progUniforms.seq, uniforms ); materialProperties.uniformsList = uniformsList; } function setProgram( camera, fog, material, object ) { _usedTextureUnits = 0; var materialProperties = properties.get( material ); var lights = currentRenderState.state.lights; var lightsHash = materialProperties.lightsHash; var lightsStateHash = lights.state.hash; if ( _clippingEnabled ) { if ( _localClippingEnabled || camera !== _currentCamera ) { var useCache = camera === _currentCamera && material.id === _currentMaterialId; // we might want to call this function with some ClippingGroup // object instead of the material, once it becomes feasible // (#8465, #8379) _clipping.setState( material.clippingPlanes, material.clipIntersection, material.clipShadows, camera, materialProperties, useCache ); } } if ( material.needsUpdate === false ) { if ( materialProperties.program === undefined ) { material.needsUpdate = true; } else if ( material.fog && materialProperties.fog !== fog ) { material.needsUpdate = true; } else if ( material.lights && ( lightsHash.stateID !== lightsStateHash.stateID || lightsHash.directionalLength !== lightsStateHash.directionalLength || lightsHash.pointLength !== lightsStateHash.pointLength || lightsHash.spotLength !== lightsStateHash.spotLength || lightsHash.rectAreaLength !== lightsStateHash.rectAreaLength || lightsHash.hemiLength !== lightsStateHash.hemiLength || lightsHash.shadowsLength !== lightsStateHash.shadowsLength ) ) { material.needsUpdate = true; } else if ( materialProperties.numClippingPlanes !== undefined && ( materialProperties.numClippingPlanes !== _clipping.numPlanes || materialProperties.numIntersection !== _clipping.numIntersection ) ) { material.needsUpdate = true; } } if ( material.needsUpdate ) { initMaterial( material, fog, object ); material.needsUpdate = false; } var refreshProgram = false; var refreshMaterial = false; var refreshLights = false; var program = materialProperties.program, p_uniforms = program.getUniforms(), m_uniforms = materialProperties.shader.uniforms; if ( state.useProgram( program.program ) ) { refreshProgram = true; refreshMaterial = true; refreshLights = true; } if ( material.id !== _currentMaterialId ) { _currentMaterialId = material.id; refreshMaterial = true; } if ( refreshProgram || _currentCamera !== camera ) { p_uniforms.setValue( _gl, 'projectionMatrix', camera.projectionMatrix ); if ( capabilities.logarithmicDepthBuffer ) { p_uniforms.setValue( _gl, 'logDepthBufFC', 2.0 / ( Math.log( camera.far + 1.0 ) / Math.LN2 ) ); } if ( _currentCamera !== camera ) { _currentCamera = camera; // lighting uniforms depend on the camera so enforce an update // now, in case this material supports lights - or later, when // the next material that does gets activated: refreshMaterial = true; // set to true on material change refreshLights = true; // remains set until update done } // load material specific uniforms // (shader material also gets them for the sake of genericity) if ( material.isShaderMaterial || material.isMeshPhongMaterial || material.isMeshStandardMaterial || material.envMap ) { var uCamPos = p_uniforms.map.cameraPosition; if ( uCamPos !== undefined ) { uCamPos.setValue( _gl, _vector3.setFromMatrixPosition( camera.matrixWorld ) ); } } if ( material.isMeshPhongMaterial || material.isMeshLambertMaterial || material.isMeshBasicMaterial || material.isMeshStandardMaterial || material.isShaderMaterial || material.skinning ) { p_uniforms.setValue( _gl, 'viewMatrix', camera.matrixWorldInverse ); } } // skinning uniforms must be set even if material didn't change // auto-setting of texture unit for bone texture must go before other textures // not sure why, but otherwise weird things happen if ( material.skinning ) { p_uniforms.setOptional( _gl, object, 'bindMatrix' ); p_uniforms.setOptional( _gl, object, 'bindMatrixInverse' ); var skeleton = object.skeleton; if ( skeleton ) { var bones = skeleton.bones; if ( capabilities.floatVertexTextures ) { if ( skeleton.boneTexture === undefined ) { // layout (1 matrix = 4 pixels) // RGBA RGBA RGBA RGBA (=> column1, column2, column3, column4) // with 8x8 pixel texture max 16 bones * 4 pixels = (8 * 8) // 16x16 pixel texture max 64 bones * 4 pixels = (16 * 16) // 32x32 pixel texture max 256 bones * 4 pixels = (32 * 32) // 64x64 pixel texture max 1024 bones * 4 pixels = (64 * 64) var size = Math.sqrt( bones.length * 4 ); // 4 pixels needed for 1 matrix size = _Math.ceilPowerOfTwo( size ); size = Math.max( size, 4 ); var boneMatrices = new Float32Array( size * size * 4 ); // 4 floats per RGBA pixel boneMatrices.set( skeleton.boneMatrices ); // copy current values var boneTexture = new DataTexture( boneMatrices, size, size, RGBAFormat, FloatType ); boneTexture.needsUpdate = true; skeleton.boneMatrices = boneMatrices; skeleton.boneTexture = boneTexture; skeleton.boneTextureSize = size; } p_uniforms.setValue( _gl, 'boneTexture', skeleton.boneTexture ); p_uniforms.setValue( _gl, 'boneTextureSize', skeleton.boneTextureSize ); } else { p_uniforms.setOptional( _gl, skeleton, 'boneMatrices' ); } } } if ( refreshMaterial ) { p_uniforms.setValue( _gl, 'toneMappingExposure', _this.toneMappingExposure ); p_uniforms.setValue( _gl, 'toneMappingWhitePoint', _this.toneMappingWhitePoint ); if ( material.lights ) { // the current material requires lighting info // note: all lighting uniforms are always set correctly // they simply reference the renderer's state for their // values // // use the current material's .needsUpdate flags to set // the GL state when required markUniformsLightsNeedsUpdate( m_uniforms, refreshLights ); } // refresh uniforms common to several materials if ( fog && material.fog ) { refreshUniformsFog( m_uniforms, fog ); } if ( material.isMeshBasicMaterial ) { refreshUniformsCommon( m_uniforms, material ); } else if ( material.isMeshLambertMaterial ) { refreshUniformsCommon( m_uniforms, material ); refreshUniformsLambert( m_uniforms, material ); } else if ( material.isMeshPhongMaterial ) { refreshUniformsCommon( m_uniforms, material ); if ( material.isMeshToonMaterial ) { refreshUniformsToon( m_uniforms, material ); } else { refreshUniformsPhong( m_uniforms, material ); } } else if ( material.isMeshStandardMaterial ) { refreshUniformsCommon( m_uniforms, material ); if ( material.isMeshPhysicalMaterial ) { refreshUniformsPhysical( m_uniforms, material ); } else { refreshUniformsStandard( m_uniforms, material ); } } else if ( material.isMeshMatcapMaterial ) { refreshUniformsCommon( m_uniforms, material ); refreshUniformsMatcap( m_uniforms, material ); } else if ( material.isMeshDepthMaterial ) { refreshUniformsCommon( m_uniforms, material ); refreshUniformsDepth( m_uniforms, material ); } else if ( material.isMeshDistanceMaterial ) { refreshUniformsCommon( m_uniforms, material ); refreshUniformsDistance( m_uniforms, material ); } else if ( material.isMeshNormalMaterial ) { refreshUniformsCommon( m_uniforms, material ); refreshUniformsNormal( m_uniforms, material ); } else if ( material.isLineBasicMaterial ) { refreshUniformsLine( m_uniforms, material ); if ( material.isLineDashedMaterial ) { refreshUniformsDash( m_uniforms, material ); } } else if ( material.isPointsMaterial ) { refreshUniformsPoints( m_uniforms, material ); } else if ( material.isSpriteMaterial ) { refreshUniformsSprites( m_uniforms, material ); } else if ( material.isShadowMaterial ) { m_uniforms.color.value = material.color; m_uniforms.opacity.value = material.opacity; } // RectAreaLight Texture // TODO (mrdoob): Find a nicer implementation if ( m_uniforms.ltc_1 !== undefined ) m_uniforms.ltc_1.value = UniformsLib.LTC_1; if ( m_uniforms.ltc_2 !== undefined ) m_uniforms.ltc_2.value = UniformsLib.LTC_2; WebGLUniforms.upload( _gl, materialProperties.uniformsList, m_uniforms, _this ); } if ( material.isShaderMaterial && material.uniformsNeedUpdate === true ) { WebGLUniforms.upload( _gl, materialProperties.uniformsList, m_uniforms, _this ); material.uniformsNeedUpdate = false; } if ( material.isSpriteMaterial ) { p_uniforms.setValue( _gl, 'center', object.center ); } // common matrices p_uniforms.setValue( _gl, 'modelViewMatrix', object.modelViewMatrix ); p_uniforms.setValue( _gl, 'normalMatrix', object.normalMatrix ); p_uniforms.setValue( _gl, 'modelMatrix', object.matrixWorld ); return program; } // Uniforms (refresh uniforms objects) function refreshUniformsCommon( uniforms, material ) { uniforms.opacity.value = material.opacity; if ( material.color ) { uniforms.diffuse.value = material.color; } if ( material.emissive ) { uniforms.emissive.value.copy( material.emissive ).multiplyScalar( material.emissiveIntensity ); } if ( material.map ) { uniforms.map.value = material.map; } if ( material.alphaMap ) { uniforms.alphaMap.value = material.alphaMap; } if ( material.specularMap ) { uniforms.specularMap.value = material.specularMap; } if ( material.envMap ) { uniforms.envMap.value = material.envMap; // don't flip CubeTexture envMaps, flip everything else: // WebGLRenderTargetCube will be flipped for backwards compatibility // WebGLRenderTargetCube.texture will be flipped because it's a Texture and NOT a CubeTexture // this check must be handled differently, or removed entirely, if WebGLRenderTargetCube uses a CubeTexture in the future uniforms.flipEnvMap.value = material.envMap.isCubeTexture ? - 1 : 1; uniforms.reflectivity.value = material.reflectivity; uniforms.refractionRatio.value = material.refractionRatio; uniforms.maxMipLevel.value = properties.get( material.envMap ).__maxMipLevel; } if ( material.lightMap ) { uniforms.lightMap.value = material.lightMap; uniforms.lightMapIntensity.value = material.lightMapIntensity; } if ( material.aoMap ) { uniforms.aoMap.value = material.aoMap; uniforms.aoMapIntensity.value = material.aoMapIntensity; } // uv repeat and offset setting priorities // 1. color map // 2. specular map // 3. normal map // 4. bump map // 5. alpha map // 6. emissive map var uvScaleMap; if ( material.map ) { uvScaleMap = material.map; } else if ( material.specularMap ) { uvScaleMap = material.specularMap; } else if ( material.displacementMap ) { uvScaleMap = material.displacementMap; } else if ( material.normalMap ) { uvScaleMap = material.normalMap; } else if ( material.bumpMap ) { uvScaleMap = material.bumpMap; } else if ( material.roughnessMap ) { uvScaleMap = material.roughnessMap; } else if ( material.metalnessMap ) { uvScaleMap = material.metalnessMap; } else if ( material.alphaMap ) { uvScaleMap = material.alphaMap; } else if ( material.emissiveMap ) { uvScaleMap = material.emissiveMap; } if ( uvScaleMap !== undefined ) { // backwards compatibility if ( uvScaleMap.isWebGLRenderTarget ) { uvScaleMap = uvScaleMap.texture; } if ( uvScaleMap.matrixAutoUpdate === true ) { uvScaleMap.updateMatrix(); } uniforms.uvTransform.value.copy( uvScaleMap.matrix ); } } function refreshUniformsLine( uniforms, material ) { uniforms.diffuse.value = material.color; uniforms.opacity.value = material.opacity; } function refreshUniformsDash( uniforms, material ) { uniforms.dashSize.value = material.dashSize; uniforms.totalSize.value = material.dashSize + material.gapSize; uniforms.scale.value = material.scale; } function refreshUniformsPoints( uniforms, material ) { uniforms.diffuse.value = material.color; uniforms.opacity.value = material.opacity; uniforms.size.value = material.size * _pixelRatio; uniforms.scale.value = _height * 0.5; uniforms.map.value = material.map; if ( material.map !== null ) { if ( material.map.matrixAutoUpdate === true ) { material.map.updateMatrix(); } uniforms.uvTransform.value.copy( material.map.matrix ); } } function refreshUniformsSprites( uniforms, material ) { uniforms.diffuse.value = material.color; uniforms.opacity.value = material.opacity; uniforms.rotation.value = material.rotation; uniforms.map.value = material.map; if ( material.map !== null ) { if ( material.map.matrixAutoUpdate === true ) { material.map.updateMatrix(); } uniforms.uvTransform.value.copy( material.map.matrix ); } } function refreshUniformsFog( uniforms, fog ) { uniforms.fogColor.value = fog.color; if ( fog.isFog ) { uniforms.fogNear.value = fog.near; uniforms.fogFar.value = fog.far; } else if ( fog.isFogExp2 ) { uniforms.fogDensity.value = fog.density; } } function refreshUniformsLambert( uniforms, material ) { if ( material.emissiveMap ) { uniforms.emissiveMap.value = material.emissiveMap; } } function refreshUniformsPhong( uniforms, material ) { uniforms.specular.value = material.specular; uniforms.shininess.value = Math.max( material.shininess, 1e-4 ); // to prevent pow( 0.0, 0.0 ) if ( material.emissiveMap ) { uniforms.emissiveMap.value = material.emissiveMap; } if ( material.bumpMap ) { uniforms.bumpMap.value = material.bumpMap; uniforms.bumpScale.value = material.bumpScale; if ( material.side === BackSide ) uniforms.bumpScale.value *= - 1; } if ( material.normalMap ) { uniforms.normalMap.value = material.normalMap; uniforms.normalScale.value.copy( material.normalScale ); if ( material.side === BackSide ) uniforms.normalScale.value.negate(); } if ( material.displacementMap ) { uniforms.displacementMap.value = material.displacementMap; uniforms.displacementScale.value = material.displacementScale; uniforms.displacementBias.value = material.displacementBias; } } function refreshUniformsToon( uniforms, material ) { refreshUniformsPhong( uniforms, material ); if ( material.gradientMap ) { uniforms.gradientMap.value = material.gradientMap; } } function refreshUniformsStandard( uniforms, material ) { uniforms.roughness.value = material.roughness; uniforms.metalness.value = material.metalness; if ( material.roughnessMap ) { uniforms.roughnessMap.value = material.roughnessMap; } if ( material.metalnessMap ) { uniforms.metalnessMap.value = material.metalnessMap; } if ( material.emissiveMap ) { uniforms.emissiveMap.value = material.emissiveMap; } if ( material.bumpMap ) { uniforms.bumpMap.value = material.bumpMap; uniforms.bumpScale.value = material.bumpScale; if ( material.side === BackSide ) uniforms.bumpScale.value *= - 1; } if ( material.normalMap ) { uniforms.normalMap.value = material.normalMap; uniforms.normalScale.value.copy( material.normalScale ); if ( material.side === BackSide ) uniforms.normalScale.value.negate(); } if ( material.displacementMap ) { uniforms.displacementMap.value = material.displacementMap; uniforms.displacementScale.value = material.displacementScale; uniforms.displacementBias.value = material.displacementBias; } if ( material.envMap ) { //uniforms.envMap.value = material.envMap; // part of uniforms common uniforms.envMapIntensity.value = material.envMapIntensity; } } function refreshUniformsPhysical( uniforms, material ) { refreshUniformsStandard( uniforms, material ); uniforms.reflectivity.value = material.reflectivity; // also part of uniforms common uniforms.clearCoat.value = material.clearCoat; uniforms.clearCoatRoughness.value = material.clearCoatRoughness; } function refreshUniformsMatcap( uniforms, material ) { if ( material.matcap ) { uniforms.matcap.value = material.matcap; } if ( material.bumpMap ) { uniforms.bumpMap.value = material.bumpMap; uniforms.bumpScale.value = material.bumpScale; if ( material.side === BackSide ) uniforms.bumpScale.value *= - 1; } if ( material.normalMap ) { uniforms.normalMap.value = material.normalMap; uniforms.normalScale.value.copy( material.normalScale ); if ( material.side === BackSide ) uniforms.normalScale.value.negate(); } if ( material.displacementMap ) { uniforms.displacementMap.value = material.displacementMap; uniforms.displacementScale.value = material.displacementScale; uniforms.displacementBias.value = material.displacementBias; } } function refreshUniformsDepth( uniforms, material ) { if ( material.displacementMap ) { uniforms.displacementMap.value = material.displacementMap; uniforms.displacementScale.value = material.displacementScale; uniforms.displacementBias.value = material.displacementBias; } } function refreshUniformsDistance( uniforms, material ) { if ( material.displacementMap ) { uniforms.displacementMap.value = material.displacementMap; uniforms.displacementScale.value = material.displacementScale; uniforms.displacementBias.value = material.displacementBias; } uniforms.referencePosition.value.copy( material.referencePosition ); uniforms.nearDistance.value = material.nearDistance; uniforms.farDistance.value = material.farDistance; } function refreshUniformsNormal( uniforms, material ) { if ( material.bumpMap ) { uniforms.bumpMap.value = material.bumpMap; uniforms.bumpScale.value = material.bumpScale; if ( material.side === BackSide ) uniforms.bumpScale.value *= - 1; } if ( material.normalMap ) { uniforms.normalMap.value = material.normalMap; uniforms.normalScale.value.copy( material.normalScale ); if ( material.side === BackSide ) uniforms.normalScale.value.negate(); } if ( material.displacementMap ) { uniforms.displacementMap.value = material.displacementMap; uniforms.displacementScale.value = material.displacementScale; uniforms.displacementBias.value = material.displacementBias; } } // If uniforms are marked as clean, they don't need to be loaded to the GPU. function markUniformsLightsNeedsUpdate( uniforms, value ) { uniforms.ambientLightColor.needsUpdate = value; uniforms.directionalLights.needsUpdate = value; uniforms.pointLights.needsUpdate = value; uniforms.spotLights.needsUpdate = value; uniforms.rectAreaLights.needsUpdate = value; uniforms.hemisphereLights.needsUpdate = value; } // Textures function allocTextureUnit() { var textureUnit = _usedTextureUnits; if ( textureUnit >= capabilities.maxTextures ) { console.warn( 'THREE.WebGLRenderer: Trying to use ' + textureUnit + ' texture units while this GPU supports only ' + capabilities.maxTextures ); } _usedTextureUnits += 1; return textureUnit; } this.allocTextureUnit = allocTextureUnit; // this.setTexture2D = setTexture2D; this.setTexture2D = ( function () { var warned = false; // backwards compatibility: peel texture.texture return function setTexture2D( texture, slot ) { if ( texture && texture.isWebGLRenderTarget ) { if ( ! warned ) { console.warn( \"THREE.WebGLRenderer.setTexture2D: don't use render targets as textures. Use their .texture property instead.\" ); warned = true; } texture = texture.texture; } textures.setTexture2D( texture, slot ); }; }() ); this.setTexture3D = ( function () { // backwards compatibility: peel texture.texture return function setTexture3D( texture, slot ) { textures.setTexture3D( texture, slot ); }; }() ); this.setTexture = ( function () { var warned = false; return function setTexture( texture, slot ) { if ( ! warned ) { console.warn( \"THREE.WebGLRenderer: .setTexture is deprecated, use setTexture2D instead.\" ); warned = true; } textures.setTexture2D( texture, slot ); }; }() ); this.setTextureCube = ( function () { var warned = false; return function setTextureCube( texture, slot ) { // backwards compatibility: peel texture.texture if ( texture && texture.isWebGLRenderTargetCube ) { if ( ! warned ) { console.warn( \"THREE.WebGLRenderer.setTextureCube: don't use cube render targets as textures. Use their .texture property instead.\" ); warned = true; } texture = texture.texture; } // currently relying on the fact that WebGLRenderTargetCube.texture is a Texture and NOT a CubeTexture // TODO: unify these code paths if ( ( texture && texture.isCubeTexture ) || ( Array.isArray( texture.image ) && texture.image.length === 6 ) ) { // CompressedTexture can have Array in image :/ // this function alone should take care of cube textures textures.setTextureCube( texture, slot ); } else { // assumed: texture property of THREE.WebGLRenderTargetCube textures.setTextureCubeDynamic( texture, slot ); } }; }() ); // this.setFramebuffer = function ( value ) { _framebuffer = value; }; this.getRenderTarget = function () { return _currentRenderTarget; }; this.setRenderTarget = function ( renderTarget ) { _currentRenderTarget = renderTarget; if ( renderTarget && properties.get( renderTarget ).__webglFramebuffer === undefined ) { textures.setupRenderTarget( renderTarget ); } var framebuffer = _framebuffer; var isCube = false; if ( renderTarget ) { var __webglFramebuffer = properties.get( renderTarget ).__webglFramebuffer; if ( renderTarget.isWebGLRenderTargetCube ) { framebuffer = __webglFramebuffer[ renderTarget.activeCubeFace ]; isCube = true; } else if ( renderTarget.isWebGLMultisampleRenderTarget ) { framebuffer = properties.get( renderTarget ).__webglMultisampledFramebuffer; } else { framebuffer = __webglFramebuffer; } _currentViewport.copy( renderTarget.viewport ); _currentScissor.copy( renderTarget.scissor ); _currentScissorTest = renderTarget.scissorTest; } else { _currentViewport.copy( _viewport ).multiplyScalar( _pixelRatio ); _currentScissor.copy( _scissor ).multiplyScalar( _pixelRatio ); _currentScissorTest = _scissorTest; } if ( _currentFramebuffer !== framebuffer ) { _gl.bindFramebuffer( 36160, framebuffer ); _currentFramebuffer = framebuffer; } state.viewport( _currentViewport ); state.scissor( _currentScissor ); state.setScissorTest( _currentScissorTest ); if ( isCube ) { var textureProperties = properties.get( renderTarget.texture ); _gl.framebufferTexture2D( 36160, 36064, 34069 + renderTarget.activeCubeFace, textureProperties.__webglTexture, renderTarget.activeMipMapLevel ); } }; this.readRenderTargetPixels = function ( renderTarget, x, y, width, height, buffer ) { if ( ! ( renderTarget && renderTarget.isWebGLRenderTarget ) ) { console.error( 'THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.' ); return; } var framebuffer = properties.get( renderTarget ).__webglFramebuffer; if ( framebuffer ) { var restore = false; if ( framebuffer !== _currentFramebuffer ) { _gl.bindFramebuffer( 36160, framebuffer ); restore = true; } try { var texture = renderTarget.texture; var textureFormat = texture.format; var textureType = texture.type; if ( textureFormat !== RGBAFormat && utils.convert( textureFormat ) !== _gl.getParameter( 35739 ) ) { console.error( 'THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.' ); return; } if ( textureType !== UnsignedByteType && utils.convert( textureType ) !== _gl.getParameter( 35738 ) && // IE11, Edge and Chrome Mac < 52 (#9513) ! ( textureType === FloatType && ( capabilities.isWebGL2 || extensions.get( 'OES_texture_float' ) || extensions.get( 'WEBGL_color_buffer_float' ) ) ) && // Chrome Mac >= 52 and Firefox ! ( textureType === HalfFloatType && ( capabilities.isWebGL2 ? extensions.get( 'EXT_color_buffer_float' ) : extensions.get( 'EXT_color_buffer_half_float' ) ) ) ) { console.error( 'THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.' ); return; } if ( _gl.checkFramebufferStatus( 36160 ) === 36053 ) { // the following if statement ensures valid read requests (no out-of-bounds pixels, see #8604) if ( ( x >= 0 && x = 0 && y 1 ) { v1.setFromMatrixPosition( camera.matrixWorld ); v2.setFromMatrixPosition( this.matrixWorld ); var distance = v1.distanceTo( v2 ); levels[ 0 ].object.visible = true; for ( var i = 1, l = levels.length; i < l; i ++ ) { if ( distance >= levels[ i ].distance ) { levels[ i - 1 ].object.visible = false; levels[ i ].object.visible = true; } else { break; } } for ( ; i < l; i ++ ) { levels[ i ].object.visible = false; } } }; }(), toJSON: function ( meta ) { var data = Object3D.prototype.toJSON.call( this, meta ); data.object.levels = []; var levels = this.levels; for ( var i = 0, l = levels.length; i < l; i ++ ) { var level = levels[ i ]; data.object.levels.push( { object: level.object.uuid, distance: level.distance } ); } return data; } } ); /** * @author mikael emtinger / http://gomo.se/ * @author alteredq / http://alteredqualia.com/ * @author ikerr / http://verold.com */ function SkinnedMesh( geometry, material ) { if ( geometry && geometry.isGeometry ) { console.error( 'THREE.SkinnedMesh no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.' ); } Mesh.call( this, geometry, material ); this.type = 'SkinnedMesh'; this.bindMode = 'attached'; this.bindMatrix = new Matrix4(); this.bindMatrixInverse = new Matrix4(); } SkinnedMesh.prototype = Object.assign( Object.create( Mesh.prototype ), { constructor: SkinnedMesh, isSkinnedMesh: true, bind: function ( skeleton, bindMatrix ) { this.skeleton = skeleton; if ( bindMatrix === undefined ) { this.updateMatrixWorld( true ); this.skeleton.calculateInverses(); bindMatrix = this.matrixWorld; } this.bindMatrix.copy( bindMatrix ); this.bindMatrixInverse.getInverse( bindMatrix ); }, pose: function () { this.skeleton.pose(); }, normalizeSkinWeights: function () { var vector = new Vector4(); var skinWeight = this.geometry.attributes.skinWeight; for ( var i = 0, l = skinWeight.count; i < l; i ++ ) { vector.x = skinWeight.getX( i ); vector.y = skinWeight.getY( i ); vector.z = skinWeight.getZ( i ); vector.w = skinWeight.getW( i ); var scale = 1.0 / vector.manhattanLength(); if ( scale !== Infinity ) { vector.multiplyScalar( scale ); } else { vector.set( 1, 0, 0, 0 ); // do something reasonable } skinWeight.setXYZW( i, vector.x, vector.y, vector.z, vector.w ); } }, updateMatrixWorld: function ( force ) { Mesh.prototype.updateMatrixWorld.call( this, force ); if ( this.bindMode === 'attached' ) { this.bindMatrixInverse.getInverse( this.matrixWorld ); } else if ( this.bindMode === 'detached' ) { this.bindMatrixInverse.getInverse( this.bindMatrix ); } else { console.warn( 'THREE.SkinnedMesh: Unrecognized bindMode: ' + this.bindMode ); } }, clone: function () { return new this.constructor( this.geometry, this.material ).copy( this ); } } ); /** * @author mikael emtinger / http://gomo.se/ * @author alteredq / http://alteredqualia.com/ * @author michael guerrero / http://realitymeltdown.com * @author ikerr / http://verold.com */ function Skeleton( bones, boneInverses ) { // copy the bone array bones = bones || []; this.bones = bones.slice( 0 ); this.boneMatrices = new Float32Array( this.bones.length * 16 ); // use the supplied bone inverses or calculate the inverses if ( boneInverses === undefined ) { this.calculateInverses(); } else { if ( this.bones.length === boneInverses.length ) { this.boneInverses = boneInverses.slice( 0 ); } else { console.warn( 'THREE.Skeleton boneInverses is the wrong length.' ); this.boneInverses = []; for ( var i = 0, il = this.bones.length; i < il; i ++ ) { this.boneInverses.push( new Matrix4() ); } } } } Object.assign( Skeleton.prototype, { calculateInverses: function () { this.boneInverses = []; for ( var i = 0, il = this.bones.length; i < il; i ++ ) { var inverse = new Matrix4(); if ( this.bones[ i ] ) { inverse.getInverse( this.bones[ i ].matrixWorld ); } this.boneInverses.push( inverse ); } }, pose: function () { var bone, i, il; // recover the bind-time world matrices for ( i = 0, il = this.bones.length; i < il; i ++ ) { bone = this.bones[ i ]; if ( bone ) { bone.matrixWorld.getInverse( this.boneInverses[ i ] ); } } // compute the local matrices, positions, rotations and scales for ( i = 0, il = this.bones.length; i < il; i ++ ) { bone = this.bones[ i ]; if ( bone ) { if ( bone.parent && bone.parent.isBone ) { bone.matrix.getInverse( bone.parent.matrixWorld ); bone.matrix.multiply( bone.matrixWorld ); } else { bone.matrix.copy( bone.matrixWorld ); } bone.matrix.decompose( bone.position, bone.quaternion, bone.scale ); } } }, update: ( function () { var offsetMatrix = new Matrix4(); var identityMatrix = new Matrix4(); return function update() { var bones = this.bones; var boneInverses = this.boneInverses; var boneMatrices = this.boneMatrices; var boneTexture = this.boneTexture; // flatten bone matrices to array for ( var i = 0, il = bones.length; i < il; i ++ ) { // compute the offset between the current and the original transform var matrix = bones[ i ] ? bones[ i ].matrixWorld : identityMatrix; offsetMatrix.multiplyMatrices( matrix, boneInverses[ i ] ); offsetMatrix.toArray( boneMatrices, i * 16 ); } if ( boneTexture !== undefined ) { boneTexture.needsUpdate = true; } }; } )(), clone: function () { return new Skeleton( this.bones, this.boneInverses ); }, getBoneByName: function ( name ) { for ( var i = 0, il = this.bones.length; i < il; i ++ ) { var bone = this.bones[ i ]; if ( bone.name === name ) { return bone; } } return undefined; } } ); /** * @author mikael emtinger / http://gomo.se/ * @author alteredq / http://alteredqualia.com/ * @author ikerr / http://verold.com */ function Bone() { Object3D.call( this ); this.type = 'Bone'; } Bone.prototype = Object.assign( Object.create( Object3D.prototype ), { constructor: Bone, isBone: true } ); /** * @author mrdoob / http://mrdoob.com/ * @author alteredq / http://alteredqualia.com/ * * parameters = { * color: , * opacity: , * * linewidth: , * linecap: \"round\", * linejoin: \"round\" * } */ function LineBasicMaterial( parameters ) { Material.call( this ); this.type = 'LineBasicMaterial'; this.color = new Color( 0xffffff ); this.linewidth = 1; this.linecap = 'round'; this.linejoin = 'round'; this.lights = false; this.setValues( parameters ); } LineBasicMaterial.prototype = Object.create( Material.prototype ); LineBasicMaterial.prototype.constructor = LineBasicMaterial; LineBasicMaterial.prototype.isLineBasicMaterial = true; LineBasicMaterial.prototype.copy = function ( source ) { Material.prototype.copy.call( this, source ); this.color.copy( source.color ); this.linewidth = source.linewidth; this.linecap = source.linecap; this.linejoin = source.linejoin; return this; }; /** * @author mrdoob / http://mrdoob.com/ */ function Line( geometry, material, mode ) { if ( mode === 1 ) { console.error( 'THREE.Line: parameter THREE.LinePieces no longer supported. Use THREE.LineSegments instead.' ); } Object3D.call( this ); this.type = 'Line'; this.geometry = geometry !== undefined ? geometry : new BufferGeometry(); this.material = material !== undefined ? material : new LineBasicMaterial( { color: Math.random() * 0xffffff } ); } Line.prototype = Object.assign( Object.create( Object3D.prototype ), { constructor: Line, isLine: true, computeLineDistances: ( function () { var start = new Vector3(); var end = new Vector3(); return function computeLineDistances() { var geometry = this.geometry; if ( geometry.isBufferGeometry ) { // we assume non-indexed geometry if ( geometry.index === null ) { var positionAttribute = geometry.attributes.position; var lineDistances = [ 0 ]; for ( var i = 1, l = positionAttribute.count; i < l; i ++ ) { start.fromBufferAttribute( positionAttribute, i - 1 ); end.fromBufferAttribute( positionAttribute, i ); lineDistances[ i ] = lineDistances[ i - 1 ]; lineDistances[ i ] += start.distanceTo( end ); } geometry.addAttribute( 'lineDistance', new Float32BufferAttribute( lineDistances, 1 ) ); } else { console.warn( 'THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.' ); } } else if ( geometry.isGeometry ) { var vertices = geometry.vertices; var lineDistances = geometry.lineDistances; lineDistances[ 0 ] = 0; for ( var i = 1, l = vertices.length; i < l; i ++ ) { lineDistances[ i ] = lineDistances[ i - 1 ]; lineDistances[ i ] += vertices[ i - 1 ].distanceTo( vertices[ i ] ); } } return this; }; }() ), raycast: ( function () { var inverseMatrix = new Matrix4(); var ray = new Ray(); var sphere = new Sphere(); return function raycast( raycaster, intersects ) { var precision = raycaster.linePrecision; var geometry = this.geometry; var matrixWorld = this.matrixWorld; // Checking boundingSphere distance to ray if ( geometry.boundingSphere === null ) geometry.computeBoundingSphere(); sphere.copy( geometry.boundingSphere ); sphere.applyMatrix4( matrixWorld ); sphere.radius += precision; if ( raycaster.ray.intersectsSphere( sphere ) === false ) return; // inverseMatrix.getInverse( matrixWorld ); ray.copy( raycaster.ray ).applyMatrix4( inverseMatrix ); var localPrecision = precision / ( ( this.scale.x + this.scale.y + this.scale.z ) / 3 ); var localPrecisionSq = localPrecision * localPrecision; var vStart = new Vector3(); var vEnd = new Vector3(); var interSegment = new Vector3(); var interRay = new Vector3(); var step = ( this && this.isLineSegments ) ? 2 : 1; if ( geometry.isBufferGeometry ) { var index = geometry.index; var attributes = geometry.attributes; var positions = attributes.position.array; if ( index !== null ) { var indices = index.array; for ( var i = 0, l = indices.length - 1; i < l; i += step ) { var a = indices[ i ]; var b = indices[ i + 1 ]; vStart.fromArray( positions, a * 3 ); vEnd.fromArray( positions, b * 3 ); var distSq = ray.distanceSqToSegment( vStart, vEnd, interRay, interSegment ); if ( distSq > localPrecisionSq ) continue; interRay.applyMatrix4( this.matrixWorld ); //Move back to world space for distance calculation var distance = raycaster.ray.origin.distanceTo( interRay ); if ( distance < raycaster.near || distance > raycaster.far ) continue; intersects.push( { distance: distance, // What do we want? intersection point on the ray or on the segment?? // point: raycaster.ray.at( distance ), point: interSegment.clone().applyMatrix4( this.matrixWorld ), index: i, face: null, faceIndex: null, object: this } ); } } else { for ( var i = 0, l = positions.length / 3 - 1; i < l; i += step ) { vStart.fromArray( positions, 3 * i ); vEnd.fromArray( positions, 3 * i + 3 ); var distSq = ray.distanceSqToSegment( vStart, vEnd, interRay, interSegment ); if ( distSq > localPrecisionSq ) continue; interRay.applyMatrix4( this.matrixWorld ); //Move back to world space for distance calculation var distance = raycaster.ray.origin.distanceTo( interRay ); if ( distance < raycaster.near || distance > raycaster.far ) continue; intersects.push( { distance: distance, // What do we want? intersection point on the ray or on the segment?? // point: raycaster.ray.at( distance ), point: interSegment.clone().applyMatrix4( this.matrixWorld ), index: i, face: null, faceIndex: null, object: this } ); } } } else if ( geometry.isGeometry ) { var vertices = geometry.vertices; var nbVertices = vertices.length; for ( var i = 0; i < nbVertices - 1; i += step ) { var distSq = ray.distanceSqToSegment( vertices[ i ], vertices[ i + 1 ], interRay, interSegment ); if ( distSq > localPrecisionSq ) continue; interRay.applyMatrix4( this.matrixWorld ); //Move back to world space for distance calculation var distance = raycaster.ray.origin.distanceTo( interRay ); if ( distance < raycaster.near || distance > raycaster.far ) continue; intersects.push( { distance: distance, // What do we want? intersection point on the ray or on the segment?? // point: raycaster.ray.at( distance ), point: interSegment.clone().applyMatrix4( this.matrixWorld ), index: i, face: null, faceIndex: null, object: this } ); } } }; }() ), copy: function ( source ) { Object3D.prototype.copy.call( this, source ); this.geometry.copy( source.geometry ); this.material.copy( source.material ); return this; }, clone: function () { return new this.constructor().copy( this ); } } ); /** * @author mrdoob / http://mrdoob.com/ */ function LineSegments( geometry, material ) { Line.call( this, geometry, material ); this.type = 'LineSegments'; } LineSegments.prototype = Object.assign( Object.create( Line.prototype ), { constructor: LineSegments, isLineSegments: true, computeLineDistances: ( function () { var start = new Vector3(); var end = new Vector3(); return function computeLineDistances() { var geometry = this.geometry; if ( geometry.isBufferGeometry ) { // we assume non-indexed geometry if ( geometry.index === null ) { var positionAttribute = geometry.attributes.position; var lineDistances = []; for ( var i = 0, l = positionAttribute.count; i < l; i += 2 ) { start.fromBufferAttribute( positionAttribute, i ); end.fromBufferAttribute( positionAttribute, i + 1 ); lineDistances[ i ] = ( i === 0 ) ? 0 : lineDistances[ i - 1 ]; lineDistances[ i + 1 ] = lineDistances[ i ] + start.distanceTo( end ); } geometry.addAttribute( 'lineDistance', new Float32BufferAttribute( lineDistances, 1 ) ); } else { console.warn( 'THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.' ); } } else if ( geometry.isGeometry ) { var vertices = geometry.vertices; var lineDistances = geometry.lineDistances; for ( var i = 0, l = vertices.length; i < l; i += 2 ) { start.copy( vertices[ i ] ); end.copy( vertices[ i + 1 ] ); lineDistances[ i ] = ( i === 0 ) ? 0 : lineDistances[ i - 1 ]; lineDistances[ i + 1 ] = lineDistances[ i ] + start.distanceTo( end ); } } return this; }; }() ) } ); /** * @author mgreter / http://github.com/mgreter */ function LineLoop( geometry, material ) { Line.call( this, geometry, material ); this.type = 'LineLoop'; } LineLoop.prototype = Object.assign( Object.create( Line.prototype ), { constructor: LineLoop, isLineLoop: true, } ); /** * @author mrdoob / http://mrdoob.com/ * @author alteredq / http://alteredqualia.com/ * * parameters = { * color: , * opacity: , * map: new THREE.Texture( ), * * size: , * sizeAttenuation: * * morphTargets: * } */ function PointsMaterial( parameters ) { Material.call( this ); this.type = 'PointsMaterial'; this.color = new Color( 0xffffff ); this.map = null; this.size = 1; this.sizeAttenuation = true; this.morphTargets = false; this.lights = false; this.setValues( parameters ); } PointsMaterial.prototype = Object.create( Material.prototype ); PointsMaterial.prototype.constructor = PointsMaterial; PointsMaterial.prototype.isPointsMaterial = true; PointsMaterial.prototype.copy = function ( source ) { Material.prototype.copy.call( this, source ); this.color.copy( source.color ); this.map = source.map; this.size = source.size; this.sizeAttenuation = source.sizeAttenuation; this.morphTargets = source.morphTargets; return this; }; /** * @author alteredq / http://alteredqualia.com/ */ function Points( geometry, material ) { Object3D.call( this ); this.type = 'Points'; this.geometry = geometry !== undefined ? geometry : new BufferGeometry(); this.material = material !== undefined ? material : new PointsMaterial( { color: Math.random() * 0xffffff } ); } Points.prototype = Object.assign( Object.create( Object3D.prototype ), { constructor: Points, isPoints: true, raycast: ( function () { var inverseMatrix = new Matrix4(); var ray = new Ray(); var sphere = new Sphere(); return function raycast( raycaster, intersects ) { var object = this; var geometry = this.geometry; var matrixWorld = this.matrixWorld; var threshold = raycaster.params.Points.threshold; // Checking boundingSphere distance to ray if ( geometry.boundingSphere === null ) geometry.computeBoundingSphere(); sphere.copy( geometry.boundingSphere ); sphere.applyMatrix4( matrixWorld ); sphere.radius += threshold; if ( raycaster.ray.intersectsSphere( sphere ) === false ) return; // inverseMatrix.getInverse( matrixWorld ); ray.copy( raycaster.ray ).applyMatrix4( inverseMatrix ); var localThreshold = threshold / ( ( this.scale.x + this.scale.y + this.scale.z ) / 3 ); var localThresholdSq = localThreshold * localThreshold; var position = new Vector3(); var intersectPoint = new Vector3(); function testPoint( point, index ) { var rayPointDistanceSq = ray.distanceSqToPoint( point ); if ( rayPointDistanceSq < localThresholdSq ) { ray.closestPointToPoint( point, intersectPoint ); intersectPoint.applyMatrix4( matrixWorld ); var distance = raycaster.ray.origin.distanceTo( intersectPoint ); if ( distance < raycaster.near || distance > raycaster.far ) return; intersects.push( { distance: distance, distanceToRay: Math.sqrt( rayPointDistanceSq ), point: intersectPoint.clone(), index: index, face: null, object: object } ); } } if ( geometry.isBufferGeometry ) { var index = geometry.index; var attributes = geometry.attributes; var positions = attributes.position.array; if ( index !== null ) { var indices = index.array; for ( var i = 0, il = indices.length; i < il; i ++ ) { var a = indices[ i ]; position.fromArray( positions, a * 3 ); testPoint( position, a ); } } else { for ( var i = 0, l = positions.length / 3; i < l; i ++ ) { position.fromArray( positions, i * 3 ); testPoint( position, i ); } } } else { var vertices = geometry.vertices; for ( var i = 0, l = vertices.length; i < l; i ++ ) { testPoint( vertices[ i ], i ); } } }; }() ), clone: function () { return new this.constructor( this.geometry, this.material ).copy( this ); } } ); /** * @author mrdoob / http://mrdoob.com/ */ function VideoTexture( video, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy ) { Texture.call( this, video, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy ); this.format = format !== undefined ? format : RGBFormat; this.minFilter = minFilter !== undefined ? minFilter : LinearFilter; this.magFilter = magFilter !== undefined ? magFilter : LinearFilter; this.generateMipmaps = false; } VideoTexture.prototype = Object.assign( Object.create( Texture.prototype ), { constructor: VideoTexture, isVideoTexture: true, update: function () { var video = this.image; if ( video.readyState >= video.HAVE_CURRENT_DATA ) { this.needsUpdate = true; } } } ); /** * @author alteredq / http://alteredqualia.com/ */ function CompressedTexture( mipmaps, width, height, format, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, encoding ) { Texture.call( this, null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding ); this.image = { width: width, height: height }; this.mipmaps = mipmaps; // no flipping for cube textures // (also flipping doesn't work for compressed textures ) this.flipY = false; // can't generate mipmaps for compressed textures // mips must be embedded in DDS files this.generateMipmaps = false; } CompressedTexture.prototype = Object.create( Texture.prototype ); CompressedTexture.prototype.constructor = CompressedTexture; CompressedTexture.prototype.isCompressedTexture = true; /** * @author mrdoob / http://mrdoob.com/ */ function CanvasTexture( canvas, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy ) { Texture.call( this, canvas, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy ); this.needsUpdate = true; } CanvasTexture.prototype = Object.create( Texture.prototype ); CanvasTexture.prototype.constructor = CanvasTexture; CanvasTexture.prototype.isCanvasTexture = true; /** * @author Matt DesLauriers / @mattdesl * @author atix / arthursilber.de */ function DepthTexture( width, height, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, format ) { format = format !== undefined ? format : DepthFormat; if ( format !== DepthFormat && format !== DepthStencilFormat ) { throw new Error( 'DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat' ); } if ( type === undefined && format === DepthFormat ) type = UnsignedShortType; if ( type === undefined && format === DepthStencilFormat ) type = UnsignedInt248Type; Texture.call( this, null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy ); this.image = { width: width, height: height }; this.magFilter = magFilter !== undefined ? magFilter : NearestFilter; this.minFilter = minFilter !== undefined ? minFilter : NearestFilter; this.flipY = false; this.generateMipmaps = false; } DepthTexture.prototype = Object.create( Texture.prototype ); DepthTexture.prototype.constructor = DepthTexture; DepthTexture.prototype.isDepthTexture = true; /** * @author mrdoob / http://mrdoob.com/ * @author Mugen87 / https://github.com/Mugen87 */ function WireframeGeometry( geometry ) { BufferGeometry.call( this ); this.type = 'WireframeGeometry'; // buffer var vertices = []; // helper variables var i, j, l, o, ol; var edge = [ 0, 0 ], edges = {}, e, edge1, edge2; var key, keys = [ 'a', 'b', 'c' ]; var vertex; // different logic for Geometry and BufferGeometry if ( geometry && geometry.isGeometry ) { // create a data structure that contains all edges without duplicates var faces = geometry.faces; for ( i = 0, l = faces.length; i < l; i ++ ) { var face = faces[ i ]; for ( j = 0; j < 3; j ++ ) { edge1 = face[ keys[ j ] ]; edge2 = face[ keys[ ( j + 1 ) % 3 ] ]; edge[ 0 ] = Math.min( edge1, edge2 ); // sorting prevents duplicates edge[ 1 ] = Math.max( edge1, edge2 ); key = edge[ 0 ] + ',' + edge[ 1 ]; if ( edges[ key ] === undefined ) { edges[ key ] = { index1: edge[ 0 ], index2: edge[ 1 ] }; } } } // generate vertices for ( key in edges ) { e = edges[ key ]; vertex = geometry.vertices[ e.index1 ]; vertices.push( vertex.x, vertex.y, vertex.z ); vertex = geometry.vertices[ e.index2 ]; vertices.push( vertex.x, vertex.y, vertex.z ); } } else if ( geometry && geometry.isBufferGeometry ) { var position, indices, groups; var group, start, count; var index1, index2; vertex = new Vector3(); if ( geometry.index !== null ) { // indexed BufferGeometry position = geometry.attributes.position; indices = geometry.index; groups = geometry.groups; if ( groups.length === 0 ) { groups = [ { start: 0, count: indices.count, materialIndex: 0 } ]; } // create a data structure that contains all eges without duplicates for ( o = 0, ol = groups.length; o < ol; ++ o ) { group = groups[ o ]; start = group.start; count = group.count; for ( i = start, l = ( start + count ); i < l; i += 3 ) { for ( j = 0; j < 3; j ++ ) { edge1 = indices.getX( i + j ); edge2 = indices.getX( i + ( j + 1 ) % 3 ); edge[ 0 ] = Math.min( edge1, edge2 ); // sorting prevents duplicates edge[ 1 ] = Math.max( edge1, edge2 ); key = edge[ 0 ] + ',' + edge[ 1 ]; if ( edges[ key ] === undefined ) { edges[ key ] = { index1: edge[ 0 ], index2: edge[ 1 ] }; } } } } // generate vertices for ( key in edges ) { e = edges[ key ]; vertex.fromBufferAttribute( position, e.index1 ); vertices.push( vertex.x, vertex.y, vertex.z ); vertex.fromBufferAttribute( position, e.index2 ); vertices.push( vertex.x, vertex.y, vertex.z ); } } else { // non-indexed BufferGeometry position = geometry.attributes.position; for ( i = 0, l = ( position.count / 3 ); i < l; i ++ ) { for ( j = 0; j < 3; j ++ ) { // three edges per triangle, an edge is represented as (index1, index2) // e.g. the first triangle has the following edges: (0,1),(1,2),(2,0) index1 = 3 * i + j; vertex.fromBufferAttribute( position, index1 ); vertices.push( vertex.x, vertex.y, vertex.z ); index2 = 3 * i + ( ( j + 1 ) % 3 ); vertex.fromBufferAttribute( position, index2 ); vertices.push( vertex.x, vertex.y, vertex.z ); } } } } // build geometry this.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) ); } WireframeGeometry.prototype = Object.create( BufferGeometry.prototype ); WireframeGeometry.prototype.constructor = WireframeGeometry; /** * @author zz85 / https://github.com/zz85 * @author Mugen87 / https://github.com/Mugen87 * * Parametric Surfaces Geometry * based on the brilliant article by @prideout http://prideout.net/blog/?p=44 */ // ParametricGeometry function ParametricGeometry( func, slices, stacks ) { Geometry.call( this ); this.type = 'ParametricGeometry'; this.parameters = { func: func, slices: slices, stacks: stacks }; this.fromBufferGeometry( new ParametricBufferGeometry( func, slices, stacks ) ); this.mergeVertices(); } ParametricGeometry.prototype = Object.create( Geometry.prototype ); ParametricGeometry.prototype.constructor = ParametricGeometry; // ParametricBufferGeometry function ParametricBufferGeometry( func, slices, stacks ) { BufferGeometry.call( this ); this.type = 'ParametricBufferGeometry'; this.parameters = { func: func, slices: slices, stacks: stacks }; // buffers var indices = []; var vertices = []; var normals = []; var uvs = []; var EPS = 0.00001; var normal = new Vector3(); var p0 = new Vector3(), p1 = new Vector3(); var pu = new Vector3(), pv = new Vector3(); var i, j; if ( func.length < 3 ) { console.error( 'THREE.ParametricGeometry: Function must now modify a Vector3 as third parameter.' ); } // generate vertices, normals and uvs var sliceCount = slices + 1; for ( i = 0; i = 0 ) { func( u, v - EPS, p1 ); pv.subVectors( p0, p1 ); } else { func( u, v + EPS, p1 ); pv.subVectors( p1, p0 ); } // cross product of tangent vectors returns surface normal normal.crossVectors( pu, pv ).normalize(); normals.push( normal.x, normal.y, normal.z ); // uv uvs.push( u, v ); } } // generate indices for ( i = 0; i < stacks; i ++ ) { for ( j = 0; j < slices; j ++ ) { var a = i * sliceCount + j; var b = i * sliceCount + j + 1; var c = ( i + 1 ) * sliceCount + j + 1; var d = ( i + 1 ) * sliceCount + j; // faces one and two indices.push( a, b, d ); indices.push( b, c, d ); } } // build geometry this.setIndex( indices ); this.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) ); this.addAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) ); this.addAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) ); } ParametricBufferGeometry.prototype = Object.create( BufferGeometry.prototype ); ParametricBufferGeometry.prototype.constructor = ParametricBufferGeometry; /** * @author clockworkgeek / https://github.com/clockworkgeek * @author timothypratley / https://github.com/timothypratley * @author WestLangley / http://github.com/WestLangley * @author Mugen87 / https://github.com/Mugen87 */ // PolyhedronGeometry function PolyhedronGeometry( vertices, indices, radius, detail ) { Geometry.call( this ); this.type = 'PolyhedronGeometry'; this.parameters = { vertices: vertices, indices: indices, radius: radius, detail: detail }; this.fromBufferGeometry( new PolyhedronBufferGeometry( vertices, indices, radius, detail ) ); this.mergeVertices(); } PolyhedronGeometry.prototype = Object.create( Geometry.prototype ); PolyhedronGeometry.prototype.constructor = PolyhedronGeometry; // PolyhedronBufferGeometry function PolyhedronBufferGeometry( vertices, indices, radius, detail ) { BufferGeometry.call( this ); this.type = 'PolyhedronBufferGeometry'; this.parameters = { vertices: vertices, indices: indices, radius: radius, detail: detail }; radius = radius || 1; detail = detail || 0; // default buffer data var vertexBuffer = []; var uvBuffer = []; // the subdivision creates the vertex buffer data subdivide( detail ); // all vertices should lie on a conceptual sphere with a given radius appplyRadius( radius ); // finally, create the uv data generateUVs(); // build non-indexed geometry this.addAttribute( 'position', new Float32BufferAttribute( vertexBuffer, 3 ) ); this.addAttribute( 'normal', new Float32BufferAttribute( vertexBuffer.slice(), 3 ) ); this.addAttribute( 'uv', new Float32BufferAttribute( uvBuffer, 2 ) ); if ( detail === 0 ) { this.computeVertexNormals(); // flat normals } else { this.normalizeNormals(); // smooth normals } // helper functions function subdivide( detail ) { var a = new Vector3(); var b = new Vector3(); var c = new Vector3(); // iterate over all faces and apply a subdivison with the given detail value for ( var i = 0; i < indices.length; i += 3 ) { // get the vertices of the face getVertexByIndex( indices[ i + 0 ], a ); getVertexByIndex( indices[ i + 1 ], b ); getVertexByIndex( indices[ i + 2 ], c ); // perform subdivision subdivideFace( a, b, c, detail ); } } function subdivideFace( a, b, c, detail ) { var cols = Math.pow( 2, detail ); // we use this multidimensional array as a data structure for creating the subdivision var v = []; var i, j; // construct all of the vertices for this subdivision for ( i = 0; i maxY ) maxY = y; } // minX, minY and invSize are later used to transform coords into integers for z-order calculation invSize = Math.max( maxX - minX, maxY - minY ); invSize = invSize !== 0 ? 1 / invSize : 0; } earcutLinked( outerNode, triangles, dim, minX, minY, invSize ); return triangles; } }; // create a circular doubly linked list from polygon points in the specified winding order function linkedList( data, start, end, dim, clockwise ) { var i, last; if ( clockwise === ( signedArea( data, start, end, dim ) > 0 ) ) { for ( i = start; i < end; i += dim ) last = insertNode( i, data[ i ], data[ i + 1 ], last ); } else { for ( i = end - dim; i >= start; i -= dim ) last = insertNode( i, data[ i ], data[ i + 1 ], last ); } if ( last && equals( last, last.next ) ) { removeNode( last ); last = last.next; } return last; } // eliminate colinear or duplicate points function filterPoints( start, end ) { if ( ! start ) return start; if ( ! end ) end = start; var p = start, again; do { again = false; if ( ! p.steiner && ( equals( p, p.next ) || area( p.prev, p, p.next ) === 0 ) ) { removeNode( p ); p = end = p.prev; if ( p === p.next ) break; again = true; } else { p = p.next; } } while ( again || p !== end ); return end; } // main ear slicing loop which triangulates a polygon (given as a linked list) function earcutLinked( ear, triangles, dim, minX, minY, invSize, pass ) { if ( ! ear ) return; // interlink polygon nodes in z-order if ( ! pass && invSize ) indexCurve( ear, minX, minY, invSize ); var stop = ear, prev, next; // iterate through ears, slicing them one by one while ( ear.prev !== ear.next ) { prev = ear.prev; next = ear.next; if ( invSize ? isEarHashed( ear, minX, minY, invSize ) : isEar( ear ) ) { // cut off the triangle triangles.push( prev.i / dim ); triangles.push( ear.i / dim ); triangles.push( next.i / dim ); removeNode( ear ); // skipping the next vertice leads to less sliver triangles ear = next.next; stop = next.next; continue; } ear = next; // if we looped through the whole remaining polygon and can't find any more ears if ( ear === stop ) { // try filtering points and slicing again if ( ! pass ) { earcutLinked( filterPoints( ear ), triangles, dim, minX, minY, invSize, 1 ); // if this didn't work, try curing all small self-intersections locally } else if ( pass === 1 ) { ear = cureLocalIntersections( ear, triangles, dim ); earcutLinked( ear, triangles, dim, minX, minY, invSize, 2 ); // as a last resort, try splitting the remaining polygon into two } else if ( pass === 2 ) { splitEarcut( ear, triangles, dim, minX, minY, invSize ); } break; } } } // check whether a polygon node forms a valid ear with adjacent nodes function isEar( ear ) { var a = ear.prev, b = ear, c = ear.next; if ( area( a, b, c ) >= 0 ) return false; // reflex, can't be an ear // now make sure we don't have other points inside the potential ear var p = ear.next.next; while ( p !== ear.prev ) { if ( pointInTriangle( a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y ) && area( p.prev, p, p.next ) >= 0 ) { return false; } p = p.next; } return true; } function isEarHashed( ear, minX, minY, invSize ) { var a = ear.prev, b = ear, c = ear.next; if ( area( a, b, c ) >= 0 ) return false; // reflex, can't be an ear // triangle bbox; min & max are calculated like this for speed var minTX = a.x < b.x ? ( a.x < c.x ? a.x : c.x ) : ( b.x < c.x ? b.x : c.x ), minTY = a.y < b.y ? ( a.y < c.y ? a.y : c.y ) : ( b.y < c.y ? b.y : c.y ), maxTX = a.x > b.x ? ( a.x > c.x ? a.x : c.x ) : ( b.x > c.x ? b.x : c.x ), maxTY = a.y > b.y ? ( a.y > c.y ? a.y : c.y ) : ( b.y > c.y ? b.y : c.y ); // z-order range for the current triangle bbox; var minZ = zOrder( minTX, minTY, minX, minY, invSize ), maxZ = zOrder( maxTX, maxTY, minX, minY, invSize ); // first look for points inside the triangle in increasing z-order var p = ear.nextZ; while ( p && p.z = 0 ) return false; p = p.nextZ; } // then look for points in decreasing z-order p = ear.prevZ; while ( p && p.z >= minZ ) { if ( p !== ear.prev && p !== ear.next && pointInTriangle( a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y ) && area( p.prev, p, p.next ) >= 0 ) return false; p = p.prevZ; } return true; } // go through all polygon nodes and cure small local self-intersections function cureLocalIntersections( start, triangles, dim ) { var p = start; do { var a = p.prev, b = p.next.next; if ( ! equals( a, b ) && intersects( a, p, p.next, b ) && locallyInside( a, b ) && locallyInside( b, a ) ) { triangles.push( a.i / dim ); triangles.push( p.i / dim ); triangles.push( b.i / dim ); // remove two nodes involved removeNode( p ); removeNode( p.next ); p = start = b; } p = p.next; } while ( p !== start ); return p; } // try splitting polygon into two and triangulate them independently function splitEarcut( start, triangles, dim, minX, minY, invSize ) { // look for a valid diagonal that divides the polygon into two var a = start; do { var b = a.next.next; while ( b !== a.prev ) { if ( a.i !== b.i && isValidDiagonal( a, b ) ) { // split the polygon in two by the diagonal var c = splitPolygon( a, b ); // filter colinear points around the cuts a = filterPoints( a, a.next ); c = filterPoints( c, c.next ); // run earcut on each half earcutLinked( a, triangles, dim, minX, minY, invSize ); earcutLinked( c, triangles, dim, minX, minY, invSize ); return; } b = b.next; } a = a.next; } while ( a !== start ); } // link every hole into the outer loop, producing a single-ring polygon without holes function eliminateHoles( data, holeIndices, outerNode, dim ) { var queue = [], i, len, start, end, list; for ( i = 0, len = holeIndices.length; i < len; i ++ ) { start = holeIndices[ i ] * dim; end = i < len - 1 ? holeIndices[ i + 1 ] * dim : data.length; list = linkedList( data, start, end, dim, false ); if ( list === list.next ) list.steiner = true; queue.push( getLeftmost( list ) ); } queue.sort( compareX ); // process holes from left to right for ( i = 0; i < queue.length; i ++ ) { eliminateHole( queue[ i ], outerNode ); outerNode = filterPoints( outerNode, outerNode.next ); } return outerNode; } function compareX( a, b ) { return a.x - b.x; } // find a bridge between vertices that connects hole with an outer ring and and link it function eliminateHole( hole, outerNode ) { outerNode = findHoleBridge( hole, outerNode ); if ( outerNode ) { var b = splitPolygon( outerNode, hole ); filterPoints( b, b.next ); } } // David Eberly's algorithm for finding a bridge between hole and outer polygon function findHoleBridge( hole, outerNode ) { var p = outerNode, hx = hole.x, hy = hole.y, qx = - Infinity, m; // find a segment intersected by a ray from the hole's leftmost point to the left; // segment's endpoint with lesser x will be potential connection point do { if ( hy = p.next.y && p.next.y !== p.y ) { var x = p.x + ( hy - p.y ) * ( p.next.x - p.x ) / ( p.next.y - p.y ); if ( x qx ) { qx = x; if ( x === hx ) { if ( hy === p.y ) return p; if ( hy === p.next.y ) return p.next; } m = p.x < p.next.x ? p : p.next; } } p = p.next; } while ( p !== outerNode ); if ( ! m ) return null; if ( hx === qx ) return m.prev; // hole touches outer segment; pick lower endpoint // look for points inside the triangle of hole point, segment intersection and endpoint; // if there are no points found, we have a valid connection; // otherwise choose the point of the minimum angle with the ray as connection point var stop = m, mx = m.x, my = m.y, tanMin = Infinity, tan; p = m.next; while ( p !== stop ) { if ( hx >= p.x && p.x >= mx && hx !== p.x && pointInTriangle( hy < my ? hx : qx, hy, mx, my, hy < my ? qx : hx, hy, p.x, p.y ) ) { tan = Math.abs( hy - p.y ) / ( hx - p.x ); // tangential if ( ( tan < tanMin || ( tan === tanMin && p.x > m.x ) ) && locallyInside( p, hole ) ) { m = p; tanMin = tan; } } p = p.next; } return m; } // interlink polygon nodes in z-order function indexCurve( start, minX, minY, invSize ) { var p = start; do { if ( p.z === null ) p.z = zOrder( p.x, p.y, minX, minY, invSize ); p.prevZ = p.prev; p.nextZ = p.next; p = p.next; } while ( p !== start ); p.prevZ.nextZ = null; p.prevZ = null; sortLinked( p ); } // Simon Tatham's linked list merge sort algorithm // http://www.chiark.greenend.org.uk/~sgtatham/algorithms/listsort.html function sortLinked( list ) { var i, p, q, e, tail, numMerges, pSize, qSize, inSize = 1; do { p = list; list = null; tail = null; numMerges = 0; while ( p ) { numMerges ++; q = p; pSize = 0; for ( i = 0; i < inSize; i ++ ) { pSize ++; q = q.nextZ; if ( ! q ) break; } qSize = inSize; while ( pSize > 0 || ( qSize > 0 && q ) ) { if ( pSize !== 0 && ( qSize === 0 || ! q || p.z 1 ); return list; } // z-order of a point given coords and inverse of the longer side of data bbox function zOrder( x, y, minX, minY, invSize ) { // coords are transformed into non-negative 15-bit integer range x = 32767 * ( x - minX ) * invSize; y = 32767 * ( y - minY ) * invSize; x = ( x | ( x = 0 : area( a, b, a.prev ) < 0 || area( a, a.next, b ) < 0; } // check if the middle point of a polygon diagonal is inside the polygon function middleInside( a, b ) { var p = a, inside = false, px = ( a.x + b.x ) / 2, py = ( a.y + b.y ) / 2; do { if ( ( ( p.y > py ) !== ( p.next.y > py ) ) && p.next.y !== p.y && ( px < ( p.next.x - p.x ) * ( py - p.y ) / ( p.next.y - p.y ) + p.x ) ) { inside = ! inside; } p = p.next; } while ( p !== a ); return inside; } // link two polygon vertices with a bridge; if the vertices belong to the same ring, it splits polygon into two; // if one belongs to the outer ring and another to a hole, it merges it into a single ring function splitPolygon( a, b ) { var a2 = new Node( a.i, a.x, a.y ), b2 = new Node( b.i, b.x, b.y ), an = a.next, bp = b.prev; a.next = b; b.prev = a; a2.next = an; an.prev = a2; b2.next = a2; a2.prev = b2; bp.next = b2; b2.prev = bp; return b2; } // create a node and optionally link it with previous one (in a circular doubly linked list) function insertNode( i, x, y, last ) { var p = new Node( i, x, y ); if ( ! last ) { p.prev = p; p.next = p; } else { p.next = last.next; p.prev = last; last.next.prev = p; last.next = p; } return p; } function removeNode( p ) { p.next.prev = p.prev; p.prev.next = p.next; if ( p.prevZ ) p.prevZ.nextZ = p.nextZ; if ( p.nextZ ) p.nextZ.prevZ = p.prevZ; } function Node( i, x, y ) { // vertice index in coordinates array this.i = i; // vertex coordinates this.x = x; this.y = y; // previous and next vertice nodes in a polygon ring this.prev = null; this.next = null; // z-order curve value this.z = null; // previous and next nodes in z-order this.prevZ = null; this.nextZ = null; // indicates whether this is a steiner point this.steiner = false; } function signedArea( data, start, end, dim ) { var sum = 0; for ( var i = start, j = end - dim; i < end; i += dim ) { sum += ( data[ j ] - data[ i ] ) * ( data[ i + 1 ] + data[ j + 1 ] ); j = i; } return sum; } /** * @author zz85 / http://www.lab4games.net/zz85/blog */ var ShapeUtils = { // calculate area of the contour polygon area: function ( contour ) { var n = contour.length; var a = 0.0; for ( var p = n - 1, q = 0; q < n; p = q ++ ) { a += contour[ p ].x * contour[ q ].y - contour[ q ].x * contour[ p ].y; } return a * 0.5; }, isClockWise: function ( pts ) { return ShapeUtils.area( pts ) < 0; }, triangulateShape: function ( contour, holes ) { var vertices = []; // flat array of vertices like [ x0,y0, x1,y1, x2,y2, ... ] var holeIndices = []; // array of hole indices var faces = []; // final array of vertex indices like [ [ a,b,d ], [ b,c,d ] ] removeDupEndPts( contour ); addContour( vertices, contour ); // var holeIndex = contour.length; holes.forEach( removeDupEndPts ); for ( var i = 0; i < holes.length; i ++ ) { holeIndices.push( holeIndex ); holeIndex += holes[ i ].length; addContour( vertices, holes[ i ] ); } // var triangles = Earcut.triangulate( vertices, holeIndices ); // for ( var i = 0; i < triangles.length; i += 3 ) { faces.push( triangles.slice( i, i + 3 ) ); } return faces; } }; function removeDupEndPts( points ) { var l = points.length; if ( l > 2 && points[ l - 1 ].equals( points[ 0 ] ) ) { points.pop(); } } function addContour( vertices, contour ) { for ( var i = 0; i < contour.length; i ++ ) { vertices.push( contour[ i ].x ); vertices.push( contour[ i ].y ); } } /** * @author zz85 / http://www.lab4games.net/zz85/blog * * Creates extruded geometry from a path shape. * * parameters = { * * curveSegments: , // number of points on the curves * steps: , // number of points for z-side extrusions / used for subdividing segments of extrude spline too * depth: , // Depth to extrude the shape * * bevelEnabled: , // turn on bevel * bevelThickness: , // how deep into the original shape bevel goes * bevelSize: , // how far from shape outline is bevel * bevelSegments: , // number of bevel layers * * extrudePath: // curve to extrude shape along * * UVGenerator: // object that provides UV generator functions * * } */ // ExtrudeGeometry function ExtrudeGeometry( shapes, options ) { Geometry.call( this ); this.type = 'ExtrudeGeometry'; this.parameters = { shapes: shapes, options: options }; this.fromBufferGeometry( new ExtrudeBufferGeometry( shapes, options ) ); this.mergeVertices(); } ExtrudeGeometry.prototype = Object.create( Geometry.prototype ); ExtrudeGeometry.prototype.constructor = ExtrudeGeometry; ExtrudeGeometry.prototype.toJSON = function () { var data = Geometry.prototype.toJSON.call( this ); var shapes = this.parameters.shapes; var options = this.parameters.options; return toJSON( shapes, options, data ); }; // ExtrudeBufferGeometry function ExtrudeBufferGeometry( shapes, options ) { BufferGeometry.call( this ); this.type = 'ExtrudeBufferGeometry'; this.parameters = { shapes: shapes, options: options }; shapes = Array.isArray( shapes ) ? shapes : [ shapes ]; var scope = this; var verticesArray = []; var uvArray = []; for ( var i = 0, l = shapes.length; i < l; i ++ ) { var shape = shapes[ i ]; addShape( shape ); } // build geometry this.addAttribute( 'position', new Float32BufferAttribute( verticesArray, 3 ) ); this.addAttribute( 'uv', new Float32BufferAttribute( uvArray, 2 ) ); this.computeVertexNormals(); // functions function addShape( shape ) { var placeholder = []; // options var curveSegments = options.curveSegments !== undefined ? options.curveSegments : 12; var steps = options.steps !== undefined ? options.steps : 1; var depth = options.depth !== undefined ? options.depth : 100; var bevelEnabled = options.bevelEnabled !== undefined ? options.bevelEnabled : true; var bevelThickness = options.bevelThickness !== undefined ? options.bevelThickness : 6; var bevelSize = options.bevelSize !== undefined ? options.bevelSize : bevelThickness - 2; var bevelSegments = options.bevelSegments !== undefined ? options.bevelSegments : 3; var extrudePath = options.extrudePath; var uvgen = options.UVGenerator !== undefined ? options.UVGenerator : WorldUVGenerator; // deprecated options if ( options.amount !== undefined ) { console.warn( 'THREE.ExtrudeBufferGeometry: amount has been renamed to depth.' ); depth = options.amount; } // var extrudePts, extrudeByPath = false; var splineTube, binormal, normal, position2; if ( extrudePath ) { extrudePts = extrudePath.getSpacedPoints( steps ); extrudeByPath = true; bevelEnabled = false; // bevels not supported for path extrusion // SETUP TNB variables // TODO1 - have a .isClosed in spline? splineTube = extrudePath.computeFrenetFrames( steps, false ); // console.log(splineTube, 'splineTube', splineTube.normals.length, 'steps', steps, 'extrudePts', extrudePts.length); binormal = new Vector3(); normal = new Vector3(); position2 = new Vector3(); } // Safeguards if bevels are not enabled if ( ! bevelEnabled ) { bevelSegments = 0; bevelThickness = 0; bevelSize = 0; } // Variables initialization var ahole, h, hl; // looping of holes var shapePoints = shape.extractPoints( curveSegments ); var vertices = shapePoints.shape; var holes = shapePoints.holes; var reverse = ! ShapeUtils.isClockWise( vertices ); if ( reverse ) { vertices = vertices.reverse(); // Maybe we should also check if holes are in the opposite direction, just to be safe ... for ( h = 0, hl = holes.length; h < hl; h ++ ) { ahole = holes[ h ]; if ( ShapeUtils.isClockWise( ahole ) ) { holes[ h ] = ahole.reverse(); } } } var faces = ShapeUtils.triangulateShape( vertices, holes ); /* Vertices */ var contour = vertices; // vertices has all points but contour has only points of circumference for ( h = 0, hl = holes.length; h < hl; h ++ ) { ahole = holes[ h ]; vertices = vertices.concat( ahole ); } function scalePt2( pt, vec, size ) { if ( ! vec ) console.error( \"THREE.ExtrudeGeometry: vec does not exist\" ); return vec.clone().multiplyScalar( size ).add( pt ); } var b, bs, t, z, vert, vlen = vertices.length, face, flen = faces.length; // Find directions for point movement function getBevelVec( inPt, inPrev, inNext ) { // computes for inPt the corresponding point inPt' on a new contour // shifted by 1 unit (length of normalized vector) to the left // if we walk along contour clockwise, this new contour is outside the old one // // inPt' is the intersection of the two lines parallel to the two // adjacent edges of inPt at a distance of 1 unit on the left side. var v_trans_x, v_trans_y, shrink_by; // resulting translation vector for inPt // good reading for geometry algorithms (here: line-line intersection) // http://geomalgorithms.com/a05-_intersect-1.html var v_prev_x = inPt.x - inPrev.x, v_prev_y = inPt.y - inPrev.y; var v_next_x = inNext.x - inPt.x, v_next_y = inNext.y - inPt.y; var v_prev_lensq = ( v_prev_x * v_prev_x + v_prev_y * v_prev_y ); // check for collinear edges var collinear0 = ( v_prev_x * v_next_y - v_prev_y * v_next_x ); if ( Math.abs( collinear0 ) > Number.EPSILON ) { // not collinear // length of vectors for normalizing var v_prev_len = Math.sqrt( v_prev_lensq ); var v_next_len = Math.sqrt( v_next_x * v_next_x + v_next_y * v_next_y ); // shift adjacent points by unit vectors to the left var ptPrevShift_x = ( inPrev.x - v_prev_y / v_prev_len ); var ptPrevShift_y = ( inPrev.y + v_prev_x / v_prev_len ); var ptNextShift_x = ( inNext.x - v_next_y / v_next_len ); var ptNextShift_y = ( inNext.y + v_next_x / v_next_len ); // scaling factor for v_prev to intersection point var sf = ( ( ptNextShift_x - ptPrevShift_x ) * v_next_y - ( ptNextShift_y - ptPrevShift_y ) * v_next_x ) / ( v_prev_x * v_next_y - v_prev_y * v_next_x ); // vector from inPt to intersection point v_trans_x = ( ptPrevShift_x + v_prev_x * sf - inPt.x ); v_trans_y = ( ptPrevShift_y + v_prev_y * sf - inPt.y ); // Don't normalize!, otherwise sharp corners become ugly // but prevent crazy spikes var v_trans_lensq = ( v_trans_x * v_trans_x + v_trans_y * v_trans_y ); if ( v_trans_lensq Number.EPSILON ) { if ( v_next_x > Number.EPSILON ) { direction_eq = true; } } else { if ( v_prev_x < - Number.EPSILON ) { if ( v_next_x < - Number.EPSILON ) { direction_eq = true; } } else { if ( Math.sign( v_prev_y ) === Math.sign( v_next_y ) ) { direction_eq = true; } } } if ( direction_eq ) { // console.log(\"Warning: lines are a straight sequence\"); v_trans_x = - v_prev_y; v_trans_y = v_prev_x; shrink_by = Math.sqrt( v_prev_lensq ); } else { // console.log(\"Warning: lines are a straight spike\"); v_trans_x = v_prev_x; v_trans_y = v_prev_y; shrink_by = Math.sqrt( v_prev_lensq / 2 ); } } return new Vector2( v_trans_x / shrink_by, v_trans_y / shrink_by ); } var contourMovements = []; for ( var i = 0, il = contour.length, j = il - 1, k = i + 1; i < il; i ++, j ++, k ++ ) { if ( j === il ) j = 0; if ( k === il ) k = 0; // (j)---(i)---(k) // console.log('i,j,k', i, j , k) contourMovements[ i ] = getBevelVec( contour[ i ], contour[ j ], contour[ k ] ); } var holesMovements = [], oneHoleMovements, verticesMovements = contourMovements.concat(); for ( h = 0, hl = holes.length; h < hl; h ++ ) { ahole = holes[ h ]; oneHoleMovements = []; for ( i = 0, il = ahole.length, j = il - 1, k = i + 1; i < il; i ++, j ++, k ++ ) { if ( j === il ) j = 0; if ( k === il ) k = 0; // (j)---(i)---(k) oneHoleMovements[ i ] = getBevelVec( ahole[ i ], ahole[ j ], ahole[ k ] ); } holesMovements.push( oneHoleMovements ); verticesMovements = verticesMovements.concat( oneHoleMovements ); } // Loop bevelSegments, 1 for the front, 1 for the back for ( b = 0; b < bevelSegments; b ++ ) { //for ( b = bevelSegments; b > 0; b -- ) { t = b / bevelSegments; z = bevelThickness * Math.cos( t * Math.PI / 2 ); bs = bevelSize * Math.sin( t * Math.PI / 2 ); // contract shape for ( i = 0, il = contour.length; i < il; i ++ ) { vert = scalePt2( contour[ i ], contourMovements[ i ], bs ); v( vert.x, vert.y, - z ); } // expand holes for ( h = 0, hl = holes.length; h < hl; h ++ ) { ahole = holes[ h ]; oneHoleMovements = holesMovements[ h ]; for ( i = 0, il = ahole.length; i < il; i ++ ) { vert = scalePt2( ahole[ i ], oneHoleMovements[ i ], bs ); v( vert.x, vert.y, - z ); } } } bs = bevelSize; // Back facing vertices for ( i = 0; i < vlen; i ++ ) { vert = bevelEnabled ? scalePt2( vertices[ i ], verticesMovements[ i ], bs ) : vertices[ i ]; if ( ! extrudeByPath ) { v( vert.x, vert.y, 0 ); } else { // v( vert.x, vert.y + extrudePts[ 0 ].y, extrudePts[ 0 ].x ); normal.copy( splineTube.normals[ 0 ] ).multiplyScalar( vert.x ); binormal.copy( splineTube.binormals[ 0 ] ).multiplyScalar( vert.y ); position2.copy( extrudePts[ 0 ] ).add( normal ).add( binormal ); v( position2.x, position2.y, position2.z ); } } // Add stepped vertices... // Including front facing vertices var s; for ( s = 1; s = 0 ) { j = i; k = i - 1; if ( k < 0 ) k = contour.length - 1; //console.log('b', i,j, i-1, k,vertices.length); var s = 0, sl = steps + bevelSegments * 2; for ( s = 0; s < sl; s ++ ) { var slen1 = vlen * s; var slen2 = vlen * ( s + 1 ); var a = layeroffset + j + slen1, b = layeroffset + k + slen1, c = layeroffset + k + slen2, d = layeroffset + j + slen2; f4( a, b, c, d ); } } } function v( x, y, z ) { placeholder.push( x ); placeholder.push( y ); placeholder.push( z ); } function f3( a, b, c ) { addVertex( a ); addVertex( b ); addVertex( c ); var nextIndex = verticesArray.length / 3; var uvs = uvgen.generateTopUV( scope, verticesArray, nextIndex - 3, nextIndex - 2, nextIndex - 1 ); addUV( uvs[ 0 ] ); addUV( uvs[ 1 ] ); addUV( uvs[ 2 ] ); } function f4( a, b, c, d ) { addVertex( a ); addVertex( b ); addVertex( d ); addVertex( b ); addVertex( c ); addVertex( d ); var nextIndex = verticesArray.length / 3; var uvs = uvgen.generateSideWallUV( scope, verticesArray, nextIndex - 6, nextIndex - 3, nextIndex - 2, nextIndex - 1 ); addUV( uvs[ 0 ] ); addUV( uvs[ 1 ] ); addUV( uvs[ 3 ] ); addUV( uvs[ 1 ] ); addUV( uvs[ 2 ] ); addUV( uvs[ 3 ] ); } function addVertex( index ) { verticesArray.push( placeholder[ index * 3 + 0 ] ); verticesArray.push( placeholder[ index * 3 + 1 ] ); verticesArray.push( placeholder[ index * 3 + 2 ] ); } function addUV( vector2 ) { uvArray.push( vector2.x ); uvArray.push( vector2.y ); } } } ExtrudeBufferGeometry.prototype = Object.create( BufferGeometry.prototype ); ExtrudeBufferGeometry.prototype.constructor = ExtrudeBufferGeometry; ExtrudeBufferGeometry.prototype.toJSON = function () { var data = BufferGeometry.prototype.toJSON.call( this ); var shapes = this.parameters.shapes; var options = this.parameters.options; return toJSON( shapes, options, data ); }; // var WorldUVGenerator = { generateTopUV: function ( geometry, vertices, indexA, indexB, indexC ) { var a_x = vertices[ indexA * 3 ]; var a_y = vertices[ indexA * 3 + 1 ]; var b_x = vertices[ indexB * 3 ]; var b_y = vertices[ indexB * 3 + 1 ]; var c_x = vertices[ indexC * 3 ]; var c_y = vertices[ indexC * 3 + 1 ]; return [ new Vector2( a_x, a_y ), new Vector2( b_x, b_y ), new Vector2( c_x, c_y ) ]; }, generateSideWallUV: function ( geometry, vertices, indexA, indexB, indexC, indexD ) { var a_x = vertices[ indexA * 3 ]; var a_y = vertices[ indexA * 3 + 1 ]; var a_z = vertices[ indexA * 3 + 2 ]; var b_x = vertices[ indexB * 3 ]; var b_y = vertices[ indexB * 3 + 1 ]; var b_z = vertices[ indexB * 3 + 2 ]; var c_x = vertices[ indexC * 3 ]; var c_y = vertices[ indexC * 3 + 1 ]; var c_z = vertices[ indexC * 3 + 2 ]; var d_x = vertices[ indexD * 3 ]; var d_y = vertices[ indexD * 3 + 1 ]; var d_z = vertices[ indexD * 3 + 2 ]; if ( Math.abs( a_y - b_y ) < 0.01 ) { return [ new Vector2( a_x, 1 - a_z ), new Vector2( b_x, 1 - b_z ), new Vector2( c_x, 1 - c_z ), new Vector2( d_x, 1 - d_z ) ]; } else { return [ new Vector2( a_y, 1 - a_z ), new Vector2( b_y, 1 - b_z ), new Vector2( c_y, 1 - c_z ), new Vector2( d_y, 1 - d_z ) ]; } } }; function toJSON( shapes, options, data ) { // data.shapes = []; if ( Array.isArray( shapes ) ) { for ( var i = 0, l = shapes.length; i < l; i ++ ) { var shape = shapes[ i ]; data.shapes.push( shape.uuid ); } } else { data.shapes.push( shapes.uuid ); } // if ( options.extrudePath !== undefined ) data.options.extrudePath = options.extrudePath.toJSON(); return data; } /** * @author zz85 / http://www.lab4games.net/zz85/blog * @author alteredq / http://alteredqualia.com/ * * Text = 3D Text * * parameters = { * font: , // font * * size: , // size of the text * height: , // thickness to extrude text * curveSegments: , // number of points on the curves * * bevelEnabled: , // turn on bevel * bevelThickness: , // how deep into text bevel goes * bevelSize: // how far from text outline is bevel * } */ // TextGeometry function TextGeometry( text, parameters ) { Geometry.call( this ); this.type = 'TextGeometry'; this.parameters = { text: text, parameters: parameters }; this.fromBufferGeometry( new TextBufferGeometry( text, parameters ) ); this.mergeVertices(); } TextGeometry.prototype = Object.create( Geometry.prototype ); TextGeometry.prototype.constructor = TextGeometry; // TextBufferGeometry function TextBufferGeometry( text, parameters ) { parameters = parameters || {}; var font = parameters.font; if ( ! ( font && font.isFont ) ) { console.error( 'THREE.TextGeometry: font parameter is not an instance of THREE.Font.' ); return new Geometry(); } var shapes = font.generateShapes( text, parameters.size ); // translate parameters to ExtrudeGeometry API parameters.depth = parameters.height !== undefined ? parameters.height : 50; // defaults if ( parameters.bevelThickness === undefined ) parameters.bevelThickness = 10; if ( parameters.bevelSize === undefined ) parameters.bevelSize = 8; if ( parameters.bevelEnabled === undefined ) parameters.bevelEnabled = false; ExtrudeBufferGeometry.call( this, shapes, parameters ); this.type = 'TextBufferGeometry'; } TextBufferGeometry.prototype = Object.create( ExtrudeBufferGeometry.prototype ); TextBufferGeometry.prototype.constructor = TextBufferGeometry; /** * @author mrdoob / http://mrdoob.com/ * @author benaadams / https://twitter.com/ben_a_adams * @author Mugen87 / https://github.com/Mugen87 */ // SphereGeometry function SphereGeometry( radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength ) { Geometry.call( this ); this.type = 'SphereGeometry'; this.parameters = { radius: radius, widthSegments: widthSegments, heightSegments: heightSegments, phiStart: phiStart, phiLength: phiLength, thetaStart: thetaStart, thetaLength: thetaLength }; this.fromBufferGeometry( new SphereBufferGeometry( radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength ) ); this.mergeVertices(); } SphereGeometry.prototype = Object.create( Geometry.prototype ); SphereGeometry.prototype.constructor = SphereGeometry; // SphereBufferGeometry function SphereBufferGeometry( radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength ) { BufferGeometry.call( this ); this.type = 'SphereBufferGeometry'; this.parameters = { radius: radius, widthSegments: widthSegments, heightSegments: heightSegments, phiStart: phiStart, phiLength: phiLength, thetaStart: thetaStart, thetaLength: thetaLength }; radius = radius || 1; widthSegments = Math.max( 3, Math.floor( widthSegments ) || 8 ); heightSegments = Math.max( 2, Math.floor( heightSegments ) || 6 ); phiStart = phiStart !== undefined ? phiStart : 0; phiLength = phiLength !== undefined ? phiLength : Math.PI * 2; thetaStart = thetaStart !== undefined ? thetaStart : 0; thetaLength = thetaLength !== undefined ? thetaLength : Math.PI; var thetaEnd = thetaStart + thetaLength; var ix, iy; var index = 0; var grid = []; var vertex = new Vector3(); var normal = new Vector3(); // buffers var indices = []; var vertices = []; var normals = []; var uvs = []; // generate vertices, normals and uvs for ( iy = 0; iy 0 ) { high = i - 1; } else { high = i; break; // DONE } } i = high; if ( arcLengths[ i ] === targetArcLength ) { return i / ( il - 1 ); } // we could get finer grain at lengths, or use simple interpolation between two points var lengthBefore = arcLengths[ i ]; var lengthAfter = arcLengths[ i + 1 ]; var segmentLength = lengthAfter - lengthBefore; // determine where we are between the 'before' and 'after' points var segmentFraction = ( targetArcLength - lengthBefore ) / segmentLength; // add that fractional amount to t var t = ( i + segmentFraction ) / ( il - 1 ); return t; }, // Returns a unit vector tangent at t // In case any sub curve does not implement its tangent derivation, // 2 points a small delta apart will be used to find its gradient // which seems to give a reasonable approximation getTangent: function ( t ) { var delta = 0.0001; var t1 = t - delta; var t2 = t + delta; // Capping in case of danger if ( t1 < 0 ) t1 = 0; if ( t2 > 1 ) t2 = 1; var pt1 = this.getPoint( t1 ); var pt2 = this.getPoint( t2 ); var vec = pt2.clone().sub( pt1 ); return vec.normalize(); }, getTangentAt: function ( u ) { var t = this.getUtoTmapping( u ); return this.getTangent( t ); }, computeFrenetFrames: function ( segments, closed ) { // see http://www.cs.indiana.edu/pub/techreports/TR425.pdf var normal = new Vector3(); var tangents = []; var normals = []; var binormals = []; var vec = new Vector3(); var mat = new Matrix4(); var i, u, theta; // compute the tangent vectors for each segment on the curve for ( i = 0; i 0 ) { theta = - theta; } for ( i = 1; i 0 ? 0 : ( Math.floor( Math.abs( intPoint ) / l ) + 1 ) * l; } else if ( weight === 0 && intPoint === l - 1 ) { intPoint = l - 2; weight = 1; } var p0, p1, p2, p3; // 4 points if ( this.closed || intPoint > 0 ) { p0 = points[ ( intPoint - 1 ) % l ]; } else { // extrapolate first point tmp.subVectors( points[ 0 ], points[ 1 ] ).add( points[ 0 ] ); p0 = tmp; } p1 = points[ intPoint % l ]; p2 = points[ ( intPoint + 1 ) % l ]; if ( this.closed || intPoint + 2 < l ) { p3 = points[ ( intPoint + 2 ) % l ]; } else { // extrapolate last point tmp.subVectors( points[ l - 1 ], points[ l - 2 ] ).add( points[ l - 1 ] ); p3 = tmp; } if ( this.curveType === 'centripetal' || this.curveType === 'chordal' ) { // init Centripetal / Chordal Catmull-Rom var pow = this.curveType === 'chordal' ? 0.5 : 0.25; var dt0 = Math.pow( p0.distanceToSquared( p1 ), pow ); var dt1 = Math.pow( p1.distanceToSquared( p2 ), pow ); var dt2 = Math.pow( p2.distanceToSquared( p3 ), pow ); // safety check for repeated points if ( dt1 < 1e-4 ) dt1 = 1.0; if ( dt0 < 1e-4 ) dt0 = dt1; if ( dt2 < 1e-4 ) dt2 = dt1; px.initNonuniformCatmullRom( p0.x, p1.x, p2.x, p3.x, dt0, dt1, dt2 ); py.initNonuniformCatmullRom( p0.y, p1.y, p2.y, p3.y, dt0, dt1, dt2 ); pz.initNonuniformCatmullRom( p0.z, p1.z, p2.z, p3.z, dt0, dt1, dt2 ); } else if ( this.curveType === 'catmullrom' ) { px.initCatmullRom( p0.x, p1.x, p2.x, p3.x, this.tension ); py.initCatmullRom( p0.y, p1.y, p2.y, p3.y, this.tension ); pz.initCatmullRom( p0.z, p1.z, p2.z, p3.z, this.tension ); } point.set( px.calc( weight ), py.calc( weight ), pz.calc( weight ) ); return point; }; CatmullRomCurve3.prototype.copy = function ( source ) { Curve.prototype.copy.call( this, source ); this.points = []; for ( var i = 0, l = source.points.length; i < l; i ++ ) { var point = source.points[ i ]; this.points.push( point.clone() ); } this.closed = source.closed; this.curveType = source.curveType; this.tension = source.tension; return this; }; CatmullRomCurve3.prototype.toJSON = function () { var data = Curve.prototype.toJSON.call( this ); data.points = []; for ( var i = 0, l = this.points.length; i < l; i ++ ) { var point = this.points[ i ]; data.points.push( point.toArray() ); } data.closed = this.closed; data.curveType = this.curveType; data.tension = this.tension; return data; }; CatmullRomCurve3.prototype.fromJSON = function ( json ) { Curve.prototype.fromJSON.call( this, json ); this.points = []; for ( var i = 0, l = json.points.length; i < l; i ++ ) { var point = json.points[ i ]; this.points.push( new Vector3().fromArray( point ) ); } this.closed = json.closed; this.curveType = json.curveType; this.tension = json.tension; return this; }; /** * @author zz85 / http://www.lab4games.net/zz85/blog * * Bezier Curves formulas obtained from * http://en.wikipedia.org/wiki/Bézier_curve */ function CatmullRom( t, p0, p1, p2, p3 ) { var v0 = ( p2 - p0 ) * 0.5; var v1 = ( p3 - p1 ) * 0.5; var t2 = t * t; var t3 = t * t2; return ( 2 * p1 - 2 * p2 + v0 + v1 ) * t3 + ( - 3 * p1 + 3 * p2 - 2 * v0 - v1 ) * t2 + v0 * t + p1; } // function QuadraticBezierP0( t, p ) { var k = 1 - t; return k * k * p; } function QuadraticBezierP1( t, p ) { return 2 * ( 1 - t ) * t * p; } function QuadraticBezierP2( t, p ) { return t * t * p; } function QuadraticBezier( t, p0, p1, p2 ) { return QuadraticBezierP0( t, p0 ) + QuadraticBezierP1( t, p1 ) + QuadraticBezierP2( t, p2 ); } // function CubicBezierP0( t, p ) { var k = 1 - t; return k * k * k * p; } function CubicBezierP1( t, p ) { var k = 1 - t; return 3 * k * k * t * p; } function CubicBezierP2( t, p ) { return 3 * ( 1 - t ) * t * t * p; } function CubicBezierP3( t, p ) { return t * t * t * p; } function CubicBezier( t, p0, p1, p2, p3 ) { return CubicBezierP0( t, p0 ) + CubicBezierP1( t, p1 ) + CubicBezierP2( t, p2 ) + CubicBezierP3( t, p3 ); } function CubicBezierCurve( v0, v1, v2, v3 ) { Curve.call( this ); this.type = 'CubicBezierCurve'; this.v0 = v0 || new Vector2(); this.v1 = v1 || new Vector2(); this.v2 = v2 || new Vector2(); this.v3 = v3 || new Vector2(); } CubicBezierCurve.prototype = Object.create( Curve.prototype ); CubicBezierCurve.prototype.constructor = CubicBezierCurve; CubicBezierCurve.prototype.isCubicBezierCurve = true; CubicBezierCurve.prototype.getPoint = function ( t, optionalTarget ) { var point = optionalTarget || new Vector2(); var v0 = this.v0, v1 = this.v1, v2 = this.v2, v3 = this.v3; point.set( CubicBezier( t, v0.x, v1.x, v2.x, v3.x ), CubicBezier( t, v0.y, v1.y, v2.y, v3.y ) ); return point; }; CubicBezierCurve.prototype.copy = function ( source ) { Curve.prototype.copy.call( this, source ); this.v0.copy( source.v0 ); this.v1.copy( source.v1 ); this.v2.copy( source.v2 ); this.v3.copy( source.v3 ); return this; }; CubicBezierCurve.prototype.toJSON = function () { var data = Curve.prototype.toJSON.call( this ); data.v0 = this.v0.toArray(); data.v1 = this.v1.toArray(); data.v2 = this.v2.toArray(); data.v3 = this.v3.toArray(); return data; }; CubicBezierCurve.prototype.fromJSON = function ( json ) { Curve.prototype.fromJSON.call( this, json ); this.v0.fromArray( json.v0 ); this.v1.fromArray( json.v1 ); this.v2.fromArray( json.v2 ); this.v3.fromArray( json.v3 ); return this; }; function CubicBezierCurve3( v0, v1, v2, v3 ) { Curve.call( this ); this.type = 'CubicBezierCurve3'; this.v0 = v0 || new Vector3(); this.v1 = v1 || new Vector3(); this.v2 = v2 || new Vector3(); this.v3 = v3 || new Vector3(); } CubicBezierCurve3.prototype = Object.create( Curve.prototype ); CubicBezierCurve3.prototype.constructor = CubicBezierCurve3; CubicBezierCurve3.prototype.isCubicBezierCurve3 = true; CubicBezierCurve3.prototype.getPoint = function ( t, optionalTarget ) { var point = optionalTarget || new Vector3(); var v0 = this.v0, v1 = this.v1, v2 = this.v2, v3 = this.v3; point.set( CubicBezier( t, v0.x, v1.x, v2.x, v3.x ), CubicBezier( t, v0.y, v1.y, v2.y, v3.y ), CubicBezier( t, v0.z, v1.z, v2.z, v3.z ) ); return point; }; CubicBezierCurve3.prototype.copy = function ( source ) { Curve.prototype.copy.call( this, source ); this.v0.copy( source.v0 ); this.v1.copy( source.v1 ); this.v2.copy( source.v2 ); this.v3.copy( source.v3 ); return this; }; CubicBezierCurve3.prototype.toJSON = function () { var data = Curve.prototype.toJSON.call( this ); data.v0 = this.v0.toArray(); data.v1 = this.v1.toArray(); data.v2 = this.v2.toArray(); data.v3 = this.v3.toArray(); return data; }; CubicBezierCurve3.prototype.fromJSON = function ( json ) { Curve.prototype.fromJSON.call( this, json ); this.v0.fromArray( json.v0 ); this.v1.fromArray( json.v1 ); this.v2.fromArray( json.v2 ); this.v3.fromArray( json.v3 ); return this; }; function LineCurve( v1, v2 ) { Curve.call( this ); this.type = 'LineCurve'; this.v1 = v1 || new Vector2(); this.v2 = v2 || new Vector2(); } LineCurve.prototype = Object.create( Curve.prototype ); LineCurve.prototype.constructor = LineCurve; LineCurve.prototype.isLineCurve = true; LineCurve.prototype.getPoint = function ( t, optionalTarget ) { var point = optionalTarget || new Vector2(); if ( t === 1 ) { point.copy( this.v2 ); } else { point.copy( this.v2 ).sub( this.v1 ); point.multiplyScalar( t ).add( this.v1 ); } return point; }; // Line curve is linear, so we can overwrite default getPointAt LineCurve.prototype.getPointAt = function ( u, optionalTarget ) { return this.getPoint( u, optionalTarget ); }; LineCurve.prototype.getTangent = function ( /* t */ ) { var tangent = this.v2.clone().sub( this.v1 ); return tangent.normalize(); }; LineCurve.prototype.copy = function ( source ) { Curve.prototype.copy.call( this, source ); this.v1.copy( source.v1 ); this.v2.copy( source.v2 ); return this; }; LineCurve.prototype.toJSON = function () { var data = Curve.prototype.toJSON.call( this ); data.v1 = this.v1.toArray(); data.v2 = this.v2.toArray(); return data; }; LineCurve.prototype.fromJSON = function ( json ) { Curve.prototype.fromJSON.call( this, json ); this.v1.fromArray( json.v1 ); this.v2.fromArray( json.v2 ); return this; }; function LineCurve3( v1, v2 ) { Curve.call( this ); this.type = 'LineCurve3'; this.v1 = v1 || new Vector3(); this.v2 = v2 || new Vector3(); } LineCurve3.prototype = Object.create( Curve.prototype ); LineCurve3.prototype.constructor = LineCurve3; LineCurve3.prototype.isLineCurve3 = true; LineCurve3.prototype.getPoint = function ( t, optionalTarget ) { var point = optionalTarget || new Vector3(); if ( t === 1 ) { point.copy( this.v2 ); } else { point.copy( this.v2 ).sub( this.v1 ); point.multiplyScalar( t ).add( this.v1 ); } return point; }; // Line curve is linear, so we can overwrite default getPointAt LineCurve3.prototype.getPointAt = function ( u, optionalTarget ) { return this.getPoint( u, optionalTarget ); }; LineCurve3.prototype.copy = function ( source ) { Curve.prototype.copy.call( this, source ); this.v1.copy( source.v1 ); this.v2.copy( source.v2 ); return this; }; LineCurve3.prototype.toJSON = function () { var data = Curve.prototype.toJSON.call( this ); data.v1 = this.v1.toArray(); data.v2 = this.v2.toArray(); return data; }; LineCurve3.prototype.fromJSON = function ( json ) { Curve.prototype.fromJSON.call( this, json ); this.v1.fromArray( json.v1 ); this.v2.fromArray( json.v2 ); return this; }; function QuadraticBezierCurve( v0, v1, v2 ) { Curve.call( this ); this.type = 'QuadraticBezierCurve'; this.v0 = v0 || new Vector2(); this.v1 = v1 || new Vector2(); this.v2 = v2 || new Vector2(); } QuadraticBezierCurve.prototype = Object.create( Curve.prototype ); QuadraticBezierCurve.prototype.constructor = QuadraticBezierCurve; QuadraticBezierCurve.prototype.isQuadraticBezierCurve = true; QuadraticBezierCurve.prototype.getPoint = function ( t, optionalTarget ) { var point = optionalTarget || new Vector2(); var v0 = this.v0, v1 = this.v1, v2 = this.v2; point.set( QuadraticBezier( t, v0.x, v1.x, v2.x ), QuadraticBezier( t, v0.y, v1.y, v2.y ) ); return point; }; QuadraticBezierCurve.prototype.copy = function ( source ) { Curve.prototype.copy.call( this, source ); this.v0.copy( source.v0 ); this.v1.copy( source.v1 ); this.v2.copy( source.v2 ); return this; }; QuadraticBezierCurve.prototype.toJSON = function () { var data = Curve.prototype.toJSON.call( this ); data.v0 = this.v0.toArray(); data.v1 = this.v1.toArray(); data.v2 = this.v2.toArray(); return data; }; QuadraticBezierCurve.prototype.fromJSON = function ( json ) { Curve.prototype.fromJSON.call( this, json ); this.v0.fromArray( json.v0 ); this.v1.fromArray( json.v1 ); this.v2.fromArray( json.v2 ); return this; }; function QuadraticBezierCurve3( v0, v1, v2 ) { Curve.call( this ); this.type = 'QuadraticBezierCurve3'; this.v0 = v0 || new Vector3(); this.v1 = v1 || new Vector3(); this.v2 = v2 || new Vector3(); } QuadraticBezierCurve3.prototype = Object.create( Curve.prototype ); QuadraticBezierCurve3.prototype.constructor = QuadraticBezierCurve3; QuadraticBezierCurve3.prototype.isQuadraticBezierCurve3 = true; QuadraticBezierCurve3.prototype.getPoint = function ( t, optionalTarget ) { var point = optionalTarget || new Vector3(); var v0 = this.v0, v1 = this.v1, v2 = this.v2; point.set( QuadraticBezier( t, v0.x, v1.x, v2.x ), QuadraticBezier( t, v0.y, v1.y, v2.y ), QuadraticBezier( t, v0.z, v1.z, v2.z ) ); return point; }; QuadraticBezierCurve3.prototype.copy = function ( source ) { Curve.prototype.copy.call( this, source ); this.v0.copy( source.v0 ); this.v1.copy( source.v1 ); this.v2.copy( source.v2 ); return this; }; QuadraticBezierCurve3.prototype.toJSON = function () { var data = Curve.prototype.toJSON.call( this ); data.v0 = this.v0.toArray(); data.v1 = this.v1.toArray(); data.v2 = this.v2.toArray(); return data; }; QuadraticBezierCurve3.prototype.fromJSON = function ( json ) { Curve.prototype.fromJSON.call( this, json ); this.v0.fromArray( json.v0 ); this.v1.fromArray( json.v1 ); this.v2.fromArray( json.v2 ); return this; }; function SplineCurve( points /* array of Vector2 */ ) { Curve.call( this ); this.type = 'SplineCurve'; this.points = points || []; } SplineCurve.prototype = Object.create( Curve.prototype ); SplineCurve.prototype.constructor = SplineCurve; SplineCurve.prototype.isSplineCurve = true; SplineCurve.prototype.getPoint = function ( t, optionalTarget ) { var point = optionalTarget || new Vector2(); var points = this.points; var p = ( points.length - 1 ) * t; var intPoint = Math.floor( p ); var weight = p - intPoint; var p0 = points[ intPoint === 0 ? intPoint : intPoint - 1 ]; var p1 = points[ intPoint ]; var p2 = points[ intPoint > points.length - 2 ? points.length - 1 : intPoint + 1 ]; var p3 = points[ intPoint > points.length - 3 ? points.length - 1 : intPoint + 2 ]; point.set( CatmullRom( weight, p0.x, p1.x, p2.x, p3.x ), CatmullRom( weight, p0.y, p1.y, p2.y, p3.y ) ); return point; }; SplineCurve.prototype.copy = function ( source ) { Curve.prototype.copy.call( this, source ); this.points = []; for ( var i = 0, l = source.points.length; i < l; i ++ ) { var point = source.points[ i ]; this.points.push( point.clone() ); } return this; }; SplineCurve.prototype.toJSON = function () { var data = Curve.prototype.toJSON.call( this ); data.points = []; for ( var i = 0, l = this.points.length; i < l; i ++ ) { var point = this.points[ i ]; data.points.push( point.toArray() ); } return data; }; SplineCurve.prototype.fromJSON = function ( json ) { Curve.prototype.fromJSON.call( this, json ); this.points = []; for ( var i = 0, l = json.points.length; i < l; i ++ ) { var point = json.points[ i ]; this.points.push( new Vector2().fromArray( point ) ); } return this; }; var Curves = /*#__PURE__*/Object.freeze({ ArcCurve: ArcCurve, CatmullRomCurve3: CatmullRomCurve3, CubicBezierCurve: CubicBezierCurve, CubicBezierCurve3: CubicBezierCurve3, EllipseCurve: EllipseCurve, LineCurve: LineCurve, LineCurve3: LineCurve3, QuadraticBezierCurve: QuadraticBezierCurve, QuadraticBezierCurve3: QuadraticBezierCurve3, SplineCurve: SplineCurve }); /** * @author zz85 / http://www.lab4games.net/zz85/blog * **/ /************************************************************** * Curved Path - a curve path is simply a array of connected * curves, but retains the api of a curve **************************************************************/ function CurvePath() { Curve.call( this ); this.type = 'CurvePath'; this.curves = []; this.autoClose = false; // Automatically closes the path } CurvePath.prototype = Object.assign( Object.create( Curve.prototype ), { constructor: CurvePath, add: function ( curve ) { this.curves.push( curve ); }, closePath: function () { // Add a line curve if start and end of lines are not connected var startPoint = this.curves[ 0 ].getPoint( 0 ); var endPoint = this.curves[ this.curves.length - 1 ].getPoint( 1 ); if ( ! startPoint.equals( endPoint ) ) { this.curves.push( new LineCurve( endPoint, startPoint ) ); } }, // To get accurate point with reference to // entire path distance at time t, // following has to be done: // 1. Length of each sub path have to be known // 2. Locate and identify type of curve // 3. Get t for the curve // 4. Return curve.getPointAt(t') getPoint: function ( t ) { var d = t * this.getLength(); var curveLengths = this.getCurveLengths(); var i = 0; // To think about boundaries points. while ( i < curveLengths.length ) { if ( curveLengths[ i ] >= d ) { var diff = curveLengths[ i ] - d; var curve = this.curves[ i ]; var segmentLength = curve.getLength(); var u = segmentLength === 0 ? 0 : 1 - diff / segmentLength; return curve.getPointAt( u ); } i ++; } return null; // loop where sum != 0, sum > d , sum+1 0 ) { // if a previous curve is present, attempt to join var firstPoint = curve.getPoint( 0 ); if ( ! firstPoint.equals( this.currentPoint ) ) { this.lineTo( firstPoint.x, firstPoint.y ); } } this.curves.push( curve ); var lastPoint = curve.getPoint( 1 ); this.currentPoint.copy( lastPoint ); }, copy: function ( source ) { CurvePath.prototype.copy.call( this, source ); this.currentPoint.copy( source.currentPoint ); return this; }, toJSON: function () { var data = CurvePath.prototype.toJSON.call( this ); data.currentPoint = this.currentPoint.toArray(); return data; }, fromJSON: function ( json ) { CurvePath.prototype.fromJSON.call( this, json ); this.currentPoint.fromArray( json.currentPoint ); return this; } } ); /** * @author zz85 / http://www.lab4games.net/zz85/blog * Defines a 2d shape plane using paths. **/ // STEP 1 Create a path. // STEP 2 Turn path into shape. // STEP 3 ExtrudeGeometry takes in Shape/Shapes // STEP 3a - Extract points from each shape, turn to vertices // STEP 3b - Triangulate each shape, add faces. function Shape( points ) { Path.call( this, points ); this.uuid = _Math.generateUUID(); this.type = 'Shape'; this.holes = []; } Shape.prototype = Object.assign( Object.create( Path.prototype ), { constructor: Shape, getPointsHoles: function ( divisions ) { var holesPts = []; for ( var i = 0, l = this.holes.length; i < l; i ++ ) { holesPts[ i ] = this.holes[ i ].getPoints( divisions ); } return holesPts; }, // get points of shape and holes (keypoints based on segments parameter) extractPoints: function ( divisions ) { return { shape: this.getPoints( divisions ), holes: this.getPointsHoles( divisions ) }; }, copy: function ( source ) { Path.prototype.copy.call( this, source ); this.holes = []; for ( var i = 0, l = source.holes.length; i < l; i ++ ) { var hole = source.holes[ i ]; this.holes.push( hole.clone() ); } return this; }, toJSON: function () { var data = Path.prototype.toJSON.call( this ); data.uuid = this.uuid; data.holes = []; for ( var i = 0, l = this.holes.length; i < l; i ++ ) { var hole = this.holes[ i ]; data.holes.push( hole.toJSON() ); } return data; }, fromJSON: function ( json ) { Path.prototype.fromJSON.call( this, json ); this.uuid = json.uuid; this.holes = []; for ( var i = 0, l = json.holes.length; i < l; i ++ ) { var hole = json.holes[ i ]; this.holes.push( new Path().fromJSON( hole ) ); } return this; } } ); /** * @author mrdoob / http://mrdoob.com/ * @author alteredq / http://alteredqualia.com/ */ function Light( color, intensity ) { Object3D.call( this ); this.type = 'Light'; this.color = new Color( color ); this.intensity = intensity !== undefined ? intensity : 1; this.receiveShadow = undefined; } Light.prototype = Object.assign( Object.create( Object3D.prototype ), { constructor: Light, isLight: true, copy: function ( source ) { Object3D.prototype.copy.call( this, source ); this.color.copy( source.color ); this.intensity = source.intensity; return this; }, toJSON: function ( meta ) { var data = Object3D.prototype.toJSON.call( this, meta ); data.object.color = this.color.getHex(); data.object.intensity = this.intensity; if ( this.groundColor !== undefined ) data.object.groundColor = this.groundColor.getHex(); if ( this.distance !== undefined ) data.object.distance = this.distance; if ( this.angle !== undefined ) data.object.angle = this.angle; if ( this.decay !== undefined ) data.object.decay = this.decay; if ( this.penumbra !== undefined ) data.object.penumbra = this.penumbra; if ( this.shadow !== undefined ) data.object.shadow = this.shadow.toJSON(); return data; } } ); /** * @author alteredq / http://alteredqualia.com/ */ function HemisphereLight( skyColor, groundColor, intensity ) { Light.call( this, skyColor, intensity ); this.type = 'HemisphereLight'; this.castShadow = undefined; this.position.copy( Object3D.DefaultUp ); this.updateMatrix(); this.groundColor = new Color( groundColor ); } HemisphereLight.prototype = Object.assign( Object.create( Light.prototype ), { constructor: HemisphereLight, isHemisphereLight: true, copy: function ( source ) { Light.prototype.copy.call( this, source ); this.groundColor.copy( source.groundColor ); return this; } } ); /** * @author mrdoob / http://mrdoob.com/ */ function LightShadow( camera ) { this.camera = camera; this.bias = 0; this.radius = 1; this.mapSize = new Vector2( 512, 512 ); this.map = null; this.matrix = new Matrix4(); } Object.assign( LightShadow.prototype, { copy: function ( source ) { this.camera = source.camera.clone(); this.bias = source.bias; this.radius = source.radius; this.mapSize.copy( source.mapSize ); return this; }, clone: function () { return new this.constructor().copy( this ); }, toJSON: function () { var object = {}; if ( this.bias !== 0 ) object.bias = this.bias; if ( this.radius !== 1 ) object.radius = this.radius; if ( this.mapSize.x !== 512 || this.mapSize.y !== 512 ) object.mapSize = this.mapSize.toArray(); object.camera = this.camera.toJSON( false ).object; delete object.camera.matrix; return object; } } ); /** * @author mrdoob / http://mrdoob.com/ */ function SpotLightShadow() { LightShadow.call( this, new PerspectiveCamera( 50, 1, 0.5, 500 ) ); } SpotLightShadow.prototype = Object.assign( Object.create( LightShadow.prototype ), { constructor: SpotLightShadow, isSpotLightShadow: true, update: function ( light ) { var camera = this.camera; var fov = _Math.RAD2DEG * 2 * light.angle; var aspect = this.mapSize.width / this.mapSize.height; var far = light.distance || camera.far; if ( fov !== camera.fov || aspect !== camera.aspect || far !== camera.far ) { camera.fov = fov; camera.aspect = aspect; camera.far = far; camera.updateProjectionMatrix(); } } } ); /** * @author alteredq / http://alteredqualia.com/ */ function SpotLight( color, intensity, distance, angle, penumbra, decay ) { Light.call( this, color, intensity ); this.type = 'SpotLight'; this.position.copy( Object3D.DefaultUp ); this.updateMatrix(); this.target = new Object3D(); Object.defineProperty( this, 'power', { get: function () { // intensity = power per solid angle. // ref: equation (17) from https://seblagarde.files.wordpress.com/2015/07/course_notes_moving_frostbite_to_pbr_v32.pdf return this.intensity * Math.PI; }, set: function ( power ) { // intensity = power per solid angle. // ref: equation (17) from https://seblagarde.files.wordpress.com/2015/07/course_notes_moving_frostbite_to_pbr_v32.pdf this.intensity = power / Math.PI; } } ); this.distance = ( distance !== undefined ) ? distance : 0; this.angle = ( angle !== undefined ) ? angle : Math.PI / 3; this.penumbra = ( penumbra !== undefined ) ? penumbra : 0; this.decay = ( decay !== undefined ) ? decay : 1; // for physically correct lights, should be 2. this.shadow = new SpotLightShadow(); } SpotLight.prototype = Object.assign( Object.create( Light.prototype ), { constructor: SpotLight, isSpotLight: true, copy: function ( source ) { Light.prototype.copy.call( this, source ); this.distance = source.distance; this.angle = source.angle; this.penumbra = source.penumbra; this.decay = source.decay; this.target = source.target.clone(); this.shadow = source.shadow.clone(); return this; } } ); /** * @author mrdoob / http://mrdoob.com/ */ function PointLight( color, intensity, distance, decay ) { Light.call( this, color, intensity ); this.type = 'PointLight'; Object.defineProperty( this, 'power', { get: function () { // intensity = power per solid angle. // ref: equation (15) from https://seblagarde.files.wordpress.com/2015/07/course_notes_moving_frostbite_to_pbr_v32.pdf return this.intensity * 4 * Math.PI; }, set: function ( power ) { // intensity = power per solid angle. // ref: equation (15) from https://seblagarde.files.wordpress.com/2015/07/course_notes_moving_frostbite_to_pbr_v32.pdf this.intensity = power / ( 4 * Math.PI ); } } ); this.distance = ( distance !== undefined ) ? distance : 0; this.decay = ( decay !== undefined ) ? decay : 1; // for physically correct lights, should be 2. this.shadow = new LightShadow( new PerspectiveCamera( 90, 1, 0.5, 500 ) ); } PointLight.prototype = Object.assign( Object.create( Light.prototype ), { constructor: PointLight, isPointLight: true, copy: function ( source ) { Light.prototype.copy.call( this, source ); this.distance = source.distance; this.decay = source.decay; this.shadow = source.shadow.clone(); return this; } } ); /** * @author alteredq / http://alteredqualia.com/ * @author arose / http://github.com/arose */ function OrthographicCamera( left, right, top, bottom, near, far ) { Camera.call( this ); this.type = 'OrthographicCamera'; this.zoom = 1; this.view = null; this.left = ( left !== undefined ) ? left : - 1; this.right = ( right !== undefined ) ? right : 1; this.top = ( top !== undefined ) ? top : 1; this.bottom = ( bottom !== undefined ) ? bottom : - 1; this.near = ( near !== undefined ) ? near : 0.1; this.far = ( far !== undefined ) ? far : 2000; this.updateProjectionMatrix(); } OrthographicCamera.prototype = Object.assign( Object.create( Camera.prototype ), { constructor: OrthographicCamera, isOrthographicCamera: true, copy: function ( source, recursive ) { Camera.prototype.copy.call( this, source, recursive ); this.left = source.left; this.right = source.right; this.top = source.top; this.bottom = source.bottom; this.near = source.near; this.far = source.far; this.zoom = source.zoom; this.view = source.view === null ? null : Object.assign( {}, source.view ); return this; }, setViewOffset: function ( fullWidth, fullHeight, x, y, width, height ) { if ( this.view === null ) { this.view = { enabled: true, fullWidth: 1, fullHeight: 1, offsetX: 0, offsetY: 0, width: 1, height: 1 }; } this.view.enabled = true; this.view.fullWidth = fullWidth; this.view.fullHeight = fullHeight; this.view.offsetX = x; this.view.offsetY = y; this.view.width = width; this.view.height = height; this.updateProjectionMatrix(); }, clearViewOffset: function () { if ( this.view !== null ) { this.view.enabled = false; } this.updateProjectionMatrix(); }, updateProjectionMatrix: function () { var dx = ( this.right - this.left ) / ( 2 * this.zoom ); var dy = ( this.top - this.bottom ) / ( 2 * this.zoom ); var cx = ( this.right + this.left ) / 2; var cy = ( this.top + this.bottom ) / 2; var left = cx - dx; var right = cx + dx; var top = cy + dy; var bottom = cy - dy; if ( this.view !== null && this.view.enabled ) { var zoomW = this.zoom / ( this.view.width / this.view.fullWidth ); var zoomH = this.zoom / ( this.view.height / this.view.fullHeight ); var scaleW = ( this.right - this.left ) / this.view.width; var scaleH = ( this.top - this.bottom ) / this.view.height; left += scaleW * ( this.view.offsetX / zoomW ); right = left + scaleW * ( this.view.width / zoomW ); top -= scaleH * ( this.view.offsetY / zoomH ); bottom = top - scaleH * ( this.view.height / zoomH ); } this.projectionMatrix.makeOrthographic( left, right, top, bottom, this.near, this.far ); this.projectionMatrixInverse.getInverse( this.projectionMatrix ); }, toJSON: function ( meta ) { var data = Object3D.prototype.toJSON.call( this, meta ); data.object.zoom = this.zoom; data.object.left = this.left; data.object.right = this.right; data.object.top = this.top; data.object.bottom = this.bottom; data.object.near = this.near; data.object.far = this.far; if ( this.view !== null ) data.object.view = Object.assign( {}, this.view ); return data; } } ); /** * @author mrdoob / http://mrdoob.com/ */ function DirectionalLightShadow( ) { LightShadow.call( this, new OrthographicCamera( - 5, 5, 5, - 5, 0.5, 500 ) ); } DirectionalLightShadow.prototype = Object.assign( Object.create( LightShadow.prototype ), { constructor: DirectionalLightShadow } ); /** * @author mrdoob / http://mrdoob.com/ * @author alteredq / http://alteredqualia.com/ */ function DirectionalLight( color, intensity ) { Light.call( this, color, intensity ); this.type = 'DirectionalLight'; this.position.copy( Object3D.DefaultUp ); this.updateMatrix(); this.target = new Object3D(); this.shadow = new DirectionalLightShadow(); } DirectionalLight.prototype = Object.assign( Object.create( Light.prototype ), { constructor: DirectionalLight, isDirectionalLight: true, copy: function ( source ) { Light.prototype.copy.call( this, source ); this.target = source.target.clone(); this.shadow = source.shadow.clone(); return this; } } ); /** * @author mrdoob / http://mrdoob.com/ */ function AmbientLight( color, intensity ) { Light.call( this, color, intensity ); this.type = 'AmbientLight'; this.castShadow = undefined; } AmbientLight.prototype = Object.assign( Object.create( Light.prototype ), { constructor: AmbientLight, isAmbientLight: true } ); /** * @author abelnation / http://github.com/abelnation */ function RectAreaLight( color, intensity, width, height ) { Light.call( this, color, intensity ); this.type = 'RectAreaLight'; this.width = ( width !== undefined ) ? width : 10; this.height = ( height !== undefined ) ? height : 10; } RectAreaLight.prototype = Object.assign( Object.create( Light.prototype ), { constructor: RectAreaLight, isRectAreaLight: true, copy: function ( source ) { Light.prototype.copy.call( this, source ); this.width = source.width; this.height = source.height; return this; }, toJSON: function ( meta ) { var data = Light.prototype.toJSON.call( this, meta ); data.object.width = this.width; data.object.height = this.height; return data; } } ); /** * @author mrdoob / http://mrdoob.com/ */ function MaterialLoader( manager ) { this.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager; this.textures = {}; } Object.assign( MaterialLoader.prototype, { load: function ( url, onLoad, onProgress, onError ) { var scope = this; var loader = new FileLoader( scope.manager ); loader.setPath( scope.path ); loader.load( url, function ( text ) { onLoad( scope.parse( JSON.parse( text ) ) ); }, onProgress, onError ); }, parse: function ( json ) { var textures = this.textures; function getTexture( name ) { if ( textures[ name ] === undefined ) { console.warn( 'THREE.MaterialLoader: Undefined texture', name ); } return textures[ name ]; } var material = new Materials[ json.type ](); if ( json.uuid !== undefined ) material.uuid = json.uuid; if ( json.name !== undefined ) material.name = json.name; if ( json.color !== undefined ) material.color.setHex( json.color ); if ( json.roughness !== undefined ) material.roughness = json.roughness; if ( json.metalness !== undefined ) material.metalness = json.metalness; if ( json.emissive !== undefined ) material.emissive.setHex( json.emissive ); if ( json.specular !== undefined ) material.specular.setHex( json.specular ); if ( json.shininess !== undefined ) material.shininess = json.shininess; if ( json.clearCoat !== undefined ) material.clearCoat = json.clearCoat; if ( json.clearCoatRoughness !== undefined ) material.clearCoatRoughness = json.clearCoatRoughness; if ( json.vertexColors !== undefined ) material.vertexColors = json.vertexColors; if ( json.fog !== undefined ) material.fog = json.fog; if ( json.flatShading !== undefined ) material.flatShading = json.flatShading; if ( json.blending !== undefined ) material.blending = json.blending; if ( json.combine !== undefined ) material.combine = json.combine; if ( json.side !== undefined ) material.side = json.side; if ( json.opacity !== undefined ) material.opacity = json.opacity; if ( json.transparent !== undefined ) material.transparent = json.transparent; if ( json.alphaTest !== undefined ) material.alphaTest = json.alphaTest; if ( json.depthTest !== undefined ) material.depthTest = json.depthTest; if ( json.depthWrite !== undefined ) material.depthWrite = json.depthWrite; if ( json.colorWrite !== undefined ) material.colorWrite = json.colorWrite; if ( json.wireframe !== undefined ) material.wireframe = json.wireframe; if ( json.wireframeLinewidth !== undefined ) material.wireframeLinewidth = json.wireframeLinewidth; if ( json.wireframeLinecap !== undefined ) material.wireframeLinecap = json.wireframeLinecap; if ( json.wireframeLinejoin !== undefined ) material.wireframeLinejoin = json.wireframeLinejoin; if ( json.rotation !== undefined ) material.rotation = json.rotation; if ( json.linewidth !== 1 ) material.linewidth = json.linewidth; if ( json.dashSize !== undefined ) material.dashSize = json.dashSize; if ( json.gapSize !== undefined ) material.gapSize = json.gapSize; if ( json.scale !== undefined ) material.scale = json.scale; if ( json.polygonOffset !== undefined ) material.polygonOffset = json.polygonOffset; if ( json.polygonOffsetFactor !== undefined ) material.polygonOffsetFactor = json.polygonOffsetFactor; if ( json.polygonOffsetUnits !== undefined ) material.polygonOffsetUnits = json.polygonOffsetUnits; if ( json.skinning !== undefined ) material.skinning = json.skinning; if ( json.morphTargets !== undefined ) material.morphTargets = json.morphTargets; if ( json.dithering !== undefined ) material.dithering = json.dithering; if ( json.visible !== undefined ) material.visible = json.visible; if ( json.userData !== undefined ) material.userData = json.userData; // Shader Material if ( json.uniforms !== undefined ) { for ( var name in json.uniforms ) { var uniform = json.uniforms[ name ]; material.uniforms[ name ] = {}; switch ( uniform.type ) { case 't': material.uniforms[ name ].value = getTexture( uniform.value ); break; case 'c': material.uniforms[ name ].value = new Color().setHex( uniform.value ); break; case 'v2': material.uniforms[ name ].value = new Vector2().fromArray( uniform.value ); break; case 'v3': material.uniforms[ name ].value = new Vector3().fromArray( uniform.value ); break; case 'v4': material.uniforms[ name ].value = new Vector4().fromArray( uniform.value ); break; case 'm3': material.uniforms[ name ].value = new Matrix3().fromArray( uniform.value ); case 'm4': material.uniforms[ name ].value = new Matrix4().fromArray( uniform.value ); break; default: material.uniforms[ name ].value = uniform.value; } } } if ( json.defines !== undefined ) material.defines = json.defines; if ( json.vertexShader !== undefined ) material.vertexShader = json.vertexShader; if ( json.fragmentShader !== undefined ) material.fragmentShader = json.fragmentShader; if ( json.extensions !== undefined ) { for ( var key in json.extensions ) { material.extensions[ key ] = json.extensions[ key ]; } } // Deprecated if ( json.shading !== undefined ) material.flatShading = json.shading === 1; // THREE.FlatShading // for PointsMaterial if ( json.size !== undefined ) material.size = json.size; if ( json.sizeAttenuation !== undefined ) material.sizeAttenuation = json.sizeAttenuation; // maps if ( json.map !== undefined ) material.map = getTexture( json.map ); if ( json.alphaMap !== undefined ) { material.alphaMap = getTexture( json.alphaMap ); material.transparent = true; } if ( json.bumpMap !== undefined ) material.bumpMap = getTexture( json.bumpMap ); if ( json.bumpScale !== undefined ) material.bumpScale = json.bumpScale; if ( json.normalMap !== undefined ) material.normalMap = getTexture( json.normalMap ); if ( json.normalMapType !== undefined ) material.normalMapType = json.normalMapType; if ( json.normalScale !== undefined ) { var normalScale = json.normalScale; if ( Array.isArray( normalScale ) === false ) { // Blender exporter used to export a scalar. See #7459 normalScale = [ normalScale, normalScale ]; } material.normalScale = new Vector2().fromArray( normalScale ); } if ( json.displacementMap !== undefined ) material.displacementMap = getTexture( json.displacementMap ); if ( json.displacementScale !== undefined ) material.displacementScale = json.displacementScale; if ( json.displacementBias !== undefined ) material.displacementBias = json.displacementBias; if ( json.roughnessMap !== undefined ) material.roughnessMap = getTexture( json.roughnessMap ); if ( json.metalnessMap !== undefined ) material.metalnessMap = getTexture( json.metalnessMap ); if ( json.emissiveMap !== undefined ) material.emissiveMap = getTexture( json.emissiveMap ); if ( json.emissiveIntensity !== undefined ) material.emissiveIntensity = json.emissiveIntensity; if ( json.specularMap !== undefined ) material.specularMap = getTexture( json.specularMap ); if ( json.envMap !== undefined ) material.envMap = getTexture( json.envMap ); if ( json.envMapIntensity !== undefined ) material.envMapIntensity = json.envMapIntensity; if ( json.reflectivity !== undefined ) material.reflectivity = json.reflectivity; if ( json.lightMap !== undefined ) material.lightMap = getTexture( json.lightMap ); if ( json.lightMapIntensity !== undefined ) material.lightMapIntensity = json.lightMapIntensity; if ( json.aoMap !== undefined ) material.aoMap = getTexture( json.aoMap ); if ( json.aoMapIntensity !== undefined ) material.aoMapIntensity = json.aoMapIntensity; if ( json.gradientMap !== undefined ) material.gradientMap = getTexture( json.gradientMap ); return material; }, setPath: function ( value ) { this.path = value; return this; }, setTextures: function ( value ) { this.textures = value; return this; } } ); /** * @author Don McCurdy / https://www.donmccurdy.com */ var LoaderUtils = { decodeText: function ( array ) { if ( typeof TextDecoder !== 'undefined' ) { return new TextDecoder().decode( array ); } // Avoid the String.fromCharCode.apply(null, array) shortcut, which // throws a \"maximum call stack size exceeded\" error for large arrays. var s = ''; for ( var i = 0, il = array.length; i < il; i ++ ) { // Implicitly assumes little-endian. s += String.fromCharCode( array[ i ] ); } // Merges multi-byte utf-8 characters. return decodeURIComponent( escape( s ) ); }, extractUrlBase: function ( url ) { var index = url.lastIndexOf( '/' ); if ( index === - 1 ) return './'; return url.substr( 0, index + 1 ); } }; /** * @author mrdoob / http://mrdoob.com/ */ function BufferGeometryLoader( manager ) { this.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager; } Object.assign( BufferGeometryLoader.prototype, { load: function ( url, onLoad, onProgress, onError ) { var scope = this; var loader = new FileLoader( scope.manager ); loader.setPath( scope.path ); loader.load( url, function ( text ) { onLoad( scope.parse( JSON.parse( text ) ) ); }, onProgress, onError ); }, parse: function ( json ) { var geometry = new BufferGeometry(); var index = json.data.index; if ( index !== undefined ) { var typedArray = new TYPED_ARRAYS[ index.type ]( index.array ); geometry.setIndex( new BufferAttribute( typedArray, 1 ) ); } var attributes = json.data.attributes; for ( var key in attributes ) { var attribute = attributes[ key ]; var typedArray = new TYPED_ARRAYS[ attribute.type ]( attribute.array ); geometry.addAttribute( key, new BufferAttribute( typedArray, attribute.itemSize, attribute.normalized ) ); } var groups = json.data.groups || json.data.drawcalls || json.data.offsets; if ( groups !== undefined ) { for ( var i = 0, n = groups.length; i !== n; ++ i ) { var group = groups[ i ]; geometry.addGroup( group.start, group.count, group.materialIndex ); } } var boundingSphere = json.data.boundingSphere; if ( boundingSphere !== undefined ) { var center = new Vector3(); if ( boundingSphere.center !== undefined ) { center.fromArray( boundingSphere.center ); } geometry.boundingSphere = new Sphere( center, boundingSphere.radius ); } if ( json.name ) geometry.name = json.name; if ( json.userData ) geometry.userData = json.userData; return geometry; }, setPath: function ( value ) { this.path = value; return this; } } ); var TYPED_ARRAYS = { Int8Array: Int8Array, Uint8Array: Uint8Array, // Workaround for IE11 pre KB2929437. See #11440 Uint8ClampedArray: typeof Uint8ClampedArray !== 'undefined' ? Uint8ClampedArray : Uint8Array, Int16Array: Int16Array, Uint16Array: Uint16Array, Int32Array: Int32Array, Uint32Array: Uint32Array, Float32Array: Float32Array, Float64Array: Float64Array }; /** * @author mrdoob / http://mrdoob.com/ */ function ObjectLoader( manager ) { this.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager; this.resourcePath = ''; } Object.assign( ObjectLoader.prototype, { crossOrigin: 'anonymous', load: function ( url, onLoad, onProgress, onError ) { var scope = this; var path = ( this.path === undefined ) ? LoaderUtils.extractUrlBase( url ) : this.path; this.resourcePath = this.resourcePath || path; var loader = new FileLoader( scope.manager ); loader.setPath( this.path ); loader.load( url, function ( text ) { var json = null; try { json = JSON.parse( text ); } catch ( error ) { if ( onError !== undefined ) onError( error ); console.error( 'THREE:ObjectLoader: Can\\'t parse ' + url + '.', error.message ); return; } var metadata = json.metadata; if ( metadata === undefined || metadata.type === undefined || metadata.type.toLowerCase() === 'geometry' ) { console.error( 'THREE.ObjectLoader: Can\\'t load ' + url ); return; } scope.parse( json, onLoad ); }, onProgress, onError ); }, setPath: function ( value ) { this.path = value; return this; }, setResourcePath: function ( value ) { this.resourcePath = value; return this; }, setCrossOrigin: function ( value ) { this.crossOrigin = value; return this; }, parse: function ( json, onLoad ) { var shapes = this.parseShape( json.shapes ); var geometries = this.parseGeometries( json.geometries, shapes ); var images = this.parseImages( json.images, function () { if ( onLoad !== undefined ) onLoad( object ); } ); var textures = this.parseTextures( json.textures, images ); var materials = this.parseMaterials( json.materials, textures ); var object = this.parseObject( json.object, geometries, materials ); if ( json.animations ) { object.animations = this.parseAnimations( json.animations ); } if ( json.images === undefined || json.images.length === 0 ) { if ( onLoad !== undefined ) onLoad( object ); } return object; }, parseShape: function ( json ) { var shapes = {}; if ( json !== undefined ) { for ( var i = 0, l = json.length; i < l; i ++ ) { var shape = new Shape().fromJSON( json[ i ] ); shapes[ shape.uuid ] = shape; } } return shapes; }, parseGeometries: function ( json, shapes ) { var geometries = {}; if ( json !== undefined ) { var bufferGeometryLoader = new BufferGeometryLoader(); for ( var i = 0, l = json.length; i < l; i ++ ) { var geometry; var data = json[ i ]; switch ( data.type ) { case 'PlaneGeometry': case 'PlaneBufferGeometry': geometry = new Geometries[ data.type ]( data.width, data.height, data.widthSegments, data.heightSegments ); break; case 'BoxGeometry': case 'BoxBufferGeometry': case 'CubeGeometry': // backwards compatible geometry = new Geometries[ data.type ]( data.width, data.height, data.depth, data.widthSegments, data.heightSegments, data.depthSegments ); break; case 'CircleGeometry': case 'CircleBufferGeometry': geometry = new Geometries[ data.type ]( data.radius, data.segments, data.thetaStart, data.thetaLength ); break; case 'CylinderGeometry': case 'CylinderBufferGeometry': geometry = new Geometries[ data.type ]( data.radiusTop, data.radiusBottom, data.height, data.radialSegments, data.heightSegments, data.openEnded, data.thetaStart, data.thetaLength ); break; case 'ConeGeometry': case 'ConeBufferGeometry': geometry = new Geometries[ data.type ]( data.radius, data.height, data.radialSegments, data.heightSegments, data.openEnded, data.thetaStart, data.thetaLength ); break; case 'SphereGeometry': case 'SphereBufferGeometry': geometry = new Geometries[ data.type ]( data.radius, data.widthSegments, data.heightSegments, data.phiStart, data.phiLength, data.thetaStart, data.thetaLength ); break; case 'DodecahedronGeometry': case 'DodecahedronBufferGeometry': case 'IcosahedronGeometry': case 'IcosahedronBufferGeometry': case 'OctahedronGeometry': case 'OctahedronBufferGeometry': case 'TetrahedronGeometry': case 'TetrahedronBufferGeometry': geometry = new Geometries[ data.type ]( data.radius, data.detail ); break; case 'RingGeometry': case 'RingBufferGeometry': geometry = new Geometries[ data.type ]( data.innerRadius, data.outerRadius, data.thetaSegments, data.phiSegments, data.thetaStart, data.thetaLength ); break; case 'TorusGeometry': case 'TorusBufferGeometry': geometry = new Geometries[ data.type ]( data.radius, data.tube, data.radialSegments, data.tubularSegments, data.arc ); break; case 'TorusKnotGeometry': case 'TorusKnotBufferGeometry': geometry = new Geometries[ data.type ]( data.radius, data.tube, data.tubularSegments, data.radialSegments, data.p, data.q ); break; case 'LatheGeometry': case 'LatheBufferGeometry': geometry = new Geometries[ data.type ]( data.points, data.segments, data.phiStart, data.phiLength ); break; case 'PolyhedronGeometry': case 'PolyhedronBufferGeometry': geometry = new Geometries[ data.type ]( data.vertices, data.indices, data.radius, data.details ); break; case 'ShapeGeometry': case 'ShapeBufferGeometry': var geometryShapes = []; for ( var j = 0, jl = data.shapes.length; j < jl; j ++ ) { var shape = shapes[ data.shapes[ j ] ]; geometryShapes.push( shape ); } geometry = new Geometries[ data.type ]( geometryShapes, data.curveSegments ); break; case 'ExtrudeGeometry': case 'ExtrudeBufferGeometry': var geometryShapes = []; for ( var j = 0, jl = data.shapes.length; j < jl; j ++ ) { var shape = shapes[ data.shapes[ j ] ]; geometryShapes.push( shape ); } var extrudePath = data.options.extrudePath; if ( extrudePath !== undefined ) { data.options.extrudePath = new Curves[ extrudePath.type ]().fromJSON( extrudePath ); } geometry = new Geometries[ data.type ]( geometryShapes, data.options ); break; case 'BufferGeometry': geometry = bufferGeometryLoader.parse( data ); break; case 'Geometry': if ( 'THREE' in window && 'LegacyJSONLoader' in THREE ) { var geometryLoader = new THREE.LegacyJSONLoader(); geometry = geometryLoader.parse( data, this.resourcePath ).geometry; } else { console.error( 'THREE.ObjectLoader: You have to import LegacyJSONLoader in order load geometry data of type \"Geometry\".' ); } break; default: console.warn( 'THREE.ObjectLoader: Unsupported geometry type \"' + data.type + '\"' ); continue; } geometry.uuid = data.uuid; if ( data.name !== undefined ) geometry.name = data.name; if ( geometry.isBufferGeometry === true && data.userData !== undefined ) geometry.userData = data.userData; geometries[ data.uuid ] = geometry; } } return geometries; }, parseMaterials: function ( json, textures ) { var cache = {}; // MultiMaterial var materials = {}; if ( json !== undefined ) { var loader = new MaterialLoader(); loader.setTextures( textures ); for ( var i = 0, l = json.length; i < l; i ++ ) { var data = json[ i ]; if ( data.type === 'MultiMaterial' ) { // Deprecated var array = []; for ( var j = 0; j < data.materials.length; j ++ ) { var material = data.materials[ j ]; if ( cache[ material.uuid ] === undefined ) { cache[ material.uuid ] = loader.parse( material ); } array.push( cache[ material.uuid ] ); } materials[ data.uuid ] = array; } else { if ( cache[ data.uuid ] === undefined ) { cache[ data.uuid ] = loader.parse( data ); } materials[ data.uuid ] = cache[ data.uuid ]; } } } return materials; }, parseAnimations: function ( json ) { var animations = []; for ( var i = 0; i < json.length; i ++ ) { var data = json[ i ]; var clip = AnimationClip.parse( data ); if ( data.uuid !== undefined ) clip.uuid = data.uuid; animations.push( clip ); } return animations; }, parseImages: function ( json, onLoad ) { var scope = this; var images = {}; function loadImage( url ) { scope.manager.itemStart( url ); return loader.load( url, function () { scope.manager.itemEnd( url ); }, undefined, function () { scope.manager.itemError( url ); scope.manager.itemEnd( url ); } ); } if ( json !== undefined && json.length > 0 ) { var manager = new LoadingManager( onLoad ); var loader = new ImageLoader( manager ); loader.setCrossOrigin( this.crossOrigin ); for ( var i = 0, il = json.length; i < il; i ++ ) { var image = json[ i ]; var url = image.url; if ( Array.isArray( url ) ) { // load array of images e.g CubeTexture images[ image.uuid ] = []; for ( var j = 0, jl = url.length; j < jl; j ++ ) { var currentUrl = url[ j ]; var path = /^(\\/\\/)|([a-z]+:(\\/\\/)?)/i.test( currentUrl ) ? currentUrl : scope.resourcePath + currentUrl; images[ image.uuid ].push( loadImage( path ) ); } } else { // load single image var path = /^(\\/\\/)|([a-z]+:(\\/\\/)?)/i.test( image.url ) ? image.url : scope.resourcePath + image.url; images[ image.uuid ] = loadImage( path ); } } } return images; }, parseTextures: function ( json, images ) { function parseConstant( value, type ) { if ( typeof value === 'number' ) return value; console.warn( 'THREE.ObjectLoader.parseTexture: Constant should be in numeric form.', value ); return type[ value ]; } var textures = {}; if ( json !== undefined ) { for ( var i = 0, l = json.length; i < l; i ++ ) { var data = json[ i ]; if ( data.image === undefined ) { console.warn( 'THREE.ObjectLoader: No \"image\" specified for', data.uuid ); } if ( images[ data.image ] === undefined ) { console.warn( 'THREE.ObjectLoader: Undefined image', data.image ); } var texture; if ( Array.isArray( images[ data.image ] ) ) { texture = new CubeTexture( images[ data.image ] ); } else { texture = new Texture( images[ data.image ] ); } texture.needsUpdate = true; texture.uuid = data.uuid; if ( data.name !== undefined ) texture.name = data.name; if ( data.mapping !== undefined ) texture.mapping = parseConstant( data.mapping, TEXTURE_MAPPING ); if ( data.offset !== undefined ) texture.offset.fromArray( data.offset ); if ( data.repeat !== undefined ) texture.repeat.fromArray( data.repeat ); if ( data.center !== undefined ) texture.center.fromArray( data.center ); if ( data.rotation !== undefined ) texture.rotation = data.rotation; if ( data.wrap !== undefined ) { texture.wrapS = parseConstant( data.wrap[ 0 ], TEXTURE_WRAPPING ); texture.wrapT = parseConstant( data.wrap[ 1 ], TEXTURE_WRAPPING ); } if ( data.format !== undefined ) texture.format = data.format; if ( data.type !== undefined ) texture.type = data.type; if ( data.encoding !== undefined ) texture.encoding = data.encoding; if ( data.minFilter !== undefined ) texture.minFilter = parseConstant( data.minFilter, TEXTURE_FILTER ); if ( data.magFilter !== undefined ) texture.magFilter = parseConstant( data.magFilter, TEXTURE_FILTER ); if ( data.anisotropy !== undefined ) texture.anisotropy = data.anisotropy; if ( data.flipY !== undefined ) texture.flipY = data.flipY; if ( data.premultiplyAlpha !== undefined ) texture.premultiplyAlpha = data.premultiplyAlpha; if ( data.unpackAlignment !== undefined ) texture.unpackAlignment = data.unpackAlignment; textures[ data.uuid ] = texture; } } return textures; }, parseObject: function ( data, geometries, materials ) { var object; function getGeometry( name ) { if ( geometries[ name ] === undefined ) { console.warn( 'THREE.ObjectLoader: Undefined geometry', name ); } return geometries[ name ]; } function getMaterial( name ) { if ( name === undefined ) return undefined; if ( Array.isArray( name ) ) { var array = []; for ( var i = 0, l = name.length; i < l; i ++ ) { var uuid = name[ i ]; if ( materials[ uuid ] === undefined ) { console.warn( 'THREE.ObjectLoader: Undefined material', uuid ); } array.push( materials[ uuid ] ); } return array; } if ( materials[ name ] === undefined ) { console.warn( 'THREE.ObjectLoader: Undefined material', name ); } return materials[ name ]; } switch ( data.type ) { case 'Scene': object = new Scene(); if ( data.background !== undefined ) { if ( Number.isInteger( data.background ) ) { object.background = new Color( data.background ); } } if ( data.fog !== undefined ) { if ( data.fog.type === 'Fog' ) { object.fog = new Fog( data.fog.color, data.fog.near, data.fog.far ); } else if ( data.fog.type === 'FogExp2' ) { object.fog = new FogExp2( data.fog.color, data.fog.density ); } } break; case 'PerspectiveCamera': object = new PerspectiveCamera( data.fov, data.aspect, data.near, data.far ); if ( data.focus !== undefined ) object.focus = data.focus; if ( data.zoom !== undefined ) object.zoom = data.zoom; if ( data.filmGauge !== undefined ) object.filmGauge = data.filmGauge; if ( data.filmOffset !== undefined ) object.filmOffset = data.filmOffset; if ( data.view !== undefined ) object.view = Object.assign( {}, data.view ); break; case 'OrthographicCamera': object = new OrthographicCamera( data.left, data.right, data.top, data.bottom, data.near, data.far ); if ( data.zoom !== undefined ) object.zoom = data.zoom; if ( data.view !== undefined ) object.view = Object.assign( {}, data.view ); break; case 'AmbientLight': object = new AmbientLight( data.color, data.intensity ); break; case 'DirectionalLight': object = new DirectionalLight( data.color, data.intensity ); break; case 'PointLight': object = new PointLight( data.color, data.intensity, data.distance, data.decay ); break; case 'RectAreaLight': object = new RectAreaLight( data.color, data.intensity, data.width, data.height ); break; case 'SpotLight': object = new SpotLight( data.color, data.intensity, data.distance, data.angle, data.penumbra, data.decay ); break; case 'HemisphereLight': object = new HemisphereLight( data.color, data.groundColor, data.intensity ); break; case 'SkinnedMesh': console.warn( 'THREE.ObjectLoader.parseObject() does not support SkinnedMesh yet.' ); case 'Mesh': var geometry = getGeometry( data.geometry ); var material = getMaterial( data.material ); if ( geometry.bones && geometry.bones.length > 0 ) { object = new SkinnedMesh( geometry, material ); } else { object = new Mesh( geometry, material ); } if ( data.drawMode !== undefined ) object.setDrawMode( data.drawMode ); break; case 'LOD': object = new LOD(); break; case 'Line': object = new Line( getGeometry( data.geometry ), getMaterial( data.material ), data.mode ); break; case 'LineLoop': object = new LineLoop( getGeometry( data.geometry ), getMaterial( data.material ) ); break; case 'LineSegments': object = new LineSegments( getGeometry( data.geometry ), getMaterial( data.material ) ); break; case 'PointCloud': case 'Points': object = new Points( getGeometry( data.geometry ), getMaterial( data.material ) ); break; case 'Sprite': object = new Sprite( getMaterial( data.material ) ); break; case 'Group': object = new Group(); break; default: object = new Object3D(); } object.uuid = data.uuid; if ( data.name !== undefined ) object.name = data.name; if ( data.matrix !== undefined ) { object.matrix.fromArray( data.matrix ); if ( data.matrixAutoUpdate !== undefined ) object.matrixAutoUpdate = data.matrixAutoUpdate; if ( object.matrixAutoUpdate ) object.matrix.decompose( object.position, object.quaternion, object.scale ); } else { if ( data.position !== undefined ) object.position.fromArray( data.position ); if ( data.rotation !== undefined ) object.rotation.fromArray( data.rotation ); if ( data.quaternion !== undefined ) object.quaternion.fromArray( data.quaternion ); if ( data.scale !== undefined ) object.scale.fromArray( data.scale ); } if ( data.castShadow !== undefined ) object.castShadow = data.castShadow; if ( data.receiveShadow !== undefined ) object.receiveShadow = data.receiveShadow; if ( data.shadow ) { if ( data.shadow.bias !== undefined ) object.shadow.bias = data.shadow.bias; if ( data.shadow.radius !== undefined ) object.shadow.radius = data.shadow.radius; if ( data.shadow.mapSize !== undefined ) object.shadow.mapSize.fromArray( data.shadow.mapSize ); if ( data.shadow.camera !== undefined ) object.shadow.camera = this.parseObject( data.shadow.camera ); } if ( data.visible !== undefined ) object.visible = data.visible; if ( data.frustumCulled !== undefined ) object.frustumCulled = data.frustumCulled; if ( data.renderOrder !== undefined ) object.renderOrder = data.renderOrder; if ( data.userData !== undefined ) object.userData = data.userData; if ( data.layers !== undefined ) object.layers.mask = data.layers; if ( data.children !== undefined ) { var children = data.children; for ( var i = 0; i < children.length; i ++ ) { object.add( this.parseObject( children[ i ], geometries, materials ) ); } } if ( data.type === 'LOD' ) { var levels = data.levels; for ( var l = 0; l < levels.length; l ++ ) { var level = levels[ l ]; var child = object.getObjectByProperty( 'uuid', level.object ); if ( child !== undefined ) { object.addLevel( child, level.distance ); } } } return object; } } ); var TEXTURE_MAPPING = { UVMapping: UVMapping, CubeReflectionMapping: CubeReflectionMapping, CubeRefractionMapping: CubeRefractionMapping, EquirectangularReflectionMapping: EquirectangularReflectionMapping, EquirectangularRefractionMapping: EquirectangularRefractionMapping, SphericalReflectionMapping: SphericalReflectionMapping, CubeUVReflectionMapping: CubeUVReflectionMapping, CubeUVRefractionMapping: CubeUVRefractionMapping }; var TEXTURE_WRAPPING = { RepeatWrapping: RepeatWrapping, ClampToEdgeWrapping: ClampToEdgeWrapping, MirroredRepeatWrapping: MirroredRepeatWrapping }; var TEXTURE_FILTER = { NearestFilter: NearestFilter, NearestMipMapNearestFilter: NearestMipMapNearestFilter, NearestMipMapLinearFilter: NearestMipMapLinearFilter, LinearFilter: LinearFilter, LinearMipMapNearestFilter: LinearMipMapNearestFilter, LinearMipMapLinearFilter: LinearMipMapLinearFilter }; /** * @author thespite / http://clicktorelease.com/ */ function ImageBitmapLoader( manager ) { if ( typeof createImageBitmap === 'undefined' ) { console.warn( 'THREE.ImageBitmapLoader: createImageBitmap() not supported.' ); } if ( typeof fetch === 'undefined' ) { console.warn( 'THREE.ImageBitmapLoader: fetch() not supported.' ); } this.manager = manager !== undefined ? manager : DefaultLoadingManager; this.options = undefined; } ImageBitmapLoader.prototype = { constructor: ImageBitmapLoader, setOptions: function setOptions( options ) { this.options = options; return this; }, load: function ( url, onLoad, onProgress, onError ) { if ( url === undefined ) url = ''; if ( this.path !== undefined ) url = this.path + url; url = this.manager.resolveURL( url ); var scope = this; var cached = Cache.get( url ); if ( cached !== undefined ) { scope.manager.itemStart( url ); setTimeout( function () { if ( onLoad ) onLoad( cached ); scope.manager.itemEnd( url ); }, 0 ); return cached; } fetch( url ).then( function ( res ) { return res.blob(); } ).then( function ( blob ) { return createImageBitmap( blob, scope.options ); } ).then( function ( imageBitmap ) { Cache.add( url, imageBitmap ); if ( onLoad ) onLoad( imageBitmap ); scope.manager.itemEnd( url ); } ).catch( function ( e ) { if ( onError ) onError( e ); scope.manager.itemError( url ); scope.manager.itemEnd( url ); } ); }, setCrossOrigin: function ( /* value */ ) { return this; }, setPath: function ( value ) { this.path = value; return this; } }; /** * @author zz85 / http://www.lab4games.net/zz85/blog * minimal class for proxing functions to Path. Replaces old \"extractSubpaths()\" **/ function ShapePath() { this.type = 'ShapePath'; this.color = new Color(); this.subPaths = []; this.currentPath = null; } Object.assign( ShapePath.prototype, { moveTo: function ( x, y ) { this.currentPath = new Path(); this.subPaths.push( this.currentPath ); this.currentPath.moveTo( x, y ); }, lineTo: function ( x, y ) { this.currentPath.lineTo( x, y ); }, quadraticCurveTo: function ( aCPx, aCPy, aX, aY ) { this.currentPath.quadraticCurveTo( aCPx, aCPy, aX, aY ); }, bezierCurveTo: function ( aCP1x, aCP1y, aCP2x, aCP2y, aX, aY ) { this.currentPath.bezierCurveTo( aCP1x, aCP1y, aCP2x, aCP2y, aX, aY ); }, splineThru: function ( pts ) { this.currentPath.splineThru( pts ); }, toShapes: function ( isCCW, noHoles ) { function toShapesNoHoles( inSubpaths ) { var shapes = []; for ( var i = 0, l = inSubpaths.length; i < l; i ++ ) { var tmpPath = inSubpaths[ i ]; var tmpShape = new Shape(); tmpShape.curves = tmpPath.curves; shapes.push( tmpShape ); } return shapes; } function isPointInsidePolygon( inPt, inPolygon ) { var polyLen = inPolygon.length; // inPt on polygon contour => immediate success or // toggling of inside/outside at every single! intersection point of an edge // with the horizontal line through inPt, left of inPt // not counting lowerY endpoints of edges and whole edges on that line var inside = false; for ( var p = polyLen - 1, q = 0; q < polyLen; p = q ++ ) { var edgeLowPt = inPolygon[ p ]; var edgeHighPt = inPolygon[ q ]; var edgeDx = edgeHighPt.x - edgeLowPt.x; var edgeDy = edgeHighPt.y - edgeLowPt.y; if ( Math.abs( edgeDy ) > Number.EPSILON ) { // not parallel if ( edgeDy < 0 ) { edgeLowPt = inPolygon[ q ]; edgeDx = - edgeDx; edgeHighPt = inPolygon[ p ]; edgeDy = - edgeDy; } if ( ( inPt.y < edgeLowPt.y ) || ( inPt.y > edgeHighPt.y ) ) continue; if ( inPt.y === edgeLowPt.y ) { if ( inPt.x === edgeLowPt.x ) return true; // inPt is on contour ? // continue; // no intersection or edgeLowPt => doesn't count !!! } else { var perpEdge = edgeDy * ( inPt.x - edgeLowPt.x ) - edgeDx * ( inPt.y - edgeLowPt.y ); if ( perpEdge === 0 ) return true; // inPt is on contour ? if ( perpEdge < 0 ) continue; inside = ! inside; // true intersection left of inPt } } else { // parallel or collinear if ( inPt.y !== edgeLowPt.y ) continue; // parallel // edge lies on the same horizontal line as inPt if ( ( ( edgeHighPt.x 1 ) { var ambiguous = false; var toChange = []; for ( var sIdx = 0, sLen = newShapes.length; sIdx < sLen; sIdx ++ ) { betterShapeHoles[ sIdx ] = []; } for ( var sIdx = 0, sLen = newShapes.length; sIdx < sLen; sIdx ++ ) { var sho = newShapeHoles[ sIdx ]; for ( var hIdx = 0; hIdx < sho.length; hIdx ++ ) { var ho = sho[ hIdx ]; var hole_unassigned = true; for ( var s2Idx = 0; s2Idx < newShapes.length; s2Idx ++ ) { if ( isPointInsidePolygon( ho.p, newShapes[ s2Idx ].p ) ) { if ( sIdx !== s2Idx ) toChange.push( { froms: sIdx, tos: s2Idx, hole: hIdx } ); if ( hole_unassigned ) { hole_unassigned = false; betterShapeHoles[ s2Idx ].push( ho ); } else { ambiguous = true; } } } if ( hole_unassigned ) { betterShapeHoles[ sIdx ].push( ho ); } } } // console.log(\"ambiguous: \", ambiguous); if ( toChange.length > 0 ) { // console.log(\"to change: \", toChange); if ( ! ambiguous ) newShapeHoles = betterShapeHoles; } } var tmpHoles; for ( var i = 0, il = newShapes.length; i < il; i ++ ) { tmpShape = newShapes[ i ].s; shapes.push( tmpShape ); tmpHoles = newShapeHoles[ i ]; for ( var j = 0, jl = tmpHoles.length; j < jl; j ++ ) { tmpShape.holes.push( tmpHoles[ j ].h ); } } //console.log(\"shape\", shapes); return shapes; } } ); /** * @author zz85 / http://www.lab4games.net/zz85/blog * @author mrdoob / http://mrdoob.com/ */ function Font( data ) { this.type = 'Font'; this.data = data; } Object.assign( Font.prototype, { isFont: true, generateShapes: function ( text, size ) { if ( size === undefined ) size = 100; var shapes = []; var paths = createPaths( text, size, this.data ); for ( var p = 0, pl = paths.length; p < pl; p ++ ) { Array.prototype.push.apply( shapes, paths[ p ].toShapes() ); } return shapes; } } ); function createPaths( text, size, data ) { var chars = Array.from ? Array.from( text ) : String( text ).split( '' ); // see #13988 var scale = size / data.resolution; var line_height = ( data.boundingBox.yMax - data.boundingBox.yMin + data.underlineThickness ) * scale; var paths = []; var offsetX = 0, offsetY = 0; for ( var i = 0; i < chars.length; i ++ ) { var char = chars[ i ]; if ( char === '\\n' ) { offsetX = 0; offsetY -= line_height; } else { var ret = createPath( char, scale, offsetX, offsetY, data ); offsetX += ret.offsetX; paths.push( ret.path ); } } return paths; } function createPath( char, scale, offsetX, offsetY, data ) { var glyph = data.glyphs[ char ] || data.glyphs[ '?' ]; if ( ! glyph ) return; var path = new ShapePath(); var x, y, cpx, cpy, cpx1, cpy1, cpx2, cpy2; if ( glyph.o ) { var outline = glyph._cachedOutline || ( glyph._cachedOutline = glyph.o.split( ' ' ) ); for ( var i = 0, l = outline.length; i < l; ) { var action = outline[ i ++ ]; switch ( action ) { case 'm': // moveTo x = outline[ i ++ ] * scale + offsetX; y = outline[ i ++ ] * scale + offsetY; path.moveTo( x, y ); break; case 'l': // lineTo x = outline[ i ++ ] * scale + offsetX; y = outline[ i ++ ] * scale + offsetY; path.lineTo( x, y ); break; case 'q': // quadraticCurveTo cpx = outline[ i ++ ] * scale + offsetX; cpy = outline[ i ++ ] * scale + offsetY; cpx1 = outline[ i ++ ] * scale + offsetX; cpy1 = outline[ i ++ ] * scale + offsetY; path.quadraticCurveTo( cpx1, cpy1, cpx, cpy ); break; case 'b': // bezierCurveTo cpx = outline[ i ++ ] * scale + offsetX; cpy = outline[ i ++ ] * scale + offsetY; cpx1 = outline[ i ++ ] * scale + offsetX; cpy1 = outline[ i ++ ] * scale + offsetY; cpx2 = outline[ i ++ ] * scale + offsetX; cpy2 = outline[ i ++ ] * scale + offsetY; path.bezierCurveTo( cpx1, cpy1, cpx2, cpy2, cpx, cpy ); break; } } } return { offsetX: glyph.ha * scale, path: path }; } /** * @author mrdoob / http://mrdoob.com/ */ function FontLoader( manager ) { this.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager; } Object.assign( FontLoader.prototype, { load: function ( url, onLoad, onProgress, onError ) { var scope = this; var loader = new FileLoader( this.manager ); loader.setPath( this.path ); loader.load( url, function ( text ) { var json; try { json = JSON.parse( text ); } catch ( e ) { console.warn( 'THREE.FontLoader: typeface.js support is being deprecated. Use typeface.json instead.' ); json = JSON.parse( text.substring( 65, text.length - 2 ) ); } var font = scope.parse( json ); if ( onLoad ) onLoad( font ); }, onProgress, onError ); }, parse: function ( json ) { return new Font( json ); }, setPath: function ( value ) { this.path = value; return this; } } ); /** * @author alteredq / http://alteredqualia.com/ */ function Loader() {} Loader.Handlers = { handlers: [], add: function ( regex, loader ) { this.handlers.push( regex, loader ); }, get: function ( file ) { var handlers = this.handlers; for ( var i = 0, l = handlers.length; i < l; i += 2 ) { var regex = handlers[ i ]; var loader = handlers[ i + 1 ]; if ( regex.test( file ) ) { return loader; } } return null; } }; Object.assign( Loader.prototype, { crossOrigin: 'anonymous', onLoadStart: function () {}, onLoadProgress: function () {}, onLoadComplete: function () {}, initMaterials: function ( materials, texturePath, crossOrigin ) { var array = []; for ( var i = 0; i < materials.length; ++ i ) { array[ i ] = this.createMaterial( materials[ i ], texturePath, crossOrigin ); } return array; }, createMaterial: ( function () { var BlendingMode = { NoBlending: NoBlending, NormalBlending: NormalBlending, AdditiveBlending: AdditiveBlending, SubtractiveBlending: SubtractiveBlending, MultiplyBlending: MultiplyBlending, CustomBlending: CustomBlending }; var color = new Color(); var textureLoader = new TextureLoader(); var materialLoader = new MaterialLoader(); return function createMaterial( m, texturePath, crossOrigin ) { // convert from old material format var textures = {}; function loadTexture( path, repeat, offset, wrap, anisotropy ) { var fullPath = texturePath + path; var loader = Loader.Handlers.get( fullPath ); var texture; if ( loader !== null ) { texture = loader.load( fullPath ); } else { textureLoader.setCrossOrigin( crossOrigin ); texture = textureLoader.load( fullPath ); } if ( repeat !== undefined ) { texture.repeat.fromArray( repeat ); if ( repeat[ 0 ] !== 1 ) texture.wrapS = RepeatWrapping; if ( repeat[ 1 ] !== 1 ) texture.wrapT = RepeatWrapping; } if ( offset !== undefined ) { texture.offset.fromArray( offset ); } if ( wrap !== undefined ) { if ( wrap[ 0 ] === 'repeat' ) texture.wrapS = RepeatWrapping; if ( wrap[ 0 ] === 'mirror' ) texture.wrapS = MirroredRepeatWrapping; if ( wrap[ 1 ] === 'repeat' ) texture.wrapT = RepeatWrapping; if ( wrap[ 1 ] === 'mirror' ) texture.wrapT = MirroredRepeatWrapping; } if ( anisotropy !== undefined ) { texture.anisotropy = anisotropy; } var uuid = _Math.generateUUID(); textures[ uuid ] = texture; return uuid; } // var json = { uuid: _Math.generateUUID(), type: 'MeshLambertMaterial' }; for ( var name in m ) { var value = m[ name ]; switch ( name ) { case 'DbgColor': case 'DbgIndex': case 'opticalDensity': case 'illumination': break; case 'DbgName': json.name = value; break; case 'blending': json.blending = BlendingMode[ value ]; break; case 'colorAmbient': case 'mapAmbient': console.warn( 'THREE.Loader.createMaterial:', name, 'is no longer supported.' ); break; case 'colorDiffuse': json.color = color.fromArray( value ).getHex(); break; case 'colorSpecular': json.specular = color.fromArray( value ).getHex(); break; case 'colorEmissive': json.emissive = color.fromArray( value ).getHex(); break; case 'specularCoef': json.shininess = value; break; case 'shading': if ( value.toLowerCase() === 'basic' ) json.type = 'MeshBasicMaterial'; if ( value.toLowerCase() === 'phong' ) json.type = 'MeshPhongMaterial'; if ( value.toLowerCase() === 'standard' ) json.type = 'MeshStandardMaterial'; break; case 'mapDiffuse': json.map = loadTexture( value, m.mapDiffuseRepeat, m.mapDiffuseOffset, m.mapDiffuseWrap, m.mapDiffuseAnisotropy ); break; case 'mapDiffuseRepeat': case 'mapDiffuseOffset': case 'mapDiffuseWrap': case 'mapDiffuseAnisotropy': break; case 'mapEmissive': json.emissiveMap = loadTexture( value, m.mapEmissiveRepeat, m.mapEmissiveOffset, m.mapEmissiveWrap, m.mapEmissiveAnisotropy ); break; case 'mapEmissiveRepeat': case 'mapEmissiveOffset': case 'mapEmissiveWrap': case 'mapEmissiveAnisotropy': break; case 'mapLight': json.lightMap = loadTexture( value, m.mapLightRepeat, m.mapLightOffset, m.mapLightWrap, m.mapLightAnisotropy ); break; case 'mapLightRepeat': case 'mapLightOffset': case 'mapLightWrap': case 'mapLightAnisotropy': break; case 'mapAO': json.aoMap = loadTexture( value, m.mapAORepeat, m.mapAOOffset, m.mapAOWrap, m.mapAOAnisotropy ); break; case 'mapAORepeat': case 'mapAOOffset': case 'mapAOWrap': case 'mapAOAnisotropy': break; case 'mapBump': json.bumpMap = loadTexture( value, m.mapBumpRepeat, m.mapBumpOffset, m.mapBumpWrap, m.mapBumpAnisotropy ); break; case 'mapBumpScale': json.bumpScale = value; break; case 'mapBumpRepeat': case 'mapBumpOffset': case 'mapBumpWrap': case 'mapBumpAnisotropy': break; case 'mapNormal': json.normalMap = loadTexture( value, m.mapNormalRepeat, m.mapNormalOffset, m.mapNormalWrap, m.mapNormalAnisotropy ); break; case 'mapNormalFactor': json.normalScale = value; break; case 'mapNormalRepeat': case 'mapNormalOffset': case 'mapNormalWrap': case 'mapNormalAnisotropy': break; case 'mapSpecular': json.specularMap = loadTexture( value, m.mapSpecularRepeat, m.mapSpecularOffset, m.mapSpecularWrap, m.mapSpecularAnisotropy ); break; case 'mapSpecularRepeat': case 'mapSpecularOffset': case 'mapSpecularWrap': case 'mapSpecularAnisotropy': break; case 'mapMetalness': json.metalnessMap = loadTexture( value, m.mapMetalnessRepeat, m.mapMetalnessOffset, m.mapMetalnessWrap, m.mapMetalnessAnisotropy ); break; case 'mapMetalnessRepeat': case 'mapMetalnessOffset': case 'mapMetalnessWrap': case 'mapMetalnessAnisotropy': break; case 'mapRoughness': json.roughnessMap = loadTexture( value, m.mapRoughnessRepeat, m.mapRoughnessOffset, m.mapRoughnessWrap, m.mapRoughnessAnisotropy ); break; case 'mapRoughnessRepeat': case 'mapRoughnessOffset': case 'mapRoughnessWrap': case 'mapRoughnessAnisotropy': break; case 'mapAlpha': json.alphaMap = loadTexture( value, m.mapAlphaRepeat, m.mapAlphaOffset, m.mapAlphaWrap, m.mapAlphaAnisotropy ); break; case 'mapAlphaRepeat': case 'mapAlphaOffset': case 'mapAlphaWrap': case 'mapAlphaAnisotropy': break; case 'flipSided': json.side = BackSide; break; case 'doubleSided': json.side = DoubleSide; break; case 'transparency': console.warn( 'THREE.Loader.createMaterial: transparency has been renamed to opacity' ); json.opacity = value; break; case 'depthTest': case 'depthWrite': case 'colorWrite': case 'opacity': case 'reflectivity': case 'transparent': case 'visible': case 'wireframe': json[ name ] = value; break; case 'vertexColors': if ( value === true ) json.vertexColors = VertexColors; if ( value === 'face' ) json.vertexColors = FaceColors; break; default: console.error( 'THREE.Loader.createMaterial: Unsupported', name, value ); break; } } if ( json.type === 'MeshBasicMaterial' ) delete json.emissive; if ( json.type !== 'MeshPhongMaterial' ) delete json.specular; if ( json.opacity < 1 ) json.transparent = true; materialLoader.setTextures( textures ); return materialLoader.parse( json ); }; } )() } ); /** * @author mrdoob / http://mrdoob.com/ */ var context; var AudioContext = { getContext: function () { if ( context === undefined ) { context = new ( window.AudioContext || window.webkitAudioContext )(); } return context; }, setContext: function ( value ) { context = value; } }; /** * @author Reece Aaron Lecrivain / http://reecenotes.com/ */ function AudioLoader( manager ) { this.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager; } Object.assign( AudioLoader.prototype, { load: function ( url, onLoad, onProgress, onError ) { var loader = new FileLoader( this.manager ); loader.setResponseType( 'arraybuffer' ); loader.setPath( this.path ); loader.load( url, function ( buffer ) { // Create a copy of the buffer. The `decodeAudioData` method // detaches the buffer when complete, preventing reuse. var bufferCopy = buffer.slice( 0 ); var context = AudioContext.getContext(); context.decodeAudioData( bufferCopy, function ( audioBuffer ) { onLoad( audioBuffer ); } ); }, onProgress, onError ); }, setPath: function ( value ) { this.path = value; return this; } } ); /** * @author mrdoob / http://mrdoob.com/ */ function StereoCamera() { this.type = 'StereoCamera'; this.aspect = 1; this.eyeSep = 0.064; this.cameraL = new PerspectiveCamera(); this.cameraL.layers.enable( 1 ); this.cameraL.matrixAutoUpdate = false; this.cameraR = new PerspectiveCamera(); this.cameraR.layers.enable( 2 ); this.cameraR.matrixAutoUpdate = false; } Object.assign( StereoCamera.prototype, { update: ( function () { var instance, focus, fov, aspect, near, far, zoom, eyeSep; var eyeRight = new Matrix4(); var eyeLeft = new Matrix4(); return function update( camera ) { var needsUpdate = instance !== this || focus !== camera.focus || fov !== camera.fov || aspect !== camera.aspect * this.aspect || near !== camera.near || far !== camera.far || zoom !== camera.zoom || eyeSep !== this.eyeSep; if ( needsUpdate ) { instance = this; focus = camera.focus; fov = camera.fov; aspect = camera.aspect * this.aspect; near = camera.near; far = camera.far; zoom = camera.zoom; // Off-axis stereoscopic effect based on // http://paulbourke.net/stereographics/stereorender/ var projectionMatrix = camera.projectionMatrix.clone(); eyeSep = this.eyeSep / 2; var eyeSepOnProjection = eyeSep * near / focus; var ymax = ( near * Math.tan( _Math.DEG2RAD * fov * 0.5 ) ) / zoom; var xmin, xmax; // translate xOffset eyeLeft.elements[ 12 ] = - eyeSep; eyeRight.elements[ 12 ] = eyeSep; // for left eye xmin = - ymax * aspect + eyeSepOnProjection; xmax = ymax * aspect + eyeSepOnProjection; projectionMatrix.elements[ 0 ] = 2 * near / ( xmax - xmin ); projectionMatrix.elements[ 8 ] = ( xmax + xmin ) / ( xmax - xmin ); this.cameraL.projectionMatrix.copy( projectionMatrix ); // for right eye xmin = - ymax * aspect - eyeSepOnProjection; xmax = ymax * aspect - eyeSepOnProjection; projectionMatrix.elements[ 0 ] = 2 * near / ( xmax - xmin ); projectionMatrix.elements[ 8 ] = ( xmax + xmin ) / ( xmax - xmin ); this.cameraR.projectionMatrix.copy( projectionMatrix ); } this.cameraL.matrixWorld.copy( camera.matrixWorld ).multiply( eyeLeft ); this.cameraR.matrixWorld.copy( camera.matrixWorld ).multiply( eyeRight ); }; } )() } ); /** * Camera for rendering cube maps * - renders scene into axis-aligned cube * * @author alteredq / http://alteredqualia.com/ */ function CubeCamera( near, far, cubeResolution, options ) { Object3D.call( this ); this.type = 'CubeCamera'; var fov = 90, aspect = 1; var cameraPX = new PerspectiveCamera( fov, aspect, near, far ); cameraPX.up.set( 0, - 1, 0 ); cameraPX.lookAt( new Vector3( 1, 0, 0 ) ); this.add( cameraPX ); var cameraNX = new PerspectiveCamera( fov, aspect, near, far ); cameraNX.up.set( 0, - 1, 0 ); cameraNX.lookAt( new Vector3( - 1, 0, 0 ) ); this.add( cameraNX ); var cameraPY = new PerspectiveCamera( fov, aspect, near, far ); cameraPY.up.set( 0, 0, 1 ); cameraPY.lookAt( new Vector3( 0, 1, 0 ) ); this.add( cameraPY ); var cameraNY = new PerspectiveCamera( fov, aspect, near, far ); cameraNY.up.set( 0, 0, - 1 ); cameraNY.lookAt( new Vector3( 0, - 1, 0 ) ); this.add( cameraNY ); var cameraPZ = new PerspectiveCamera( fov, aspect, near, far ); cameraPZ.up.set( 0, - 1, 0 ); cameraPZ.lookAt( new Vector3( 0, 0, 1 ) ); this.add( cameraPZ ); var cameraNZ = new PerspectiveCamera( fov, aspect, near, far ); cameraNZ.up.set( 0, - 1, 0 ); cameraNZ.lookAt( new Vector3( 0, 0, - 1 ) ); this.add( cameraNZ ); options = options || { format: RGBFormat, magFilter: LinearFilter, minFilter: LinearFilter }; this.renderTarget = new WebGLRenderTargetCube( cubeResolution, cubeResolution, options ); this.renderTarget.texture.name = \"CubeCamera\"; this.update = function ( renderer, scene ) { if ( this.parent === null ) this.updateMatrixWorld(); var currentRenderTarget = renderer.getRenderTarget(); var renderTarget = this.renderTarget; var generateMipmaps = renderTarget.texture.generateMipmaps; renderTarget.texture.generateMipmaps = false; renderTarget.activeCubeFace = 0; renderer.setRenderTarget( renderTarget ); renderer.render( scene, cameraPX ); renderTarget.activeCubeFace = 1; renderer.render( scene, cameraNX ); renderTarget.activeCubeFace = 2; renderer.render( scene, cameraPY ); renderTarget.activeCubeFace = 3; renderer.render( scene, cameraNY ); renderTarget.activeCubeFace = 4; renderer.render( scene, cameraPZ ); renderTarget.texture.generateMipmaps = generateMipmaps; renderTarget.activeCubeFace = 5; renderer.render( scene, cameraNZ ); renderer.setRenderTarget( currentRenderTarget ); }; this.clear = function ( renderer, color, depth, stencil ) { var currentRenderTarget = renderer.getRenderTarget(); var renderTarget = this.renderTarget; for ( var i = 0; i < 6; i ++ ) { renderTarget.activeCubeFace = i; renderer.setRenderTarget( renderTarget ); renderer.clear( color, depth, stencil ); } renderer.setRenderTarget( currentRenderTarget ); }; } CubeCamera.prototype = Object.create( Object3D.prototype ); CubeCamera.prototype.constructor = CubeCamera; /** * @author alteredq / http://alteredqualia.com/ */ function Clock( autoStart ) { this.autoStart = ( autoStart !== undefined ) ? autoStart : true; this.startTime = 0; this.oldTime = 0; this.elapsedTime = 0; this.running = false; } Object.assign( Clock.prototype, { start: function () { this.startTime = ( typeof performance === 'undefined' ? Date : performance ).now(); // see #10732 this.oldTime = this.startTime; this.elapsedTime = 0; this.running = true; }, stop: function () { this.getElapsedTime(); this.running = false; this.autoStart = false; }, getElapsedTime: function () { this.getDelta(); return this.elapsedTime; }, getDelta: function () { var diff = 0; if ( this.autoStart && ! this.running ) { this.start(); return 0; } if ( this.running ) { var newTime = ( typeof performance === 'undefined' ? Date : performance ).now(); diff = ( newTime - this.oldTime ) / 1000; this.oldTime = newTime; this.elapsedTime += diff; } return diff; } } ); /** * @author mrdoob / http://mrdoob.com/ */ function AudioListener() { Object3D.call( this ); this.type = 'AudioListener'; this.context = AudioContext.getContext(); this.gain = this.context.createGain(); this.gain.connect( this.context.destination ); this.filter = null; this.timeDelta = 0; } AudioListener.prototype = Object.assign( Object.create( Object3D.prototype ), { constructor: AudioListener, getInput: function () { return this.gain; }, removeFilter: function ( ) { if ( this.filter !== null ) { this.gain.disconnect( this.filter ); this.filter.disconnect( this.context.destination ); this.gain.connect( this.context.destination ); this.filter = null; } return this; }, getFilter: function () { return this.filter; }, setFilter: function ( value ) { if ( this.filter !== null ) { this.gain.disconnect( this.filter ); this.filter.disconnect( this.context.destination ); } else { this.gain.disconnect( this.context.destination ); } this.filter = value; this.gain.connect( this.filter ); this.filter.connect( this.context.destination ); return this; }, getMasterVolume: function () { return this.gain.gain.value; }, setMasterVolume: function ( value ) { this.gain.gain.setTargetAtTime( value, this.context.currentTime, 0.01 ); return this; }, updateMatrixWorld: ( function () { var position = new Vector3(); var quaternion = new Quaternion(); var scale = new Vector3(); var orientation = new Vector3(); var clock = new Clock(); return function updateMatrixWorld( force ) { Object3D.prototype.updateMatrixWorld.call( this, force ); var listener = this.context.listener; var up = this.up; this.timeDelta = clock.getDelta(); this.matrixWorld.decompose( position, quaternion, scale ); orientation.set( 0, 0, - 1 ).applyQuaternion( quaternion ); if ( listener.positionX ) { // code path for Chrome (see #14393) var endTime = this.context.currentTime + this.timeDelta; listener.positionX.linearRampToValueAtTime( position.x, endTime ); listener.positionY.linearRampToValueAtTime( position.y, endTime ); listener.positionZ.linearRampToValueAtTime( position.z, endTime ); listener.forwardX.linearRampToValueAtTime( orientation.x, endTime ); listener.forwardY.linearRampToValueAtTime( orientation.y, endTime ); listener.forwardZ.linearRampToValueAtTime( orientation.z, endTime ); listener.upX.linearRampToValueAtTime( up.x, endTime ); listener.upY.linearRampToValueAtTime( up.y, endTime ); listener.upZ.linearRampToValueAtTime( up.z, endTime ); } else { listener.setPosition( position.x, position.y, position.z ); listener.setOrientation( orientation.x, orientation.y, orientation.z, up.x, up.y, up.z ); } }; } )() } ); /** * @author mrdoob / http://mrdoob.com/ * @author Reece Aaron Lecrivain / http://reecenotes.com/ */ function Audio( listener ) { Object3D.call( this ); this.type = 'Audio'; this.listener = listener; this.context = listener.context; this.gain = this.context.createGain(); this.gain.connect( listener.getInput() ); this.autoplay = false; this.buffer = null; this.detune = 0; this.loop = false; this.startTime = 0; this.offset = 0; this.playbackRate = 1; this.isPlaying = false; this.hasPlaybackControl = true; this.sourceType = 'empty'; this.filters = []; } Audio.prototype = Object.assign( Object.create( Object3D.prototype ), { constructor: Audio, getOutput: function () { return this.gain; }, setNodeSource: function ( audioNode ) { this.hasPlaybackControl = false; this.sourceType = 'audioNode'; this.source = audioNode; this.connect(); return this; }, setMediaElementSource: function ( mediaElement ) { this.hasPlaybackControl = false; this.sourceType = 'mediaNode'; this.source = this.context.createMediaElementSource( mediaElement ); this.connect(); return this; }, setBuffer: function ( audioBuffer ) { this.buffer = audioBuffer; this.sourceType = 'buffer'; if ( this.autoplay ) this.play(); return this; }, play: function () { if ( this.isPlaying === true ) { console.warn( 'THREE.Audio: Audio is already playing.' ); return; } if ( this.hasPlaybackControl === false ) { console.warn( 'THREE.Audio: this Audio has no playback control.' ); return; } var source = this.context.createBufferSource(); source.buffer = this.buffer; source.loop = this.loop; source.onended = this.onEnded.bind( this ); this.startTime = this.context.currentTime; source.start( this.startTime, this.offset ); this.isPlaying = true; this.source = source; this.setDetune( this.detune ); this.setPlaybackRate( this.playbackRate ); return this.connect(); }, pause: function () { if ( this.hasPlaybackControl === false ) { console.warn( 'THREE.Audio: this Audio has no playback control.' ); return; } if ( this.isPlaying === true ) { this.source.stop(); this.source.onended = null; this.offset += ( this.context.currentTime - this.startTime ) * this.playbackRate; this.isPlaying = false; } return this; }, stop: function () { if ( this.hasPlaybackControl === false ) { console.warn( 'THREE.Audio: this Audio has no playback control.' ); return; } this.source.stop(); this.source.onended = null; this.offset = 0; this.isPlaying = false; return this; }, connect: function () { if ( this.filters.length > 0 ) { this.source.connect( this.filters[ 0 ] ); for ( var i = 1, l = this.filters.length; i < l; i ++ ) { this.filters[ i - 1 ].connect( this.filters[ i ] ); } this.filters[ this.filters.length - 1 ].connect( this.getOutput() ); } else { this.source.connect( this.getOutput() ); } return this; }, disconnect: function () { if ( this.filters.length > 0 ) { this.source.disconnect( this.filters[ 0 ] ); for ( var i = 1, l = this.filters.length; i < l; i ++ ) { this.filters[ i - 1 ].disconnect( this.filters[ i ] ); } this.filters[ this.filters.length - 1 ].disconnect( this.getOutput() ); } else { this.source.disconnect( this.getOutput() ); } return this; }, getFilters: function () { return this.filters; }, setFilters: function ( value ) { if ( ! value ) value = []; if ( this.isPlaying === true ) { this.disconnect(); this.filters = value; this.connect(); } else { this.filters = value; } return this; }, setDetune: function ( value ) { this.detune = value; if ( this.source.detune === undefined ) return; // only set detune when available if ( this.isPlaying === true ) { this.source.detune.setTargetAtTime( this.detune, this.context.currentTime, 0.01 ); } return this; }, getDetune: function () { return this.detune; }, getFilter: function () { return this.getFilters()[ 0 ]; }, setFilter: function ( filter ) { return this.setFilters( filter ? [ filter ] : [] ); }, setPlaybackRate: function ( value ) { if ( this.hasPlaybackControl === false ) { console.warn( 'THREE.Audio: this Audio has no playback control.' ); return; } this.playbackRate = value; if ( this.isPlaying === true ) { this.source.playbackRate.setTargetAtTime( this.playbackRate, this.context.currentTime, 0.01 ); } return this; }, getPlaybackRate: function () { return this.playbackRate; }, onEnded: function () { this.isPlaying = false; }, getLoop: function () { if ( this.hasPlaybackControl === false ) { console.warn( 'THREE.Audio: this Audio has no playback control.' ); return false; } return this.loop; }, setLoop: function ( value ) { if ( this.hasPlaybackControl === false ) { console.warn( 'THREE.Audio: this Audio has no playback control.' ); return; } this.loop = value; if ( this.isPlaying === true ) { this.source.loop = this.loop; } return this; }, getVolume: function () { return this.gain.gain.value; }, setVolume: function ( value ) { this.gain.gain.setTargetAtTime( value, this.context.currentTime, 0.01 ); return this; } } ); /** * @author mrdoob / http://mrdoob.com/ */ function PositionalAudio( listener ) { Audio.call( this, listener ); this.panner = this.context.createPanner(); this.panner.connect( this.gain ); } PositionalAudio.prototype = Object.assign( Object.create( Audio.prototype ), { constructor: PositionalAudio, getOutput: function () { return this.panner; }, getRefDistance: function () { return this.panner.refDistance; }, setRefDistance: function ( value ) { this.panner.refDistance = value; return this; }, getRolloffFactor: function () { return this.panner.rolloffFactor; }, setRolloffFactor: function ( value ) { this.panner.rolloffFactor = value; return this; }, getDistanceModel: function () { return this.panner.distanceModel; }, setDistanceModel: function ( value ) { this.panner.distanceModel = value; return this; }, getMaxDistance: function () { return this.panner.maxDistance; }, setMaxDistance: function ( value ) { this.panner.maxDistance = value; return this; }, setDirectionalCone: function ( coneInnerAngle, coneOuterAngle, coneOuterGain ) { this.panner.coneInnerAngle = coneInnerAngle; this.panner.coneOuterAngle = coneOuterAngle; this.panner.coneOuterGain = coneOuterGain; return this; }, updateMatrixWorld: ( function () { var position = new Vector3(); var quaternion = new Quaternion(); var scale = new Vector3(); var orientation = new Vector3(); return function updateMatrixWorld( force ) { Object3D.prototype.updateMatrixWorld.call( this, force ); if ( this.hasPlaybackControl === true && this.isPlaying === false ) return; this.matrixWorld.decompose( position, quaternion, scale ); orientation.set( 0, 0, 1 ).applyQuaternion( quaternion ); var panner = this.panner; if ( panner.positionX ) { // code path for Chrome and Firefox (see #14393) var endTime = this.context.currentTime + this.listener.timeDelta; panner.positionX.linearRampToValueAtTime( position.x, endTime ); panner.positionY.linearRampToValueAtTime( position.y, endTime ); panner.positionZ.linearRampToValueAtTime( position.z, endTime ); panner.orientationX.linearRampToValueAtTime( orientation.x, endTime ); panner.orientationY.linearRampToValueAtTime( orientation.y, endTime ); panner.orientationZ.linearRampToValueAtTime( orientation.z, endTime ); } else { panner.setPosition( position.x, position.y, position.z ); panner.setOrientation( orientation.x, orientation.y, orientation.z ); } }; } )() } ); /** * @author mrdoob / http://mrdoob.com/ */ function AudioAnalyser( audio, fftSize ) { this.analyser = audio.context.createAnalyser(); this.analyser.fftSize = fftSize !== undefined ? fftSize : 2048; this.data = new Uint8Array( this.analyser.frequencyBinCount ); audio.getOutput().connect( this.analyser ); } Object.assign( AudioAnalyser.prototype, { getFrequencyData: function () { this.analyser.getByteFrequencyData( this.data ); return this.data; }, getAverageFrequency: function () { var value = 0, data = this.getFrequencyData(); for ( var i = 0; i < data.length; i ++ ) { value += data[ i ]; } return value / data.length; } } ); /** * * Buffered scene graph property that allows weighted accumulation. * * * @author Ben Houston / http://clara.io/ * @author David Sarno / http://lighthaus.us/ * @author tschw */ function PropertyMixer( binding, typeName, valueSize ) { this.binding = binding; this.valueSize = valueSize; var bufferType = Float64Array, mixFunction; switch ( typeName ) { case 'quaternion': mixFunction = this._slerp; break; case 'string': case 'bool': bufferType = Array; mixFunction = this._select; break; default: mixFunction = this._lerp; } this.buffer = new bufferType( valueSize * 4 ); // layout: [ incoming | accu0 | accu1 | orig ] // // interpolators can use .buffer as their .result // the data then goes to 'incoming' // // 'accu0' and 'accu1' are used frame-interleaved for // the cumulative result and are compared to detect // changes // // 'orig' stores the original state of the property this._mixBufferRegion = mixFunction; this.cumulativeWeight = 0; this.useCount = 0; this.referenceCount = 0; } Object.assign( PropertyMixer.prototype, { // accumulate data in the 'incoming' region into 'accu' accumulate: function ( accuIndex, weight ) { // note: happily accumulating nothing when weight = 0, the caller knows // the weight and shouldn't have made the call in the first place var buffer = this.buffer, stride = this.valueSize, offset = accuIndex * stride + stride, currentWeight = this.cumulativeWeight; if ( currentWeight === 0 ) { // accuN := incoming * weight for ( var i = 0; i !== stride; ++ i ) { buffer[ offset + i ] = buffer[ i ]; } currentWeight = weight; } else { // accuN := accuN + incoming * weight currentWeight += weight; var mix = weight / currentWeight; this._mixBufferRegion( buffer, offset, 0, mix, stride ); } this.cumulativeWeight = currentWeight; }, // apply the state of 'accu' to the binding when accus differ apply: function ( accuIndex ) { var stride = this.valueSize, buffer = this.buffer, offset = accuIndex * stride + stride, weight = this.cumulativeWeight, binding = this.binding; this.cumulativeWeight = 0; if ( weight < 1 ) { // accuN := accuN + original * ( 1 - cumulativeWeight ) var originalValueOffset = stride * 3; this._mixBufferRegion( buffer, offset, originalValueOffset, 1 - weight, stride ); } for ( var i = stride, e = stride + stride; i !== e; ++ i ) { if ( buffer[ i ] !== buffer[ i + stride ] ) { // value has changed -> update scene graph binding.setValue( buffer, offset ); break; } } }, // remember the state of the bound property and copy it to both accus saveOriginalState: function () { var binding = this.binding; var buffer = this.buffer, stride = this.valueSize, originalValueOffset = stride * 3; binding.getValue( buffer, originalValueOffset ); // accu[0..1] := orig -- initially detect changes against the original for ( var i = stride, e = originalValueOffset; i !== e; ++ i ) { buffer[ i ] = buffer[ originalValueOffset + ( i % stride ) ]; } this.cumulativeWeight = 0; }, // apply the state previously taken via 'saveOriginalState' to the binding restoreOriginalState: function () { var originalValueOffset = this.valueSize * 3; this.binding.setValue( this.buffer, originalValueOffset ); }, // mix functions _select: function ( buffer, dstOffset, srcOffset, t, stride ) { if ( t >= 0.5 ) { for ( var i = 0; i !== stride; ++ i ) { buffer[ dstOffset + i ] = buffer[ srcOffset + i ]; } } }, _slerp: function ( buffer, dstOffset, srcOffset, t ) { Quaternion.slerpFlat( buffer, dstOffset, buffer, dstOffset, buffer, srcOffset, t ); }, _lerp: function ( buffer, dstOffset, srcOffset, t, stride ) { var s = 1 - t; for ( var i = 0; i !== stride; ++ i ) { var j = dstOffset + i; buffer[ j ] = buffer[ j ] * s + buffer[ srcOffset + i ] * t; } } } ); /** * * A reference to a real property in the scene graph. * * * @author Ben Houston / http://clara.io/ * @author David Sarno / http://lighthaus.us/ * @author tschw */ // Characters [].:/ are reserved for track binding syntax. var RESERVED_CHARS_RE = '\\\\[\\\\]\\\\.:\\\\/'; function Composite( targetGroup, path, optionalParsedPath ) { var parsedPath = optionalParsedPath || PropertyBinding.parseTrackName( path ); this._targetGroup = targetGroup; this._bindings = targetGroup.subscribe_( path, parsedPath ); } Object.assign( Composite.prototype, { getValue: function ( array, offset ) { this.bind(); // bind all binding var firstValidIndex = this._targetGroup.nCachedObjects_, binding = this._bindings[ firstValidIndex ]; // and only call .getValue on the first if ( binding !== undefined ) binding.getValue( array, offset ); }, setValue: function ( array, offset ) { var bindings = this._bindings; for ( var i = this._targetGroup.nCachedObjects_, n = bindings.length; i !== n; ++ i ) { bindings[ i ].setValue( array, offset ); } }, bind: function () { var bindings = this._bindings; for ( var i = this._targetGroup.nCachedObjects_, n = bindings.length; i !== n; ++ i ) { bindings[ i ].bind(); } }, unbind: function () { var bindings = this._bindings; for ( var i = this._targetGroup.nCachedObjects_, n = bindings.length; i !== n; ++ i ) { bindings[ i ].unbind(); } } } ); function PropertyBinding( rootNode, path, parsedPath ) { this.path = path; this.parsedPath = parsedPath || PropertyBinding.parseTrackName( path ); this.node = PropertyBinding.findNode( rootNode, this.parsedPath.nodeName ) || rootNode; this.rootNode = rootNode; } Object.assign( PropertyBinding, { Composite: Composite, create: function ( root, path, parsedPath ) { if ( ! ( root && root.isAnimationObjectGroup ) ) { return new PropertyBinding( root, path, parsedPath ); } else { return new PropertyBinding.Composite( root, path, parsedPath ); } }, /** * Replaces spaces with underscores and removes unsupported characters from * node names, to ensure compatibility with parseTrackName(). * * @param {string} name Node name to be sanitized. * @return {string} */ sanitizeNodeName: ( function () { var reservedRe = new RegExp( '[' + RESERVED_CHARS_RE + ']', 'g' ); return function sanitizeNodeName( name ) { return name.replace( /\\s/g, '_' ).replace( reservedRe, '' ); }; }() ), parseTrackName: function () { // Attempts to allow node names from any language. ES5's `\\w` regexp matches // only latin characters, and the unicode \\p{L} is not yet supported. So // instead, we exclude reserved characters and match everything else. var wordChar = '[^' + RESERVED_CHARS_RE + ']'; var wordCharOrDot = '[^' + RESERVED_CHARS_RE.replace( '\\\\.', '' ) + ']'; // Parent directories, delimited by '/' or ':'. Currently unused, but must // be matched to parse the rest of the track name. var directoryRe = /((?:WC+[\\/:])*)/.source.replace( 'WC', wordChar ); // Target node. May contain word characters (a-zA-Z0-9_) and '.' or '-'. var nodeRe = /(WCOD+)?/.source.replace( 'WCOD', wordCharOrDot ); // Object on target node, and accessor. May not contain reserved // characters. Accessor may contain any character except closing bracket. var objectRe = /(?:\\.(WC+)(?:\\[(.+)\\])?)?/.source.replace( 'WC', wordChar ); // Property and accessor. May not contain reserved characters. Accessor may // contain any non-bracket characters. var propertyRe = /\\.(WC+)(?:\\[(.+)\\])?/.source.replace( 'WC', wordChar ); var trackRe = new RegExp( '' + '^' + directoryRe + nodeRe + objectRe + propertyRe + '$' ); var supportedObjectNames = [ 'material', 'materials', 'bones' ]; return function parseTrackName( trackName ) { var matches = trackRe.exec( trackName ); if ( ! matches ) { throw new Error( 'PropertyBinding: Cannot parse trackName: ' + trackName ); } var results = { // directoryName: matches[ 1 ], // (tschw) currently unused nodeName: matches[ 2 ], objectName: matches[ 3 ], objectIndex: matches[ 4 ], propertyName: matches[ 5 ], // required propertyIndex: matches[ 6 ] }; var lastDot = results.nodeName && results.nodeName.lastIndexOf( '.' ); if ( lastDot !== undefined && lastDot !== - 1 ) { var objectName = results.nodeName.substring( lastDot + 1 ); // Object names must be checked against a whitelist. Otherwise, there // is no way to parse 'foo.bar.baz': 'baz' must be a property, but // 'bar' could be the objectName, or part of a nodeName (which can // include '.' characters). if ( supportedObjectNames.indexOf( objectName ) !== - 1 ) { results.nodeName = results.nodeName.substring( 0, lastDot ); results.objectName = objectName; } } if ( results.propertyName === null || results.propertyName.length === 0 ) { throw new Error( 'PropertyBinding: can not parse propertyName from trackName: ' + trackName ); } return results; }; }(), findNode: function ( root, nodeName ) { if ( ! nodeName || nodeName === \"\" || nodeName === \"root\" || nodeName === \".\" || nodeName === - 1 || nodeName === root.name || nodeName === root.uuid ) { return root; } // search into skeleton bones. if ( root.skeleton ) { var bone = root.skeleton.getBoneByName( nodeName ); if ( bone !== undefined ) { return bone; } } // search into node subtree. if ( root.children ) { var searchNodeSubtree = function ( children ) { for ( var i = 0; i < children.length; i ++ ) { var childNode = children[ i ]; if ( childNode.name === nodeName || childNode.uuid === nodeName ) { return childNode; } var result = searchNodeSubtree( childNode.children ); if ( result ) return result; } return null; }; var subTreeNode = searchNodeSubtree( root.children ); if ( subTreeNode ) { return subTreeNode; } } return null; } } ); Object.assign( PropertyBinding.prototype, { // prototype, continued // these are used to \"bind\" a nonexistent property _getValue_unavailable: function () {}, _setValue_unavailable: function () {}, BindingType: { Direct: 0, EntireArray: 1, ArrayElement: 2, HasFromToArray: 3 }, Versioning: { None: 0, NeedsUpdate: 1, MatrixWorldNeedsUpdate: 2 }, GetterByBindingType: [ function getValue_direct( buffer, offset ) { buffer[ offset ] = this.node[ this.propertyName ]; }, function getValue_array( buffer, offset ) { var source = this.resolvedProperty; for ( var i = 0, n = source.length; i !== n; ++ i ) { buffer[ offset ++ ] = source[ i ]; } }, function getValue_arrayElement( buffer, offset ) { buffer[ offset ] = this.resolvedProperty[ this.propertyIndex ]; }, function getValue_toArray( buffer, offset ) { this.resolvedProperty.toArray( buffer, offset ); } ], SetterByBindingTypeAndVersioning: [ [ // Direct function setValue_direct( buffer, offset ) { this.targetObject[ this.propertyName ] = buffer[ offset ]; }, function setValue_direct_setNeedsUpdate( buffer, offset ) { this.targetObject[ this.propertyName ] = buffer[ offset ]; this.targetObject.needsUpdate = true; }, function setValue_direct_setMatrixWorldNeedsUpdate( buffer, offset ) { this.targetObject[ this.propertyName ] = buffer[ offset ]; this.targetObject.matrixWorldNeedsUpdate = true; } ], [ // EntireArray function setValue_array( buffer, offset ) { var dest = this.resolvedProperty; for ( var i = 0, n = dest.length; i !== n; ++ i ) { dest[ i ] = buffer[ offset ++ ]; } }, function setValue_array_setNeedsUpdate( buffer, offset ) { var dest = this.resolvedProperty; for ( var i = 0, n = dest.length; i !== n; ++ i ) { dest[ i ] = buffer[ offset ++ ]; } this.targetObject.needsUpdate = true; }, function setValue_array_setMatrixWorldNeedsUpdate( buffer, offset ) { var dest = this.resolvedProperty; for ( var i = 0, n = dest.length; i !== n; ++ i ) { dest[ i ] = buffer[ offset ++ ]; } this.targetObject.matrixWorldNeedsUpdate = true; } ], [ // ArrayElement function setValue_arrayElement( buffer, offset ) { this.resolvedProperty[ this.propertyIndex ] = buffer[ offset ]; }, function setValue_arrayElement_setNeedsUpdate( buffer, offset ) { this.resolvedProperty[ this.propertyIndex ] = buffer[ offset ]; this.targetObject.needsUpdate = true; }, function setValue_arrayElement_setMatrixWorldNeedsUpdate( buffer, offset ) { this.resolvedProperty[ this.propertyIndex ] = buffer[ offset ]; this.targetObject.matrixWorldNeedsUpdate = true; } ], [ // HasToFromArray function setValue_fromArray( buffer, offset ) { this.resolvedProperty.fromArray( buffer, offset ); }, function setValue_fromArray_setNeedsUpdate( buffer, offset ) { this.resolvedProperty.fromArray( buffer, offset ); this.targetObject.needsUpdate = true; }, function setValue_fromArray_setMatrixWorldNeedsUpdate( buffer, offset ) { this.resolvedProperty.fromArray( buffer, offset ); this.targetObject.matrixWorldNeedsUpdate = true; } ] ], getValue: function getValue_unbound( targetArray, offset ) { this.bind(); this.getValue( targetArray, offset ); // Note: This class uses a State pattern on a per-method basis: // 'bind' sets 'this.getValue' / 'setValue' and shadows the // prototype version of these methods with one that represents // the bound state. When the property is not found, the methods // become no-ops. }, setValue: function getValue_unbound( sourceArray, offset ) { this.bind(); this.setValue( sourceArray, offset ); }, // create getter / setter pair for a property in the scene graph bind: function () { var targetObject = this.node, parsedPath = this.parsedPath, objectName = parsedPath.objectName, propertyName = parsedPath.propertyName, propertyIndex = parsedPath.propertyIndex; if ( ! targetObject ) { targetObject = PropertyBinding.findNode( this.rootNode, parsedPath.nodeName ) || this.rootNode; this.node = targetObject; } // set fail state so we can just 'return' on error this.getValue = this._getValue_unavailable; this.setValue = this._setValue_unavailable; // ensure there is a value node if ( ! targetObject ) { console.error( 'THREE.PropertyBinding: Trying to update node for track: ' + this.path + ' but it wasn\\'t found.' ); return; } if ( objectName ) { var objectIndex = parsedPath.objectIndex; // special cases were we need to reach deeper into the hierarchy to get the face materials.... switch ( objectName ) { case 'materials': if ( ! targetObject.material ) { console.error( 'THREE.PropertyBinding: Can not bind to material as node does not have a material.', this ); return; } if ( ! targetObject.material.materials ) { console.error( 'THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.', this ); return; } targetObject = targetObject.material.materials; break; case 'bones': if ( ! targetObject.skeleton ) { console.error( 'THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.', this ); return; } // potential future optimization: skip this if propertyIndex is already an integer // and convert the integer string to a true integer. targetObject = targetObject.skeleton.bones; // support resolving morphTarget names into indices. for ( var i = 0; i < targetObject.length; i ++ ) { if ( targetObject[ i ].name === objectIndex ) { objectIndex = i; break; } } break; default: if ( targetObject[ objectName ] === undefined ) { console.error( 'THREE.PropertyBinding: Can not bind to objectName of node undefined.', this ); return; } targetObject = targetObject[ objectName ]; } if ( objectIndex !== undefined ) { if ( targetObject[ objectIndex ] === undefined ) { console.error( 'THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.', this, targetObject ); return; } targetObject = targetObject[ objectIndex ]; } } // resolve property var nodeProperty = targetObject[ propertyName ]; if ( nodeProperty === undefined ) { var nodeName = parsedPath.nodeName; console.error( 'THREE.PropertyBinding: Trying to update property for track: ' + nodeName + '.' + propertyName + ' but it wasn\\'t found.', targetObject ); return; } // determine versioning scheme var versioning = this.Versioning.None; this.targetObject = targetObject; if ( targetObject.needsUpdate !== undefined ) { // material versioning = this.Versioning.NeedsUpdate; } else if ( targetObject.matrixWorldNeedsUpdate !== undefined ) { // node transform versioning = this.Versioning.MatrixWorldNeedsUpdate; } // determine how the property gets bound var bindingType = this.BindingType.Direct; if ( propertyIndex !== undefined ) { // access a sub element of the property array (only primitives are supported right now) if ( propertyName === \"morphTargetInfluences\" ) { // potential optimization, skip this if propertyIndex is already an integer, and convert the integer string to a true integer. // support resolving morphTarget names into indices. if ( ! targetObject.geometry ) { console.error( 'THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.', this ); return; } if ( targetObject.geometry.isBufferGeometry ) { if ( ! targetObject.geometry.morphAttributes ) { console.error( 'THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.', this ); return; } for ( var i = 0; i < this.node.geometry.morphAttributes.position.length; i ++ ) { if ( targetObject.geometry.morphAttributes.position[ i ].name === propertyIndex ) { propertyIndex = i; break; } } } else { if ( ! targetObject.geometry.morphTargets ) { console.error( 'THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphTargets.', this ); return; } for ( var i = 0; i < this.node.geometry.morphTargets.length; i ++ ) { if ( targetObject.geometry.morphTargets[ i ].name === propertyIndex ) { propertyIndex = i; break; } } } } bindingType = this.BindingType.ArrayElement; this.resolvedProperty = nodeProperty; this.propertyIndex = propertyIndex; } else if ( nodeProperty.fromArray !== undefined && nodeProperty.toArray !== undefined ) { // must use copy for Object3D.Euler/Quaternion bindingType = this.BindingType.HasFromToArray; this.resolvedProperty = nodeProperty; } else if ( Array.isArray( nodeProperty ) ) { bindingType = this.BindingType.EntireArray; this.resolvedProperty = nodeProperty; } else { this.propertyName = propertyName; } // select getter / setter this.getValue = this.GetterByBindingType[ bindingType ]; this.setValue = this.SetterByBindingTypeAndVersioning[ bindingType ][ versioning ]; }, unbind: function () { this.node = null; // back to the prototype version of getValue / setValue // note: avoiding to mutate the shape of 'this' via 'delete' this.getValue = this._getValue_unbound; this.setValue = this._setValue_unbound; } } ); //!\\ DECLARE ALIAS AFTER assign prototype ! Object.assign( PropertyBinding.prototype, { // initial state of these methods that calls 'bind' _getValue_unbound: PropertyBinding.prototype.getValue, _setValue_unbound: PropertyBinding.prototype.setValue, } ); /** * * A group of objects that receives a shared animation state. * * Usage: * * - Add objects you would otherwise pass as 'root' to the * constructor or the .clipAction method of AnimationMixer. * * - Instead pass this object as 'root'. * * - You can also add and remove objects later when the mixer * is running. * * Note: * * Objects of this class appear as one object to the mixer, * so cache control of the individual objects must be done * on the group. * * Limitation: * * - The animated properties must be compatible among the * all objects in the group. * * - A single property can either be controlled through a * target group or directly, but not both. * * @author tschw */ function AnimationObjectGroup() { this.uuid = _Math.generateUUID(); // cached objects followed by the active ones this._objects = Array.prototype.slice.call( arguments ); this.nCachedObjects_ = 0; // threshold // note: read by PropertyBinding.Composite var indices = {}; this._indicesByUUID = indices; // for bookkeeping for ( var i = 0, n = arguments.length; i !== n; ++ i ) { indices[ arguments[ i ].uuid ] = i; } this._paths = []; // inside: string this._parsedPaths = []; // inside: { we don't care, here } this._bindings = []; // inside: Array< PropertyBinding > this._bindingsIndicesByPath = {}; // inside: indices in these arrays var scope = this; this.stats = { objects: { get total() { return scope._objects.length; }, get inUse() { return this.total - scope.nCachedObjects_; } }, get bindingsPerObject() { return scope._bindings.length; } }; } Object.assign( AnimationObjectGroup.prototype, { isAnimationObjectGroup: true, add: function () { var objects = this._objects, nObjects = objects.length, nCachedObjects = this.nCachedObjects_, indicesByUUID = this._indicesByUUID, paths = this._paths, parsedPaths = this._parsedPaths, bindings = this._bindings, nBindings = bindings.length, knownObject = undefined; for ( var i = 0, n = arguments.length; i !== n; ++ i ) { var object = arguments[ i ], uuid = object.uuid, index = indicesByUUID[ uuid ]; if ( index === undefined ) { // unknown object -> add it to the ACTIVE region index = nObjects ++; indicesByUUID[ uuid ] = index; objects.push( object ); // accounting is done, now do the same for all bindings for ( var j = 0, m = nBindings; j !== m; ++ j ) { bindings[ j ].push( new PropertyBinding( object, paths[ j ], parsedPaths[ j ] ) ); } } else if ( index < nCachedObjects ) { knownObject = objects[ index ]; // move existing object to the ACTIVE region var firstActiveIndex = -- nCachedObjects, lastCachedObject = objects[ firstActiveIndex ]; indicesByUUID[ lastCachedObject.uuid ] = index; objects[ index ] = lastCachedObject; indicesByUUID[ uuid ] = firstActiveIndex; objects[ firstActiveIndex ] = object; // accounting is done, now do the same for all bindings for ( var j = 0, m = nBindings; j !== m; ++ j ) { var bindingsForPath = bindings[ j ], lastCached = bindingsForPath[ firstActiveIndex ], binding = bindingsForPath[ index ]; bindingsForPath[ index ] = lastCached; if ( binding === undefined ) { // since we do not bother to create new bindings // for objects that are cached, the binding may // or may not exist binding = new PropertyBinding( object, paths[ j ], parsedPaths[ j ] ); } bindingsForPath[ firstActiveIndex ] = binding; } } else if ( objects[ index ] !== knownObject ) { console.error( 'THREE.AnimationObjectGroup: Different objects with the same UUID ' + 'detected. Clean the caches or recreate your infrastructure when reloading scenes.' ); } // else the object is already where we want it to be } // for arguments this.nCachedObjects_ = nCachedObjects; }, remove: function () { var objects = this._objects, nCachedObjects = this.nCachedObjects_, indicesByUUID = this._indicesByUUID, bindings = this._bindings, nBindings = bindings.length; for ( var i = 0, n = arguments.length; i !== n; ++ i ) { var object = arguments[ i ], uuid = object.uuid, index = indicesByUUID[ uuid ]; if ( index !== undefined && index >= nCachedObjects ) { // move existing object into the CACHED region var lastCachedIndex = nCachedObjects ++, firstActiveObject = objects[ lastCachedIndex ]; indicesByUUID[ firstActiveObject.uuid ] = index; objects[ index ] = firstActiveObject; indicesByUUID[ uuid ] = lastCachedIndex; objects[ lastCachedIndex ] = object; // accounting is done, now do the same for all bindings for ( var j = 0, m = nBindings; j !== m; ++ j ) { var bindingsForPath = bindings[ j ], firstActive = bindingsForPath[ lastCachedIndex ], binding = bindingsForPath[ index ]; bindingsForPath[ index ] = firstActive; bindingsForPath[ lastCachedIndex ] = binding; } } } // for arguments this.nCachedObjects_ = nCachedObjects; }, // remove & forget uncache: function () { var objects = this._objects, nObjects = objects.length, nCachedObjects = this.nCachedObjects_, indicesByUUID = this._indicesByUUID, bindings = this._bindings, nBindings = bindings.length; for ( var i = 0, n = arguments.length; i !== n; ++ i ) { var object = arguments[ i ], uuid = object.uuid, index = indicesByUUID[ uuid ]; if ( index !== undefined ) { delete indicesByUUID[ uuid ]; if ( index < nCachedObjects ) { // object is cached, shrink the CACHED region var firstActiveIndex = -- nCachedObjects, lastCachedObject = objects[ firstActiveIndex ], lastIndex = -- nObjects, lastObject = objects[ lastIndex ]; // last cached object takes this object's place indicesByUUID[ lastCachedObject.uuid ] = index; objects[ index ] = lastCachedObject; // last object goes to the activated slot and pop indicesByUUID[ lastObject.uuid ] = firstActiveIndex; objects[ firstActiveIndex ] = lastObject; objects.pop(); // accounting is done, now do the same for all bindings for ( var j = 0, m = nBindings; j !== m; ++ j ) { var bindingsForPath = bindings[ j ], lastCached = bindingsForPath[ firstActiveIndex ], last = bindingsForPath[ lastIndex ]; bindingsForPath[ index ] = lastCached; bindingsForPath[ firstActiveIndex ] = last; bindingsForPath.pop(); } } else { // object is active, just swap with the last and pop var lastIndex = -- nObjects, lastObject = objects[ lastIndex ]; indicesByUUID[ lastObject.uuid ] = index; objects[ index ] = lastObject; objects.pop(); // accounting is done, now do the same for all bindings for ( var j = 0, m = nBindings; j !== m; ++ j ) { var bindingsForPath = bindings[ j ]; bindingsForPath[ index ] = bindingsForPath[ lastIndex ]; bindingsForPath.pop(); } } // cached or active } // if object is known } // for arguments this.nCachedObjects_ = nCachedObjects; }, // Internal interface used by befriended PropertyBinding.Composite: subscribe_: function ( path, parsedPath ) { // returns an array of bindings for the given path that is changed // according to the contained objects in the group var indicesByPath = this._bindingsIndicesByPath, index = indicesByPath[ path ], bindings = this._bindings; if ( index !== undefined ) return bindings[ index ]; var paths = this._paths, parsedPaths = this._parsedPaths, objects = this._objects, nObjects = objects.length, nCachedObjects = this.nCachedObjects_, bindingsForPath = new Array( nObjects ); index = bindings.length; indicesByPath[ path ] = index; paths.push( path ); parsedPaths.push( parsedPath ); bindings.push( bindingsForPath ); for ( var i = nCachedObjects, n = objects.length; i !== n; ++ i ) { var object = objects[ i ]; bindingsForPath[ i ] = new PropertyBinding( object, path, parsedPath ); } return bindingsForPath; }, unsubscribe_: function ( path ) { // tells the group to forget about a property path and no longer // update the array previously obtained with 'subscribe_' var indicesByPath = this._bindingsIndicesByPath, index = indicesByPath[ path ]; if ( index !== undefined ) { var paths = this._paths, parsedPaths = this._parsedPaths, bindings = this._bindings, lastBindingsIndex = bindings.length - 1, lastBindings = bindings[ lastBindingsIndex ], lastBindingsPath = path[ lastBindingsIndex ]; indicesByPath[ lastBindingsPath ] = index; bindings[ index ] = lastBindings; bindings.pop(); parsedPaths[ index ] = parsedPaths[ lastBindingsIndex ]; parsedPaths.pop(); paths[ index ] = paths[ lastBindingsIndex ]; paths.pop(); } } } ); /** * * Action provided by AnimationMixer for scheduling clip playback on specific * objects. * * @author Ben Houston / http://clara.io/ * @author David Sarno / http://lighthaus.us/ * @author tschw * */ function AnimationAction( mixer, clip, localRoot ) { this._mixer = mixer; this._clip = clip; this._localRoot = localRoot || null; var tracks = clip.tracks, nTracks = tracks.length, interpolants = new Array( nTracks ); var interpolantSettings = { endingStart: ZeroCurvatureEnding, endingEnd: ZeroCurvatureEnding }; for ( var i = 0; i !== nTracks; ++ i ) { var interpolant = tracks[ i ].createInterpolant( null ); interpolants[ i ] = interpolant; interpolant.settings = interpolantSettings; } this._interpolantSettings = interpolantSettings; this._interpolants = interpolants; // bound by the mixer // inside: PropertyMixer (managed by the mixer) this._propertyBindings = new Array( nTracks ); this._cacheIndex = null; // for the memory manager this._byClipCacheIndex = null; // for the memory manager this._timeScaleInterpolant = null; this._weightInterpolant = null; this.loop = LoopRepeat; this._loopCount = - 1; // global mixer time when the action is to be started // it's set back to 'null' upon start of the action this._startTime = null; // scaled local time of the action // gets clamped or wrapped to 0..clip.duration according to loop this.time = 0; this.timeScale = 1; this._effectiveTimeScale = 1; this.weight = 1; this._effectiveWeight = 1; this.repetitions = Infinity; // no. of repetitions when looping this.paused = false; // true -> zero effective time scale this.enabled = true; // false -> zero effective weight this.clampWhenFinished = false;// keep feeding the last frame? this.zeroSlopeAtStart = true;// for smooth interpolation w/o separate this.zeroSlopeAtEnd = true;// clips for start, loop and end } Object.assign( AnimationAction.prototype, { // State & Scheduling play: function () { this._mixer._activateAction( this ); return this; }, stop: function () { this._mixer._deactivateAction( this ); return this.reset(); }, reset: function () { this.paused = false; this.enabled = true; this.time = 0; // restart clip this._loopCount = - 1;// forget previous loops this._startTime = null;// forget scheduling return this.stopFading().stopWarping(); }, isRunning: function () { return this.enabled && ! this.paused && this.timeScale !== 0 && this._startTime === null && this._mixer._isActiveAction( this ); }, // return true when play has been called isScheduled: function () { return this._mixer._isActiveAction( this ); }, startAt: function ( time ) { this._startTime = time; return this; }, setLoop: function ( mode, repetitions ) { this.loop = mode; this.repetitions = repetitions; return this; }, // Weight // set the weight stopping any scheduled fading // although .enabled = false yields an effective weight of zero, this // method does *not* change .enabled, because it would be confusing setEffectiveWeight: function ( weight ) { this.weight = weight; // note: same logic as when updated at runtime this._effectiveWeight = this.enabled ? weight : 0; return this.stopFading(); }, // return the weight considering fading and .enabled getEffectiveWeight: function () { return this._effectiveWeight; }, fadeIn: function ( duration ) { return this._scheduleFading( duration, 0, 1 ); }, fadeOut: function ( duration ) { return this._scheduleFading( duration, 1, 0 ); }, crossFadeFrom: function ( fadeOutAction, duration, warp ) { fadeOutAction.fadeOut( duration ); this.fadeIn( duration ); if ( warp ) { var fadeInDuration = this._clip.duration, fadeOutDuration = fadeOutAction._clip.duration, startEndRatio = fadeOutDuration / fadeInDuration, endStartRatio = fadeInDuration / fadeOutDuration; fadeOutAction.warp( 1.0, startEndRatio, duration ); this.warp( endStartRatio, 1.0, duration ); } return this; }, crossFadeTo: function ( fadeInAction, duration, warp ) { return fadeInAction.crossFadeFrom( this, duration, warp ); }, stopFading: function () { var weightInterpolant = this._weightInterpolant; if ( weightInterpolant !== null ) { this._weightInterpolant = null; this._mixer._takeBackControlInterpolant( weightInterpolant ); } return this; }, // Time Scale Control // set the time scale stopping any scheduled warping // although .paused = true yields an effective time scale of zero, this // method does *not* change .paused, because it would be confusing setEffectiveTimeScale: function ( timeScale ) { this.timeScale = timeScale; this._effectiveTimeScale = this.paused ? 0 : timeScale; return this.stopWarping(); }, // return the time scale considering warping and .paused getEffectiveTimeScale: function () { return this._effectiveTimeScale; }, setDuration: function ( duration ) { this.timeScale = this._clip.duration / duration; return this.stopWarping(); }, syncWith: function ( action ) { this.time = action.time; this.timeScale = action.timeScale; return this.stopWarping(); }, halt: function ( duration ) { return this.warp( this._effectiveTimeScale, 0, duration ); }, warp: function ( startTimeScale, endTimeScale, duration ) { var mixer = this._mixer, now = mixer.time, interpolant = this._timeScaleInterpolant, timeScale = this.timeScale; if ( interpolant === null ) { interpolant = mixer._lendControlInterpolant(); this._timeScaleInterpolant = interpolant; } var times = interpolant.parameterPositions, values = interpolant.sampleValues; times[ 0 ] = now; times[ 1 ] = now + duration; values[ 0 ] = startTimeScale / timeScale; values[ 1 ] = endTimeScale / timeScale; return this; }, stopWarping: function () { var timeScaleInterpolant = this._timeScaleInterpolant; if ( timeScaleInterpolant !== null ) { this._timeScaleInterpolant = null; this._mixer._takeBackControlInterpolant( timeScaleInterpolant ); } return this; }, // Object Accessors getMixer: function () { return this._mixer; }, getClip: function () { return this._clip; }, getRoot: function () { return this._localRoot || this._mixer._root; }, // Interna _update: function ( time, deltaTime, timeDirection, accuIndex ) { // called by the mixer if ( ! this.enabled ) { // call ._updateWeight() to update ._effectiveWeight this._updateWeight( time ); return; } var startTime = this._startTime; if ( startTime !== null ) { // check for scheduled start of action var timeRunning = ( time - startTime ) * timeDirection; if ( timeRunning < 0 || timeDirection === 0 ) { return; // yet to come / don't decide when delta = 0 } // start this._startTime = null; // unschedule deltaTime = timeDirection * timeRunning; } // apply time scale and advance time deltaTime *= this._updateTimeScale( time ); var clipTime = this._updateTime( deltaTime ); // note: _updateTime may disable the action resulting in // an effective weight of 0 var weight = this._updateWeight( time ); if ( weight > 0 ) { var interpolants = this._interpolants; var propertyMixers = this._propertyBindings; for ( var j = 0, m = interpolants.length; j !== m; ++ j ) { interpolants[ j ].evaluate( clipTime ); propertyMixers[ j ].accumulate( accuIndex, weight ); } } }, _updateWeight: function ( time ) { var weight = 0; if ( this.enabled ) { weight = this.weight; var interpolant = this._weightInterpolant; if ( interpolant !== null ) { var interpolantValue = interpolant.evaluate( time )[ 0 ]; weight *= interpolantValue; if ( time > interpolant.parameterPositions[ 1 ] ) { this.stopFading(); if ( interpolantValue === 0 ) { // faded out, disable this.enabled = false; } } } } this._effectiveWeight = weight; return weight; }, _updateTimeScale: function ( time ) { var timeScale = 0; if ( ! this.paused ) { timeScale = this.timeScale; var interpolant = this._timeScaleInterpolant; if ( interpolant !== null ) { var interpolantValue = interpolant.evaluate( time )[ 0 ]; timeScale *= interpolantValue; if ( time > interpolant.parameterPositions[ 1 ] ) { this.stopWarping(); if ( timeScale === 0 ) { // motion has halted, pause this.paused = true; } else { // warp done - apply final time scale this.timeScale = timeScale; } } } } this._effectiveTimeScale = timeScale; return timeScale; }, _updateTime: function ( deltaTime ) { var time = this.time + deltaTime; var duration = this._clip.duration; var loop = this.loop; var loopCount = this._loopCount; var pingPong = ( loop === LoopPingPong ); if ( deltaTime === 0 ) { if ( loopCount === - 1 ) return time; return ( pingPong && ( loopCount & 1 ) === 1 ) ? duration - time : time; } if ( loop === LoopOnce ) { if ( loopCount === - 1 ) { // just started this._loopCount = 0; this._setEndings( true, true, false ); } handle_stop: { if ( time >= duration ) { time = duration; } else if ( time < 0 ) { time = 0; } else break handle_stop; if ( this.clampWhenFinished ) this.paused = true; else this.enabled = false; this._mixer.dispatchEvent( { type: 'finished', action: this, direction: deltaTime < 0 ? - 1 : 1 } ); } } else { // repetitive Repeat or PingPong if ( loopCount === - 1 ) { // just started if ( deltaTime >= 0 ) { loopCount = 0; this._setEndings( true, this.repetitions === 0, pingPong ); } else { // when looping in reverse direction, the initial // transition through zero counts as a repetition, // so leave loopCount at -1 this._setEndings( this.repetitions === 0, true, pingPong ); } } if ( time >= duration || time < 0 ) { // wrap around var loopDelta = Math.floor( time / duration ); // signed time -= duration * loopDelta; loopCount += Math.abs( loopDelta ); var pending = this.repetitions - loopCount; if ( pending 0 ? duration : 0; this._mixer.dispatchEvent( { type: 'finished', action: this, direction: deltaTime > 0 ? 1 : - 1 } ); } else { // keep running if ( pending === 1 ) { // entering the last round var atStart = deltaTime < 0; this._setEndings( atStart, ! atStart, pingPong ); } else { this._setEndings( false, false, pingPong ); } this._loopCount = loopCount; this._mixer.dispatchEvent( { type: 'loop', action: this, loopDelta: loopDelta } ); } } if ( pingPong && ( loopCount & 1 ) === 1 ) { // invert time for the \"pong round\" this.time = time; return duration - time; } } this.time = time; return time; }, _setEndings: function ( atStart, atEnd, pingPong ) { var settings = this._interpolantSettings; if ( pingPong ) { settings.endingStart = ZeroSlopeEnding; settings.endingEnd = ZeroSlopeEnding; } else { // assuming for LoopOnce atStart == atEnd == true if ( atStart ) { settings.endingStart = this.zeroSlopeAtStart ? ZeroSlopeEnding : ZeroCurvatureEnding; } else { settings.endingStart = WrapAroundEnding; } if ( atEnd ) { settings.endingEnd = this.zeroSlopeAtEnd ? ZeroSlopeEnding : ZeroCurvatureEnding; } else { settings.endingEnd = WrapAroundEnding; } } }, _scheduleFading: function ( duration, weightNow, weightThen ) { var mixer = this._mixer, now = mixer.time, interpolant = this._weightInterpolant; if ( interpolant === null ) { interpolant = mixer._lendControlInterpolant(); this._weightInterpolant = interpolant; } var times = interpolant.parameterPositions, values = interpolant.sampleValues; times[ 0 ] = now; values[ 0 ] = weightNow; times[ 1 ] = now + duration; values[ 1 ] = weightThen; return this; } } ); /** * * Player for AnimationClips. * * * @author Ben Houston / http://clara.io/ * @author David Sarno / http://lighthaus.us/ * @author tschw */ function AnimationMixer( root ) { this._root = root; this._initMemoryManager(); this._accuIndex = 0; this.time = 0; this.timeScale = 1.0; } AnimationMixer.prototype = Object.assign( Object.create( EventDispatcher.prototype ), { constructor: AnimationMixer, _bindAction: function ( action, prototypeAction ) { var root = action._localRoot || this._root, tracks = action._clip.tracks, nTracks = tracks.length, bindings = action._propertyBindings, interpolants = action._interpolants, rootUuid = root.uuid, bindingsByRoot = this._bindingsByRootAndName, bindingsByName = bindingsByRoot[ rootUuid ]; if ( bindingsByName === undefined ) { bindingsByName = {}; bindingsByRoot[ rootUuid ] = bindingsByName; } for ( var i = 0; i !== nTracks; ++ i ) { var track = tracks[ i ], trackName = track.name, binding = bindingsByName[ trackName ]; if ( binding !== undefined ) { bindings[ i ] = binding; } else { binding = bindings[ i ]; if ( binding !== undefined ) { // existing binding, make sure the cache knows if ( binding._cacheIndex === null ) { ++ binding.referenceCount; this._addInactiveBinding( binding, rootUuid, trackName ); } continue; } var path = prototypeAction && prototypeAction. _propertyBindings[ i ].binding.parsedPath; binding = new PropertyMixer( PropertyBinding.create( root, trackName, path ), track.ValueTypeName, track.getValueSize() ); ++ binding.referenceCount; this._addInactiveBinding( binding, rootUuid, trackName ); bindings[ i ] = binding; } interpolants[ i ].resultBuffer = binding.buffer; } }, _activateAction: function ( action ) { if ( ! this._isActiveAction( action ) ) { if ( action._cacheIndex === null ) { // this action has been forgotten by the cache, but the user // appears to be still using it -> rebind var rootUuid = ( action._localRoot || this._root ).uuid, clipUuid = action._clip.uuid, actionsForClip = this._actionsByClip[ clipUuid ]; this._bindAction( action, actionsForClip && actionsForClip.knownActions[ 0 ] ); this._addInactiveAction( action, clipUuid, rootUuid ); } var bindings = action._propertyBindings; // increment reference counts / sort out state for ( var i = 0, n = bindings.length; i !== n; ++ i ) { var binding = bindings[ i ]; if ( binding.useCount ++ === 0 ) { this._lendBinding( binding ); binding.saveOriginalState(); } } this._lendAction( action ); } }, _deactivateAction: function ( action ) { if ( this._isActiveAction( action ) ) { var bindings = action._propertyBindings; // decrement reference counts / sort out state for ( var i = 0, n = bindings.length; i !== n; ++ i ) { var binding = bindings[ i ]; if ( -- binding.useCount === 0 ) { binding.restoreOriginalState(); this._takeBackBinding( binding ); } } this._takeBackAction( action ); } }, // Memory manager _initMemoryManager: function () { this._actions = []; // 'nActiveActions' followed by inactive ones this._nActiveActions = 0; this._actionsByClip = {}; // inside: // { // knownActions: Array< AnimationAction > - used as prototypes // actionByRoot: AnimationAction - lookup // } this._bindings = []; // 'nActiveBindings' followed by inactive ones this._nActiveBindings = 0; this._bindingsByRootAndName = {}; // inside: Map< name, PropertyMixer > this._controlInterpolants = []; // same game as above this._nActiveControlInterpolants = 0; var scope = this; this.stats = { actions: { get total() { return scope._actions.length; }, get inUse() { return scope._nActiveActions; } }, bindings: { get total() { return scope._bindings.length; }, get inUse() { return scope._nActiveBindings; } }, controlInterpolants: { get total() { return scope._controlInterpolants.length; }, get inUse() { return scope._nActiveControlInterpolants; } } }; }, // Memory management for AnimationAction objects _isActiveAction: function ( action ) { var index = action._cacheIndex; return index !== null && index < this._nActiveActions; }, _addInactiveAction: function ( action, clipUuid, rootUuid ) { var actions = this._actions, actionsByClip = this._actionsByClip, actionsForClip = actionsByClip[ clipUuid ]; if ( actionsForClip === undefined ) { actionsForClip = { knownActions: [ action ], actionByRoot: {} }; action._byClipCacheIndex = 0; actionsByClip[ clipUuid ] = actionsForClip; } else { var knownActions = actionsForClip.knownActions; action._byClipCacheIndex = knownActions.length; knownActions.push( action ); } action._cacheIndex = actions.length; actions.push( action ); actionsForClip.actionByRoot[ rootUuid ] = action; }, _removeInactiveAction: function ( action ) { var actions = this._actions, lastInactiveAction = actions[ actions.length - 1 ], cacheIndex = action._cacheIndex; lastInactiveAction._cacheIndex = cacheIndex; actions[ cacheIndex ] = lastInactiveAction; actions.pop(); action._cacheIndex = null; var clipUuid = action._clip.uuid, actionsByClip = this._actionsByClip, actionsForClip = actionsByClip[ clipUuid ], knownActionsForClip = actionsForClip.knownActions, lastKnownAction = knownActionsForClip[ knownActionsForClip.length - 1 ], byClipCacheIndex = action._byClipCacheIndex; lastKnownAction._byClipCacheIndex = byClipCacheIndex; knownActionsForClip[ byClipCacheIndex ] = lastKnownAction; knownActionsForClip.pop(); action._byClipCacheIndex = null; var actionByRoot = actionsForClip.actionByRoot, rootUuid = ( action._localRoot || this._root ).uuid; delete actionByRoot[ rootUuid ]; if ( knownActionsForClip.length === 0 ) { delete actionsByClip[ clipUuid ]; } this._removeInactiveBindingsForAction( action ); }, _removeInactiveBindingsForAction: function ( action ) { var bindings = action._propertyBindings; for ( var i = 0, n = bindings.length; i !== n; ++ i ) { var binding = bindings[ i ]; if ( -- binding.referenceCount === 0 ) { this._removeInactiveBinding( binding ); } } }, _lendAction: function ( action ) { // [ active actions | inactive actions ] // [ active actions >| inactive actions ] // s a // // a s var actions = this._actions, prevIndex = action._cacheIndex, lastActiveIndex = this._nActiveActions ++, firstInactiveAction = actions[ lastActiveIndex ]; action._cacheIndex = lastActiveIndex; actions[ lastActiveIndex ] = action; firstInactiveAction._cacheIndex = prevIndex; actions[ prevIndex ] = firstInactiveAction; }, _takeBackAction: function ( action ) { // [ active actions | inactive actions ] // [ active actions |< inactive actions ] // a s // // s a var actions = this._actions, prevIndex = action._cacheIndex, firstInactiveIndex = -- this._nActiveActions, lastActiveAction = actions[ firstInactiveIndex ]; action._cacheIndex = firstInactiveIndex; actions[ firstInactiveIndex ] = action; lastActiveAction._cacheIndex = prevIndex; actions[ prevIndex ] = lastActiveAction; }, // Memory management for PropertyMixer objects _addInactiveBinding: function ( binding, rootUuid, trackName ) { var bindingsByRoot = this._bindingsByRootAndName, bindingByName = bindingsByRoot[ rootUuid ], bindings = this._bindings; if ( bindingByName === undefined ) { bindingByName = {}; bindingsByRoot[ rootUuid ] = bindingByName; } bindingByName[ trackName ] = binding; binding._cacheIndex = bindings.length; bindings.push( binding ); }, _removeInactiveBinding: function ( binding ) { var bindings = this._bindings, propBinding = binding.binding, rootUuid = propBinding.rootNode.uuid, trackName = propBinding.path, bindingsByRoot = this._bindingsByRootAndName, bindingByName = bindingsByRoot[ rootUuid ], lastInactiveBinding = bindings[ bindings.length - 1 ], cacheIndex = binding._cacheIndex; lastInactiveBinding._cacheIndex = cacheIndex; bindings[ cacheIndex ] = lastInactiveBinding; bindings.pop(); delete bindingByName[ trackName ]; remove_empty_map: { for ( var _ in bindingByName ) break remove_empty_map; // eslint-disable-line no-unused-vars delete bindingsByRoot[ rootUuid ]; } }, _lendBinding: function ( binding ) { var bindings = this._bindings, prevIndex = binding._cacheIndex, lastActiveIndex = this._nActiveBindings ++, firstInactiveBinding = bindings[ lastActiveIndex ]; binding._cacheIndex = lastActiveIndex; bindings[ lastActiveIndex ] = binding; firstInactiveBinding._cacheIndex = prevIndex; bindings[ prevIndex ] = firstInactiveBinding; }, _takeBackBinding: function ( binding ) { var bindings = this._bindings, prevIndex = binding._cacheIndex, firstInactiveIndex = -- this._nActiveBindings, lastActiveBinding = bindings[ firstInactiveIndex ]; binding._cacheIndex = firstInactiveIndex; bindings[ firstInactiveIndex ] = binding; lastActiveBinding._cacheIndex = prevIndex; bindings[ prevIndex ] = lastActiveBinding; }, // Memory management of Interpolants for weight and time scale _lendControlInterpolant: function () { var interpolants = this._controlInterpolants, lastActiveIndex = this._nActiveControlInterpolants ++, interpolant = interpolants[ lastActiveIndex ]; if ( interpolant === undefined ) { interpolant = new LinearInterpolant( new Float32Array( 2 ), new Float32Array( 2 ), 1, this._controlInterpolantsResultBuffer ); interpolant.__cacheIndex = lastActiveIndex; interpolants[ lastActiveIndex ] = interpolant; } return interpolant; }, _takeBackControlInterpolant: function ( interpolant ) { var interpolants = this._controlInterpolants, prevIndex = interpolant.__cacheIndex, firstInactiveIndex = -- this._nActiveControlInterpolants, lastActiveInterpolant = interpolants[ firstInactiveIndex ]; interpolant.__cacheIndex = firstInactiveIndex; interpolants[ firstInactiveIndex ] = interpolant; lastActiveInterpolant.__cacheIndex = prevIndex; interpolants[ prevIndex ] = lastActiveInterpolant; }, _controlInterpolantsResultBuffer: new Float32Array( 1 ), // return an action for a clip optionally using a custom root target // object (this method allocates a lot of dynamic memory in case a // previously unknown clip/root combination is specified) clipAction: function ( clip, optionalRoot ) { var root = optionalRoot || this._root, rootUuid = root.uuid, clipObject = typeof clip === 'string' ? AnimationClip.findByName( root, clip ) : clip, clipUuid = clipObject !== null ? clipObject.uuid : clip, actionsForClip = this._actionsByClip[ clipUuid ], prototypeAction = null; if ( actionsForClip !== undefined ) { var existingAction = actionsForClip.actionByRoot[ rootUuid ]; if ( existingAction !== undefined ) { return existingAction; } // we know the clip, so we don't have to parse all // the bindings again but can just copy prototypeAction = actionsForClip.knownActions[ 0 ]; // also, take the clip from the prototype action if ( clipObject === null ) clipObject = prototypeAction._clip; } // clip must be known when specified via string if ( clipObject === null ) return null; // allocate all resources required to run it var newAction = new AnimationAction( this, clipObject, optionalRoot ); this._bindAction( newAction, prototypeAction ); // and make the action known to the memory manager this._addInactiveAction( newAction, clipUuid, rootUuid ); return newAction; }, // get an existing action existingAction: function ( clip, optionalRoot ) { var root = optionalRoot || this._root, rootUuid = root.uuid, clipObject = typeof clip === 'string' ? AnimationClip.findByName( root, clip ) : clip, clipUuid = clipObject ? clipObject.uuid : clip, actionsForClip = this._actionsByClip[ clipUuid ]; if ( actionsForClip !== undefined ) { return actionsForClip.actionByRoot[ rootUuid ] || null; } return null; }, // deactivates all previously scheduled actions stopAllAction: function () { var actions = this._actions, nActions = this._nActiveActions, bindings = this._bindings, nBindings = this._nActiveBindings; this._nActiveActions = 0; this._nActiveBindings = 0; for ( var i = 0; i !== nActions; ++ i ) { actions[ i ].reset(); } for ( var i = 0; i !== nBindings; ++ i ) { bindings[ i ].useCount = 0; } return this; }, // advance the time and update apply the animation update: function ( deltaTime ) { deltaTime *= this.timeScale; var actions = this._actions, nActions = this._nActiveActions, time = this.time += deltaTime, timeDirection = Math.sign( deltaTime ), accuIndex = this._accuIndex ^= 1; // run active actions for ( var i = 0; i !== nActions; ++ i ) { var action = actions[ i ]; action._update( time, deltaTime, timeDirection, accuIndex ); } // update scene graph var bindings = this._bindings, nBindings = this._nActiveBindings; for ( var i = 0; i !== nBindings; ++ i ) { bindings[ i ].apply( accuIndex ); } return this; }, // return this mixer's root target object getRoot: function () { return this._root; }, // free all resources specific to a particular clip uncacheClip: function ( clip ) { var actions = this._actions, clipUuid = clip.uuid, actionsByClip = this._actionsByClip, actionsForClip = actionsByClip[ clipUuid ]; if ( actionsForClip !== undefined ) { // note: just calling _removeInactiveAction would mess up the // iteration state and also require updating the state we can // just throw away var actionsToRemove = actionsForClip.knownActions; for ( var i = 0, n = actionsToRemove.length; i !== n; ++ i ) { var action = actionsToRemove[ i ]; this._deactivateAction( action ); var cacheIndex = action._cacheIndex, lastInactiveAction = actions[ actions.length - 1 ]; action._cacheIndex = null; action._byClipCacheIndex = null; lastInactiveAction._cacheIndex = cacheIndex; actions[ cacheIndex ] = lastInactiveAction; actions.pop(); this._removeInactiveBindingsForAction( action ); } delete actionsByClip[ clipUuid ]; } }, // free all resources specific to a particular root target object uncacheRoot: function ( root ) { var rootUuid = root.uuid, actionsByClip = this._actionsByClip; for ( var clipUuid in actionsByClip ) { var actionByRoot = actionsByClip[ clipUuid ].actionByRoot, action = actionByRoot[ rootUuid ]; if ( action !== undefined ) { this._deactivateAction( action ); this._removeInactiveAction( action ); } } var bindingsByRoot = this._bindingsByRootAndName, bindingByName = bindingsByRoot[ rootUuid ]; if ( bindingByName !== undefined ) { for ( var trackName in bindingByName ) { var binding = bindingByName[ trackName ]; binding.restoreOriginalState(); this._removeInactiveBinding( binding ); } } }, // remove a targeted clip from the cache uncacheAction: function ( clip, optionalRoot ) { var action = this.existingAction( clip, optionalRoot ); if ( action !== null ) { this._deactivateAction( action ); this._removeInactiveAction( action ); } } } ); /** * @author mrdoob / http://mrdoob.com/ */ function Uniform( value ) { if ( typeof value === 'string' ) { console.warn( 'THREE.Uniform: Type parameter is no longer needed.' ); value = arguments[ 1 ]; } this.value = value; } Uniform.prototype.clone = function () { return new Uniform( this.value.clone === undefined ? this.value : this.value.clone() ); }; /** * @author benaadams / https://twitter.com/ben_a_adams */ function InstancedBufferGeometry() { BufferGeometry.call( this ); this.type = 'InstancedBufferGeometry'; this.maxInstancedCount = undefined; } InstancedBufferGeometry.prototype = Object.assign( Object.create( BufferGeometry.prototype ), { constructor: InstancedBufferGeometry, isInstancedBufferGeometry: true, copy: function ( source ) { BufferGeometry.prototype.copy.call( this, source ); this.maxInstancedCount = source.maxInstancedCount; return this; }, clone: function () { return new this.constructor().copy( this ); } } ); /** * @author benaadams / https://twitter.com/ben_a_adams */ function InstancedInterleavedBuffer( array, stride, meshPerAttribute ) { InterleavedBuffer.call( this, array, stride ); this.meshPerAttribute = meshPerAttribute || 1; } InstancedInterleavedBuffer.prototype = Object.assign( Object.create( InterleavedBuffer.prototype ), { constructor: InstancedInterleavedBuffer, isInstancedInterleavedBuffer: true, copy: function ( source ) { InterleavedBuffer.prototype.copy.call( this, source ); this.meshPerAttribute = source.meshPerAttribute; return this; } } ); /** * @author benaadams / https://twitter.com/ben_a_adams */ function InstancedBufferAttribute( array, itemSize, normalized, meshPerAttribute ) { if ( typeof ( normalized ) === 'number' ) { meshPerAttribute = normalized; normalized = false; console.error( 'THREE.InstancedBufferAttribute: The constructor now expects normalized as the third argument.' ); } BufferAttribute.call( this, array, itemSize, normalized ); this.meshPerAttribute = meshPerAttribute || 1; } InstancedBufferAttribute.prototype = Object.assign( Object.create( BufferAttribute.prototype ), { constructor: InstancedBufferAttribute, isInstancedBufferAttribute: true, copy: function ( source ) { BufferAttribute.prototype.copy.call( this, source ); this.meshPerAttribute = source.meshPerAttribute; return this; } } ); /** * @author mrdoob / http://mrdoob.com/ * @author bhouston / http://clara.io/ * @author stephomi / http://stephaneginier.com/ */ function Raycaster( origin, direction, near, far ) { this.ray = new Ray( origin, direction ); // direction is assumed to be normalized (for accurate distance calculations) this.near = near || 0; this.far = far || Infinity; this.params = { Mesh: {}, Line: {}, LOD: {}, Points: { threshold: 1 }, Sprite: {} }; Object.defineProperties( this.params, { PointCloud: { get: function () { console.warn( 'THREE.Raycaster: params.PointCloud has been renamed to params.Points.' ); return this.Points; } } } ); } function ascSort( a, b ) { return a.distance - b.distance; } function intersectObject( object, raycaster, intersects, recursive ) { if ( object.visible === false ) return; object.raycast( raycaster, intersects ); if ( recursive === true ) { var children = object.children; for ( var i = 0, l = children.length; i < l; i ++ ) { intersectObject( children[ i ], raycaster, intersects, true ); } } } Object.assign( Raycaster.prototype, { linePrecision: 1, set: function ( origin, direction ) { // direction is assumed to be normalized (for accurate distance calculations) this.ray.set( origin, direction ); }, setFromCamera: function ( coords, camera ) { if ( ( camera && camera.isPerspectiveCamera ) ) { this.ray.origin.setFromMatrixPosition( camera.matrixWorld ); this.ray.direction.set( coords.x, coords.y, 0.5 ).unproject( camera ).sub( this.ray.origin ).normalize(); } else if ( ( camera && camera.isOrthographicCamera ) ) { this.ray.origin.set( coords.x, coords.y, ( camera.near + camera.far ) / ( camera.near - camera.far ) ).unproject( camera ); // set origin in plane of camera this.ray.direction.set( 0, 0, - 1 ).transformDirection( camera.matrixWorld ); } else { console.error( 'THREE.Raycaster: Unsupported camera type.' ); } }, intersectObject: function ( object, recursive, optionalTarget ) { var intersects = optionalTarget || []; intersectObject( object, this, intersects, recursive ); intersects.sort( ascSort ); return intersects; }, intersectObjects: function ( objects, recursive, optionalTarget ) { var intersects = optionalTarget || []; if ( Array.isArray( objects ) === false ) { console.warn( 'THREE.Raycaster.intersectObjects: objects is not an Array.' ); return intersects; } for ( var i = 0, l = objects.length; i < l; i ++ ) { intersectObject( objects[ i ], this, intersects, recursive ); } intersects.sort( ascSort ); return intersects; } } ); /** * @author bhouston / http://clara.io * @author WestLangley / http://github.com/WestLangley * * Ref: https://en.wikipedia.org/wiki/Spherical_coordinate_system * * The polar angle (phi) is measured from the positive y-axis. The positive y-axis is up. * The azimuthal angle (theta) is measured from the positive z-axiz. */ function Spherical( radius, phi, theta ) { this.radius = ( radius !== undefined ) ? radius : 1.0; this.phi = ( phi !== undefined ) ? phi : 0; // polar angle this.theta = ( theta !== undefined ) ? theta : 0; // azimuthal angle return this; } Object.assign( Spherical.prototype, { set: function ( radius, phi, theta ) { this.radius = radius; this.phi = phi; this.theta = theta; return this; }, clone: function () { return new this.constructor().copy( this ); }, copy: function ( other ) { this.radius = other.radius; this.phi = other.phi; this.theta = other.theta; return this; }, // restrict phi to be betwee EPS and PI-EPS makeSafe: function () { var EPS = 0.000001; this.phi = Math.max( EPS, Math.min( Math.PI - EPS, this.phi ) ); return this; }, setFromVector3: function ( v ) { return this.setFromCartesianCoords( v.x, v.y, v.z ); }, setFromCartesianCoords: function ( x, y, z ) { this.radius = Math.sqrt( x * x + y * y + z * z ); if ( this.radius === 0 ) { this.theta = 0; this.phi = 0; } else { this.theta = Math.atan2( x, z ); this.phi = Math.acos( _Math.clamp( y / this.radius, - 1, 1 ) ); } return this; } } ); /** * @author Mugen87 / https://github.com/Mugen87 * * Ref: https://en.wikipedia.org/wiki/Cylindrical_coordinate_system * */ function Cylindrical( radius, theta, y ) { this.radius = ( radius !== undefined ) ? radius : 1.0; // distance from the origin to a point in the x-z plane this.theta = ( theta !== undefined ) ? theta : 0; // counterclockwise angle in the x-z plane measured in radians from the positive z-axis this.y = ( y !== undefined ) ? y : 0; // height above the x-z plane return this; } Object.assign( Cylindrical.prototype, { set: function ( radius, theta, y ) { this.radius = radius; this.theta = theta; this.y = y; return this; }, clone: function () { return new this.constructor().copy( this ); }, copy: function ( other ) { this.radius = other.radius; this.theta = other.theta; this.y = other.y; return this; }, setFromVector3: function ( v ) { return this.setFromCartesianCoords( v.x, v.y, v.z ); }, setFromCartesianCoords: function ( x, y, z ) { this.radius = Math.sqrt( x * x + z * z ); this.theta = Math.atan2( x, z ); this.y = y; return this; } } ); /** * @author bhouston / http://clara.io */ function Box2( min, max ) { this.min = ( min !== undefined ) ? min : new Vector2( + Infinity, + Infinity ); this.max = ( max !== undefined ) ? max : new Vector2( - Infinity, - Infinity ); } Object.assign( Box2.prototype, { set: function ( min, max ) { this.min.copy( min ); this.max.copy( max ); return this; }, setFromPoints: function ( points ) { this.makeEmpty(); for ( var i = 0, il = points.length; i < il; i ++ ) { this.expandByPoint( points[ i ] ); } return this; }, setFromCenterAndSize: function () { var v1 = new Vector2(); return function setFromCenterAndSize( center, size ) { var halfSize = v1.copy( size ).multiplyScalar( 0.5 ); this.min.copy( center ).sub( halfSize ); this.max.copy( center ).add( halfSize ); return this; }; }(), clone: function () { return new this.constructor().copy( this ); }, copy: function ( box ) { this.min.copy( box.min ); this.max.copy( box.max ); return this; }, makeEmpty: function () { this.min.x = this.min.y = + Infinity; this.max.x = this.max.y = - Infinity; return this; }, isEmpty: function () { // this is a more robust check for empty than ( volume this.max.y ? false : true; }, containsBox: function ( box ) { return this.min.x this.max.y ? false : true; }, clampPoint: function ( point, target ) { if ( target === undefined ) { console.warn( 'THREE.Box2: .clampPoint() target is now required' ); target = new Vector2(); } return target.copy( point ).clamp( this.min, this.max ); }, distanceToPoint: function () { var v1 = new Vector2(); return function distanceToPoint( point ) { var clampedPoint = v1.copy( point ).clamp( this.min, this.max ); return clampedPoint.sub( point ).length(); }; }(), intersect: function ( box ) { this.min.max( box.min ); this.max.min( box.max ); return this; }, union: function ( box ) { this.min.min( box.min ); this.max.max( box.max ); return this; }, translate: function ( offset ) { this.min.add( offset ); this.max.add( offset ); return this; }, equals: function ( box ) { return box.min.equals( this.min ) && box.max.equals( this.max ); } } ); /** * @author bhouston / http://clara.io */ function Line3( start, end ) { this.start = ( start !== undefined ) ? start : new Vector3(); this.end = ( end !== undefined ) ? end : new Vector3(); } Object.assign( Line3.prototype, { set: function ( start, end ) { this.start.copy( start ); this.end.copy( end ); return this; }, clone: function () { return new this.constructor().copy( this ); }, copy: function ( line ) { this.start.copy( line.start ); this.end.copy( line.end ); return this; }, getCenter: function ( target ) { if ( target === undefined ) { console.warn( 'THREE.Line3: .getCenter() target is now required' ); target = new Vector3(); } return target.addVectors( this.start, this.end ).multiplyScalar( 0.5 ); }, delta: function ( target ) { if ( target === undefined ) { console.warn( 'THREE.Line3: .delta() target is now required' ); target = new Vector3(); } return target.subVectors( this.end, this.start ); }, distanceSq: function () { return this.start.distanceToSquared( this.end ); }, distance: function () { return this.start.distanceTo( this.end ); }, at: function ( t, target ) { if ( target === undefined ) { console.warn( 'THREE.Line3: .at() target is now required' ); target = new Vector3(); } return this.delta( target ).multiplyScalar( t ).add( this.start ); }, closestPointToPointParameter: function () { var startP = new Vector3(); var startEnd = new Vector3(); return function closestPointToPointParameter( point, clampToLine ) { startP.subVectors( point, this.start ); startEnd.subVectors( this.end, this.start ); var startEnd2 = startEnd.dot( startEnd ); var startEnd_startP = startEnd.dot( startP ); var t = startEnd_startP / startEnd2; if ( clampToLine ) { t = _Math.clamp( t, 0, 1 ); } return t; }; }(), closestPointToPoint: function ( point, clampToLine, target ) { var t = this.closestPointToPointParameter( point, clampToLine ); if ( target === undefined ) { console.warn( 'THREE.Line3: .closestPointToPoint() target is now required' ); target = new Vector3(); } return this.delta( target ).multiplyScalar( t ).add( this.start ); }, applyMatrix4: function ( matrix ) { this.start.applyMatrix4( matrix ); this.end.applyMatrix4( matrix ); return this; }, equals: function ( line ) { return line.start.equals( this.start ) && line.end.equals( this.end ); } } ); /** * @author alteredq / http://alteredqualia.com/ */ function ImmediateRenderObject( material ) { Object3D.call( this ); this.material = material; this.render = function ( /* renderCallback */ ) {}; } ImmediateRenderObject.prototype = Object.create( Object3D.prototype ); ImmediateRenderObject.prototype.constructor = ImmediateRenderObject; ImmediateRenderObject.prototype.isImmediateRenderObject = true; /** * @author mrdoob / http://mrdoob.com/ * @author WestLangley / http://github.com/WestLangley */ function VertexNormalsHelper( object, size, hex, linewidth ) { this.object = object; this.size = ( size !== undefined ) ? size : 1; var color = ( hex !== undefined ) ? hex : 0xff0000; var width = ( linewidth !== undefined ) ? linewidth : 1; // var nNormals = 0; var objGeometry = this.object.geometry; if ( objGeometry && objGeometry.isGeometry ) { nNormals = objGeometry.faces.length * 3; } else if ( objGeometry && objGeometry.isBufferGeometry ) { nNormals = objGeometry.attributes.normal.count; } // var geometry = new BufferGeometry(); var positions = new Float32BufferAttribute( nNormals * 2 * 3, 3 ); geometry.addAttribute( 'position', positions ); LineSegments.call( this, geometry, new LineBasicMaterial( { color: color, linewidth: width } ) ); // this.matrixAutoUpdate = false; this.update(); } VertexNormalsHelper.prototype = Object.create( LineSegments.prototype ); VertexNormalsHelper.prototype.constructor = VertexNormalsHelper; VertexNormalsHelper.prototype.update = ( function () { var v1 = new Vector3(); var v2 = new Vector3(); var normalMatrix = new Matrix3(); return function update() { var keys = [ 'a', 'b', 'c' ]; this.object.updateMatrixWorld( true ); normalMatrix.getNormalMatrix( this.object.matrixWorld ); var matrixWorld = this.object.matrixWorld; var position = this.geometry.attributes.position; // var objGeometry = this.object.geometry; if ( objGeometry && objGeometry.isGeometry ) { var vertices = objGeometry.vertices; var faces = objGeometry.faces; var idx = 0; for ( var i = 0, l = faces.length; i < l; i ++ ) { var face = faces[ i ]; for ( var j = 0, jl = face.vertexNormals.length; j < jl; j ++ ) { var vertex = vertices[ face[ keys[ j ] ] ]; var normal = face.vertexNormals[ j ]; v1.copy( vertex ).applyMatrix4( matrixWorld ); v2.copy( normal ).applyMatrix3( normalMatrix ).normalize().multiplyScalar( this.size ).add( v1 ); position.setXYZ( idx, v1.x, v1.y, v1.z ); idx = idx + 1; position.setXYZ( idx, v2.x, v2.y, v2.z ); idx = idx + 1; } } } else if ( objGeometry && objGeometry.isBufferGeometry ) { var objPos = objGeometry.attributes.position; var objNorm = objGeometry.attributes.normal; var idx = 0; // for simplicity, ignore index and drawcalls, and render every normal for ( var j = 0, jl = objPos.count; j < jl; j ++ ) { v1.set( objPos.getX( j ), objPos.getY( j ), objPos.getZ( j ) ).applyMatrix4( matrixWorld ); v2.set( objNorm.getX( j ), objNorm.getY( j ), objNorm.getZ( j ) ); v2.applyMatrix3( normalMatrix ).normalize().multiplyScalar( this.size ).add( v1 ); position.setXYZ( idx, v1.x, v1.y, v1.z ); idx = idx + 1; position.setXYZ( idx, v2.x, v2.y, v2.z ); idx = idx + 1; } } position.needsUpdate = true; }; }() ); /** * @author alteredq / http://alteredqualia.com/ * @author mrdoob / http://mrdoob.com/ * @author WestLangley / http://github.com/WestLangley */ function SpotLightHelper( light, color ) { Object3D.call( this ); this.light = light; this.light.updateMatrixWorld(); this.matrix = light.matrixWorld; this.matrixAutoUpdate = false; this.color = color; var geometry = new BufferGeometry(); var positions = [ 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, - 1, 0, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, - 1, 1 ]; for ( var i = 0, j = 1, l = 32; i < l; i ++, j ++ ) { var p1 = ( i / l ) * Math.PI * 2; var p2 = ( j / l ) * Math.PI * 2; positions.push( Math.cos( p1 ), Math.sin( p1 ), 1, Math.cos( p2 ), Math.sin( p2 ), 1 ); } geometry.addAttribute( 'position', new Float32BufferAttribute( positions, 3 ) ); var material = new LineBasicMaterial( { fog: false } ); this.cone = new LineSegments( geometry, material ); this.add( this.cone ); this.update(); } SpotLightHelper.prototype = Object.create( Object3D.prototype ); SpotLightHelper.prototype.constructor = SpotLightHelper; SpotLightHelper.prototype.dispose = function () { this.cone.geometry.dispose(); this.cone.material.dispose(); }; SpotLightHelper.prototype.update = function () { var vector = new Vector3(); return function update() { this.light.updateMatrixWorld(); var coneLength = this.light.distance ? this.light.distance : 1000; var coneWidth = coneLength * Math.tan( this.light.angle ); this.cone.scale.set( coneWidth, coneWidth, coneLength ); vector.setFromMatrixPosition( this.light.target.matrixWorld ); this.cone.lookAt( vector ); if ( this.color !== undefined ) { this.cone.material.color.set( this.color ); } else { this.cone.material.color.copy( this.light.color ); } }; }(); /** * @author Sean Griffin / http://twitter.com/sgrif * @author Michael Guerrero / http://realitymeltdown.com * @author mrdoob / http://mrdoob.com/ * @author ikerr / http://verold.com * @author Mugen87 / https://github.com/Mugen87 */ function getBoneList( object ) { var boneList = []; if ( object && object.isBone ) { boneList.push( object ); } for ( var i = 0; i < object.children.length; i ++ ) { boneList.push.apply( boneList, getBoneList( object.children[ i ] ) ); } return boneList; } function SkeletonHelper( object ) { var bones = getBoneList( object ); var geometry = new BufferGeometry(); var vertices = []; var colors = []; var color1 = new Color( 0, 0, 1 ); var color2 = new Color( 0, 1, 0 ); for ( var i = 0; i < bones.length; i ++ ) { var bone = bones[ i ]; if ( bone.parent && bone.parent.isBone ) { vertices.push( 0, 0, 0 ); vertices.push( 0, 0, 0 ); colors.push( color1.r, color1.g, color1.b ); colors.push( color2.r, color2.g, color2.b ); } } geometry.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) ); geometry.addAttribute( 'color', new Float32BufferAttribute( colors, 3 ) ); var material = new LineBasicMaterial( { vertexColors: VertexColors, depthTest: false, depthWrite: false, transparent: true } ); LineSegments.call( this, geometry, material ); this.root = object; this.bones = bones; this.matrix = object.matrixWorld; this.matrixAutoUpdate = false; } SkeletonHelper.prototype = Object.create( LineSegments.prototype ); SkeletonHelper.prototype.constructor = SkeletonHelper; SkeletonHelper.prototype.updateMatrixWorld = function () { var vector = new Vector3(); var boneMatrix = new Matrix4(); var matrixWorldInv = new Matrix4(); return function updateMatrixWorld( force ) { var bones = this.bones; var geometry = this.geometry; var position = geometry.getAttribute( 'position' ); matrixWorldInv.getInverse( this.root.matrixWorld ); for ( var i = 0, j = 0; i < bones.length; i ++ ) { var bone = bones[ i ]; if ( bone.parent && bone.parent.isBone ) { boneMatrix.multiplyMatrices( matrixWorldInv, bone.matrixWorld ); vector.setFromMatrixPosition( boneMatrix ); position.setXYZ( j, vector.x, vector.y, vector.z ); boneMatrix.multiplyMatrices( matrixWorldInv, bone.parent.matrixWorld ); vector.setFromMatrixPosition( boneMatrix ); position.setXYZ( j + 1, vector.x, vector.y, vector.z ); j += 2; } } geometry.getAttribute( 'position' ).needsUpdate = true; Object3D.prototype.updateMatrixWorld.call( this, force ); }; }(); /** * @author alteredq / http://alteredqualia.com/ * @author mrdoob / http://mrdoob.com/ */ function PointLightHelper( light, sphereSize, color ) { this.light = light; this.light.updateMatrixWorld(); this.color = color; var geometry = new SphereBufferGeometry( sphereSize, 4, 2 ); var material = new MeshBasicMaterial( { wireframe: true, fog: false } ); Mesh.call( this, geometry, material ); this.matrix = this.light.matrixWorld; this.matrixAutoUpdate = false; this.update(); /* var distanceGeometry = new THREE.IcosahedronBufferGeometry( 1, 2 ); var distanceMaterial = new THREE.MeshBasicMaterial( { color: hexColor, fog: false, wireframe: true, opacity: 0.1, transparent: true } ); this.lightSphere = new THREE.Mesh( bulbGeometry, bulbMaterial ); this.lightDistance = new THREE.Mesh( distanceGeometry, distanceMaterial ); var d = light.distance; if ( d === 0.0 ) { this.lightDistance.visible = false; } else { this.lightDistance.scale.set( d, d, d ); } this.add( this.lightDistance ); */ } PointLightHelper.prototype = Object.create( Mesh.prototype ); PointLightHelper.prototype.constructor = PointLightHelper; PointLightHelper.prototype.dispose = function () { this.geometry.dispose(); this.material.dispose(); }; PointLightHelper.prototype.update = function () { if ( this.color !== undefined ) { this.material.color.set( this.color ); } else { this.material.color.copy( this.light.color ); } /* var d = this.light.distance; if ( d === 0.0 ) { this.lightDistance.visible = false; } else { this.lightDistance.visible = true; this.lightDistance.scale.set( d, d, d ); } */ }; /** * @author abelnation / http://github.com/abelnation * @author Mugen87 / http://github.com/Mugen87 * @author WestLangley / http://github.com/WestLangley * * This helper must be added as a child of the light */ function RectAreaLightHelper( light, color ) { this.type = 'RectAreaLightHelper'; this.light = light; this.color = color; // optional hardwired color for the helper var positions = [ 1, 1, 0, - 1, 1, 0, - 1, - 1, 0, 1, - 1, 0, 1, 1, 0 ]; var geometry = new BufferGeometry(); geometry.addAttribute( 'position', new Float32BufferAttribute( positions, 3 ) ); geometry.computeBoundingSphere(); var material = new LineBasicMaterial( { fog: false } ); Line.call( this, geometry, material ); // var positions2 = [ 1, 1, 0, - 1, 1, 0, - 1, - 1, 0, 1, 1, 0, - 1, - 1, 0, 1, - 1, 0 ]; var geometry2 = new BufferGeometry(); geometry2.addAttribute( 'position', new Float32BufferAttribute( positions2, 3 ) ); geometry2.computeBoundingSphere(); this.add( new Mesh( geometry2, new MeshBasicMaterial( { side: BackSide, fog: false } ) ) ); this.update(); } RectAreaLightHelper.prototype = Object.create( Line.prototype ); RectAreaLightHelper.prototype.constructor = RectAreaLightHelper; RectAreaLightHelper.prototype.update = function () { this.scale.set( 0.5 * this.light.width, 0.5 * this.light.height, 1 ); if ( this.color !== undefined ) { this.material.color.set( this.color ); this.children[ 0 ].material.color.set( this.color ); } else { this.material.color.copy( this.light.color ).multiplyScalar( this.light.intensity ); // prevent hue shift var c = this.material.color; var max = Math.max( c.r, c.g, c.b ); if ( max > 1 ) c.multiplyScalar( 1 / max ); this.children[ 0 ].material.color.copy( this.material.color ); } }; RectAreaLightHelper.prototype.dispose = function () { this.geometry.dispose(); this.material.dispose(); this.children[ 0 ].geometry.dispose(); this.children[ 0 ].material.dispose(); }; /** * @author alteredq / http://alteredqualia.com/ * @author mrdoob / http://mrdoob.com/ * @author Mugen87 / https://github.com/Mugen87 */ function HemisphereLightHelper( light, size, color ) { Object3D.call( this ); this.light = light; this.light.updateMatrixWorld(); this.matrix = light.matrixWorld; this.matrixAutoUpdate = false; this.color = color; var geometry = new OctahedronBufferGeometry( size ); geometry.rotateY( Math.PI * 0.5 ); this.material = new MeshBasicMaterial( { wireframe: true, fog: false } ); if ( this.color === undefined ) this.material.vertexColors = VertexColors; var position = geometry.getAttribute( 'position' ); var colors = new Float32Array( position.count * 3 ); geometry.addAttribute( 'color', new BufferAttribute( colors, 3 ) ); this.add( new Mesh( geometry, this.material ) ); this.update(); } HemisphereLightHelper.prototype = Object.create( Object3D.prototype ); HemisphereLightHelper.prototype.constructor = HemisphereLightHelper; HemisphereLightHelper.prototype.dispose = function () { this.children[ 0 ].geometry.dispose(); this.children[ 0 ].material.dispose(); }; HemisphereLightHelper.prototype.update = function () { var vector = new Vector3(); var color1 = new Color(); var color2 = new Color(); return function update() { var mesh = this.children[ 0 ]; if ( this.color !== undefined ) { this.material.color.set( this.color ); } else { var colors = mesh.geometry.getAttribute( 'color' ); color1.copy( this.light.color ); color2.copy( this.light.groundColor ); for ( var i = 0, l = colors.count; i < l; i ++ ) { var color = ( i < ( l / 2 ) ) ? color1 : color2; colors.setXYZ( i, color.r, color.g, color.b ); } colors.needsUpdate = true; } mesh.lookAt( vector.setFromMatrixPosition( this.light.matrixWorld ).negate() ); }; }(); /** * @author mrdoob / http://mrdoob.com/ */ function GridHelper( size, divisions, color1, color2 ) { size = size || 10; divisions = divisions || 10; color1 = new Color( color1 !== undefined ? color1 : 0x444444 ); color2 = new Color( color2 !== undefined ? color2 : 0x888888 ); var center = divisions / 2; var step = size / divisions; var halfSize = size / 2; var vertices = [], colors = []; for ( var i = 0, j = 0, k = - halfSize; i","categories":[],"tags":[]},{"title":"","slug":"Three.js移动DecalGeometry/js/dat.gui.min","date":"2019-03-17T10:06:35.707Z","updated":"2019-03-17T10:06:35.707Z","comments":true,"path":"2019/03/17/cjtcra7jm000ah1l3iopbyck2/","link":"","permalink":"http://www.zcating.tk/2019/03/17/cjtcra7jm000ah1l3iopbyck2/","excerpt":"","text":"/** * dat-gui JavaScript Controller Library * https://github.com/dataarts/dat.gui * * Copyright 2016 Data Arts Team, Google Creative Lab * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 */ !function(e,t){\"object\"==typeof exports&&\"object\"==typeof module?module.exports=t():\"function\"==typeof define&&define.amd?define([],t):\"object\"==typeof exports?exports.dat=t():e.dat=t()}(this,function(){return function(e){function t(o){if(n[o])return n[o].exports;var i=n[o]={exports:{},id:o,loaded:!1};return e[o].call(i.exports,i,i.exports,t),i.loaded=!0,i.exports}var n={};return t.m=e,t.c=n,t.p=\"\",t(0)}([function(e,t,n){\"use strict\";function o(e){return e&&e.__esModule?e:{\"default\":e}}var i=n(1),r=o(i);e.exports=r[\"default\"]},function(e,t,n){\"use strict\";function o(e){return e&&e.__esModule?e:{\"default\":e}}t.__esModule=!0;var i=n(2),r=o(i),a=n(6),l=o(a),s=n(3),u=o(s),d=n(7),c=o(d),f=n(8),_=o(f),p=n(10),h=o(p),m=n(11),b=o(m),g=n(12),v=o(g),y=n(13),w=o(y),x=n(14),E=o(x),C=n(15),A=o(C),S=n(16),k=o(S),O=n(9),T=o(O),R=n(17),L=o(R);t[\"default\"]={color:{Color:r[\"default\"],math:l[\"default\"],interpret:u[\"default\"]},controllers:{Controller:c[\"default\"],BooleanController:_[\"default\"],OptionController:h[\"default\"],StringController:b[\"default\"],NumberController:v[\"default\"],NumberControllerBox:w[\"default\"],NumberControllerSlider:E[\"default\"],FunctionController:A[\"default\"],ColorController:k[\"default\"]},dom:{dom:T[\"default\"]},gui:{GUI:L[\"default\"]},GUI:L[\"default\"]}},function(e,t,n){\"use strict\";function o(e){return e&&e.__esModule?e:{\"default\":e}}function i(e,t){if(!(e instanceof t))throw new TypeError(\"Cannot call a class as a function\")}function r(e,t,n){Object.defineProperty(e,t,{get:function(){return\"RGB\"===this.__state.space?this.__state[t]:(h.recalculateRGB(this,t,n),this.__state[t])},set:function(e){\"RGB\"!==this.__state.space&&(h.recalculateRGB(this,t,n),this.__state.space=\"RGB\"),this.__state[t]=e}})}function a(e,t){Object.defineProperty(e,t,{get:function(){return\"HSV\"===this.__state.space?this.__state[t]:(h.recalculateHSV(this),this.__state[t])},set:function(e){\"HSV\"!==this.__state.space&&(h.recalculateHSV(this),this.__state.space=\"HSV\"),this.__state[t]=e}})}t.__esModule=!0;var l=n(3),s=o(l),u=n(6),d=o(u),c=n(4),f=o(c),_=n(5),p=o(_),h=function(){function e(){if(i(this,e),this.__state=s[\"default\"].apply(this,arguments),this.__state===!1)throw new Error(\"Failed to interpret color arguments\");this.__state.a=this.__state.a||1}return e.prototype.toString=function(){return(0,f[\"default\"])(this)},e.prototype.toHexString=function(){return(0,f[\"default\"])(this,!0)},e.prototype.toOriginal=function(){return this.__state.conversion.write(this)},e}();h.recalculateRGB=function(e,t,n){if(\"HEX\"===e.__state.space)e.__state[t]=d[\"default\"].component_from_hex(e.__state.hex,n);else{if(\"HSV\"!==e.__state.space)throw new Error(\"Corrupted color state\");p[\"default\"].extend(e.__state,d[\"default\"].hsv_to_rgb(e.__state.h,e.__state.s,e.__state.v))}},h.recalculateHSV=function(e){var t=d[\"default\"].rgb_to_hsv(e.r,e.g,e.b);p[\"default\"].extend(e.__state,{s:t.s,v:t.v}),p[\"default\"].isNaN(t.h)?p[\"default\"].isUndefined(e.__state.h)&&(e.__state.h=0):e.__state.h=t.h},h.COMPONENTS=[\"r\",\"g\",\"b\",\"h\",\"s\",\"v\",\"hex\",\"a\"],r(h.prototype,\"r\",2),r(h.prototype,\"g\",1),r(h.prototype,\"b\",0),a(h.prototype,\"h\"),a(h.prototype,\"s\"),a(h.prototype,\"v\"),Object.defineProperty(h.prototype,\"a\",{get:function(){return this.__state.a},set:function(e){this.__state.a=e}}),Object.defineProperty(h.prototype,\"hex\",{get:function(){return\"HEX\"!==!this.__state.space&&(this.__state.hex=d[\"default\"].rgb_to_hex(this.r,this.g,this.b)),this.__state.hex},set:function(e){this.__state.space=\"HEX\",this.__state.hex=e}}),t[\"default\"]=h},function(e,t,n){\"use strict\";function o(e){return e&&e.__esModule?e:{\"default\":e}}t.__esModule=!0;var i=n(4),r=o(i),a=n(5),l=o(a),s=[{litmus:l[\"default\"].isString,conversions:{THREE_CHAR_HEX:{read:function(e){var t=e.match(/^#([A-F0-9])([A-F0-9])([A-F0-9])$/i);return null!==t&&{space:\"HEX\",hex:parseInt(\"0x\"+t[1].toString()+t[1].toString()+t[2].toString()+t[2].toString()+t[3].toString()+t[3].toString(),0)}},write:r[\"default\"]},SIX_CHAR_HEX:{read:function(e){var t=e.match(/^#([A-F0-9]{6})$/i);return null!==t&&{space:\"HEX\",hex:parseInt(\"0x\"+t[1].toString(),0)}},write:r[\"default\"]},CSS_RGB:{read:function(e){var t=e.match(/^rgb\\(\\s*(.+)\\s*,\\s*(.+)\\s*,\\s*(.+)\\s*\\)/);return null!==t&&{space:\"RGB\",r:parseFloat(t[1]),g:parseFloat(t[2]),b:parseFloat(t[3])}},write:r[\"default\"]},CSS_RGBA:{read:function(e){var t=e.match(/^rgba\\(\\s*(.+)\\s*,\\s*(.+)\\s*,\\s*(.+)\\s*,\\s*(.+)\\s*\\)/);return null!==t&&{space:\"RGB\",r:parseFloat(t[1]),g:parseFloat(t[2]),b:parseFloat(t[3]),a:parseFloat(t[4])}},write:r[\"default\"]}}},{litmus:l[\"default\"].isNumber,conversions:{HEX:{read:function(e){return{space:\"HEX\",hex:e,conversionName:\"HEX\"}},write:function(e){return e.hex}}}},{litmus:l[\"default\"].isArray,conversions:{RGB_ARRAY:{read:function(e){return 3===e.length&&{space:\"RGB\",r:e[0],g:e[1],b:e[2]}},write:function(e){return[e.r,e.g,e.b]}},RGBA_ARRAY:{read:function(e){return 4===e.length&&{space:\"RGB\",r:e[0],g:e[1],b:e[2],a:e[3]}},write:function(e){return[e.r,e.g,e.b,e.a]}}}},{litmus:l[\"default\"].isObject,conversions:{RGBA_OBJ:{read:function(e){return!!(l[\"default\"].isNumber(e.r)&&l[\"default\"].isNumber(e.g)&&l[\"default\"].isNumber(e.b)&&l[\"default\"].isNumber(e.a))&&{space:\"RGB\",r:e.r,g:e.g,b:e.b,a:e.a}},write:function(e){return{r:e.r,g:e.g,b:e.b,a:e.a}}},RGB_OBJ:{read:function(e){return!!(l[\"default\"].isNumber(e.r)&&l[\"default\"].isNumber(e.g)&&l[\"default\"].isNumber(e.b))&&{space:\"RGB\",r:e.r,g:e.g,b:e.b}},write:function(e){return{r:e.r,g:e.g,b:e.b}}},HSVA_OBJ:{read:function(e){return!!(l[\"default\"].isNumber(e.h)&&l[\"default\"].isNumber(e.s)&&l[\"default\"].isNumber(e.v)&&l[\"default\"].isNumber(e.a))&&{space:\"HSV\",h:e.h,s:e.s,v:e.v,a:e.a}},write:function(e){return{h:e.h,s:e.s,v:e.v,a:e.a}}},HSV_OBJ:{read:function(e){return!!(l[\"default\"].isNumber(e.h)&&l[\"default\"].isNumber(e.s)&&l[\"default\"].isNumber(e.v))&&{space:\"HSV\",h:e.h,s:e.s,v:e.v}},write:function(e){return{h:e.h,s:e.s,v:e.v}}}}}],u=void 0,d=void 0,c=function(){d=!1;var e=arguments.length>1?l[\"default\"].toArray(arguments):arguments[0];return l[\"default\"].each(s,function(t){if(t.litmus(e))return l[\"default\"].each(t.conversions,function(t,n){if(u=t.read(e),d===!1&&u!==!1)return d=u,u.conversionName=n,u.conversion=t,l[\"default\"].BREAK}),l[\"default\"].BREAK}),d};t[\"default\"]=c},function(e,t){\"use strict\";t.__esModule=!0,t[\"default\"]=function(e,t){var n=e.__state.conversionName.toString(),o=Math.round(e.r),i=Math.round(e.g),r=Math.round(e.b),a=e.a,l=Math.round(e.h),s=e.s.toFixed(1),u=e.v.toFixed(1);if(t||\"THREE_CHAR_HEX\"===n||\"SIX_CHAR_HEX\"===n){for(var d=e.hex.toString(16);d.length=0;n--)t=[e[n].apply(this,t)];return t[0]}},each:function(e,t,o){if(e)if(n&&e.forEach&&e.forEach===n)e.forEach(t,o);else if(e.length===e.length+0){var i=void 0,r=void 0;for(i=0,r=e.length;iul{margin-top:27px}.dg.a.has-save>ul.closed{margin-top:0}.dg.a .save-row{position:fixed;top:0;z-index:1002}.dg li{-webkit-transition:height .1s ease-out;transition:height .1s ease-out}.dg li:not(.folder){cursor:auto;height:27px;line-height:27px;overflow:hidden;padding:0 4px 0 5px}.dg li.folder{padding:0;border-left:4px solid transparent}.dg li.title{cursor:pointer;margin-left:-4px}.dg .closed li:not(.title),.dg .closed ul li,.dg .closed ul li>*{height:0;overflow:hidden;border:0}.dg .cr{clear:both;padding-left:3px;height:27px}.dg .property-name{cursor:default;float:left;clear:left;width:40%;overflow:hidden;text-overflow:ellipsis}.dg .c{float:left;width:60%}.dg .c input[type=text]{border:0;margin-top:4px;padding:3px;width:100%;float:right}.dg .has-slider input[type=text]{width:30%;margin-left:0}.dg .slider{float:left;width:66%;margin-left:-5px;margin-right:0;height:19px;margin-top:4px}.dg .slider-fg{height:100%}.dg .c input[type=checkbox]{margin-top:9px}.dg .c select{margin-top:5px}.dg .cr.boolean,.dg .cr.boolean *,.dg .cr.function,.dg .cr.function *,.dg .cr.function .property-name{cursor:pointer}.dg .selector{display:none;position:absolute;margin-left:-9px;margin-top:23px;z-index:10}.dg .c:hover .selector,.dg .selector.drag{display:block}.dg li.save-row{padding:0}.dg li.save-row .button{display:inline-block;padding:0 6px}.dg.dialogue{background-color:#222;width:460px;padding:15px;font-size:13px;line-height:15px}#dg-new-constructor{padding:10px;color:#222;font-family:Monaco,monospace;font-size:10px;border:0;resize:none;box-shadow:inset 1px 1px 1px #888;word-wrap:break-word;margin:12px 0;display:block;width:440px;overflow-y:scroll;height:100px;position:relative}#dg-local-explain{display:none;font-size:11px;line-height:17px;border-radius:3px;background-color:#333;padding:8px;margin-top:10px}#dg-local-explain code{font-size:10px}#dat-gui-save-locally{display:none}.dg{color:#eee;font:11px Lucida Grande,sans-serif;text-shadow:0 -1px 0 #111}.dg.main::-webkit-scrollbar{width:5px;background:#1a1a1a}.dg.main::-webkit-scrollbar-corner{height:0;display:none}.dg.main::-webkit-scrollbar-thumb{border-radius:5px;background:#676767}.dg li:not(.folder){background:#1a1a1a;border-bottom:1px solid #2c2c2c}.dg li.save-row{line-height:25px;background:#dad5cb;border:0}.dg li.save-row select{margin-left:5px;width:108px}.dg li.save-row .button{margin-left:5px;margin-top:1px;border-radius:2px;font-size:9px;line-height:7px;padding:4px 4px 5px;background:#c5bdad;color:#fff;text-shadow:0 1px 0 #b0a58f;box-shadow:0 -1px 0 #b0a58f;cursor:pointer}.dg li.save-row .button.gears{background:#c5bdad url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAsAAAANCAYAAAB/9ZQ7AAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAQJJREFUeNpiYKAU/P//PwGIC/ApCABiBSAW+I8AClAcgKxQ4T9hoMAEUrxx2QSGN6+egDX+/vWT4e7N82AMYoPAx/evwWoYoSYbACX2s7KxCxzcsezDh3evFoDEBYTEEqycggWAzA9AuUSQQgeYPa9fPv6/YWm/Acx5IPb7ty/fw+QZblw67vDs8R0YHyQhgObx+yAJkBqmG5dPPDh1aPOGR/eugW0G4vlIoTIfyFcA+QekhhHJhPdQxbiAIguMBTQZrPD7108M6roWYDFQiIAAv6Aow/1bFwXgis+f2LUAynwoIaNcz8XNx3Dl7MEJUDGQpx9gtQ8YCueB+D26OECAAQDadt7e46D42QAAAABJRU5ErkJggg==) 2px 1px no-repeat;height:7px;width:8px}.dg li.save-row .button:hover{background-color:#bab19e;box-shadow:0 -1px 0 #b0a58f}.dg li.folder{border-bottom:0}.dg li.title{padding-left:16px;background:#000 url(data:image/gif;base64,R0lGODlhBQAFAJEAAP////Pz8////////yH5BAEAAAIALAAAAAAFAAUAAAIIlI+hKgFxoCgAOw==) 6px 10px no-repeat;cursor:pointer;border-bottom:1px solid hsla(0,0%,100%,.2)}.dg .closed li.title{background-image:url(data:image/gif;base64,R0lGODlhBQAFAJEAAP////Pz8////////yH5BAEAAAIALAAAAAAFAAUAAAIIlGIWqMCbWAEAOw==)}.dg .cr.boolean{border-left:3px solid #806787}.dg .cr.color{border-left:3px solid}.dg .cr.function{border-left:3px solid #e61d5f}.dg .cr.number{border-left:3px solid #2fa1d6}.dg .cr.number input[type=text]{color:#2fa1d6}.dg .cr.string{border-left:3px solid #1ed36f}.dg .cr.string input[type=text]{color:#1ed36f}.dg .cr.boolean:hover,.dg .cr.function:hover{background:#111}.dg .c input[type=text]{background:#303030;outline:none}.dg .c input[type=text]:hover{background:#3c3c3c}.dg .c input[type=text]:focus{background:#494949;color:#fff}.dg .c .slider{background:#303030;cursor:ew-resize}.dg .c .slider-fg{background:#2fa1d6;max-width:100%}.dg .c .slider:hover{background:#3c3c3c}.dg .c .slider:hover .slider-fg{background:#44abda}\",\"\"])},function(e,t){e.exports=function(){var e=[];return e.toString=function(){for(var e=[],t=0;t","categories":[],"tags":[]},{"title":"","slug":"Three.js移动DecalGeometry/js/stats.min","date":"2019-03-17T10:06:35.707Z","updated":"2019-03-17T10:06:35.707Z","comments":true,"path":"2019/03/17/cjtcra7jl0009h1l3gc0m08h5/","link":"","permalink":"http://www.zcating.tk/2019/03/17/cjtcra7jl0009h1l3gc0m08h5/","excerpt":"","text":"// stats.js - http://github.com/mrdoob/stats.js var Stats=function(){function h(a){c.appendChild(a.dom);return a}function k(a){for(var d=0;de+1E3&&(r.update(1E3*a/(c-e),100),e=c,a=0,t)){var d=performance.memory;t.update(d.usedJSHeapSize/1048576,d.jsHeapSizeLimit/1048576)}return c},update:function(){g=this.end()},domElement:c,setMode:k}}; Stats.Panel=function(h,k,l){var c=Infinity,g=0,e=Math.round,a=e(window.devicePixelRatio||1),r=80*a,f=48*a,t=3*a,u=2*a,d=3*a,m=15*a,n=74*a,p=30*a,q=document.createElement(\"canvas\");q.width=r;q.height=f;q.style.cssText=\"width:80px;height:48px\";var b=q.getContext(\"2d\");b.font=\"bold \"+9*a+\"px Helvetica,Arial,sans-serif\";b.textBaseline=\"top\";b.fillStyle=l;b.fillRect(0,0,r,f);b.fillStyle=k;b.fillText(h,t,u);b.fillRect(d,m,n,p);b.fillStyle=l;b.globalAlpha=.9;b.fillRect(d,m,n,p);return{dom:q,update:function(f, v){c=Math.min(c,f);g=Math.max(g,f);b.fillStyle=l;b.globalAlpha=1;b.fillRect(0,0,r,m);b.fillStyle=k;b.fillText(e(f)+\" \"+h+\" (\"+e(c)+\"-\"+e(g)+\")\",t,u);b.drawImage(q,d+a,m,n-a,p,d,m,n-a,p);b.fillRect(d+n-a,m,a,p);b.fillStyle=l;b.globalAlpha=.9;b.fillRect(d+n-a,m,a,e((1-f/v)*p))}}};\"object\"===typeof module&&(module.exports=Stats);","categories":[],"tags":[]},{"title":"","slug":"Three.js移动DecalGeometry/js/GLTFLoader","date":"2019-03-17T10:06:35.706Z","updated":"2019-03-17T10:06:35.706Z","comments":true,"path":"2019/03/17/cjtcra7jq000ch1l3x74k9blo/","link":"","permalink":"http://www.zcating.tk/2019/03/17/cjtcra7jq000ch1l3x74k9blo/","excerpt":"","text":"/** * @author Rich Tibbett / https://github.com/richtr * @author mrdoob / http://mrdoob.com/ * @author Tony Parisi / http://www.tonyparisi.com/ * @author Takahiro / https://github.com/takahirox * @author Don McCurdy / https://www.donmccurdy.com */ THREE.GLTFLoader = ( function () { function GLTFLoader( manager ) { this.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager; this.dracoLoader = null; } GLTFLoader.prototype = { constructor: GLTFLoader, crossOrigin: 'anonymous', load: function ( url, onLoad, onProgress, onError ) { var scope = this; var resourcePath; if ( this.resourcePath !== undefined ) { resourcePath = this.resourcePath; } else if ( this.path !== undefined ) { resourcePath = this.path; } else { resourcePath = THREE.LoaderUtils.extractUrlBase( url ); } // Tells the LoadingManager to track an extra item, which resolves after // the model is fully loaded. This means the count of items loaded will // be incorrect, but ensures manager.onLoad() does not fire early. scope.manager.itemStart( url ); var _onError = function ( e ) { if ( onError ) { onError( e ); } else { console.error( e ); } scope.manager.itemError( url ); scope.manager.itemEnd( url ); }; var loader = new THREE.FileLoader( scope.manager ); loader.setPath( this.path ); loader.setResponseType( 'arraybuffer' ); loader.load( url, function ( data ) { try { scope.parse( data, resourcePath, function ( gltf ) { onLoad( gltf ); scope.manager.itemEnd( url ); }, _onError ); } catch ( e ) { _onError( e ); } }, onProgress, _onError ); }, setCrossOrigin: function ( value ) { this.crossOrigin = value; return this; }, setPath: function ( value ) { this.path = value; return this; }, setResourcePath: function ( value ) { this.resourcePath = value; return this; }, setDRACOLoader: function ( dracoLoader ) { this.dracoLoader = dracoLoader; return this; }, parse: function ( data, path, onLoad, onError ) { var content; var extensions = {}; if ( typeof data === 'string' ) { content = data; } else { var magic = THREE.LoaderUtils.decodeText( new Uint8Array( data, 0, 4 ) ); if ( magic === BINARY_EXTENSION_HEADER_MAGIC ) { try { extensions[ EXTENSIONS.KHR_BINARY_GLTF ] = new GLTFBinaryExtension( data ); } catch ( error ) { if ( onError ) onError( error ); return; } content = extensions[ EXTENSIONS.KHR_BINARY_GLTF ].content; } else { content = THREE.LoaderUtils.decodeText( new Uint8Array( data ) ); } } var json = JSON.parse( content ); if ( json.asset === undefined || json.asset.version[ 0 ] < 2 ) { if ( onError ) onError( new Error( 'THREE.GLTFLoader: Unsupported asset. glTF versions >=2.0 are supported. Use LegacyGLTFLoader instead.' ) ); return; } if ( json.extensionsUsed ) { for ( var i = 0; i < json.extensionsUsed.length; ++ i ) { var extensionName = json.extensionsUsed[ i ]; var extensionsRequired = json.extensionsRequired || []; switch ( extensionName ) { case EXTENSIONS.KHR_LIGHTS_PUNCTUAL: extensions[ extensionName ] = new GLTFLightsExtension( json ); break; case EXTENSIONS.KHR_MATERIALS_UNLIT: extensions[ extensionName ] = new GLTFMaterialsUnlitExtension( json ); break; case EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS: extensions[ extensionName ] = new GLTFMaterialsPbrSpecularGlossinessExtension( json ); break; case EXTENSIONS.KHR_DRACO_MESH_COMPRESSION: extensions[ extensionName ] = new GLTFDracoMeshCompressionExtension( json, this.dracoLoader ); break; case EXTENSIONS.MSFT_TEXTURE_DDS: extensions[ EXTENSIONS.MSFT_TEXTURE_DDS ] = new GLTFTextureDDSExtension( json ); break; case EXTENSIONS.KHR_TEXTURE_TRANSFORM: extensions[ EXTENSIONS.KHR_TEXTURE_TRANSFORM ] = new GLTFTextureTransformExtension( json ); break; default: if ( extensionsRequired.indexOf( extensionName ) >= 0 ) { console.warn( 'THREE.GLTFLoader: Unknown extension \"' + extensionName + '\".' ); } } } } var parser = new GLTFParser( json, extensions, { path: path || this.resourcePath || '', crossOrigin: this.crossOrigin, manager: this.manager } ); parser.parse( function ( scene, scenes, cameras, animations, json ) { var glTF = { scene: scene, scenes: scenes, cameras: cameras, animations: animations, asset: json.asset, parser: parser, userData: {} }; addUnknownExtensionsToUserData( extensions, glTF, json ); onLoad( glTF ); }, onError ); } }; /* GLTFREGISTRY */ function GLTFRegistry() { var objects = {}; return { get: function ( key ) { return objects[ key ]; }, add: function ( key, object ) { objects[ key ] = object; }, remove: function ( key ) { delete objects[ key ]; }, removeAll: function () { objects = {}; } }; } /*********************************/ /********** EXTENSIONS ***********/ /*********************************/ var EXTENSIONS = { KHR_BINARY_GLTF: 'KHR_binary_glTF', KHR_DRACO_MESH_COMPRESSION: 'KHR_draco_mesh_compression', KHR_LIGHTS_PUNCTUAL: 'KHR_lights_punctual', KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS: 'KHR_materials_pbrSpecularGlossiness', KHR_MATERIALS_UNLIT: 'KHR_materials_unlit', KHR_TEXTURE_TRANSFORM: 'KHR_texture_transform', MSFT_TEXTURE_DDS: 'MSFT_texture_dds' }; /** * DDS Texture Extension * * Specification: * https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Vendor/MSFT_texture_dds * */ function GLTFTextureDDSExtension() { if ( ! THREE.DDSLoader ) { throw new Error( 'THREE.GLTFLoader: Attempting to load .dds texture without importing THREE.DDSLoader' ); } this.name = EXTENSIONS.MSFT_TEXTURE_DDS; this.ddsLoader = new THREE.DDSLoader(); } /** * Lights Extension * * Specification: PENDING */ function GLTFLightsExtension( json ) { this.name = EXTENSIONS.KHR_LIGHTS_PUNCTUAL; var extension = ( json.extensions && json.extensions[ EXTENSIONS.KHR_LIGHTS_PUNCTUAL ] ) || {}; this.lightDefs = extension.lights || []; } GLTFLightsExtension.prototype.loadLight = function ( lightIndex ) { var lightDef = this.lightDefs[ lightIndex ]; var lightNode; var color = new THREE.Color( 0xffffff ); if ( lightDef.color !== undefined ) color.fromArray( lightDef.color ); var range = lightDef.range !== undefined ? lightDef.range : 0; switch ( lightDef.type ) { case 'directional': lightNode = new THREE.DirectionalLight( color ); lightNode.target.position.set( 0, 0, - 1 ); lightNode.add( lightNode.target ); break; case 'point': lightNode = new THREE.PointLight( color ); lightNode.distance = range; break; case 'spot': lightNode = new THREE.SpotLight( color ); lightNode.distance = range; // Handle spotlight properties. lightDef.spot = lightDef.spot || {}; lightDef.spot.innerConeAngle = lightDef.spot.innerConeAngle !== undefined ? lightDef.spot.innerConeAngle : 0; lightDef.spot.outerConeAngle = lightDef.spot.outerConeAngle !== undefined ? lightDef.spot.outerConeAngle : Math.PI / 4.0; lightNode.angle = lightDef.spot.outerConeAngle; lightNode.penumbra = 1.0 - lightDef.spot.innerConeAngle / lightDef.spot.outerConeAngle; lightNode.target.position.set( 0, 0, - 1 ); lightNode.add( lightNode.target ); break; default: throw new Error( 'THREE.GLTFLoader: Unexpected light type, \"' + lightDef.type + '\".' ); } // Some lights (e.g. spot) default to a position other than the origin. Reset the position // here, because node-level parsing will only override position if explicitly specified. lightNode.position.set( 0, 0, 0 ); lightNode.decay = 2; if ( lightDef.intensity !== undefined ) lightNode.intensity = lightDef.intensity; lightNode.name = lightDef.name || ( 'light_' + lightIndex ); return Promise.resolve( lightNode ); }; /** * Unlit Materials Extension (pending) * * PR: https://github.com/KhronosGroup/glTF/pull/1163 */ function GLTFMaterialsUnlitExtension( json ) { this.name = EXTENSIONS.KHR_MATERIALS_UNLIT; } GLTFMaterialsUnlitExtension.prototype.getMaterialType = function ( material ) { return THREE.MeshBasicMaterial; }; GLTFMaterialsUnlitExtension.prototype.extendParams = function ( materialParams, material, parser ) { var pending = []; materialParams.color = new THREE.Color( 1.0, 1.0, 1.0 ); materialParams.opacity = 1.0; var metallicRoughness = material.pbrMetallicRoughness; if ( metallicRoughness ) { if ( Array.isArray( metallicRoughness.baseColorFactor ) ) { var array = metallicRoughness.baseColorFactor; materialParams.color.fromArray( array ); materialParams.opacity = array[ 3 ]; } if ( metallicRoughness.baseColorTexture !== undefined ) { pending.push( parser.assignTexture( materialParams, 'map', metallicRoughness.baseColorTexture ) ); } } return Promise.all( pending ); }; /* BINARY EXTENSION */ var BINARY_EXTENSION_BUFFER_NAME = 'binary_glTF'; var BINARY_EXTENSION_HEADER_MAGIC = 'glTF'; var BINARY_EXTENSION_HEADER_LENGTH = 12; var BINARY_EXTENSION_CHUNK_TYPES = { JSON: 0x4E4F534A, BIN: 0x004E4942 }; function GLTFBinaryExtension( data ) { this.name = EXTENSIONS.KHR_BINARY_GLTF; this.content = null; this.body = null; var headerView = new DataView( data, 0, BINARY_EXTENSION_HEADER_LENGTH ); this.header = { magic: THREE.LoaderUtils.decodeText( new Uint8Array( data.slice( 0, 4 ) ) ), version: headerView.getUint32( 4, true ), length: headerView.getUint32( 8, true ) }; if ( this.header.magic !== BINARY_EXTENSION_HEADER_MAGIC ) { throw new Error( 'THREE.GLTFLoader: Unsupported glTF-Binary header.' ); } else if ( this.header.version < 2.0 ) { throw new Error( 'THREE.GLTFLoader: Legacy binary file detected. Use LegacyGLTFLoader instead.' ); } var chunkView = new DataView( data, BINARY_EXTENSION_HEADER_LENGTH ); var chunkIndex = 0; while ( chunkIndex < chunkView.byteLength ) { var chunkLength = chunkView.getUint32( chunkIndex, true ); chunkIndex += 4; var chunkType = chunkView.getUint32( chunkIndex, true ); chunkIndex += 4; if ( chunkType === BINARY_EXTENSION_CHUNK_TYPES.JSON ) { var contentArray = new Uint8Array( data, BINARY_EXTENSION_HEADER_LENGTH + chunkIndex, chunkLength ); this.content = THREE.LoaderUtils.decodeText( contentArray ); } else if ( chunkType === BINARY_EXTENSION_CHUNK_TYPES.BIN ) { var byteOffset = BINARY_EXTENSION_HEADER_LENGTH + chunkIndex; this.body = data.slice( byteOffset, byteOffset + chunkLength ); } // Clients must ignore chunks with unknown types. chunkIndex += chunkLength; } if ( this.content === null ) { throw new Error( 'THREE.GLTFLoader: JSON content not found.' ); } } /** * DRACO Mesh Compression Extension * * Specification: https://github.com/KhronosGroup/glTF/pull/874 */ function GLTFDracoMeshCompressionExtension( json, dracoLoader ) { if ( ! dracoLoader ) { throw new Error( 'THREE.GLTFLoader: No DRACOLoader instance provided.' ); } this.name = EXTENSIONS.KHR_DRACO_MESH_COMPRESSION; this.json = json; this.dracoLoader = dracoLoader; THREE.DRACOLoader.getDecoderModule(); } GLTFDracoMeshCompressionExtension.prototype.decodePrimitive = function ( primitive, parser ) { var json = this.json; var dracoLoader = this.dracoLoader; var bufferViewIndex = primitive.extensions[ this.name ].bufferView; var gltfAttributeMap = primitive.extensions[ this.name ].attributes; var threeAttributeMap = {}; var attributeNormalizedMap = {}; var attributeTypeMap = {}; for ( var attributeName in gltfAttributeMap ) { if ( ! ( attributeName in ATTRIBUTES ) ) continue; threeAttributeMap[ ATTRIBUTES[ attributeName ] ] = gltfAttributeMap[ attributeName ]; } for ( attributeName in primitive.attributes ) { if ( ATTRIBUTES[ attributeName ] !== undefined && gltfAttributeMap[ attributeName ] !== undefined ) { var accessorDef = json.accessors[ primitive.attributes[ attributeName ] ]; var componentType = WEBGL_COMPONENT_TYPES[ accessorDef.componentType ]; attributeTypeMap[ ATTRIBUTES[ attributeName ] ] = componentType; attributeNormalizedMap[ ATTRIBUTES[ attributeName ] ] = accessorDef.normalized === true; } } return parser.getDependency( 'bufferView', bufferViewIndex ).then( function ( bufferView ) { return new Promise( function ( resolve ) { dracoLoader.decodeDracoFile( bufferView, function ( geometry ) { for ( var attributeName in geometry.attributes ) { var attribute = geometry.attributes[ attributeName ]; var normalized = attributeNormalizedMap[ attributeName ]; if ( normalized !== undefined ) attribute.normalized = normalized; } resolve( geometry ); }, threeAttributeMap, attributeTypeMap ); } ); } ); }; /** * Texture Transform Extension * * Specification: */ function GLTFTextureTransformExtension( json ) { this.name = EXTENSIONS.KHR_TEXTURE_TRANSFORM; } GLTFTextureTransformExtension.prototype.extendTexture = function ( texture, transform ) { texture = texture.clone(); if ( transform.offset !== undefined ) { texture.offset.fromArray( transform.offset ); } if ( transform.rotation !== undefined ) { texture.rotation = transform.rotation; } if ( transform.scale !== undefined ) { texture.repeat.fromArray( transform.scale ); } if ( transform.texCoord !== undefined ) { console.warn( 'THREE.GLTFLoader: Custom UV sets in \"' + this.name + '\" extension not yet supported.' ); } texture.needsUpdate = true; return texture; }; /** * Specular-Glossiness Extension * * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_pbrSpecularGlossiness */ function GLTFMaterialsPbrSpecularGlossinessExtension() { return { name: EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS, specularGlossinessParams: [ 'color', 'map', 'lightMap', 'lightMapIntensity', 'aoMap', 'aoMapIntensity', 'emissive', 'emissiveIntensity', 'emissiveMap', 'bumpMap', 'bumpScale', 'normalMap', 'displacementMap', 'displacementScale', 'displacementBias', 'specularMap', 'specular', 'glossinessMap', 'glossiness', 'alphaMap', 'envMap', 'envMapIntensity', 'refractionRatio', ], getMaterialType: function () { return THREE.ShaderMaterial; }, extendParams: function ( params, material, parser ) { var pbrSpecularGlossiness = material.extensions[ this.name ]; var shader = THREE.ShaderLib[ 'standard' ]; var uniforms = THREE.UniformsUtils.clone( shader.uniforms ); var specularMapParsFragmentChunk = [ '#ifdef USE_SPECULARMAP', ' uniform sampler2D specularMap;', '#endif' ].join( '\\n' ); var glossinessMapParsFragmentChunk = [ '#ifdef USE_GLOSSINESSMAP', ' uniform sampler2D glossinessMap;', '#endif' ].join( '\\n' ); var specularMapFragmentChunk = [ 'vec3 specularFactor = specular;', '#ifdef USE_SPECULARMAP', ' vec4 texelSpecular = texture2D( specularMap, vUv );', ' texelSpecular = sRGBToLinear( texelSpecular );', ' // reads channel RGB, compatible with a glTF Specular-Glossiness (RGBA) texture', ' specularFactor *= texelSpecular.rgb;', '#endif' ].join( '\\n' ); var glossinessMapFragmentChunk = [ 'float glossinessFactor = glossiness;', '#ifdef USE_GLOSSINESSMAP', ' vec4 texelGlossiness = texture2D( glossinessMap, vUv );', ' // reads channel A, compatible with a glTF Specular-Glossiness (RGBA) texture', ' glossinessFactor *= texelGlossiness.a;', '#endif' ].join( '\\n' ); var lightPhysicalFragmentChunk = [ 'PhysicalMaterial material;', 'material.diffuseColor = diffuseColor.rgb;', 'material.specularRoughness = clamp( 1.0 - glossinessFactor, 0.04, 1.0 );', 'material.specularColor = specularFactor.rgb;', ].join( '\\n' ); var fragmentShader = shader.fragmentShader .replace( 'uniform float roughness;', 'uniform vec3 specular;' ) .replace( 'uniform float metalness;', 'uniform float glossiness;' ) .replace( '#include ', specularMapParsFragmentChunk ) .replace( '#include ', glossinessMapParsFragmentChunk ) .replace( '#include ', specularMapFragmentChunk ) .replace( '#include ', glossinessMapFragmentChunk ) .replace( '#include ', lightPhysicalFragmentChunk ); delete uniforms.roughness; delete uniforms.metalness; delete uniforms.roughnessMap; delete uniforms.metalnessMap; uniforms.specular = { value: new THREE.Color().setHex( 0x111111 ) }; uniforms.glossiness = { value: 0.5 }; uniforms.specularMap = { value: null }; uniforms.glossinessMap = { value: null }; params.vertexShader = shader.vertexShader; params.fragmentShader = fragmentShader; params.uniforms = uniforms; params.defines = { 'STANDARD': '' }; params.color = new THREE.Color( 1.0, 1.0, 1.0 ); params.opacity = 1.0; var pending = []; if ( Array.isArray( pbrSpecularGlossiness.diffuseFactor ) ) { var array = pbrSpecularGlossiness.diffuseFactor; params.color.fromArray( array ); params.opacity = array[ 3 ]; } if ( pbrSpecularGlossiness.diffuseTexture !== undefined ) { pending.push( parser.assignTexture( params, 'map', pbrSpecularGlossiness.diffuseTexture ) ); } params.emissive = new THREE.Color( 0.0, 0.0, 0.0 ); params.glossiness = pbrSpecularGlossiness.glossinessFactor !== undefined ? pbrSpecularGlossiness.glossinessFactor : 1.0; params.specular = new THREE.Color( 1.0, 1.0, 1.0 ); if ( Array.isArray( pbrSpecularGlossiness.specularFactor ) ) { params.specular.fromArray( pbrSpecularGlossiness.specularFactor ); } if ( pbrSpecularGlossiness.specularGlossinessTexture !== undefined ) { var specGlossMapDef = pbrSpecularGlossiness.specularGlossinessTexture; pending.push( parser.assignTexture( params, 'glossinessMap', specGlossMapDef ) ); pending.push( parser.assignTexture( params, 'specularMap', specGlossMapDef ) ); } return Promise.all( pending ); }, createMaterial: function ( params ) { // setup material properties based on MeshStandardMaterial for Specular-Glossiness var material = new THREE.ShaderMaterial( { defines: params.defines, vertexShader: params.vertexShader, fragmentShader: params.fragmentShader, uniforms: params.uniforms, fog: true, lights: true, opacity: params.opacity, transparent: params.transparent } ); material.isGLTFSpecularGlossinessMaterial = true; material.color = params.color; material.map = params.map === undefined ? null : params.map; material.lightMap = null; material.lightMapIntensity = 1.0; material.aoMap = params.aoMap === undefined ? null : params.aoMap; material.aoMapIntensity = 1.0; material.emissive = params.emissive; material.emissiveIntensity = 1.0; material.emissiveMap = params.emissiveMap === undefined ? null : params.emissiveMap; material.bumpMap = params.bumpMap === undefined ? null : params.bumpMap; material.bumpScale = 1; material.normalMap = params.normalMap === undefined ? null : params.normalMap; if ( params.normalScale ) material.normalScale = params.normalScale; material.displacementMap = null; material.displacementScale = 1; material.displacementBias = 0; material.specularMap = params.specularMap === undefined ? null : params.specularMap; material.specular = params.specular; material.glossinessMap = params.glossinessMap === undefined ? null : params.glossinessMap; material.glossiness = params.glossiness; material.alphaMap = null; material.envMap = params.envMap === undefined ? null : params.envMap; material.envMapIntensity = 1.0; material.refractionRatio = 0.98; material.extensions.derivatives = true; return material; }, /** * Clones a GLTFSpecularGlossinessMaterial instance. The ShaderMaterial.copy() method can * copy only properties it knows about or inherits, and misses many properties that would * normally be defined by MeshStandardMaterial. * * This method allows GLTFSpecularGlossinessMaterials to be cloned in the process of * loading a glTF model, but cloning later (e.g. by the user) would require these changes * AND also updating `.onBeforeRender` on the parent mesh. * * @param {THREE.ShaderMaterial} source * @return {THREE.ShaderMaterial} */ cloneMaterial: function ( source ) { var target = source.clone(); target.isGLTFSpecularGlossinessMaterial = true; var params = this.specularGlossinessParams; for ( var i = 0, il = params.length; i < il; i ++ ) { target[ params[ i ] ] = source[ params[ i ] ]; } return target; }, // Here's based on refreshUniformsCommon() and refreshUniformsStandard() in WebGLRenderer. refreshUniforms: function ( renderer, scene, camera, geometry, material, group ) { if ( material.isGLTFSpecularGlossinessMaterial !== true ) { return; } var uniforms = material.uniforms; var defines = material.defines; uniforms.opacity.value = material.opacity; uniforms.diffuse.value.copy( material.color ); uniforms.emissive.value.copy( material.emissive ).multiplyScalar( material.emissiveIntensity ); uniforms.map.value = material.map; uniforms.specularMap.value = material.specularMap; uniforms.alphaMap.value = material.alphaMap; uniforms.lightMap.value = material.lightMap; uniforms.lightMapIntensity.value = material.lightMapIntensity; uniforms.aoMap.value = material.aoMap; uniforms.aoMapIntensity.value = material.aoMapIntensity; // uv repeat and offset setting priorities // 1. color map // 2. specular map // 3. normal map // 4. bump map // 5. alpha map // 6. emissive map var uvScaleMap; if ( material.map ) { uvScaleMap = material.map; } else if ( material.specularMap ) { uvScaleMap = material.specularMap; } else if ( material.displacementMap ) { uvScaleMap = material.displacementMap; } else if ( material.normalMap ) { uvScaleMap = material.normalMap; } else if ( material.bumpMap ) { uvScaleMap = material.bumpMap; } else if ( material.glossinessMap ) { uvScaleMap = material.glossinessMap; } else if ( material.alphaMap ) { uvScaleMap = material.alphaMap; } else if ( material.emissiveMap ) { uvScaleMap = material.emissiveMap; } if ( uvScaleMap !== undefined ) { // backwards compatibility if ( uvScaleMap.isWebGLRenderTarget ) { uvScaleMap = uvScaleMap.texture; } if ( uvScaleMap.matrixAutoUpdate === true ) { uvScaleMap.updateMatrix(); } uniforms.uvTransform.value.copy( uvScaleMap.matrix ); } if ( material.envMap ) { uniforms.envMap.value = material.envMap; uniforms.envMapIntensity.value = material.envMapIntensity; // don't flip CubeTexture envMaps, flip everything else: // WebGLRenderTargetCube will be flipped for backwards compatibility // WebGLRenderTargetCube.texture will be flipped because it's a Texture and NOT a CubeTexture // this check must be handled differently, or removed entirely, if WebGLRenderTargetCube uses a CubeTexture in the future uniforms.flipEnvMap.value = material.envMap.isCubeTexture ? - 1 : 1; uniforms.reflectivity.value = material.reflectivity; uniforms.refractionRatio.value = material.refractionRatio; uniforms.maxMipLevel.value = renderer.properties.get( material.envMap ).__maxMipLevel; } uniforms.specular.value.copy( material.specular ); uniforms.glossiness.value = material.glossiness; uniforms.glossinessMap.value = material.glossinessMap; uniforms.emissiveMap.value = material.emissiveMap; uniforms.bumpMap.value = material.bumpMap; uniforms.normalMap.value = material.normalMap; uniforms.displacementMap.value = material.displacementMap; uniforms.displacementScale.value = material.displacementScale; uniforms.displacementBias.value = material.displacementBias; if ( uniforms.glossinessMap.value !== null && defines.USE_GLOSSINESSMAP === undefined ) { defines.USE_GLOSSINESSMAP = ''; // set USE_ROUGHNESSMAP to enable vUv defines.USE_ROUGHNESSMAP = ''; } if ( uniforms.glossinessMap.value === null && defines.USE_GLOSSINESSMAP !== undefined ) { delete defines.USE_GLOSSINESSMAP; delete defines.USE_ROUGHNESSMAP; } } }; } /*********************************/ /********** INTERPOLATION ********/ /*********************************/ // Spline Interpolation // Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#appendix-c-spline-interpolation function GLTFCubicSplineInterpolant( parameterPositions, sampleValues, sampleSize, resultBuffer ) { THREE.Interpolant.call( this, parameterPositions, sampleValues, sampleSize, resultBuffer ); } GLTFCubicSplineInterpolant.prototype = Object.create( THREE.Interpolant.prototype ); GLTFCubicSplineInterpolant.prototype.constructor = GLTFCubicSplineInterpolant; GLTFCubicSplineInterpolant.prototype.copySampleValue_ = function ( index ) { // Copies a sample value to the result buffer. See description of glTF // CUBICSPLINE values layout in interpolate_() function below. var result = this.resultBuffer, values = this.sampleValues, valueSize = this.valueSize, offset = index * valueSize * 3 + valueSize; for ( var i = 0; i !== valueSize; i ++ ) { result[ i ] = values[ offset + i ]; } return result; }; GLTFCubicSplineInterpolant.prototype.beforeStart_ = GLTFCubicSplineInterpolant.prototype.copySampleValue_; GLTFCubicSplineInterpolant.prototype.afterEnd_ = GLTFCubicSplineInterpolant.prototype.copySampleValue_; GLTFCubicSplineInterpolant.prototype.interpolate_ = function ( i1, t0, t, t1 ) { var result = this.resultBuffer; var values = this.sampleValues; var stride = this.valueSize; var stride2 = stride * 2; var stride3 = stride * 3; var td = t1 - t0; var p = ( t - t0 ) / td; var pp = p * p; var ppp = pp * p; var offset1 = i1 * stride3; var offset0 = offset1 - stride3; var s2 = - 2 * ppp + 3 * pp; var s3 = ppp - pp; var s0 = 1 - s2; var s1 = s3 - pp + p; // Layout of keyframe output values for CUBICSPLINE animations: // [ inTangent_1, splineVertex_1, outTangent_1, inTangent_2, splineVertex_2, ... ] for ( var i = 0; i !== stride; i ++ ) { var p0 = values[ offset0 + i + stride ]; // splineVertex_k var m0 = values[ offset0 + i + stride2 ] * td; // outTangent_k * (t_k+1 - t_k) var p1 = values[ offset1 + i + stride ]; // splineVertex_k+1 var m1 = values[ offset1 + i ] * td; // inTangent_k+1 * (t_k+1 - t_k) result[ i ] = s0 * p0 + s1 * m0 + s2 * p1 + s3 * m1; } return result; }; /*********************************/ /********** INTERNALS ************/ /*********************************/ /* CONSTANTS */ var WEBGL_CONSTANTS = { FLOAT: 5126, //FLOAT_MAT2: 35674, FLOAT_MAT3: 35675, FLOAT_MAT4: 35676, FLOAT_VEC2: 35664, FLOAT_VEC3: 35665, FLOAT_VEC4: 35666, LINEAR: 9729, REPEAT: 10497, SAMPLER_2D: 35678, POINTS: 0, LINES: 1, LINE_LOOP: 2, LINE_STRIP: 3, TRIANGLES: 4, TRIANGLE_STRIP: 5, TRIANGLE_FAN: 6, UNSIGNED_BYTE: 5121, UNSIGNED_SHORT: 5123 }; var WEBGL_TYPE = { 5126: Number, //35674: THREE.Matrix2, 35675: THREE.Matrix3, 35676: THREE.Matrix4, 35664: THREE.Vector2, 35665: THREE.Vector3, 35666: THREE.Vector4, 35678: THREE.Texture }; var WEBGL_COMPONENT_TYPES = { 5120: Int8Array, 5121: Uint8Array, 5122: Int16Array, 5123: Uint16Array, 5125: Uint32Array, 5126: Float32Array }; var WEBGL_FILTERS = { 9728: THREE.NearestFilter, 9729: THREE.LinearFilter, 9984: THREE.NearestMipMapNearestFilter, 9985: THREE.LinearMipMapNearestFilter, 9986: THREE.NearestMipMapLinearFilter, 9987: THREE.LinearMipMapLinearFilter }; var WEBGL_WRAPPINGS = { 33071: THREE.ClampToEdgeWrapping, 33648: THREE.MirroredRepeatWrapping, 10497: THREE.RepeatWrapping }; var WEBGL_SIDES = { 1028: THREE.BackSide, // Culling front 1029: THREE.FrontSide // Culling back //1032: THREE.NoSide // Culling front and back, what to do? }; var WEBGL_DEPTH_FUNCS = { 512: THREE.NeverDepth, 513: THREE.LessDepth, 514: THREE.EqualDepth, 515: THREE.LessEqualDepth, 516: THREE.GreaterEqualDepth, 517: THREE.NotEqualDepth, 518: THREE.GreaterEqualDepth, 519: THREE.AlwaysDepth }; var WEBGL_BLEND_EQUATIONS = { 32774: THREE.AddEquation, 32778: THREE.SubtractEquation, 32779: THREE.ReverseSubtractEquation }; var WEBGL_BLEND_FUNCS = { 0: THREE.ZeroFactor, 1: THREE.OneFactor, 768: THREE.SrcColorFactor, 769: THREE.OneMinusSrcColorFactor, 770: THREE.SrcAlphaFactor, 771: THREE.OneMinusSrcAlphaFactor, 772: THREE.DstAlphaFactor, 773: THREE.OneMinusDstAlphaFactor, 774: THREE.DstColorFactor, 775: THREE.OneMinusDstColorFactor, 776: THREE.SrcAlphaSaturateFactor // The followings are not supported by Three.js yet //32769: CONSTANT_COLOR, //32770: ONE_MINUS_CONSTANT_COLOR, //32771: CONSTANT_ALPHA, //32772: ONE_MINUS_CONSTANT_COLOR }; var WEBGL_TYPE_SIZES = { 'SCALAR': 1, 'VEC2': 2, 'VEC3': 3, 'VEC4': 4, 'MAT2': 4, 'MAT3': 9, 'MAT4': 16 }; var ATTRIBUTES = { POSITION: 'position', NORMAL: 'normal', TEXCOORD_0: 'uv', TEXCOORD_1: 'uv2', COLOR_0: 'color', WEIGHTS_0: 'skinWeight', JOINTS_0: 'skinIndex', }; var PATH_PROPERTIES = { scale: 'scale', translation: 'position', rotation: 'quaternion', weights: 'morphTargetInfluences' }; var INTERPOLATION = { CUBICSPLINE: THREE.InterpolateSmooth, // We use custom interpolation GLTFCubicSplineInterpolation for CUBICSPLINE. // KeyframeTrack.optimize() can't handle glTF Cubic Spline output values layout, // using THREE.InterpolateSmooth for KeyframeTrack instantiation to prevent optimization. // See KeyframeTrack.optimize() for the detail. LINEAR: THREE.InterpolateLinear, STEP: THREE.InterpolateDiscrete }; var STATES_ENABLES = { 2884: 'CULL_FACE', 2929: 'DEPTH_TEST', 3042: 'BLEND', 3089: 'SCISSOR_TEST', 32823: 'POLYGON_OFFSET_FILL', 32926: 'SAMPLE_ALPHA_TO_COVERAGE' }; var ALPHA_MODES = { OPAQUE: 'OPAQUE', MASK: 'MASK', BLEND: 'BLEND' }; var MIME_TYPE_FORMATS = { 'image/png': THREE.RGBAFormat, 'image/jpeg': THREE.RGBFormat }; /* UTILITY FUNCTIONS */ function resolveURL( url, path ) { // Invalid URL if ( typeof url !== 'string' || url === '' ) return ''; // Absolute URL http://,https://,// if ( /^(https?:)?\\/\\//i.test( url ) ) return url; // Data URI if ( /^data:.*,.*$/i.test( url ) ) return url; // Blob URL if ( /^blob:.*$/i.test( url ) ) return url; // Relative URL return path + url; } /** * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#default-material */ function createDefaultMaterial() { return new THREE.MeshStandardMaterial( { color: 0xFFFFFF, emissive: 0x000000, metalness: 1, roughness: 1, transparent: false, depthTest: true, side: THREE.FrontSide } ); } function addUnknownExtensionsToUserData( knownExtensions, object, objectDef ) { // Add unknown glTF extensions to an object's userData. for ( var name in objectDef.extensions ) { if ( knownExtensions[ name ] === undefined ) { object.userData.gltfExtensions = object.userData.gltfExtensions || {}; object.userData.gltfExtensions[ name ] = objectDef.extensions[ name ]; } } } /** * @param {THREE.Object3D|THREE.Material|THREE.BufferGeometry} object * @param {GLTF.definition} gltfDef */ function assignExtrasToUserData( object, gltfDef ) { if ( gltfDef.extras !== undefined ) { if ( typeof gltfDef.extras === 'object' ) { object.userData = gltfDef.extras; } else { console.warn( 'THREE.GLTFLoader: Ignoring primitive type .extras, ' + gltfDef.extras ); } } } /** * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#morph-targets * * @param {THREE.BufferGeometry} geometry * @param {Array} targets * @param {GLTFParser} parser * @return {Promise} */ function addMorphTargets( geometry, targets, parser ) { var hasMorphPosition = false; var hasMorphNormal = false; for ( var i = 0, il = targets.length; i < il; i ++ ) { var target = targets[ i ]; if ( target.POSITION !== undefined ) hasMorphPosition = true; if ( target.NORMAL !== undefined ) hasMorphNormal = true; if ( hasMorphPosition && hasMorphNormal ) break; } if ( ! hasMorphPosition && ! hasMorphNormal ) return Promise.resolve( geometry ); var pendingPositionAccessors = []; var pendingNormalAccessors = []; for ( var i = 0, il = targets.length; i < il; i ++ ) { var target = targets[ i ]; if ( hasMorphPosition ) { // TODO: Error-prone use of a callback inside a loop. var accessor = target.POSITION !== undefined ? parser.getDependency( 'accessor', target.POSITION ) .then( function ( accessor ) { // Cloning not to pollute original accessor below return cloneBufferAttribute( accessor ); } ) : geometry.attributes.position; pendingPositionAccessors.push( accessor ); } if ( hasMorphNormal ) { // TODO: Error-prone use of a callback inside a loop. var accessor = target.NORMAL !== undefined ? parser.getDependency( 'accessor', target.NORMAL ) .then( function ( accessor ) { return cloneBufferAttribute( accessor ); } ) : geometry.attributes.normal; pendingNormalAccessors.push( accessor ); } } return Promise.all( [ Promise.all( pendingPositionAccessors ), Promise.all( pendingNormalAccessors ) ] ).then( function ( accessors ) { var morphPositions = accessors[ 0 ]; var morphNormals = accessors[ 1 ]; for ( var i = 0, il = targets.length; i < il; i ++ ) { var target = targets[ i ]; var attributeName = 'morphTarget' + i; if ( hasMorphPosition ) { // Three.js morph position is absolute value. The formula is // basePosition // + weight0 * ( morphPosition0 - basePosition ) // + weight1 * ( morphPosition1 - basePosition ) // ... // while the glTF one is relative // basePosition // + weight0 * glTFmorphPosition0 // + weight1 * glTFmorphPosition1 // ... // then we need to convert from relative to absolute here. if ( target.POSITION !== undefined ) { var positionAttribute = morphPositions[ i ]; positionAttribute.name = attributeName; var position = geometry.attributes.position; for ( var j = 0, jl = positionAttribute.count; j < jl; j ++ ) { positionAttribute.setXYZ( j, positionAttribute.getX( j ) + position.getX( j ), positionAttribute.getY( j ) + position.getY( j ), positionAttribute.getZ( j ) + position.getZ( j ) ); } } } if ( hasMorphNormal ) { // see target.POSITION's comment if ( target.NORMAL !== undefined ) { var normalAttribute = morphNormals[ i ]; normalAttribute.name = attributeName; var normal = geometry.attributes.normal; for ( var j = 0, jl = normalAttribute.count; j < jl; j ++ ) { normalAttribute.setXYZ( j, normalAttribute.getX( j ) + normal.getX( j ), normalAttribute.getY( j ) + normal.getY( j ), normalAttribute.getZ( j ) + normal.getZ( j ) ); } } } } if ( hasMorphPosition ) geometry.morphAttributes.position = morphPositions; if ( hasMorphNormal ) geometry.morphAttributes.normal = morphNormals; return geometry; } ); } /** * @param {THREE.Mesh} mesh * @param {GLTF.Mesh} meshDef */ function updateMorphTargets( mesh, meshDef ) { mesh.updateMorphTargets(); if ( meshDef.weights !== undefined ) { for ( var i = 0, il = meshDef.weights.length; i < il; i ++ ) { mesh.morphTargetInfluences[ i ] = meshDef.weights[ i ]; } } // .extras has user-defined data, so check that .extras.targetNames is an array. if ( meshDef.extras && Array.isArray( meshDef.extras.targetNames ) ) { var targetNames = meshDef.extras.targetNames; if ( mesh.morphTargetInfluences.length === targetNames.length ) { mesh.morphTargetDictionary = {}; for ( var i = 0, il = targetNames.length; i < il; i ++ ) { mesh.morphTargetDictionary[ targetNames[ i ] ] = i; } } else { console.warn( 'THREE.GLTFLoader: Invalid extras.targetNames length. Ignoring names.' ); } } } function isPrimitiveEqual( a, b ) { var dracoExtA = a.extensions ? a.extensions[ EXTENSIONS.KHR_DRACO_MESH_COMPRESSION ] : undefined; var dracoExtB = b.extensions ? b.extensions[ EXTENSIONS.KHR_DRACO_MESH_COMPRESSION ] : undefined; if ( dracoExtA && dracoExtB ) { if ( dracoExtA.bufferView !== dracoExtB.bufferView ) return false; return isObjectEqual( dracoExtA.attributes, dracoExtB.attributes ); } if ( a.indices !== b.indices ) { return false; } return isObjectEqual( a.attributes, b.attributes ); } function isObjectEqual( a, b ) { if ( Object.keys( a ).length !== Object.keys( b ).length ) return false; for ( var key in a ) { if ( a[ key ] !== b[ key ] ) return false; } return true; } function isArrayEqual( a, b ) { if ( a.length !== b.length ) return false; for ( var i = 0, il = a.length; i < il; i ++ ) { if ( a[ i ] !== b[ i ] ) return false; } return true; } function getCachedGeometry( cache, newPrimitive ) { for ( var i = 0, il = cache.length; i < il; i ++ ) { var cached = cache[ i ]; if ( isPrimitiveEqual( cached.primitive, newPrimitive ) ) return cached.promise; } return null; } function getCachedCombinedGeometry( cache, geometries ) { for ( var i = 0, il = cache.length; i < il; i ++ ) { var cached = cache[ i ]; if ( isArrayEqual( geometries, cached.baseGeometries ) ) return cached.geometry; } return null; } function getCachedMultiPassGeometry( cache, geometry, primitives ) { for ( var i = 0, il = cache.length; i < il; i ++ ) { var cached = cache[ i ]; if ( geometry === cached.baseGeometry && isArrayEqual( primitives, cached.primitives ) ) return cached.geometry; } return null; } function cloneBufferAttribute( attribute ) { if ( attribute.isInterleavedBufferAttribute ) { var count = attribute.count; var itemSize = attribute.itemSize; var array = attribute.array.slice( 0, count * itemSize ); for ( var i = 0, j = 0; i < count; ++ i ) { array[ j ++ ] = attribute.getX( i ); if ( itemSize >= 2 ) array[ j ++ ] = attribute.getY( i ); if ( itemSize >= 3 ) array[ j ++ ] = attribute.getZ( i ); if ( itemSize >= 4 ) array[ j ++ ] = attribute.getW( i ); } return new THREE.BufferAttribute( array, itemSize, attribute.normalized ); } return attribute.clone(); } /** * Checks if we can build a single Mesh with MultiMaterial from multiple primitives. * Returns true if all primitives use the same attributes/morphAttributes/mode * and also have index. Otherwise returns false. * * @param {Array} primitives * @return {Boolean} */ function isMultiPassGeometry( primitives ) { if ( primitives.length < 2 ) return false; var primitive0 = primitives[ 0 ]; var targets0 = primitive0.targets || []; if ( primitive0.indices === undefined ) return false; for ( var i = 1, il = primitives.length; i < il; i ++ ) { var primitive = primitives[ i ]; if ( primitive0.mode !== primitive.mode ) return false; if ( primitive.indices === undefined ) return false; if ( primitive.extensions && primitive.extensions[ EXTENSIONS.KHR_DRACO_MESH_COMPRESSION ] ) return false; if ( ! isObjectEqual( primitive0.attributes, primitive.attributes ) ) return false; var targets = primitive.targets || []; if ( targets0.length !== targets.length ) return false; for ( var j = 0, jl = targets0.length; j < jl; j ++ ) { if ( ! isObjectEqual( targets0[ j ], targets[ j ] ) ) return false; } } return true; } /* GLTF PARSER */ function GLTFParser( json, extensions, options ) { this.json = json || {}; this.extensions = extensions || {}; this.options = options || {}; // loader object cache this.cache = new GLTFRegistry(); // BufferGeometry caching this.primitiveCache = []; this.multiplePrimitivesCache = []; this.multiPassGeometryCache = []; this.textureLoader = new THREE.TextureLoader( this.options.manager ); this.textureLoader.setCrossOrigin( this.options.crossOrigin ); this.fileLoader = new THREE.FileLoader( this.options.manager ); this.fileLoader.setResponseType( 'arraybuffer' ); } GLTFParser.prototype.parse = function ( onLoad, onError ) { var json = this.json; // Clear the loader cache this.cache.removeAll(); // Mark the special nodes/meshes in json for efficient parse this.markDefs(); // Fire the callback on complete this.getMultiDependencies( [ 'scene', 'animation', 'camera' ] ).then( function ( dependencies ) { var scenes = dependencies.scenes || []; var scene = scenes[ json.scene || 0 ]; var animations = dependencies.animations || []; var cameras = dependencies.cameras || []; onLoad( scene, scenes, cameras, animations, json ); } ).catch( onError ); }; /** * Marks the special nodes/meshes in json for efficient parse. */ GLTFParser.prototype.markDefs = function () { var nodeDefs = this.json.nodes || []; var skinDefs = this.json.skins || []; var meshDefs = this.json.meshes || []; var meshReferences = {}; var meshUses = {}; // Nothing in the node definition indicates whether it is a Bone or an // Object3D. Use the skins' joint references to mark bones. for ( var skinIndex = 0, skinLength = skinDefs.length; skinIndex < skinLength; skinIndex ++ ) { var joints = skinDefs[ skinIndex ].joints; for ( var i = 0, il = joints.length; i < il; i ++ ) { nodeDefs[ joints[ i ] ].isBone = true; } } // Meshes can (and should) be reused by multiple nodes in a glTF asset. To // avoid having more than one THREE.Mesh with the same name, count // references and rename instances below. // // Example: CesiumMilkTruck sample model reuses \"Wheel\" meshes. for ( var nodeIndex = 0, nodeLength = nodeDefs.length; nodeIndex < nodeLength; nodeIndex ++ ) { var nodeDef = nodeDefs[ nodeIndex ]; if ( nodeDef.mesh !== undefined ) { if ( meshReferences[ nodeDef.mesh ] === undefined ) { meshReferences[ nodeDef.mesh ] = meshUses[ nodeDef.mesh ] = 0; } meshReferences[ nodeDef.mesh ] ++; // Nothing in the mesh definition indicates whether it is // a SkinnedMesh or Mesh. Use the node's mesh reference // to mark SkinnedMesh if node has skin. if ( nodeDef.skin !== undefined ) { meshDefs[ nodeDef.mesh ].isSkinnedMesh = true; } } } this.json.meshReferences = meshReferences; this.json.meshUses = meshUses; }; /** * Requests the specified dependency asynchronously, with caching. * @param {string} type * @param {number} index * @return {Promise} */ GLTFParser.prototype.getDependency = function ( type, index ) { var cacheKey = type + ':' + index; var dependency = this.cache.get( cacheKey ); if ( ! dependency ) { switch ( type ) { case 'scene': dependency = this.loadScene( index ); break; case 'node': dependency = this.loadNode( index ); break; case 'mesh': dependency = this.loadMesh( index ); break; case 'accessor': dependency = this.loadAccessor( index ); break; case 'bufferView': dependency = this.loadBufferView( index ); break; case 'buffer': dependency = this.loadBuffer( index ); break; case 'material': dependency = this.loadMaterial( index ); break; case 'texture': dependency = this.loadTexture( index ); break; case 'skin': dependency = this.loadSkin( index ); break; case 'animation': dependency = this.loadAnimation( index ); break; case 'camera': dependency = this.loadCamera( index ); break; case 'light': dependency = this.extensions[ EXTENSIONS.KHR_LIGHTS_PUNCTUAL ].loadLight( index ); break; default: throw new Error( 'Unknown type: ' + type ); } this.cache.add( cacheKey, dependency ); } return dependency; }; /** * Requests all dependencies of the specified type asynchronously, with caching. * @param {string} type * @return {Promise} */ GLTFParser.prototype.getDependencies = function ( type ) { var dependencies = this.cache.get( type ); if ( ! dependencies ) { var parser = this; var defs = this.json[ type + ( type === 'mesh' ? 'es' : 's' ) ] || []; dependencies = Promise.all( defs.map( function ( def, index ) { return parser.getDependency( type, index ); } ) ); this.cache.add( type, dependencies ); } return dependencies; }; /** * Requests all multiple dependencies of the specified types asynchronously, with caching. * @param {Array} types * @return {Promise} */ GLTFParser.prototype.getMultiDependencies = function ( types ) { var results = {}; var pending = []; for ( var i = 0, il = types.length; i < il; i ++ ) { var type = types[ i ]; var value = this.getDependencies( type ); // TODO: Error-prone use of a callback inside a loop. value = value.then( function ( key, value ) { results[ key ] = value; }.bind( this, type + ( type === 'mesh' ? 'es' : 's' ) ) ); pending.push( value ); } return Promise.all( pending ).then( function () { return results; } ); }; /** * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#buffers-and-buffer-views * @param {number} bufferIndex * @return {Promise} */ GLTFParser.prototype.loadBuffer = function ( bufferIndex ) { var bufferDef = this.json.buffers[ bufferIndex ]; var loader = this.fileLoader; if ( bufferDef.type && bufferDef.type !== 'arraybuffer' ) { throw new Error( 'THREE.GLTFLoader: ' + bufferDef.type + ' buffer type is not supported.' ); } // If present, GLB container is required to be the first buffer. if ( bufferDef.uri === undefined && bufferIndex === 0 ) { return Promise.resolve( this.extensions[ EXTENSIONS.KHR_BINARY_GLTF ].body ); } var options = this.options; return new Promise( function ( resolve, reject ) { loader.load( resolveURL( bufferDef.uri, options.path ), resolve, undefined, function () { reject( new Error( 'THREE.GLTFLoader: Failed to load buffer \"' + bufferDef.uri + '\".' ) ); } ); } ); }; /** * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#buffers-and-buffer-views * @param {number} bufferViewIndex * @return {Promise} */ GLTFParser.prototype.loadBufferView = function ( bufferViewIndex ) { var bufferViewDef = this.json.bufferViews[ bufferViewIndex ]; return this.getDependency( 'buffer', bufferViewDef.buffer ).then( function ( buffer ) { var byteLength = bufferViewDef.byteLength || 0; var byteOffset = bufferViewDef.byteOffset || 0; return buffer.slice( byteOffset, byteOffset + byteLength ); } ); }; /** * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#accessors * @param {number} accessorIndex * @return {Promise} */ GLTFParser.prototype.loadAccessor = function ( accessorIndex ) { var parser = this; var json = this.json; var accessorDef = this.json.accessors[ accessorIndex ]; if ( accessorDef.bufferView === undefined && accessorDef.sparse === undefined ) { // Ignore empty accessors, which may be used to declare runtime // information about attributes coming from another source (e.g. Draco // compression extension). return Promise.resolve( null ); } var pendingBufferViews = []; if ( accessorDef.bufferView !== undefined ) { pendingBufferViews.push( this.getDependency( 'bufferView', accessorDef.bufferView ) ); } else { pendingBufferViews.push( null ); } if ( accessorDef.sparse !== undefined ) { pendingBufferViews.push( this.getDependency( 'bufferView', accessorDef.sparse.indices.bufferView ) ); pendingBufferViews.push( this.getDependency( 'bufferView', accessorDef.sparse.values.bufferView ) ); } return Promise.all( pendingBufferViews ).then( function ( bufferViews ) { var bufferView = bufferViews[ 0 ]; var itemSize = WEBGL_TYPE_SIZES[ accessorDef.type ]; var TypedArray = WEBGL_COMPONENT_TYPES[ accessorDef.componentType ]; // For VEC3: itemSize is 3, elementBytes is 4, itemBytes is 12. var elementBytes = TypedArray.BYTES_PER_ELEMENT; var itemBytes = elementBytes * itemSize; var byteOffset = accessorDef.byteOffset || 0; var byteStride = accessorDef.bufferView !== undefined ? json.bufferViews[ accessorDef.bufferView ].byteStride : undefined; var normalized = accessorDef.normalized === true; var array, bufferAttribute; // The buffer is not interleaved if the stride is the item size in bytes. if ( byteStride && byteStride !== itemBytes ) { var ibCacheKey = 'InterleavedBuffer:' + accessorDef.bufferView + ':' + accessorDef.componentType; var ib = parser.cache.get( ibCacheKey ); if ( ! ib ) { // Use the full buffer if it's interleaved. array = new TypedArray( bufferView ); // Integer parameters to IB/IBA are in array elements, not bytes. ib = new THREE.InterleavedBuffer( array, byteStride / elementBytes ); parser.cache.add( ibCacheKey, ib ); } bufferAttribute = new THREE.InterleavedBufferAttribute( ib, itemSize, byteOffset / elementBytes, normalized ); } else { if ( bufferView === null ) { array = new TypedArray( accessorDef.count * itemSize ); } else { array = new TypedArray( bufferView, byteOffset, accessorDef.count * itemSize ); } bufferAttribute = new THREE.BufferAttribute( array, itemSize, normalized ); } // https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#sparse-accessors if ( accessorDef.sparse !== undefined ) { var itemSizeIndices = WEBGL_TYPE_SIZES.SCALAR; var TypedArrayIndices = WEBGL_COMPONENT_TYPES[ accessorDef.sparse.indices.componentType ]; var byteOffsetIndices = accessorDef.sparse.indices.byteOffset || 0; var byteOffsetValues = accessorDef.sparse.values.byteOffset || 0; var sparseIndices = new TypedArrayIndices( bufferViews[ 1 ], byteOffsetIndices, accessorDef.sparse.count * itemSizeIndices ); var sparseValues = new TypedArray( bufferViews[ 2 ], byteOffsetValues, accessorDef.sparse.count * itemSize ); if ( bufferView !== null ) { // Avoid modifying the original ArrayBuffer, if the bufferView wasn't initialized with zeroes. bufferAttribute.setArray( bufferAttribute.array.slice() ); } for ( var i = 0, il = sparseIndices.length; i < il; i ++ ) { var index = sparseIndices[ i ]; bufferAttribute.setX( index, sparseValues[ i * itemSize ] ); if ( itemSize >= 2 ) bufferAttribute.setY( index, sparseValues[ i * itemSize + 1 ] ); if ( itemSize >= 3 ) bufferAttribute.setZ( index, sparseValues[ i * itemSize + 2 ] ); if ( itemSize >= 4 ) bufferAttribute.setW( index, sparseValues[ i * itemSize + 3 ] ); if ( itemSize >= 5 ) throw new Error( 'THREE.GLTFLoader: Unsupported itemSize in sparse BufferAttribute.' ); } } return bufferAttribute; } ); }; /** * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#textures * @param {number} textureIndex * @return {Promise} */ GLTFParser.prototype.loadTexture = function ( textureIndex ) { var parser = this; var json = this.json; var options = this.options; var textureLoader = this.textureLoader; var URL = window.URL || window.webkitURL; var textureDef = json.textures[ textureIndex ]; var textureExtensions = textureDef.extensions || {}; var source; if ( textureExtensions[ EXTENSIONS.MSFT_TEXTURE_DDS ] ) { source = json.images[ textureExtensions[ EXTENSIONS.MSFT_TEXTURE_DDS ].source ]; } else { source = json.images[ textureDef.source ]; } var sourceURI = source.uri; var isObjectURL = false; if ( source.bufferView !== undefined ) { // Load binary image data from bufferView, if provided. sourceURI = parser.getDependency( 'bufferView', source.bufferView ).then( function ( bufferView ) { isObjectURL = true; var blob = new Blob( [ bufferView ], { type: source.mimeType } ); sourceURI = URL.createObjectURL( blob ); return sourceURI; } ); } return Promise.resolve( sourceURI ).then( function ( sourceURI ) { // Load Texture resource. var loader = THREE.Loader.Handlers.get( sourceURI ); if ( ! loader ) { loader = textureExtensions[ EXTENSIONS.MSFT_TEXTURE_DDS ] ? parser.extensions[ EXTENSIONS.MSFT_TEXTURE_DDS ].ddsLoader : textureLoader; } return new Promise( function ( resolve, reject ) { loader.load( resolveURL( sourceURI, options.path ), resolve, undefined, reject ); } ); } ).then( function ( texture ) { // Clean up resources and configure Texture. if ( isObjectURL === true ) { URL.revokeObjectURL( sourceURI ); } texture.flipY = false; if ( textureDef.name !== undefined ) texture.name = textureDef.name; // Ignore unknown mime types, like DDS files. if ( source.mimeType in MIME_TYPE_FORMATS ) { texture.format = MIME_TYPE_FORMATS[ source.mimeType ]; } var samplers = json.samplers || {}; var sampler = samplers[ textureDef.sampler ] || {}; texture.magFilter = WEBGL_FILTERS[ sampler.magFilter ] || THREE.LinearFilter; texture.minFilter = WEBGL_FILTERS[ sampler.minFilter ] || THREE.LinearMipMapLinearFilter; texture.wrapS = WEBGL_WRAPPINGS[ sampler.wrapS ] || THREE.RepeatWrapping; texture.wrapT = WEBGL_WRAPPINGS[ sampler.wrapT ] || THREE.RepeatWrapping; return texture; } ); }; /** * Asynchronously assigns a texture to the given material parameters. * @param {Object} materialParams * @param {string} mapName * @param {Object} mapDef * @return {Promise} */ GLTFParser.prototype.assignTexture = function ( materialParams, mapName, mapDef ) { var parser = this; return this.getDependency( 'texture', mapDef.index ).then( function ( texture ) { switch ( mapName ) { case 'aoMap': case 'emissiveMap': case 'metalnessMap': case 'normalMap': case 'roughnessMap': texture.format = THREE.RGBFormat; break; } if ( parser.extensions[ EXTENSIONS.KHR_TEXTURE_TRANSFORM ] ) { var transform = mapDef.extensions !== undefined ? mapDef.extensions[ EXTENSIONS.KHR_TEXTURE_TRANSFORM ] : undefined; if ( transform ) { texture = parser.extensions[ EXTENSIONS.KHR_TEXTURE_TRANSFORM ].extendTexture( texture, transform ); } } materialParams[ mapName ] = texture; } ); }; /** * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#materials * @param {number} materialIndex * @return {Promise} */ GLTFParser.prototype.loadMaterial = function ( materialIndex ) { var parser = this; var json = this.json; var extensions = this.extensions; var materialDef = json.materials[ materialIndex ]; var materialType; var materialParams = {}; var materialExtensions = materialDef.extensions || {}; var pending = []; if ( materialExtensions[ EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS ] ) { var sgExtension = extensions[ EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS ]; materialType = sgExtension.getMaterialType( materialDef ); pending.push( sgExtension.extendParams( materialParams, materialDef, parser ) ); } else if ( materialExtensions[ EXTENSIONS.KHR_MATERIALS_UNLIT ] ) { var kmuExtension = extensions[ EXTENSIONS.KHR_MATERIALS_UNLIT ]; materialType = kmuExtension.getMaterialType( materialDef ); pending.push( kmuExtension.extendParams( materialParams, materialDef, parser ) ); } else { // Specification: // https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#metallic-roughness-material materialType = THREE.MeshStandardMaterial; var metallicRoughness = materialDef.pbrMetallicRoughness || {}; materialParams.color = new THREE.Color( 1.0, 1.0, 1.0 ); materialParams.opacity = 1.0; if ( Array.isArray( metallicRoughness.baseColorFactor ) ) { var array = metallicRoughness.baseColorFactor; materialParams.color.fromArray( array ); materialParams.opacity = array[ 3 ]; } if ( metallicRoughness.baseColorTexture !== undefined ) { pending.push( parser.assignTexture( materialParams, 'map', metallicRoughness.baseColorTexture ) ); } materialParams.metalness = metallicRoughness.metallicFactor !== undefined ? metallicRoughness.metallicFactor : 1.0; materialParams.roughness = metallicRoughness.roughnessFactor !== undefined ? metallicRoughness.roughnessFactor : 1.0; if ( metallicRoughness.metallicRoughnessTexture !== undefined ) { pending.push( parser.assignTexture( materialParams, 'metalnessMap', metallicRoughness.metallicRoughnessTexture ) ); pending.push( parser.assignTexture( materialParams, 'roughnessMap', metallicRoughness.metallicRoughnessTexture ) ); } } if ( materialDef.doubleSided === true ) { materialParams.side = THREE.DoubleSide; } var alphaMode = materialDef.alphaMode || ALPHA_MODES.OPAQUE; if ( alphaMode === ALPHA_MODES.BLEND ) { materialParams.transparent = true; } else { materialParams.transparent = false; if ( alphaMode === ALPHA_MODES.MASK ) { materialParams.alphaTest = materialDef.alphaCutoff !== undefined ? materialDef.alphaCutoff : 0.5; } } if ( materialDef.normalTexture !== undefined && materialType !== THREE.MeshBasicMaterial ) { pending.push( parser.assignTexture( materialParams, 'normalMap', materialDef.normalTexture ) ); materialParams.normalScale = new THREE.Vector2( 1, 1 ); if ( materialDef.normalTexture.scale !== undefined ) { materialParams.normalScale.set( materialDef.normalTexture.scale, materialDef.normalTexture.scale ); } } if ( materialDef.occlusionTexture !== undefined && materialType !== THREE.MeshBasicMaterial ) { pending.push( parser.assignTexture( materialParams, 'aoMap', materialDef.occlusionTexture ) ); if ( materialDef.occlusionTexture.strength !== undefined ) { materialParams.aoMapIntensity = materialDef.occlusionTexture.strength; } } if ( materialDef.emissiveFactor !== undefined && materialType !== THREE.MeshBasicMaterial ) { materialParams.emissive = new THREE.Color().fromArray( materialDef.emissiveFactor ); } if ( materialDef.emissiveTexture !== undefined && materialType !== THREE.MeshBasicMaterial ) { pending.push( parser.assignTexture( materialParams, 'emissiveMap', materialDef.emissiveTexture ) ); } return Promise.all( pending ).then( function () { var material; if ( materialType === THREE.ShaderMaterial ) { material = extensions[ EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS ].createMaterial( materialParams ); } else { material = new materialType( materialParams ); } if ( materialDef.name !== undefined ) material.name = materialDef.name; // Normal map textures use OpenGL conventions: // https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#materialnormaltexture if ( material.normalScale ) { material.normalScale.y = - material.normalScale.y; } // baseColorTexture, emissiveTexture, and specularGlossinessTexture use sRGB encoding. if ( material.map ) material.map.encoding = THREE.sRGBEncoding; if ( material.emissiveMap ) material.emissiveMap.encoding = THREE.sRGBEncoding; if ( material.specularMap ) material.specularMap.encoding = THREE.sRGBEncoding; assignExtrasToUserData( material, materialDef ); if ( materialDef.extensions ) addUnknownExtensionsToUserData( extensions, material, materialDef ); return material; } ); }; /** * @param {THREE.BufferGeometry} geometry * @param {GLTF.Primitive} primitiveDef * @param {GLTFParser} parser * @return {Promise} */ function addPrimitiveAttributes( geometry, primitiveDef, parser ) { var attributes = primitiveDef.attributes; var pending = []; function assignAttributeAccessor( accessorIndex, attributeName ) { return parser.getDependency( 'accessor', accessorIndex ) .then( function ( accessor ) { geometry.addAttribute( attributeName, accessor ); } ); } for ( var gltfAttributeName in attributes ) { var threeAttributeName = ATTRIBUTES[ gltfAttributeName ]; if ( ! threeAttributeName ) continue; // Skip attributes already provided by e.g. Draco extension. if ( threeAttributeName in geometry.attributes ) continue; pending.push( assignAttributeAccessor( attributes[ gltfAttributeName ], threeAttributeName ) ); } if ( primitiveDef.indices !== undefined && ! geometry.index ) { var accessor = parser.getDependency( 'accessor', primitiveDef.indices ).then( function ( accessor ) { geometry.setIndex( accessor ); } ); pending.push( accessor ); } assignExtrasToUserData( geometry, primitiveDef ); return Promise.all( pending ).then( function () { return primitiveDef.targets !== undefined ? addMorphTargets( geometry, primitiveDef.targets, parser ) : geometry; } ); } /** * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#geometry * * Creates BufferGeometries from primitives. * If we can build a single BufferGeometry with .groups from multiple primitives, returns one BufferGeometry. * Otherwise, returns BufferGeometries without .groups as many as primitives. * * @param {Array} primitives * @return {Promise} */ GLTFParser.prototype.loadGeometries = function ( primitives ) { var parser = this; var extensions = this.extensions; var cache = this.primitiveCache; var isMultiPass = isMultiPassGeometry( primitives ); var originalPrimitives; if ( isMultiPass ) { originalPrimitives = primitives; // save original primitives and use later // We build a single BufferGeometry with .groups from multiple primitives // because all primitives share the same attributes/morph/mode and have indices. primitives = [ primitives[ 0 ] ]; // Sets .groups and combined indices to a geometry later in this method. } function createDracoPrimitive( primitive ) { return extensions[ EXTENSIONS.KHR_DRACO_MESH_COMPRESSION ] .decodePrimitive( primitive, parser ) .then( function ( geometry ) { return addPrimitiveAttributes( geometry, primitive, parser ); } ); } var pending = []; for ( var i = 0, il = primitives.length; i < il; i ++ ) { var primitive = primitives[ i ]; // See if we've already created this geometry var cached = getCachedGeometry( cache, primitive ); if ( cached ) { // Use the cached geometry if it exists pending.push( cached ); } else { var geometryPromise; if ( primitive.extensions && primitive.extensions[ EXTENSIONS.KHR_DRACO_MESH_COMPRESSION ] ) { // Use DRACO geometry if available geometryPromise = createDracoPrimitive( primitive ); } else { // Otherwise create a new geometry geometryPromise = addPrimitiveAttributes( new THREE.BufferGeometry(), primitive, parser ); } // Cache this geometry cache.push( { primitive: primitive, promise: geometryPromise } ); pending.push( geometryPromise ); } } return Promise.all( pending ).then( function ( geometries ) { if ( isMultiPass ) { var baseGeometry = geometries[ 0 ]; // See if we've already created this combined geometry var cache = parser.multiPassGeometryCache; var cached = getCachedMultiPassGeometry( cache, baseGeometry, originalPrimitives ); if ( cached !== null ) return [ cached.geometry ]; // Cloning geometry because of index override. // Attributes can be reused so cloning by myself here. var geometry = new THREE.BufferGeometry(); geometry.name = baseGeometry.name; geometry.userData = baseGeometry.userData; for ( var key in baseGeometry.attributes ) geometry.addAttribute( key, baseGeometry.attributes[ key ] ); for ( var key in baseGeometry.morphAttributes ) geometry.morphAttributes[ key ] = baseGeometry.morphAttributes[ key ]; var pendingIndices = []; for ( var i = 0, il = originalPrimitives.length; i < il; i ++ ) { pendingIndices.push( parser.getDependency( 'accessor', originalPrimitives[ i ].indices ) ); } return Promise.all( pendingIndices ).then( function ( accessors ) { var indices = []; var offset = 0; for ( var i = 0, il = originalPrimitives.length; i < il; i ++ ) { var accessor = accessors[ i ]; for ( var j = 0, jl = accessor.count; j < jl; j ++ ) indices.push( accessor.array[ j ] ); geometry.addGroup( offset, accessor.count, i ); offset += accessor.count; } geometry.setIndex( indices ); cache.push( { geometry: geometry, baseGeometry: baseGeometry, primitives: originalPrimitives } ); return [ geometry ]; } ); } else if ( geometries.length > 1 && THREE.BufferGeometryUtils !== undefined ) { // Tries to merge geometries with BufferGeometryUtils if possible for ( var i = 1, il = primitives.length; i < il; i ++ ) { // can't merge if draw mode is different if ( primitives[ 0 ].mode !== primitives[ i ].mode ) return geometries; } // See if we've already created this combined geometry var cache = parser.multiplePrimitivesCache; var cached = getCachedCombinedGeometry( cache, geometries ); if ( cached ) { if ( cached.geometry !== null ) return [ cached.geometry ]; } else { var geometry = THREE.BufferGeometryUtils.mergeBufferGeometries( geometries, true ); cache.push( { geometry: geometry, baseGeometries: geometries } ); if ( geometry !== null ) return [ geometry ]; } } return geometries; } ); }; /** * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#meshes * @param {number} meshIndex * @return {Promise} */ GLTFParser.prototype.loadMesh = function ( meshIndex ) { var parser = this; var json = this.json; var extensions = this.extensions; var meshDef = json.meshes[ meshIndex ]; var primitives = meshDef.primitives; var pending = []; for ( var i = 0, il = primitives.length; i < il; i ++ ) { var material = primitives[ i ].material === undefined ? createDefaultMaterial() : this.getDependency( 'material', primitives[ i ].material ); pending.push( material ); } return Promise.all( pending ).then( function ( originalMaterials ) { return parser.loadGeometries( primitives ).then( function ( geometries ) { var isMultiMaterial = geometries.length === 1 && geometries[ 0 ].groups.length > 0; var meshes = []; for ( var i = 0, il = geometries.length; i < il; i ++ ) { var geometry = geometries[ i ]; var primitive = primitives[ i ]; // 1. create Mesh var mesh; var material = isMultiMaterial ? originalMaterials : originalMaterials[ i ]; if ( primitive.mode === WEBGL_CONSTANTS.TRIANGLES || primitive.mode === WEBGL_CONSTANTS.TRIANGLE_STRIP || primitive.mode === WEBGL_CONSTANTS.TRIANGLE_FAN || primitive.mode === undefined ) { // .isSkinnedMesh isn't in glTF spec. See .markDefs() mesh = meshDef.isSkinnedMesh === true ? new THREE.SkinnedMesh( geometry, material ) : new THREE.Mesh( geometry, material ); if ( mesh.isSkinnedMesh === true ) mesh.normalizeSkinWeights(); // #15319 if ( primitive.mode === WEBGL_CONSTANTS.TRIANGLE_STRIP ) { mesh.drawMode = THREE.TriangleStripDrawMode; } else if ( primitive.mode === WEBGL_CONSTANTS.TRIANGLE_FAN ) { mesh.drawMode = THREE.TriangleFanDrawMode; } } else if ( primitive.mode === WEBGL_CONSTANTS.LINES ) { mesh = new THREE.LineSegments( geometry, material ); } else if ( primitive.mode === WEBGL_CONSTANTS.LINE_STRIP ) { mesh = new THREE.Line( geometry, material ); } else if ( primitive.mode === WEBGL_CONSTANTS.LINE_LOOP ) { mesh = new THREE.LineLoop( geometry, material ); } else if ( primitive.mode === WEBGL_CONSTANTS.POINTS ) { mesh = new THREE.Points( geometry, material ); } else { throw new Error( 'THREE.GLTFLoader: Primitive mode unsupported: ' + primitive.mode ); } if ( Object.keys( mesh.geometry.morphAttributes ).length > 0 ) { updateMorphTargets( mesh, meshDef ); } mesh.name = meshDef.name || ( 'mesh_' + meshIndex ); if ( geometries.length > 1 ) mesh.name += '_' + i; assignExtrasToUserData( mesh, meshDef ); meshes.push( mesh ); // 2. update Material depending on Mesh and BufferGeometry var materials = isMultiMaterial ? mesh.material : [ mesh.material ]; var useVertexColors = geometry.attributes.color !== undefined; var useFlatShading = geometry.attributes.normal === undefined; var useSkinning = mesh.isSkinnedMesh === true; var useMorphTargets = Object.keys( geometry.morphAttributes ).length > 0; var useMorphNormals = useMorphTargets && geometry.morphAttributes.normal !== undefined; for ( var j = 0, jl = materials.length; j < jl; j ++ ) { var material = materials[ j ]; if ( mesh.isPoints ) { var cacheKey = 'PointsMaterial:' + material.uuid; var pointsMaterial = parser.cache.get( cacheKey ); if ( ! pointsMaterial ) { pointsMaterial = new THREE.PointsMaterial(); THREE.Material.prototype.copy.call( pointsMaterial, material ); pointsMaterial.color.copy( material.color ); pointsMaterial.map = material.map; pointsMaterial.lights = false; // PointsMaterial doesn't support lights yet parser.cache.add( cacheKey, pointsMaterial ); } material = pointsMaterial; } else if ( mesh.isLine ) { var cacheKey = 'LineBasicMaterial:' + material.uuid; var lineMaterial = parser.cache.get( cacheKey ); if ( ! lineMaterial ) { lineMaterial = new THREE.LineBasicMaterial(); THREE.Material.prototype.copy.call( lineMaterial, material ); lineMaterial.color.copy( material.color ); lineMaterial.lights = false; // LineBasicMaterial doesn't support lights yet parser.cache.add( cacheKey, lineMaterial ); } material = lineMaterial; } // Clone the material if it will be modified if ( useVertexColors || useFlatShading || useSkinning || useMorphTargets ) { var cacheKey = 'ClonedMaterial:' + material.uuid + ':'; if ( material.isGLTFSpecularGlossinessMaterial ) cacheKey += 'specular-glossiness:'; if ( useSkinning ) cacheKey += 'skinning:'; if ( useVertexColors ) cacheKey += 'vertex-colors:'; if ( useFlatShading ) cacheKey += 'flat-shading:'; if ( useMorphTargets ) cacheKey += 'morph-targets:'; if ( useMorphNormals ) cacheKey += 'morph-normals:'; var cachedMaterial = parser.cache.get( cacheKey ); if ( ! cachedMaterial ) { cachedMaterial = material.isGLTFSpecularGlossinessMaterial ? extensions[ EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS ].cloneMaterial( material ) : material.clone(); if ( useSkinning ) cachedMaterial.skinning = true; if ( useVertexColors ) cachedMaterial.vertexColors = THREE.VertexColors; if ( useFlatShading ) cachedMaterial.flatShading = true; if ( useMorphTargets ) cachedMaterial.morphTargets = true; if ( useMorphNormals ) cachedMaterial.morphNormals = true; parser.cache.add( cacheKey, cachedMaterial ); } material = cachedMaterial; } materials[ j ] = material; // workarounds for mesh and geometry if ( material.aoMap && geometry.attributes.uv2 === undefined && geometry.attributes.uv !== undefined ) { console.log( 'THREE.GLTFLoader: Duplicating UVs to support aoMap.' ); geometry.addAttribute( 'uv2', new THREE.BufferAttribute( geometry.attributes.uv.array, 2 ) ); } if ( material.isGLTFSpecularGlossinessMaterial ) { // for GLTFSpecularGlossinessMaterial(ShaderMaterial) uniforms runtime update mesh.onBeforeRender = extensions[ EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS ].refreshUniforms; } } mesh.material = isMultiMaterial ? materials : materials[ 0 ]; } if ( meshes.length === 1 ) { return meshes[ 0 ]; } var group = new THREE.Group(); for ( var i = 0, il = meshes.length; i < il; i ++ ) { group.add( meshes[ i ] ); } return group; } ); } ); }; /** * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#cameras * @param {number} cameraIndex * @return {Promise} */ GLTFParser.prototype.loadCamera = function ( cameraIndex ) { var camera; var cameraDef = this.json.cameras[ cameraIndex ]; var params = cameraDef[ cameraDef.type ]; if ( ! params ) { console.warn( 'THREE.GLTFLoader: Missing camera parameters.' ); return; } if ( cameraDef.type === 'perspective' ) { camera = new THREE.PerspectiveCamera( THREE.Math.radToDeg( params.yfov ), params.aspectRatio || 1, params.znear || 1, params.zfar || 2e6 ); } else if ( cameraDef.type === 'orthographic' ) { camera = new THREE.OrthographicCamera( params.xmag / - 2, params.xmag / 2, params.ymag / 2, params.ymag / - 2, params.znear, params.zfar ); } if ( cameraDef.name !== undefined ) camera.name = cameraDef.name; assignExtrasToUserData( camera, cameraDef ); return Promise.resolve( camera ); }; /** * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#skins * @param {number} skinIndex * @return {Promise} */ GLTFParser.prototype.loadSkin = function ( skinIndex ) { var skinDef = this.json.skins[ skinIndex ]; var skinEntry = { joints: skinDef.joints }; if ( skinDef.inverseBindMatrices === undefined ) { return Promise.resolve( skinEntry ); } return this.getDependency( 'accessor', skinDef.inverseBindMatrices ).then( function ( accessor ) { skinEntry.inverseBindMatrices = accessor; return skinEntry; } ); }; /** * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#animations * @param {number} animationIndex * @return {Promise} */ GLTFParser.prototype.loadAnimation = function ( animationIndex ) { var json = this.json; var animationDef = json.animations[ animationIndex ]; var pendingNodes = []; var pendingInputAccessors = []; var pendingOutputAccessors = []; var pendingSamplers = []; var pendingTargets = []; for ( var i = 0, il = animationDef.channels.length; i < il; i ++ ) { var channel = animationDef.channels[ i ]; var sampler = animationDef.samplers[ channel.sampler ]; var target = channel.target; var name = target.node !== undefined ? target.node : target.id; // NOTE: target.id is deprecated. var input = animationDef.parameters !== undefined ? animationDef.parameters[ sampler.input ] : sampler.input; var output = animationDef.parameters !== undefined ? animationDef.parameters[ sampler.output ] : sampler.output; pendingNodes.push( this.getDependency( 'node', name ) ); pendingInputAccessors.push( this.getDependency( 'accessor', input ) ); pendingOutputAccessors.push( this.getDependency( 'accessor', output ) ); pendingSamplers.push( sampler ); pendingTargets.push( target ); } return Promise.all( [ Promise.all( pendingNodes ), Promise.all( pendingInputAccessors ), Promise.all( pendingOutputAccessors ), Promise.all( pendingSamplers ), Promise.all( pendingTargets ) ] ).then( function ( dependencies ) { var nodes = dependencies[ 0 ]; var inputAccessors = dependencies[ 1 ]; var outputAccessors = dependencies[ 2 ]; var samplers = dependencies[ 3 ]; var targets = dependencies[ 4 ]; var tracks = []; for ( var i = 0, il = nodes.length; i < il; i ++ ) { var node = nodes[ i ]; var inputAccessor = inputAccessors[ i ]; var outputAccessor = outputAccessors[ i ]; var sampler = samplers[ i ]; var target = targets[ i ]; if ( node === undefined ) continue; node.updateMatrix(); node.matrixAutoUpdate = true; var TypedKeyframeTrack; switch ( PATH_PROPERTIES[ target.path ] ) { case PATH_PROPERTIES.weights: TypedKeyframeTrack = THREE.NumberKeyframeTrack; break; case PATH_PROPERTIES.rotation: TypedKeyframeTrack = THREE.QuaternionKeyframeTrack; break; case PATH_PROPERTIES.position: case PATH_PROPERTIES.scale: default: TypedKeyframeTrack = THREE.VectorKeyframeTrack; break; } var targetName = node.name ? node.name : node.uuid; var interpolation = sampler.interpolation !== undefined ? INTERPOLATION[ sampler.interpolation ] : THREE.InterpolateLinear; var targetNames = []; if ( PATH_PROPERTIES[ target.path ] === PATH_PROPERTIES.weights ) { // node can be THREE.Group here but // PATH_PROPERTIES.weights(morphTargetInfluences) should be // the property of a mesh object under group. node.traverse( function ( object ) { if ( object.isMesh === true && object.morphTargetInfluences ) { targetNames.push( object.name ? object.name : object.uuid ); } } ); } else { targetNames.push( targetName ); } // KeyframeTrack.optimize() will modify given 'times' and 'values' // buffers before creating a truncated copy to keep. Because buffers may // be reused by other tracks, make copies here. for ( var j = 0, jl = targetNames.length; j < jl; j ++ ) { var track = new TypedKeyframeTrack( targetNames[ j ] + '.' + PATH_PROPERTIES[ target.path ], THREE.AnimationUtils.arraySlice( inputAccessor.array, 0 ), THREE.AnimationUtils.arraySlice( outputAccessor.array, 0 ), interpolation ); // Here is the trick to enable custom interpolation. // Overrides .createInterpolant in a factory method which creates custom interpolation. if ( sampler.interpolation === 'CUBICSPLINE' ) { track.createInterpolant = function InterpolantFactoryMethodGLTFCubicSpline( result ) { // A CUBICSPLINE keyframe in glTF has three output values for each input value, // representing inTangent, splineVertex, and outTangent. As a result, track.getValueSize() // must be divided by three to get the interpolant's sampleSize argument. return new GLTFCubicSplineInterpolant( this.times, this.values, this.getValueSize() / 3, result ); }; // Workaround, provide an alternate way to know if the interpolant type is cubis spline to track. // track.getInterpolation() doesn't return valid value for custom interpolant. track.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline = true; } tracks.push( track ); } } var name = animationDef.name !== undefined ? animationDef.name : 'animation_' + animationIndex; return new THREE.AnimationClip( name, undefined, tracks ); } ); }; /** * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#nodes-and-hierarchy * @param {number} nodeIndex * @return {Promise} */ GLTFParser.prototype.loadNode = function ( nodeIndex ) { var json = this.json; var extensions = this.extensions; var parser = this; var meshReferences = json.meshReferences; var meshUses = json.meshUses; var nodeDef = json.nodes[ nodeIndex ]; return ( function () { // .isBone isn't in glTF spec. See .markDefs if ( nodeDef.isBone === true ) { return Promise.resolve( new THREE.Bone() ); } else if ( nodeDef.mesh !== undefined ) { return parser.getDependency( 'mesh', nodeDef.mesh ).then( function ( mesh ) { var node; if ( meshReferences[ nodeDef.mesh ] > 1 ) { var instanceNum = meshUses[ nodeDef.mesh ] ++; node = mesh.clone(); node.name += '_instance_' + instanceNum; // onBeforeRender copy for Specular-Glossiness node.onBeforeRender = mesh.onBeforeRender; for ( var i = 0, il = node.children.length; i < il; i ++ ) { node.children[ i ].name += '_instance_' + instanceNum; node.children[ i ].onBeforeRender = mesh.children[ i ].onBeforeRender; } } else { node = mesh; } // if weights are provided on the node, override weights on the mesh. if ( nodeDef.weights !== undefined ) { node.traverse( function ( o ) { if ( ! o.isMesh ) return; for ( var i = 0, il = nodeDef.weights.length; i < il; i ++ ) { o.morphTargetInfluences[ i ] = nodeDef.weights[ i ]; } } ); } return node; } ); } else if ( nodeDef.camera !== undefined ) { return parser.getDependency( 'camera', nodeDef.camera ); } else if ( nodeDef.extensions && nodeDef.extensions[ EXTENSIONS.KHR_LIGHTS_PUNCTUAL ] && nodeDef.extensions[ EXTENSIONS.KHR_LIGHTS_PUNCTUAL ].light !== undefined ) { return parser.getDependency( 'light', nodeDef.extensions[ EXTENSIONS.KHR_LIGHTS_PUNCTUAL ].light ); } else { return Promise.resolve( new THREE.Object3D() ); } }() ).then( function ( node ) { if ( nodeDef.name !== undefined ) { node.name = THREE.PropertyBinding.sanitizeNodeName( nodeDef.name ); } assignExtrasToUserData( node, nodeDef ); if ( nodeDef.extensions ) addUnknownExtensionsToUserData( extensions, node, nodeDef ); if ( nodeDef.matrix !== undefined ) { var matrix = new THREE.Matrix4(); matrix.fromArray( nodeDef.matrix ); node.applyMatrix( matrix ); } else { if ( nodeDef.translation !== undefined ) { node.position.fromArray( nodeDef.translation ); } if ( nodeDef.rotation !== undefined ) { node.quaternion.fromArray( nodeDef.rotation ); } if ( nodeDef.scale !== undefined ) { node.scale.fromArray( nodeDef.scale ); } } return node; } ); }; /** * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#scenes * @param {number} sceneIndex * @return {Promise} */ GLTFParser.prototype.loadScene = function () { // scene node hierachy builder function buildNodeHierachy( nodeId, parentObject, json, parser ) { var nodeDef = json.nodes[ nodeId ]; return parser.getDependency( 'node', nodeId ).then( function ( node ) { if ( nodeDef.skin === undefined ) return node; // build skeleton here as well var skinEntry; return parser.getDependency( 'skin', nodeDef.skin ).then( function ( skin ) { skinEntry = skin; var pendingJoints = []; for ( var i = 0, il = skinEntry.joints.length; i < il; i ++ ) { pendingJoints.push( parser.getDependency( 'node', skinEntry.joints[ i ] ) ); } return Promise.all( pendingJoints ); } ).then( function ( jointNodes ) { var meshes = node.isGroup === true ? node.children : [ node ]; for ( var i = 0, il = meshes.length; i < il; i ++ ) { var mesh = meshes[ i ]; var bones = []; var boneInverses = []; for ( var j = 0, jl = jointNodes.length; j < jl; j ++ ) { var jointNode = jointNodes[ j ]; if ( jointNode ) { bones.push( jointNode ); var mat = new THREE.Matrix4(); if ( skinEntry.inverseBindMatrices !== undefined ) { mat.fromArray( skinEntry.inverseBindMatrices.array, j * 16 ); } boneInverses.push( mat ); } else { console.warn( 'THREE.GLTFLoader: Joint \"%s\" could not be found.', skinEntry.joints[ j ] ); } } mesh.bind( new THREE.Skeleton( bones, boneInverses ), mesh.matrixWorld ); }; return node; } ); } ).then( function ( node ) { // build node hierachy parentObject.add( node ); var pending = []; if ( nodeDef.children ) { var children = nodeDef.children; for ( var i = 0, il = children.length; i < il; i ++ ) { var child = children[ i ]; pending.push( buildNodeHierachy( child, node, json, parser ) ); } } return Promise.all( pending ); } ); } return function loadScene( sceneIndex ) { var json = this.json; var extensions = this.extensions; var sceneDef = this.json.scenes[ sceneIndex ]; var parser = this; var scene = new THREE.Scene(); if ( sceneDef.name !== undefined ) scene.name = sceneDef.name; assignExtrasToUserData( scene, sceneDef ); if ( sceneDef.extensions ) addUnknownExtensionsToUserData( extensions, scene, sceneDef ); var nodeIds = sceneDef.nodes || []; var pending = []; for ( var i = 0, il = nodeIds.length; i < il; i ++ ) { pending.push( buildNodeHierachy( nodeIds[ i ], scene, json, parser ) ); } return Promise.all( pending ).then( function () { return scene; } ); }; }(); return GLTFLoader; } )();","categories":[],"tags":[]},{"title":"","slug":"Three.js移动DecalGeometry/js/OrbitControls","date":"2019-03-17T10:06:35.706Z","updated":"2019-03-17T10:06:35.706Z","comments":true,"path":"2019/03/17/cjtcra7jj0008h1l3iwj92j4q/","link":"","permalink":"http://www.zcating.tk/2019/03/17/cjtcra7jj0008h1l3iwj92j4q/","excerpt":"","text":"/** * @author qiao / https://github.com/qiao * @author mrdoob / http://mrdoob.com * @author alteredq / http://alteredqualia.com/ * @author WestLangley / http://github.com/WestLangley * @author erich666 / http://erichaines.com */ // This set of controls performs orbiting, dollying (zooming), and panning. // Unlike TrackballControls, it maintains the \"up\" direction object.up (+Y by default). // // Orbit - left mouse / touch: one-finger move // Zoom - middle mouse, or mousewheel / touch: two-finger spread or squish // Pan - right mouse, or left mouse + ctrl/meta/shiftKey, or arrow keys / touch: two-finger move THREE.OrbitControls = function ( object, domElement ) { this.object = object; this.domElement = ( domElement !== undefined ) ? domElement : document; // Set to false to disable this control this.enabled = true; // \"target\" sets the location of focus, where the object orbits around this.target = new THREE.Vector3(); // How far you can dolly in and out ( PerspectiveCamera only ) this.minDistance = 0; this.maxDistance = Infinity; // How far you can zoom in and out ( OrthographicCamera only ) this.minZoom = 0; this.maxZoom = Infinity; // How far you can orbit vertically, upper and lower limits. // Range is 0 to Math.PI radians. this.minPolarAngle = 0; // radians this.maxPolarAngle = Math.PI; // radians // How far you can orbit horizontally, upper and lower limits. // If set, must be a sub-interval of the interval [ - Math.PI, Math.PI ]. this.minAzimuthAngle = - Infinity; // radians this.maxAzimuthAngle = Infinity; // radians // Set to true to enable damping (inertia) // If damping is enabled, you must call controls.update() in your animation loop this.enableDamping = false; this.dampingFactor = 0.25; // This option actually enables dollying in and out; left as \"zoom\" for backwards compatibility. // Set to false to disable zooming this.enableZoom = true; this.zoomSpeed = 1.0; // Set to false to disable rotating this.enableRotate = true; this.rotateSpeed = 1.0; // Set to false to disable panning this.enablePan = true; this.panSpeed = 1.0; this.screenSpacePanning = false; // if true, pan in screen-space this.keyPanSpeed = 7.0; // pixels moved per arrow key push // Set to true to automatically rotate around the target // If auto-rotate is enabled, you must call controls.update() in your animation loop this.autoRotate = false; this.autoRotateSpeed = 2.0; // 30 seconds per round when fps is 60 // Set to false to disable use of the keys this.enableKeys = true; // The four arrow keys this.keys = { LEFT: 37, UP: 38, RIGHT: 39, BOTTOM: 40 }; // Mouse buttons this.mouseButtons = { LEFT: THREE.MOUSE.LEFT, MIDDLE: THREE.MOUSE.MIDDLE, RIGHT: THREE.MOUSE.RIGHT }; // for reset this.target0 = this.target.clone(); this.position0 = this.object.position.clone(); this.zoom0 = this.object.zoom; // // public methods // this.getPolarAngle = function () { return spherical.phi; }; this.getAzimuthalAngle = function () { return spherical.theta; }; this.saveState = function () { scope.target0.copy( scope.target ); scope.position0.copy( scope.object.position ); scope.zoom0 = scope.object.zoom; }; this.reset = function () { scope.target.copy( scope.target0 ); scope.object.position.copy( scope.position0 ); scope.object.zoom = scope.zoom0; scope.object.updateProjectionMatrix(); scope.dispatchEvent( changeEvent ); scope.update(); state = STATE.NONE; }; // this method is exposed, but perhaps it would be better if we can make it private... this.update = function () { var offset = new THREE.Vector3(); // so camera.up is the orbit axis var quat = new THREE.Quaternion().setFromUnitVectors( object.up, new THREE.Vector3( 0, 1, 0 ) ); var quatInverse = quat.clone().inverse(); var lastPosition = new THREE.Vector3(); var lastQuaternion = new THREE.Quaternion(); return function update() { var position = scope.object.position; offset.copy( position ).sub( scope.target ); // rotate offset to \"y-axis-is-up\" space offset.applyQuaternion( quat ); // angle from z-axis around y-axis spherical.setFromVector3( offset ); if ( scope.autoRotate && state === STATE.NONE ) { rotateLeft( getAutoRotationAngle() ); } spherical.theta += sphericalDelta.theta; spherical.phi += sphericalDelta.phi; // restrict theta to be between desired limits spherical.theta = Math.max( scope.minAzimuthAngle, Math.min( scope.maxAzimuthAngle, spherical.theta ) ); // restrict phi to be between desired limits spherical.phi = Math.max( scope.minPolarAngle, Math.min( scope.maxPolarAngle, spherical.phi ) ); spherical.makeSafe(); spherical.radius *= scale; // restrict radius to be between desired limits spherical.radius = Math.max( scope.minDistance, Math.min( scope.maxDistance, spherical.radius ) ); // move target to panned location scope.target.add( panOffset ); offset.setFromSpherical( spherical ); // rotate offset back to \"camera-up-vector-is-up\" space offset.applyQuaternion( quatInverse ); position.copy( scope.target ).add( offset ); scope.object.lookAt( scope.target ); if ( scope.enableDamping === true ) { sphericalDelta.theta *= ( 1 - scope.dampingFactor ); sphericalDelta.phi *= ( 1 - scope.dampingFactor ); panOffset.multiplyScalar( 1 - scope.dampingFactor ); } else { sphericalDelta.set( 0, 0, 0 ); panOffset.set( 0, 0, 0 ); } scale = 1; // update condition is: // min(camera displacement, camera rotation in radians)^2 > EPS // using small-angle approximation cos(x/2) = 1 - x^2 / 8 if ( zoomChanged || lastPosition.distanceToSquared( scope.object.position ) > EPS || 8 * ( 1 - lastQuaternion.dot( scope.object.quaternion ) ) > EPS ) { scope.dispatchEvent( changeEvent ); lastPosition.copy( scope.object.position ); lastQuaternion.copy( scope.object.quaternion ); zoomChanged = false; return true; } return false; }; }(); this.dispose = function () { scope.domElement.removeEventListener( 'contextmenu', onContextMenu, false ); scope.domElement.removeEventListener( 'mousedown', onMouseDown, false ); scope.domElement.removeEventListener( 'wheel', onMouseWheel, false ); scope.domElement.removeEventListener( 'touchstart', onTouchStart, false ); scope.domElement.removeEventListener( 'touchend', onTouchEnd, false ); scope.domElement.removeEventListener( 'touchmove', onTouchMove, false ); document.removeEventListener( 'mousemove', onMouseMove, false ); document.removeEventListener( 'mouseup', onMouseUp, false ); window.removeEventListener( 'keydown', onKeyDown, false ); //scope.dispatchEvent( { type: 'dispose' } ); // should this be added here? }; // // internals // var scope = this; var changeEvent = { type: 'change' }; var startEvent = { type: 'start' }; var endEvent = { type: 'end' }; var STATE = { NONE: - 1, ROTATE: 0, DOLLY: 1, PAN: 2, TOUCH_ROTATE: 3, TOUCH_DOLLY_PAN: 4 }; var state = STATE.NONE; var EPS = 0.000001; // current position in spherical coordinates var spherical = new THREE.Spherical(); var sphericalDelta = new THREE.Spherical(); var scale = 1; var panOffset = new THREE.Vector3(); var zoomChanged = false; var rotateStart = new THREE.Vector2(); var rotateEnd = new THREE.Vector2(); var rotateDelta = new THREE.Vector2(); var panStart = new THREE.Vector2(); var panEnd = new THREE.Vector2(); var panDelta = new THREE.Vector2(); var dollyStart = new THREE.Vector2(); var dollyEnd = new THREE.Vector2(); var dollyDelta = new THREE.Vector2(); function getAutoRotationAngle() { return 2 * Math.PI / 60 / 60 * scope.autoRotateSpeed; } function getZoomScale() { return Math.pow( 0.95, scope.zoomSpeed ); } function rotateLeft( angle ) { sphericalDelta.theta -= angle; } function rotateUp( angle ) { sphericalDelta.phi -= angle; } var panLeft = function () { var v = new THREE.Vector3(); return function panLeft( distance, objectMatrix ) { v.setFromMatrixColumn( objectMatrix, 0 ); // get X column of objectMatrix v.multiplyScalar( - distance ); panOffset.add( v ); }; }(); var panUp = function () { var v = new THREE.Vector3(); return function panUp( distance, objectMatrix ) { if ( scope.screenSpacePanning === true ) { v.setFromMatrixColumn( objectMatrix, 1 ); } else { v.setFromMatrixColumn( objectMatrix, 0 ); v.crossVectors( scope.object.up, v ); } v.multiplyScalar( distance ); panOffset.add( v ); }; }(); // deltaX and deltaY are in pixels; right and down are positive var pan = function () { var offset = new THREE.Vector3(); return function pan( deltaX, deltaY ) { var element = scope.domElement === document ? scope.domElement.body : scope.domElement; if ( scope.object.isPerspectiveCamera ) { // perspective var position = scope.object.position; offset.copy( position ).sub( scope.target ); var targetDistance = offset.length(); // half of the fov is center to top of screen targetDistance *= Math.tan( ( scope.object.fov / 2 ) * Math.PI / 180.0 ); // we use only clientHeight here so aspect ratio does not distort speed panLeft( 2 * deltaX * targetDistance / element.clientHeight, scope.object.matrix ); panUp( 2 * deltaY * targetDistance / element.clientHeight, scope.object.matrix ); } else if ( scope.object.isOrthographicCamera ) { // orthographic panLeft( deltaX * ( scope.object.right - scope.object.left ) / scope.object.zoom / element.clientWidth, scope.object.matrix ); panUp( deltaY * ( scope.object.top - scope.object.bottom ) / scope.object.zoom / element.clientHeight, scope.object.matrix ); } else { // camera neither orthographic nor perspective console.warn( 'WARNING: OrbitControls.js encountered an unknown camera type - pan disabled.' ); scope.enablePan = false; } }; }(); function dollyIn( dollyScale ) { if ( scope.object.isPerspectiveCamera ) { scale /= dollyScale; } else if ( scope.object.isOrthographicCamera ) { scope.object.zoom = Math.max( scope.minZoom, Math.min( scope.maxZoom, scope.object.zoom * dollyScale ) ); scope.object.updateProjectionMatrix(); zoomChanged = true; } else { console.warn( 'WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled.' ); scope.enableZoom = false; } } function dollyOut( dollyScale ) { if ( scope.object.isPerspectiveCamera ) { scale *= dollyScale; } else if ( scope.object.isOrthographicCamera ) { scope.object.zoom = Math.max( scope.minZoom, Math.min( scope.maxZoom, scope.object.zoom / dollyScale ) ); scope.object.updateProjectionMatrix(); zoomChanged = true; } else { console.warn( 'WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled.' ); scope.enableZoom = false; } } // // event callbacks - update the object state // function handleMouseDownRotate( event ) { //console.log( 'handleMouseDownRotate' ); rotateStart.set( event.clientX, event.clientY ); } function handleMouseDownDolly( event ) { //console.log( 'handleMouseDownDolly' ); dollyStart.set( event.clientX, event.clientY ); } function handleMouseDownPan( event ) { //console.log( 'handleMouseDownPan' ); panStart.set( event.clientX, event.clientY ); } function handleMouseMoveRotate( event ) { //console.log( 'handleMouseMoveRotate' ); rotateEnd.set( event.clientX, event.clientY ); rotateDelta.subVectors( rotateEnd, rotateStart ).multiplyScalar( scope.rotateSpeed ); var element = scope.domElement === document ? scope.domElement.body : scope.domElement; rotateLeft( 2 * Math.PI * rotateDelta.x / element.clientHeight ); // yes, height rotateUp( 2 * Math.PI * rotateDelta.y / element.clientHeight ); rotateStart.copy( rotateEnd ); scope.update(); } function handleMouseMoveDolly( event ) { //console.log( 'handleMouseMoveDolly' ); dollyEnd.set( event.clientX, event.clientY ); dollyDelta.subVectors( dollyEnd, dollyStart ); if ( dollyDelta.y > 0 ) { dollyIn( getZoomScale() ); } else if ( dollyDelta.y < 0 ) { dollyOut( getZoomScale() ); } dollyStart.copy( dollyEnd ); scope.update(); } function handleMouseMovePan( event ) { //console.log( 'handleMouseMovePan' ); panEnd.set( event.clientX, event.clientY ); panDelta.subVectors( panEnd, panStart ).multiplyScalar( scope.panSpeed ); pan( panDelta.x, panDelta.y ); panStart.copy( panEnd ); scope.update(); } function handleMouseUp( event ) { // console.log( 'handleMouseUp' ); } function handleMouseWheel( event ) { // console.log( 'handleMouseWheel' ); if ( event.deltaY < 0 ) { dollyOut( getZoomScale() ); } else if ( event.deltaY > 0 ) { dollyIn( getZoomScale() ); } scope.update(); } function handleKeyDown( event ) { // console.log( 'handleKeyDown' ); var needsUpdate = false; switch ( event.keyCode ) { case scope.keys.UP: pan( 0, scope.keyPanSpeed ); needsUpdate = true; break; case scope.keys.BOTTOM: pan( 0, - scope.keyPanSpeed ); needsUpdate = true; break; case scope.keys.LEFT: pan( scope.keyPanSpeed, 0 ); needsUpdate = true; break; case scope.keys.RIGHT: pan( - scope.keyPanSpeed, 0 ); needsUpdate = true; break; } if ( needsUpdate ) { // prevent the browser from scrolling on cursor keys event.preventDefault(); scope.update(); } } function handleTouchStartRotate( event ) { //console.log( 'handleTouchStartRotate' ); rotateStart.set( event.touches[ 0 ].pageX, event.touches[ 0 ].pageY ); } function handleTouchStartDollyPan( event ) { //console.log( 'handleTouchStartDollyPan' ); if ( scope.enableZoom ) { var dx = event.touches[ 0 ].pageX - event.touches[ 1 ].pageX; var dy = event.touches[ 0 ].pageY - event.touches[ 1 ].pageY; var distance = Math.sqrt( dx * dx + dy * dy ); dollyStart.set( 0, distance ); } if ( scope.enablePan ) { var x = 0.5 * ( event.touches[ 0 ].pageX + event.touches[ 1 ].pageX ); var y = 0.5 * ( event.touches[ 0 ].pageY + event.touches[ 1 ].pageY ); panStart.set( x, y ); } } function handleTouchMoveRotate( event ) { //console.log( 'handleTouchMoveRotate' ); rotateEnd.set( event.touches[ 0 ].pageX, event.touches[ 0 ].pageY ); rotateDelta.subVectors( rotateEnd, rotateStart ).multiplyScalar( scope.rotateSpeed ); var element = scope.domElement === document ? scope.domElement.body : scope.domElement; rotateLeft( 2 * Math.PI * rotateDelta.x / element.clientHeight ); // yes, height rotateUp( 2 * Math.PI * rotateDelta.y / element.clientHeight ); rotateStart.copy( rotateEnd ); scope.update(); } function handleTouchMoveDollyPan( event ) { //console.log( 'handleTouchMoveDollyPan' ); if ( scope.enableZoom ) { var dx = event.touches[ 0 ].pageX - event.touches[ 1 ].pageX; var dy = event.touches[ 0 ].pageY - event.touches[ 1 ].pageY; var distance = Math.sqrt( dx * dx + dy * dy ); dollyEnd.set( 0, distance ); dollyDelta.set( 0, Math.pow( dollyEnd.y / dollyStart.y, scope.zoomSpeed ) ); dollyIn( dollyDelta.y ); dollyStart.copy( dollyEnd ); } if ( scope.enablePan ) { var x = 0.5 * ( event.touches[ 0 ].pageX + event.touches[ 1 ].pageX ); var y = 0.5 * ( event.touches[ 0 ].pageY + event.touches[ 1 ].pageY ); panEnd.set( x, y ); panDelta.subVectors( panEnd, panStart ).multiplyScalar( scope.panSpeed ); pan( panDelta.x, panDelta.y ); panStart.copy( panEnd ); } scope.update(); } function handleTouchEnd( event ) { //console.log( 'handleTouchEnd' ); } // // event handlers - FSM: listen for events and reset state // function onMouseDown( event ) { if ( scope.enabled === false ) return; // Prevent the browser from scrolling. event.preventDefault(); // Manually set the focus since calling preventDefault above // prevents the browser from setting it automatically. scope.domElement.focus ? scope.domElement.focus() : window.focus(); switch ( event.button ) { case scope.mouseButtons.LEFT: if ( event.ctrlKey || event.metaKey || event.shiftKey ) { if ( scope.enablePan === false ) return; handleMouseDownPan( event ); state = STATE.PAN; } else { if ( scope.enableRotate === false ) return; handleMouseDownRotate( event ); state = STATE.ROTATE; } break; case scope.mouseButtons.MIDDLE: if ( scope.enableZoom === false ) return; handleMouseDownDolly( event ); state = STATE.DOLLY; break; case scope.mouseButtons.RIGHT: if ( scope.enablePan === false ) return; handleMouseDownPan( event ); state = STATE.PAN; break; } if ( state !== STATE.NONE ) { document.addEventListener( 'mousemove', onMouseMove, false ); document.addEventListener( 'mouseup', onMouseUp, false ); scope.dispatchEvent( startEvent ); } } function onMouseMove( event ) { if ( scope.enabled === false ) return; event.preventDefault(); switch ( state ) { case STATE.ROTATE: if ( scope.enableRotate === false ) return; handleMouseMoveRotate( event ); break; case STATE.DOLLY: if ( scope.enableZoom === false ) return; handleMouseMoveDolly( event ); break; case STATE.PAN: if ( scope.enablePan === false ) return; handleMouseMovePan( event ); break; } } function onMouseUp( event ) { if ( scope.enabled === false ) return; handleMouseUp( event ); document.removeEventListener( 'mousemove', onMouseMove, false ); document.removeEventListener( 'mouseup', onMouseUp, false ); scope.dispatchEvent( endEvent ); state = STATE.NONE; } function onMouseWheel( event ) { if ( scope.enabled === false || scope.enableZoom === false || ( state !== STATE.NONE && state !== STATE.ROTATE ) ) return; event.preventDefault(); event.stopPropagation(); scope.dispatchEvent( startEvent ); handleMouseWheel( event ); scope.dispatchEvent( endEvent ); } function onKeyDown( event ) { if ( scope.enabled === false || scope.enableKeys === false || scope.enablePan === false ) return; handleKeyDown( event ); } function onTouchStart( event ) { if ( scope.enabled === false ) return; event.preventDefault(); switch ( event.touches.length ) { case 1: // one-fingered touch: rotate if ( scope.enableRotate === false ) return; handleTouchStartRotate( event ); state = STATE.TOUCH_ROTATE; break; case 2: // two-fingered touch: dolly-pan if ( scope.enableZoom === false && scope.enablePan === false ) return; handleTouchStartDollyPan( event ); state = STATE.TOUCH_DOLLY_PAN; break; default: state = STATE.NONE; } if ( state !== STATE.NONE ) { scope.dispatchEvent( startEvent ); } } function onTouchMove( event ) { if ( scope.enabled === false ) return; event.preventDefault(); event.stopPropagation(); switch ( event.touches.length ) { case 1: // one-fingered touch: rotate if ( scope.enableRotate === false ) return; if ( state !== STATE.TOUCH_ROTATE ) return; // is this needed? handleTouchMoveRotate( event ); break; case 2: // two-fingered touch: dolly-pan if ( scope.enableZoom === false && scope.enablePan === false ) return; if ( state !== STATE.TOUCH_DOLLY_PAN ) return; // is this needed? handleTouchMoveDollyPan( event ); break; default: state = STATE.NONE; } } function onTouchEnd( event ) { if ( scope.enabled === false ) return; handleTouchEnd( event ); scope.dispatchEvent( endEvent ); state = STATE.NONE; } function onContextMenu( event ) { if ( scope.enabled === false ) return; event.preventDefault(); } // scope.domElement.addEventListener( 'contextmenu', onContextMenu, false ); scope.domElement.addEventListener( 'mousedown', onMouseDown, false ); scope.domElement.addEventListener( 'wheel', onMouseWheel, false ); scope.domElement.addEventListener( 'touchstart', onTouchStart, false ); scope.domElement.addEventListener( 'touchend', onTouchEnd, false ); scope.domElement.addEventListener( 'touchmove', onTouchMove, false ); window.addEventListener( 'keydown', onKeyDown, false ); // force an update at start this.update(); }; THREE.OrbitControls.prototype = Object.create( THREE.EventDispatcher.prototype ); THREE.OrbitControls.prototype.constructor = THREE.OrbitControls; Object.defineProperties( THREE.OrbitControls.prototype, { center: { get: function () { console.warn( 'THREE.OrbitControls: .center has been renamed to .target' ); return this.target; } }, // backward compatibility noZoom: { get: function () { console.warn( 'THREE.OrbitControls: .noZoom has been deprecated. Use .enableZoom instead.' ); return ! this.enableZoom; }, set: function ( value ) { console.warn( 'THREE.OrbitControls: .noZoom has been deprecated. Use .enableZoom instead.' ); this.enableZoom = ! value; } }, noRotate: { get: function () { console.warn( 'THREE.OrbitControls: .noRotate has been deprecated. Use .enableRotate instead.' ); return ! this.enableRotate; }, set: function ( value ) { console.warn( 'THREE.OrbitControls: .noRotate has been deprecated. Use .enableRotate instead.' ); this.enableRotate = ! value; } }, noPan: { get: function () { console.warn( 'THREE.OrbitControls: .noPan has been deprecated. Use .enablePan instead.' ); return ! this.enablePan; }, set: function ( value ) { console.warn( 'THREE.OrbitControls: .noPan has been deprecated. Use .enablePan instead.' ); this.enablePan = ! value; } }, noKeys: { get: function () { console.warn( 'THREE.OrbitControls: .noKeys has been deprecated. Use .enableKeys instead.' ); return ! this.enableKeys; }, set: function ( value ) { console.warn( 'THREE.OrbitControls: .noKeys has been deprecated. Use .enableKeys instead.' ); this.enableKeys = ! value; } }, staticMoving: { get: function () { console.warn( 'THREE.OrbitControls: .staticMoving has been deprecated. Use .enableDamping instead.' ); return ! this.enableDamping; }, set: function ( value ) { console.warn( 'THREE.OrbitControls: .staticMoving has been deprecated. Use .enableDamping instead.' ); this.enableDamping = ! value; } }, dynamicDampingFactor: { get: function () { console.warn( 'THREE.OrbitControls: .dynamicDampingFactor has been renamed. Use .dampingFactor instead.' ); return this.dampingFactor; }, set: function ( value ) { console.warn( 'THREE.OrbitControls: .dynamicDampingFactor has been renamed. Use .dampingFactor instead.' ); this.dampingFactor = value; } } } );","categories":[],"tags":[]},{"title":"","slug":"Three.js移动DecalGeometry/js/DecalGeometry","date":"2019-03-17T10:06:35.705Z","updated":"2019-03-17T10:06:35.705Z","comments":true,"path":"2019/03/17/cjtcra7jn000bh1l3ietiaews/","link":"","permalink":"http://www.zcating.tk/2019/03/17/cjtcra7jn000bh1l3ietiaews/","excerpt":"","text":"/** * @author Mugen87 / https://github.com/Mugen87 * @author spite / https://github.com/spite * * You can use this geometry to create a decal mesh, that serves different kinds of purposes. * e.g. adding unique details to models, performing dynamic visual environmental changes or covering seams. * * Constructor parameter: * * mesh — Any mesh object * position — Position of the decal projector * orientation — Orientation of the decal projector * size — Size of the decal projector * * reference: http://blog.wolfire.com/2009/06/how-to-project-decals/ * */ ( function () { function DecalGeometry( mesh, position, orientation, size ) { THREE.BufferGeometry.call( this ); // buffers var vertices = []; var normals = []; var uvs = []; // helpers var plane = new THREE.Vector3(); // this matrix represents the transformation of the decal projector var projectorMatrix = new THREE.Matrix4(); projectorMatrix.makeRotationFromEuler( orientation ); projectorMatrix.setPosition( position ); var projectorMatrixInverse = new THREE.Matrix4().getInverse( projectorMatrix ); // generate buffers generate(); // build geometry this.addAttribute( 'position', new THREE.Float32BufferAttribute( vertices, 3 ) ); this.addAttribute( 'normal', new THREE.Float32BufferAttribute( normals, 3 ) ); this.addAttribute( 'uv', new THREE.Float32BufferAttribute( uvs, 2 ) ); function generate() { var i; var geometry = new THREE.BufferGeometry(); var decalVertices = []; var vertex = new THREE.Vector3(); var normal = new THREE.Vector3(); // handle different geometry types if ( mesh.geometry.isGeometry ) { geometry.fromGeometry( mesh.geometry ); } else { geometry.copy( mesh.geometry ); } var positionAttribute = geometry.attributes.position; var normalAttribute = geometry.attributes.normal; // first, create an array of 'DecalVertex' objects // three consecutive 'DecalVertex' objects represent a single face // // this data structure will be later used to perform the clipping if ( geometry.index !== null ) { // indexed BufferGeometry var index = geometry.index; for ( i = 0; i < index.count; i ++ ) { vertex.fromBufferAttribute( positionAttribute, index.getX( i ) ); normal.fromBufferAttribute( normalAttribute, index.getX( i ) ); pushDecalVertex( decalVertices, vertex, normal ); } } else { // non-indexed BufferGeometry for ( i = 0; i < positionAttribute.count; i ++ ) { vertex.fromBufferAttribute( positionAttribute, i ); normal.fromBufferAttribute( normalAttribute, i ); pushDecalVertex( decalVertices, vertex, normal ); } } // second, clip the geometry so that it doesn't extend out from the projector decalVertices = clipGeometry( decalVertices, plane.set( 1, 0, 0 ) ); decalVertices = clipGeometry( decalVertices, plane.set( - 1, 0, 0 ) ); decalVertices = clipGeometry( decalVertices, plane.set( 0, 1, 0 ) ); decalVertices = clipGeometry( decalVertices, plane.set( 0, - 1, 0 ) ); decalVertices = clipGeometry( decalVertices, plane.set( 0, 0, 1 ) ); decalVertices = clipGeometry( decalVertices, plane.set( 0, 0, - 1 ) ); // third, generate final vertices, normals and uvs for ( i = 0; i < decalVertices.length; i ++ ) { var decalVertex = decalVertices[ i ]; // create texture coordinates (we are still in projector space) uvs.push( 0.5 + ( decalVertex.position.x / size.x ), 0.5 + ( decalVertex.position.y / size.y ) ); // transform the vertex back to world space decalVertex.position.applyMatrix4( projectorMatrix ); // now create vertex and normal buffer data vertices.push( decalVertex.position.x, decalVertex.position.y, decalVertex.position.z ); normals.push( decalVertex.normal.x, decalVertex.normal.y, decalVertex.normal.z ); } } function pushDecalVertex( decalVertices, vertex, normal ) { // transform the vertex to world space, then to projector space vertex.applyMatrix4( mesh.matrixWorld ); vertex.applyMatrix4( projectorMatrixInverse ); decalVertices.push( new DecalVertex( vertex.clone(), normal.clone() ) ); } function clipGeometry( inVertices, plane ) { var outVertices = []; var s = 0.5 * Math.abs( size.dot( plane ) ); // a single iteration clips one face, // which consists of three consecutive 'DecalVertex' objects for ( var i = 0; i < inVertices.length; i += 3 ) { var v1Out, v2Out, v3Out, total = 0; var nV1, nV2, nV3, nV4; var d1 = inVertices[ i + 0 ].position.dot( plane ) - s; var d2 = inVertices[ i + 1 ].position.dot( plane ) - s; var d3 = inVertices[ i + 2 ].position.dot( plane ) - s; v1Out = d1 > 0; v2Out = d2 > 0; v3Out = d3 > 0; // calculate, how many vertices of the face lie outside of the clipping plane total = ( v1Out ? 1 : 0 ) + ( v2Out ? 1 : 0 ) + ( v3Out ? 1 : 0 ); switch ( total ) { case 0: { // the entire face lies inside of the plane, no clipping needed outVertices.push( inVertices[ i ] ); outVertices.push( inVertices[ i + 1 ] ); outVertices.push( inVertices[ i + 2 ] ); break; } case 1: { // one vertex lies outside of the plane, perform clipping if ( v1Out ) { nV1 = inVertices[ i + 1 ]; nV2 = inVertices[ i + 2 ]; nV3 = clip( inVertices[ i ], nV1, plane, s ); nV4 = clip( inVertices[ i ], nV2, plane, s ); } if ( v2Out ) { nV1 = inVertices[ i ]; nV2 = inVertices[ i + 2 ]; nV3 = clip( inVertices[ i + 1 ], nV1, plane, s ); nV4 = clip( inVertices[ i + 1 ], nV2, plane, s ); outVertices.push( nV3 ); outVertices.push( nV2.clone() ); outVertices.push( nV1.clone() ); outVertices.push( nV2.clone() ); outVertices.push( nV3.clone() ); outVertices.push( nV4 ); break; } if ( v3Out ) { nV1 = inVertices[ i ]; nV2 = inVertices[ i + 1 ]; nV3 = clip( inVertices[ i + 2 ], nV1, plane, s ); nV4 = clip( inVertices[ i + 2 ], nV2, plane, s ); } outVertices.push( nV1.clone() ); outVertices.push( nV2.clone() ); outVertices.push( nV3 ); outVertices.push( nV4 ); outVertices.push( nV3.clone() ); outVertices.push( nV2.clone() ); break; } case 2: { // two vertices lies outside of the plane, perform clipping if ( ! v1Out ) { nV1 = inVertices[ i ].clone(); nV2 = clip( nV1, inVertices[ i + 1 ], plane, s ); nV3 = clip( nV1, inVertices[ i + 2 ], plane, s ); outVertices.push( nV1 ); outVertices.push( nV2 ); outVertices.push( nV3 ); } if ( ! v2Out ) { nV1 = inVertices[ i + 1 ].clone(); nV2 = clip( nV1, inVertices[ i + 2 ], plane, s ); nV3 = clip( nV1, inVertices[ i ], plane, s ); outVertices.push( nV1 ); outVertices.push( nV2 ); outVertices.push( nV3 ); } if ( ! v3Out ) { nV1 = inVertices[ i + 2 ].clone(); nV2 = clip( nV1, inVertices[ i ], plane, s ); nV3 = clip( nV1, inVertices[ i + 1 ], plane, s ); outVertices.push( nV1 ); outVertices.push( nV2 ); outVertices.push( nV3 ); } break; } case 3: { // the entire face lies outside of the plane, so let's discard the corresponding vertices break; } } } return outVertices; } function clip( v0, v1, p, s ) { var d0 = v0.position.dot( p ) - s; var d1 = v1.position.dot( p ) - s; var s0 = d0 / ( d0 - d1 ); var v = new DecalVertex( new THREE.Vector3( v0.position.x + s0 * ( v1.position.x - v0.position.x ), v0.position.y + s0 * ( v1.position.y - v0.position.y ), v0.position.z + s0 * ( v1.position.z - v0.position.z ) ), new THREE.Vector3( v0.normal.x + s0 * ( v1.normal.x - v0.normal.x ), v0.normal.y + s0 * ( v1.normal.y - v0.normal.y ), v0.normal.z + s0 * ( v1.normal.z - v0.normal.z ) ) ); // need to clip more values (texture coordinates)? do it this way: // intersectpoint.value = a.value + s * ( b.value - a.value ); return v; } } DecalGeometry.prototype = Object.create( THREE.BufferGeometry.prototype ); DecalGeometry.prototype.constructor = DecalGeometry; // helper function DecalVertex( position, normal ) { this.position = position; this.normal = normal; } DecalVertex.prototype.clone = function () { return new DecalVertex( this.position.clone(), this.normal.clone() ); }; // export THREE.DecalGeometry = DecalGeometry; } )();","categories":[],"tags":[]},{"title":"前端小知识","slug":"前端小知识","date":"2019-03-16T09:43:50.019Z","updated":"2019-03-16T09:43:50.019Z","comments":true,"path":"2019/03/16/cjtb4lmja00005gl3r59k9f05/","link":"","permalink":"http://www.zcating.tk/2019/03/16/cjtb4lmja00005gl3r59k9f05/","excerpt":"本篇是为了记录开发中遇到的一些知识性的东西。","text":"本篇是为了记录开发中遇到的一些知识性的东西。 JS this全局环境下首先要确定是否this的环境，如果所在环境是全局，那么就要分不同的运行环境： 浏览器下，window === this。 nodejs环境下，global === this。 函数环境下普通调用分为严格模式和非严格模式， 非严格模式：如果直接在函数中调用this会直接触发全局变量。 1234function hello() &#123; console.log(this);&#125;hello(); // window 或 global 严格模式： 1234function hello() &#123; console.log(this);&#125;hello(); // undefined 在对象内部调用这种情况比较多，一般就是作为对象的实例来调用，以下两个是最基本的做法： 1234567891011121314151617// 构造函数function Person(name) &#123; this.name = name;&#125; var person = new Person('Tony');console.log(person.name); // Tony// 作为对象的函数function Swim() &#123; console.log(this.name + ' is swimming...');&#125;var duck = &#123; name: 'penny', swim: Swim&#125;duck.swim(); // penny is swimming... 当你想通过外部传递this来调用该函数的时候，那么你应该使用call和apply： 12345678function walk() &#123; console.log(this.name + ' is walking...');&#125;var student = &#123;name: 'Jenny'&#125;;walk(); // Uncaught TypeError: Cannot read property 'name' of undefined.walk.call(student); // 'Jenny is walking...'walk.apply(student); // 'Jenny is walking...' 更进一步的，可以调用bind()，将外部对象绑定到这个函数对象的拷贝中，使得这个函数对象拷贝的内部的this指向这个对象： 1var walkWithStudent = walk.bind(student); 函数表达式和函数声明式区别函数表达式是以下这种情况： 123var personWalks = function() &#123; console.log('walking')&#125; 函数定义式是以下这种形式： 123function personRuns () &#123; console.log('running');&#125; 这俩唯一的区别就是在于他们的作用域，当我们在函数表达式定义前调用表达式的变量，那么会有以下这种情况发生： 123456// Uncaught ReferenceError: personWalk is not definedpersonWalk();var personWalks = function() &#123; console.log('walking')&#125; 当我们在函数声明式定义前调用声明式的声明，那么不会报错： 123456// works.personRuns();function personRuns () &#123; console.log('running');&#125; JS Function关于函数原型中的apply, call, bind的理解。 首先是call和apply：它的作用是调用一个具有给定this值的函数，意思就是，如果这个函数里面有this，那么会将this绑定到call或apply的第一个参数上，然后再调用这个函数。但是两个不同的地方在于，如果这个函数有参数，那么call提供的是一个参数列表，而apply提供的是一个数组。举例： 12345678function drive(isNew) &#123; var adj = isNew ? 'New ' : 'Old '; console.log(adj + this.name + ' is driving...');&#125;var man = &#123;name: 'Tom'&#125;;drive.call(man, true); // New Tom is driving...drive.apply(man, [false]); // Old Tom is driving... bind的作用将对象与函数的this绑定，然后返回一个已经绑定了这个对象的新的函数对象，也就是，这个新的函数内部的this是指向这个对象的。 1234567function drive(isNew) &#123; var adj = isNew ? 'New ' : 'Old '; console.log(adj + this.name + ' is driving...');&#125;var man = &#123;name: 'Tom'&#125;;drive.bind(man)(true); // New Tom is driving... JS new假设你定义了一个SomeObject对象new SomeObject()来创建对象实例的时候，根据标准，会做如下事情： 继承SomeObject.prototype的一个新对象实例会被创建。 使用指定的参数调用构造函数SomeObject()，并将this绑定到新创建的对象。 构造函数返回的对象就是new的结果，如果构造函数没有返回一个对象，那么就用步骤一中生成的对象。 用伪代码表示： 1234567891011121314function SomeObject (name) &#123; this.name = name;&#125;var construct = function (name) &#123; var object = &#123;&#125;; // 继承 object.__proto__ = SomeObject.prototype; var result = SomeObject.call(object, name); return typeof result === 'object' ? result : object;&#125;; JS 继承根据JavaScript ES5的语法，创建一个类，是这样做的。 1234567891011function Person() &#123; this.stand = function() &#123; console.log(\"standing\"); &#125;&#125;Person.prototype.walk = function() &#123; console.log(\"walking\");&#125;var person = new Person();person.walk(); // walkingperson.stand(); // standing 然后，如果你想继承，可以这样： 1234567891011121314function Student() &#123; Person.call(); this.study = function() &#123; console.log('studing'); &#125;&#125;Student.prototype = Object.create(Person.prototype);Student.prototype.constructor = Person;// 这样 Student 就能调用Person的成员函数了..var student = new Student();student.study(); // studingstudent.stand(); // standingstudent.walk(); // walking 以上那一堆prototype的玩意儿就是一个叫原型链的东西。 如果用ES6写继承，是这样的： 123456789101112131415161718class Pet &#123; constructor(id) &#123; this.id = id; &#125; walk() &#123; console.log('walking'); &#125;&#125;class Dog extends Pet &#123; constructor(id) &#123; super(id); this.type = 'dog'; &#125; bark() &#123; console.log('wooooooof!'); &#125;&#125; 是的，继承的时候就不用写原型链这玩意了。 == 和 ===首先一点肯定是建议使用===。 ===：严格相等，直接比较两个对象的值和类型，都一样才返回真。 ==：抽象相等，会对对象进行类型转换，然后再进行比较。 至于真值表，我觉得没必要记吧。 ES6 …(扩展运算符)扩展运算符有以下几种用法： 函数的可变参数12345678910let array = [];function pushAll(...items) &#123; array.push(...items);&#125;function traverse(...items) &#123; for(let i = 0; i &lt; items.length; i++) &#123; console.log(items[i]); &#125;&#125; 数组合并1234567let numbers1 = [1, 2, 3];let numbers2 = [4, 5, 6];let newNumbers = [7, 8, 9];newNumbers = [...newNumbers, ...numbers1, ...numbers2];console.log(newNumbers); // [7, 8, 9, 1, 2, 3, 4, 5, 6] 函数参数映射123456function sum(x, y, z) &#123; console.log(x+y+z);&#125;let array = [1, 2, 3];log(...array); // 6 Object.assign1234let person = &#123;walk:'walking', call:'calling'&#125;let student = &#123;study: 'studing', ...person&#125;console.log(student); // &#123;study: \"studing\", walk: \"walking\", call: \"calling\"&#125; 将各种迭代器转数组12345678910111213let string = 'hello';console.log([...string]); // [\"h\", \"e\", \"l\", \"l\", \"o\"]// 自定义迭代器也是可以的：let mystring = &#123;&#125;;mystring[Symbol.iterator] = function* () &#123; yield 'h'; yield 'e'; yield 'l'; yield 'l'; yield 'o';&#125;console.log([...mystring]); // [\"h\", \"e\", \"l\", \"l\", \"o\"] ES6 Generator（生成器）生成器主要的作用是封装了一套左闭右开的迭代器，避免自定义维护。123456789101112function* numbers() &#123; yield 1; yield 2; yield 3;&#125;let generator = numbers();console.log(generator.next()); // &#123;value: 1, done: false&#125;console.log(generator.next()); // &#123;value: 2, done: false&#125;console.log(generator.next()); // &#123;value: 3, done: false&#125;console.log(generator.next()); // &#123;value: undefined, done: true&#125; 可以看到generator.next()返回了一个对象：{value: Any, done: Boolean}。 value表示每个yield后面的对象或者是函数返回值； done表示是否执行到最末尾； 其他需要注意的地方 yield* 代表返回后面迭代器中的迭代值，考虑下面代码： 12345678910111213141516function* numbers() &#123; yield 1; yield* [2, 3, 4, 5]; yield 6;&#125;const generator = numbers();console.log(generator.next()); // &#123;value: 1, done: false&#125;console.log(generator.next()); // &#123;value: 2, done: false&#125;console.log(generator.next()); // &#123;value: 3, done: false&#125;console.log(generator.next()); // &#123;value: 4, done: false&#125;console.log(generator.next()); // &#123;value: 5, done: false&#125;console.log(generator.next()); // &#123;value: 6, done: false&#125;console.log(generator.next()); // &#123;value: undefined, done: true&#125;// 也就是说，这个关键字会对其后面的参数（迭代器）进行遍历。 在成员函数next(value:Any)中，它是包含了一个value，这个value将作为yield结束后的返回值，考虑以下代码： 123456789101112131415161718function* numbers() &#123; const x = yield 1; const y = yield x + 1; const z = yield 10 / y;&#125;const generator = numbers();console.log(generator.next(9)); // &#123;value: 1, done: false&#125;// x = 9console.log(generator.next(10)); // &#123;value: 10, done: false&#125;// y = 1console.log(generator.next(1)); // &#123;value: 10, done: false&#125;// z = 99console.log(generator.next(99)); // &#123;value: undefined, done: true&#125;// yield 结束后的返回值，意思就是在生成器中，yield的返回值。 ES6 async/await 关键字有了生成器，那么就可以结合Promise，以同步的方式写异步代码。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778// 假设我们去参加铁人三项，我们必须完成每一项之后，才能继续下一项// 定义游泳function startSwimming() &#123; return new Promise(function (resolve) &#123; console.log('Start swimming..'); setTimeout(function () &#123; console.log('Finish swimming..'); resolve(&#123;type: 'swim'&#125;); &#125;, 500); &#125;);&#125;// 定义自行车function startBiking(swimming) &#123; if (swimming.type !== 'swim') &#123; return &#123;type: 'none'&#125;; &#125; return new Promise(function (resolve) &#123; console.log('Start biking..'); setTimeout(function () &#123; console.log('Finish biking..'); resolve(&#123;type: 'bike'&#125;); &#125;, 1000); &#125;);&#125;// 定义马拉松function startMarathon(biking) &#123; if (biking.type !== 'bike') &#123; return &#123;type: 'none'&#125;; &#125; return new Promise(function (resolve) &#123; console.log('Start running..'); setTimeout(function () &#123; console.log('Finish running..'); resolve(&#123;type: 'marathon'&#125;); &#125;, 2000); &#125;);&#125;// 主要看这里，这里是我们的铁人三项生成器function* TriathlonGenerator() &#123; console.log('Welcome to join Triathlon!'); // 游泳 const swimming = yield startSwimming(); console.log(swimming); // 自行车 const biking = yield startBiking(swimming); console.log(biking); // 马拉松 const running = yield startMarathon(biking); console.log(running); if (running &amp;&amp; running.type === 'marathon') &#123; console.log('finish all item..'); &#125; return running;&#125;// 运行我们特定的生成器的函数function doTriathlon(TriathlonGenerator) &#123; const triathlonIter = TriathlonGenerator(); // 这里是递归操作，目的是为了是生成的迭代器能够按顺序执行。 function doing(argument) &#123; const info = triathlonIter.next(argument); console.log(info.value); if (info.done) &#123; return info.value; &#125; else &#123; return Promise.resolve(info.value).then(function (value) &#123; doing(value); &#125;); &#125; &#125; return doing();&#125;doTriathlon(TriathlonGenerator); 那么，以上代码中关于生成器的部分代码可以约等于以下代码： 123456789101112131415161718192021// 主要看这里，这里是我们的铁人三项生成器，async function doTriathlonAsync() &#123; console.log('Welcome to join Triathlon!'); // 游泳 const swimming = await startSwimming(); console.log(swimming); // 自行车 const biking = await startBiking(swimming); console.log(biking); // 马拉松 const running = await startMarathon(biking); console.log(running); if (running &amp;&amp; running.type === 'marathon') &#123; console.log('finish all item..'); &#125; return running;&#125;doTriathlonAsync();","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://www.zcating.tk/categories/JavaScript/"}],"tags":[]},{"title":"OpenGL shader 测试","slug":"OpenGL-测试","date":"2019-03-10T11:00:00.000Z","updated":"2019-03-16T10:03:25.408Z","comments":true,"path":"2019/03/10/cjt4fboc7000077l3p2r1dj3x/","link":"","permalink":"http://www.zcating.tk/2019/03/10/cjt4fboc7000077l3p2r1dj3x/","excerpt":"里面包含了一些OpenGL shader的测试代码，由于WebGL的shader代码跟OpenGL ES2类似，所以可以直接用OpenGL的shader代码来渲染，效果也是类似的。","text":"里面包含了一些OpenGL shader的测试代码，由于WebGL的shader代码跟OpenGL ES2类似，所以可以直接用OpenGL的shader代码来渲染，效果也是类似的。 #opengl-container { width: 300px; height: 300px; } #shader-editor { flex: 1; margin-right: 10px; font-size: 16px; } .opengl-items { display: flex; } .error-message-text { } void main() { gl_Position = vec4( position, 1.0 ); } #ifdef GL_ES precision mediump float; #endif uniform vec2 u_resolution; uniform float u_time; // Plot a line on Y using a value between 0.0 - 1.0 float plot(vec2 standard, float pct) { return smoothstep(pct - 0.005, pct, standard.y) - smoothstep(pct, pct + 0.005, standard.y); } void main() { vec2 standard = gl_FragCoord.xy/u_resolution; float y = standard.x; float pct = plot(standard, y); vec3 color = (vec3(1.0) - pct) + pct * vec3(0.0, 0.0, 0.0); gl_FragColor = vec4(color, 1.0); } #ifdef GL_ES precision mediump float; #endif uniform vec2 u_resolution; uniform float u_time; // Plot a line on Y using a value between 0.0 - 1.0 float plot(vec2 standard, float pct) { return smoothstep(pct - 0.005, pct, standard.y) - smoothstep(pct, pct + 0.005, standard.y); } void main() { vec2 standard = gl_FragCoord.xy / u_resolution ; standard.x *= u_resolution.x / u_resolution.y; float alpha = 1.0; float y = cos(alpha * standard.x + u_time); y = 0.5*y + 0.5; float pct = plot(standard, y); vec3 color = (vec3(1.0) - pct) + pct * vec3(0.0, 0.0, 0.0); gl_FragColor = vec4(color, 1.0); } #ifdef GL_ES precision mediump float; #endif uniform vec2 u_resolution; uniform vec2 u_mouse; uniform float u_time; float circle(in vec2 standard, in float radius) { vec2 dist = standard - vec2(0.5); return 1. - smoothstep(radius - (radius * 0.01), radius + (radius * 0.01), dot(dist, dist) * 4.0); } void main(){ vec2 standard = gl_FragCoord.xy / u_resolution ; vec2 translate = vec2(cos(u_time),sin(u_time)); standard += translate * 0.3; vec3 color = vec3(circle(standard, 0.1)); gl_FragColor = vec4( color, 1.0 ); } function GLCanvas(containerId, fragmentShaderText) { var scope = this; this.container = document.getElementById(containerId); this.camera = new THREE.Camera(); this.camera.position.z = 1; this.scene = new THREE.Scene(); this.uniforms = { u_time: { type: \"f\", value: 1.0 }, u_resolution: { type: \"v2\", value: new THREE.Vector2() } }; this.material = new THREE.ShaderMaterial( { uniforms: this.uniforms, vertexShader: document.getElementById( 'vertexShader' ).textContent, fragmentShader: fragmentShaderText }); var geometry = new THREE.PlaneBufferGeometry( 10, 10 ); var mesh = new THREE.Mesh( geometry, this.material ); this.scene.add( mesh ); this.renderer = new THREE.WebGLRenderer(); this.renderer.setPixelRatio( window.devicePixelRatio ); this.container.appendChild( this.renderer.domElement ); this.onWindowResize = function ( event ) { scope.renderer.setSize( scope.container.offsetWidth, scope.container.offsetHeight ); scope.uniforms.u_resolution.value.x = scope.renderer.domElement.width; scope.uniforms.u_resolution.value.y = scope.renderer.domElement.height; } this.animate = function() { requestAnimationFrame( scope.animate ); scope.render(); } this.render = function() { scope.uniforms.u_time.value += 0.05; scope.renderer.render( scope.scene, scope.camera ); } this.onWindowResize(); window.addEventListener( 'resize', this.onWindowResize, false ); this.animate(); } function ShaderEditor (viewId, containerId) { var scope = this; this.editor = ace.edit(viewId); this.editor.resize(true); this.editorDom = document.getElementById(viewId); this.editorDom.style.height = this.editor.getSession().getScreenLength() * (this.editor.renderer.lineHeight + 2) + 'px'; this.canvas = new GLCanvas(containerId, this.editor.getValue()); this.editor.getSession().setUseWrapMode(true); this.editor.setAutoScrollEditorIntoView(true) ; this.editor.getSession().on('change', function (event) { scope.canvas.material.fragmentShader = scope.editor.getValue(); scope.canvas.material.needsUpdate = true; var newHeight = scope.editor.getSession().getScreenLength() * scope.editor.renderer.lineHeight; scope.editorDom.style.height = newHeight + 'px'; scope.editor.resize(); }); this.changeText = function (text) { scope.editor.setValue(text); scope.editor.clearSelection(); } } .selectors { display: flex; flex-wrap: wrap; flex-direction: row; margin-bottom: 10px; } .selectors>.title { line-height:30px; } .selectors>.selector { display: flex; flex-direction: row; align-items: center; margin: 0 10px; } 方程: 直线 三角函数 圆形 #ifdef GL_ES precision mediump float; #endif uniform vec2 u_resolution; uniform float u_time; // Plot a line on Y using a value between 0.0 - 1.0 float plot(vec2 standard, float pct) { return smoothstep(pct - 0.005, pct, standard.y) - smoothstep(pct, pct + 0.005, standard.y); } void main() { vec2 standard = gl_FragCoord.xy/u_resolution; float y = standard.x; float pct = plot(standard, y); vec3 color = (vec3(1.0) - pct) + pct * vec3(0.0, 0.0, 0.0); gl_FragColor = vec4(color, 1.0); } $(document).ready(function () { var shaderEditor = new ShaderEditor('shader-editor', 'opengl-container'); $('.selector input[name=equation]').change(function () { if (this.value === '1') { shaderEditor.changeText(document.getElementById('LineShader').textContent); } else if (this.value === '2') { shaderEditor.changeText(document.getElementById('TriangleFunctionShader').textContent); } else if (this.value === '3') { shaderEditor.changeText(document.getElementById('CircularShader').textContent); } }); })","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://www.zcating.tk/categories/JavaScript/"},{"name":"OpenGL","slug":"JavaScript/OpenGL","permalink":"http://www.zcating.tk/categories/JavaScript/OpenGL/"}],"tags":[]},{"title":"flex布局测试","slug":"flex布局测试","date":"2019-03-09T11:00:00.000Z","updated":"2019-03-12T11:33:02.303Z","comments":true,"path":"2019/03/09/cjt2znude000k81l3g8rawzd1/","link":"","permalink":"http://www.zcating.tk/2019/03/09/cjt2znude000k81l3g8rawzd1/","excerpt":"一个简单的flex布局测试。","text":"一个简单的flex布局测试。 var isMobile = null; var isPC = null; var isWechat = null; $(document).ready(function () { isMobile = !!navigator.userAgent.match(/AppleWebKit.*Mobile.*/); isWechat = !!navigator.userAgent.match(/MicroMessenger/); if (isMobile || isWechat) { $('.flex-test').css('width', '300px'); } }); .auto-widget { width: 100px; height: auto; color: #fff; } .small-widget { width:50px; height:50px; color:#fff; flex-shrink: 0; } .mid-widget { width:100px; height:100px; color:#fff; flex-shrink: 0; } .big-widget { line-height: 200px; width:200px; height:200px; color:#fff; } .sun { background-size: cover; background-image:url(./Sun.jpg); } .earth { background-size: cover; background-image:url(./Earth.jpg); } .mars { background-size: cover; background-image:url(./Mars.jpg); } .moon { background-size: cover; background-image:url(./Moon.jpg); } .neptune { background-size: cover; background-image:url(./Neptune.jpg); } .saturn { background-size: cover; background-image:url(./Saturn.jpg); } .uranus { background-size: cover; background-image:url(./Uranus.jpg); } .selectors { display: flex; flex-wrap: wrap; flex-direction: row; margin-bottom: 10px; } .selectors>.title { line-height:30px; } .selectors>.selector { display: flex; flex-direction: row; align-items: center; margin: 0 10px; } .flex-test { width: 500px; height:400px; display: flex; flex-direction: row; overflow: auto; border: 1px solid #000000; } .flex-test img { transition: .2s; } .flex-test div { transition: .2s; } .slider { -webkit-appearance: none; appearance: none; width: 300px; height: 20px; background: #d3d3d3; outline: none; opacity: 0.7; -webkit-transition: .2s; transition: opacity .2s; } .slider:hover { opacity: 1; } .slider::-webkit-slider-thumb { -webkit-appearance: none; appearance: none; width: 20px; height: 20px; background: blue; cursor: pointer; } .slider::-moz-range-thumb { width: 20px; height: 20px; background: blue; cursor: pointer; } 容器属性flex-direction $(document).ready(function () { $('input[type=radio][name=flex-direction-selector]').change(function() { $('.body1>.flex-test').first().css('flex-direction', this.value); }); }); flex-direction: row column row-reverse column-reverse flex-wrap $(document).ready(function () { $('input[type=radio][name=flex-wrap-selector]').change(function() { $('.body2>.flex-test').first().css('flex-wrap', this.value); }); }); flex-wrap: nowrap wrap wrap-reverse justify-content $(document).ready(function () { $('input[type=radio][name=flex-justify-content-selector]').change(function() { $('.body3>.flex-test').first().css('justify-content', this.value); }); }); justify-content: flex-start flex-end center space-between space-around align-items $(document).ready(function () { $('.body4 input[type=radio][name=flex-align-items-selector]').change(function() { $('.body4>.flex-test').first().css('align-items', this.value); }); }); align-items: stretch flex-start flex-end center baseline Sun Earth Mars align-content $(document).ready(function () { $('input[type=radio][name=flex-wrap-align-content-selector]').change(function() { $('.body5>.flex-test').first().css('flex-wrap', this.value); }); $('input[type=radio][name=flex-align-content-selector]').change(function() { $('.body5>.flex-test').first().css('align-content', this.value); }); }); flex-wrap: nowrap wrap wrap-reverse align-content: stretch flex-start flex-end center space-between space-around 项目属性order $(document).ready(function () { $('input[type=radio][name=flex-order-selector]').prop({disabled: true}); $('.body6>.flex-test>div').click(function() { $('input[type=radio][name=flex-order-selector]').prop({disabled: false}); $('.body6>.flex-test>div.active').removeClass('active'); $(this).addClass('active'); var value = $(this).css('order'); $('input[type=radio][name=flex-order-selector][value=' + (value || 0) + ']').prop('checked', true); }); $('input[type=radio][name=flex-order-selector]').change(function() { var active = $('.body6>.flex-test>div.active'); active.css('order', this.value); active.text(this.value); }); }); order: 0 1 2 3 4 5 6 7 8 0 0 0 0 0 0 0 .body6>.flex-test { flex-wrap: wrap; } .body6>.flex-test>div.active { margin: 0 10px; border: 2px solid red; } flex-grow $(document).ready(function () { $('input[type=radio][name=flex-grow-selector]').prop({disabled: true}); $('.body7>.flex-test>div').click(function() { $('input[type=radio][name=flex-grow-selector]').prop({disabled: false}); $('.body7>.flex-test>div.active').removeClass('active'); $(this).addClass('active'); var value = $(this).css('flex-grow'); $('input[type=radio][name=flex-grow-selector][value=' + (value || 0) + ']').prop('checked', true); }); $('input[type=radio][name=flex-grow-selector]').change(function() { var active = $('.body7>.flex-test>div.active'); active.css('flex-grow', this.value); active.text(this.value); }); }); grow: 0 1 2 3 4 5 6 7 8 0 0 0 .body7>.flex-test { flex-wrap: wrap; } .body7>.flex-test>div.active { border: 2px solid red; } flex-shrink $(document).ready(function () { $('input[type=radio][name=flex-grow-selector]').prop({disabled: true}); $('.body8>.flex-test>div').click(function() { $('input[type=radio][name=flex-shrink-selector]').prop({disabled: false}); $('.body8>.flex-test>div.active').removeClass('active'); $(this).addClass('active'); var value = $(this).css('flex-shrink'); $('input[type=radio][name=flex-shrink-selector][value=' + (value || 0) + ']').prop('checked', true); }); $('input[type=radio][name=flex-shrink-selector]').change(function() { var active = $('.body8>.flex-test>div.active'); active.css('flex-shrink', this.value); active.text(this.value); }); }); shrink: 0 1 2 3 4 5 6 7 8 1 1 1 1 1 1 1 .body8>.flex-test>div { flex-shrink: 1; } .body8>.flex-test>div.active { border: 2px solid red; } flex-basis $(document).ready(function () { $('input[type=range]').prop({disabled: true}); $('.body9>.flex-test>div').click(function() { $('input[type=range]').prop({disabled: false}); $('.body9>.flex-test>div').removeClass('active'); $(this).addClass('active'); var value = $(this).css('flex-basis'); value = 'auto' ? '50px' : value; $(this).css('flex-basis', value); $('input[type=range]').prop('value', parseInt(value.split('px')[0])); $('#slider-value').text(value); }); $('input[type=range]').on('input', function() { var value = this.value + 'px'; $('#slider-value').text(value); $('.body9>.flex-test>div.active').css('flex-basis', value); }); $('#reset-slider-button').click(function() { $('input[type=range]').prop({disabled: true, value: 50}); $('#slider-value').text('50px'); $('.body9>.flex-test>div').removeClass('active'); $('.body9>.flex-test>div').css('flex-basis', 'auto'); }); }); Reset flex-basis: 50px 1 1 1 1 1 1 1 .body9>.flex-test>div { flex-shrink: 1; } .body9>.flex-test>div.active { border: 2px solid red; } align-selfalign-self的属性有这些： auto（默认） flex-start flex-end center baseline stretch其中auto，跟align-items一样。 $(document).ready(function () { $('input[type=radio][name=flex-align-self-selector]').prop({disabled: true}); $('.body10>.flex-test>div').click(function() { $('input[type=radio][name=flex-align-self-selector]').prop({disabled: false}); $('.body10>.flex-test>div').removeClass('active'); $(this).addClass('active'); var value = $(this).css('align-self'); $('input[type=radio][name=flex-align-self-selector][value=' + value + ']').prop('checked', true); }); $('.body10 input[type=radio][name=flex-align-self-selector]').change(function() { $('.body10>.flex-test>div.active').css('align-self', this.value); }); $('.body10 input[type=radio][name=flex-align-items-selector2]').change(function() { $('.body10>.flex-test').first().css('align-items', this.value); }); }); align-items: stretch flex-start flex-end center baseline align-self: auto flex-start flex-end center baseline stretch Sun Earth Moon Mars Neptune Saturn Uranus .body10>.flex-test>div { flex-shrink: 1; } .body10>.flex-test>div.active { border: 2px solid red; }","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://www.zcating.tk/categories/JavaScript/"}],"tags":[]},{"title":"iOS-用OpenGL渲染相机输出的图像","slug":"iOS-用OpenGL渲染相机输出的图像","date":"2019-03-05T11:00:00.000Z","updated":"2019-03-07T11:31:48.334Z","comments":true,"path":"2019/03/05/cjt2znud8000c81l3t7ucufhl/","link":"","permalink":"http://www.zcating.tk/2019/03/05/cjt2znud8000c81l3t7ucufhl/","excerpt":"相机类相关的类： AVCaptureSession AVCaptureDeviceInput AVCatureDevice AVCaptureDeviceOutput AVCaptureVideoDataOutput","text":"相机类相关的类： AVCaptureSession AVCaptureDeviceInput AVCatureDevice AVCaptureDeviceOutput AVCaptureVideoDataOutput 定义以下properties： 1234@property (nonatomic, strong) AVCaptureSession *session;@property (nonatomic, strong) AVCaptureDeviceInput *frontCameraInput;@property (nonatomic, strong) AVCaptureDeviceInput *backCameraInput;@property (nonatomic, strong) AVCaptureVideoDataOutput *videoOutput; 我们通过session来操作摄像头、摄像头参数以及摄像头数据，使用懒加载初始化session： 123456-(AVCaptureSession *)session &#123; if (_session == nil) &#123; _session = [AVCaptureSession new]; &#125; return _session;&#125; 同样是懒加载初始化设备输入： 123456789101112131415161718192021222324252627282930313233-(AVCaptureDeviceInput *)backCameraInput &#123; if (_backCameraInput == nil) &#123; NSArray *devices = [AVCaptureDevice devicesWithMediaType:AVMediaTypeVideo]; NSError *error; for (AVCaptureDevice *device in devices) &#123; if (device.position == AVCaptureDevicePositionFront) &#123; continue; &#125; _backCameraInput = [AVCaptureDeviceInput deviceInputWithDevice:device error:&amp;error]; if (error) &#123; NSLog(@&quot;[FaceCamera] error: %@&quot;, error.description); &#125; &#125; &#125; return _backCameraInput;&#125;-(AVCaptureDeviceInput *)frontCameraInput &#123; if (_frontCameraInput == nil) &#123; NSArray *devices = [AVCaptureDevice devicesWithMediaType:AVMediaTypeVideo]; NSError *error; for (AVCaptureDevice *device in devices) &#123; if (device.position == AVCaptureDevicePositionBack) &#123; continue; &#125; _frontCameraInput = [AVCaptureDeviceInput deviceInputWithDevice:device error:&amp;error]; if (error) &#123; NSLog(@&quot;[FaceCamera] error: %@&quot;, error.description); &#125; &#125; &#125; return _frontCameraInput;&#125; 因为手机端，只有两个摄像头设备（前置和后置），还可以这样： 1234567891011121314151617181920212223-(AVCaptureDeviceInput *)backCameraInput &#123; if (_backCameraInput == nil) &#123; NSArray *devices = [AVCaptureDevice devicesWithMediaType:AVMediaTypeVideo]; NSError *error; _frontCameraInput = [AVCaptureDeviceInput deviceInputWithDevice:devices[0] error:&amp;error]; if (error) &#123; NSLog(@&quot;[FaceCamera] error: %@&quot;, error.description); &#125; &#125; return _backCameraInput;&#125;-(AVCaptureDeviceInput *)frontCameraInput &#123; if (_frontCameraInput == nil) &#123; NSArray *devices = [AVCaptureDevice devicesWithMediaType:AVMediaTypeVideo]; NSError *error; _frontCameraInput = [AVCaptureDeviceInput deviceInputWithDevice:devices[0] error:&amp;error]; if (error) &#123; NSLog(@&quot;[FaceCamera] error: %@&quot;, error.description); &#125; &#125; return _frontCameraInput;&#125; 然后懒加载视频输出 1234567891011121314-(AVCaptureVideoDataOutput *)videoOutput &#123; if (_videoOutput == nil) &#123; _videoOutput = [AVCaptureVideoDataOutput new]; // 这里的setting可以去看具体的文档 _videoOutput.videoSettings = @&#123; (NSString*)kCVPixelBufferPixelFormatTypeKey: @(kCMPixelFormat_32BGRA) &#125;; // 这里表示，当你处理的这一帧超过一帧的时间，这一帧会做丢失处理 _videoOutput.alwaysDiscardsLateVideoFrames = YES; // 设置输出的委托，并且指定操作队列，这里_videoQueue是自定义的操作队列 [_videoOutput setSampleBufferDelegate:self queue:_videoQueue]; &#125; return _videoOutput;&#125; 将输入输出添加进session： 123456789101112131415161718-(void)updateSession &#123; // 在这里添加主要的输入和输出。 // 摄像头的位置 if (self.devicePosition == AVCaptureDevicePositionFront) &#123; if ([self.session canAddInput:self.frontCameraInput]) &#123; [self.session addInput:self.frontCameraInput]; &#125; &#125; else &#123; if ([self.session canAddInput:self.backCameraInput]) &#123; [self.session addInput:self.backCameraInput]; &#125; &#125; // 摄像头的输出 if ([self.session canAddOutput:self.videoOutput]) &#123; [self.session addOutput:self.videoOutput]; &#125;&#125; 相机启动和关闭相关的函数， 123456789101112131415161718192021222324252627282930313233343536373839404142434445- (void)start &#123; // 如果已经启动，直接返回 if (_running == YES) &#123; return; &#125; // 如果 session 未加载，加载 session if (_sessionLoaded == NO) &#123; [self updateSession]; _sessionLoaded = YES; &#125; // 启动 session [self.session startRunning]; _running = YES;&#125;- (void)stop &#123; // 如果已经关闭，直接返回 if (_running == NO) &#123; return; &#125; // 将所有的输入移除 for (AVCaptureInput *input in self.session.inputs) &#123; [self.session removeInput:input]; &#125; // 将所有的输出移除 for (AVCaptureOutput *output in self.session.outputs) &#123; [self.session removeOutput:output]; &#125; // 停止 session [self.session stopRunning]; _running = NO; // 标记 session 为未加载状态 _sessionLoaded = NO;&#125;-(void)pause &#123; // 普通暂停，只需要直接停止就好 [self.session stopRunning]; _running = NO;&#125; 上面的start和stop非常重要，当你切换摄像头、分辨率或添加其他新的输入输出（比如`AVCaptureMetadataOutput ）的时候，需要这样做： 123456789101112131415161718-(void)switchCameras &#123; // 先保存当前的运行状态 BOOL wasRunning = _running; // 判断当的运行状态 if (wasRunning) &#123; [self stop]; &#125; // 这里是切换摄像头的主要逻辑 // 这里可以换成切换其他的逻辑 if (self.devicePosition == AVCaptureDevicePositionFront) &#123; self.devicePosition = AVCaptureDevicePositionBack; &#125; else &#123; self.devicePosition = AVCaptureDevicePositionFront; &#125; if (wasRunning) &#123; [self start]; &#125;&#125; 编写视频输出的delegate： 1234- (void)captureOutput:(AVCaptureOutput *)output didOutputSampleBuffer:(CMSampleBufferRef)sampleBuffer fromConnection:(AVCaptureConnection *)connection &#123; // 我们将在这里转发这个delegate [self.delegate processFrame:sampleBuffer];&#125; 相机视图类首先，我们要初始化视图： 123456789101112131415161718192021- (id)initWithFrame:(CGRect)frame &#123; self = [super initWithFrame:frame]; if (self) &#123; self.contentScaleFactor = [[UIScreen mainScreen] scale]; self.context = [[EAGLContext alloc] initWithAPI:kEAGLRenderingAPIOpenGLES3]; [EAGLContext setCurrentContext:self.context]; [self setupLayer]; // 可以先忽略 [self setupBuffers]; &#125; return self;&#125;- (void)setupLayer &#123; CAEAGLLayer *eaglLayer = (CAEAGLLayer *)self.layer; eaglLayer.opaque = TRUE; eaglLayer.drawableProperties = @&#123; kEAGLDrawablePropertyRetainedBacking: @(YES), kEAGLDrawablePropertyColorFormat: kEAGLColorFormatRGBA8 &#125;;&#125; 为了能够使用OpenGL来绘制摄像机图像，我们首先需要设定好OpenGL缓冲区： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849enum CameraAttributes &#123; CameraAttributesPosition = 0, CameraAttributesTextureCoordinate = 1,&#125;;- (void)setupBuffers &#123; // 深度测试的目的是为了绘制当前像素组中里屏幕最近的像素。 // 需要绘制透明图层的时候，关闭深度测试，不然透明图层不会透过去。 glDisable(GL_DEPTH_TEST); // 将原色和目标色混合，目的还是用来绘制透明图层。 glEnable(GL_BLEND); // 在图元从远到近的排列下，透明图层的使用以下方法来实现是最佳选择。请注意，此透明度计算不要求alpha位存在于帧缓冲区。 // https://www.khronos.org/registry/OpenGL-Refpages/es2.0/xhtml/glBlendFunc.xml glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA); // 顶点着色的第一个属性。 glEnableVertexAttribArray(CameraAttributesPosition); // 将该属性在CPU和GPU建立上逻辑关系。 glVertexAttribPointer(CameraAttributesPosition, 2, GL_FLOAT, GL_FALSE, 2 * sizeof(GLfloat), 0); // 顶点着色器的第二个属性。 glEnableVertexAttribArray(CameraAttributesTextureCoordinate); // 将该属性在CPU和GPU建立上逻辑关系。 glVertexAttribPointer(CameraAttributesTextureCoordinate, 2, GL_FLOAT, GL_FALSE, 2 * sizeof(GLfloat), 0); // 建立帧缓冲区，并将其绑定到_frameBufferID上，通过_frameBufferID我们可以拿到在OpenGL中的帧缓冲的数据。 glGenFramebuffers(1, &amp;_frameBufferID); glBindFramebuffer(GL_FRAMEBUFFER, _frameBufferID); // 建立渲染缓冲区。 glGenRenderbuffers(1, &amp;_colorBufferID); glBindRenderbuffer(GL_RENDERBUFFER, _colorBufferID); // 将渲染缓冲区 以 GL_COLOR_ATTACHMENT0 的形式绑定到帧缓冲区上。 glFramebufferRenderbuffer(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, GL_RENDERBUFFER, _colorBufferID); // 获取帧缓冲区的状态。 if (glCheckFramebufferStatus(GL_FRAMEBUFFER) != GL_FRAMEBUFFER_COMPLETE) &#123; NSLog(@&quot;Failed to make complete framebuffer object %x&quot;, glCheckFramebufferStatus(GL_FRAMEBUFFER)); &#125; // 将EAGLDrawable的存储绑定到渲染缓冲对象上。 [self.context renderbufferStorage:GL_RENDERBUFFER fromDrawable:(CAEAGLLayer *)self.layer]; // 获取渲染缓冲区的宽高 glGetRenderbufferParameteriv(GL_RENDERBUFFER, GL_RENDERBUFFER_WIDTH, &amp;_renderBufferWidth); glGetRenderbufferParameteriv(GL_RENDERBUFFER, GL_RENDERBUFFER_HEIGHT, &amp;_renderBufferHeight);&#125; 到这里，我们已经设置好了我们的可绘制的图层self.layer，然后我们要将摄像头数据输入到渲染缓冲上，渲染缓冲的数据经过处理后，在上下文会将数据在self.layer中展示，但是在这之前，我们先得编写着色器，通过着色器，摄像头捕捉到的图像数据会在渲染缓冲区中被处理。下面给出一个简单的着色器外覆类，主要的功能是加载顶点着色器和片段着色器，它包含了两个参数，分别是顶点着色器和片段着色器的地址： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100@interface Shader : NSObject@property (nonatomic) GLuint program;@end@implementation Shader- (instancetype)initWithVertexShaderURL:(NSURL *)vertexShaderURL fragmentShaderURL:(NSURL *)fragmentShaderURL &#123; self = [super init]; if (self) &#123; // 编译代码着色器。 GLuint vertexShaderID = [self complieWithType:FCShaderTypeVertex URL:vertexShaderURL]; GLuint fragmentShaderID = [self complieWithType:FCShaderTypeFragment URL:fragmentShaderURL]; // 创建着色器程序，并链接上述的着色器 self.program = glCreateProgram(); glAttachShader(self.program, vertexShaderID); glAttachShader(self.program, fragmentShaderID); glLinkProgram(self.program); GLint status = 0; glGetProgramiv(self.program, GL_LINK_STATUS, &amp;status); if (status == 0) &#123; GLint logLength; glGetProgramiv(self.program, GL_INFO_LOG_LENGTH, &amp;logLength); if (logLength &gt; 0) &#123; GLchar *log = (GLchar *)malloc(logLength); glGetProgramInfoLog(self.program, logLength, &amp;logLength, log); NSLog(@&quot;Program link log: %s&quot;, log); free(log); &#125; &#125; // 链接完毕，program中已经有着色器，将着色器销毁。 if (vertexShaderID) &#123; glDetachShader(self.program, vertexShaderID); glDeleteShader(vertexShaderID); &#125; if (fragmentShaderID) &#123; glDetachShader(self.program, fragmentShaderID); glDeleteShader(fragmentShaderID); &#125; &#125; return self;&#125;#pragma mark - PUBLIC-(void)use &#123; // 运行着色器程序 glUseProgram(self.program);&#125;#pragma mark - PRIVATE// 外覆函数，处理 URL，将URL指向的文件中的代码读取出来。- (GLuint)complieWithType:(ShaderType)type URL:(NSURL *)url &#123; NSError *error; NSString *code = [[NSString alloc] initWithContentsOfURL:url encoding:NSUTF8StringEncoding error:&amp;error]; if (code == nil) &#123; NSLog(@&quot;Failed to load vertex shader: %@&quot;, [error localizedDescription]); return 0; &#125; return [self complieWithType:type code:code];&#125;// 实际操作的函数，直接处理代码- (GLuint)complieWithType:(ShaderType)type code:(NSString *)code &#123; GLenum glType = type == ShaderTypeVertex ? GL_VERTEX_SHADER : GL_FRAGMENT_SHADER; const GLchar* rawCode = [code UTF8String]; // 创建着色器并编译着色器代码。 GLuint shaderID = glCreateShader(glType); glShaderSource(shaderID, 1, &amp;rawCode, NULL); glCompileShader(shaderID); // 一些错误处理。 GLint status = 0; glGetShaderiv(shaderID, GL_COMPILE_STATUS, &amp;status); if (status == 0) &#123; [self showCompileErrorWith:shaderID]; glDeleteShader(shaderID); return 0; &#125; return shaderID;&#125;- (void)showCompileErrorWith:(GLint)shaderID &#123; GLint infoLength; glGetShaderiv(shaderID, GL_INFO_LOG_LENGTH, &amp;infoLength); if (infoLength == 0) &#123; return; &#125; GLchar *info = (GLchar *)malloc(infoLength); glGetShaderInfoLog(shaderID, infoLength, &amp;infoLength, info); NSLog(@&quot;Shader compile log:\\n%s&quot;, info); free(info);&#125;@end 这样，完整的视图构造函数如下： 123456789101112131415- (id)initWithFrame:(CGRect)frame &#123; self = [super initWithFrame:frame]; if (self) &#123; NSURL *vertShaderURL = [[NSBundle mainBundle] URLForResource:@&quot;CameraRGBA&quot; withExtension:@&quot;vsh&quot;]; NSURL *fragShaderURL = [[NSBundle mainBundle] URLForResource:@&quot;CameraRGBA&quot; withExtension:@&quot;fsh&quot;]; _shader = [[Shader alloc] initWithVertexShaderURL:vertShaderURL fragmentShaderURL:fragShaderURL]; self.contentScaleFactor = [[UIScreen mainScreen] scale]; self.context = [[EAGLContext alloc] initWithAPI:kEAGLRenderingAPIOpenGLES3]; [EAGLContext setCurrentContext:self.context]; [self setupLayer]; // 可以先忽略 [self setupBuffers]; &#125; return self;&#125; 这里顶点着色器，片段着色器以及相机的回调将结合在一起编写。为了显示摄像头数据，我们的思路是将相机数据转换成纹理，然后将纹理绑定到指定的点上，先展示顶点数据： 123456789101112131415// 顶点数据GLfloat _imageVertices[8] = &#123; -1, -1, 1, -1, -1, 1, 1, 1&#125;;// Texture 在顶点数据中的位置GLfloat _textureCoordinates[] = &#123; 0, 0, 1, 0, 0, 1, 1, 1&#125;; 画个图，就能明白了： 其中，viewpoint是我们整个渲染的大小，通过这样来设置：glViewport(0, 0, _renderBufferWidth, _renderBufferHeight)。 下面，来处理相机数据，使得数据能够在屏幕上展示。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798- (void)processframe:(CMSampleBufferRef)frame &#123; CVPixelBufferRef pixelBuffer = CMSampleBufferGetImageBuffer(frame); int frameWidth = (int)CVPixelBufferGetWidth(pixelBuffer); int frameHeight = (int)CVPixelBufferGetHeight(pixelBuffer); // 设置全局的EAGLContext为self.context，不设置容易导致渲染失败 if(![[EAGLContext currentContext] isEqual:self.context]) &#123; [EAGLContext setCurrentContext:self.context]; &#125; // 刷新缓存 CVOpenGLESTextureCacheFlush(self.cameraTextureCache, 0); // CVOpenGLESTextureRef cameraTexture; CVReturn err = CVOpenGLESTextureCacheCreateTextureFromImage(kCFAllocatorDefault, self.cameraTextureCache, pixelBuffer, NULL, GL_TEXTURE_2D, GL_RGBA, frameWidth, frameHeight, GL_BGRA, GL_UNSIGNED_BYTE, 0, &amp;cameraTexture); if (err) &#123; NSLog(@&quot;Create Texture Failed: %d&quot;, err); &#125; // 设定渲染屏幕的大小，一个正方形，以左上角为原点，右为x轴正向，下为y轴正向 glViewport(0, 0, _renderBufferWidth, _renderBufferHeight); // 清空当前的缓存值，以便可以渲染下一帧 glClear(GL_COLOR_BUFFER_BIT); // 设置纹理单元 glActiveTexture(GL_TEXTURE0); // 绑定纹理目标(cameraTexture)到指定的纹理单元，该函数会自动把纹理赋给片段着色器上的采样器 glBindTexture(CVOpenGLESTextureGetTarget(cameraTexture), CVOpenGLESTextureGetName(cameraTexture)); // 设定纹理的属性 // 更细节的属性可以查看文档，linear的作用主要是使得渲染出来的图像更为平滑 glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR); glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR); // 设定了GL_CLAMP_TO_EDGE 的纹理会被限制在0到1中，超出的部分会重复纹理坐标边缘的颜色值，产生边缘被拉伸的效果 glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE); glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE); // 绑定帧缓冲区 glBindFramebuffer(GL_FRAMEBUFFER, _frameBufferID); // 启动着色器程序 [_shader use]; // 将图像顶点输入到顶点着色器中 glVertexAttribPointer(CameraAttributesPosition, 2, GL_FLOAT, 0, 0, _imageVertices); glEnableVertexAttribArray(CameraAttributesPosition); // 将纹理的相对于顶点组的坐标输入到顶点着色器中 glVertexAttribPointer(CameraAttributesTextureCoordinate, 2, GL_FLOAT, 0, 0, _textureCoordinates); glEnableVertexAttribArray(CameraAttributesTextureCoordinate); // strip，意味着当存在了三个顶点的时候，每增加一个顶点，新增一个三角形。设三角形第n个结点为V(n)，那么，这个新增的三角形的连接方式为：( V(n), V(n-1), V(n-2) ) (n &gt;= 3) glDrawArrays(GL_TRIANGLE_STRIP, 0, 4); glBindRenderbuffer(GL_RENDERBUFFER, _colorBufferID); // 展示当前的渲染缓冲区 [self.context presentRenderbuffer:GL_RENDERBUFFER]; // 将纹理渲染后，我们要将它销毁，避免内存泄露。 CFRelease(cameraTexture);&#125;// 顶点着色器#version 300 es// 这里是 CameraAttributesPosition，通过glVertexAttribPointer，将值传入到着色器中layout(location = 0) in vec4 position;// 这里是 CameraAttributesTextureCoordinate layout(location = 1) in vec2 textureCoordinate;// 输出到片段着色器out vec2 outTextureCoordinate;void main()&#123; // 标定渲染点元在世界坐标中的位置 gl_Position = position; // 将纹理在点元中的相对坐标传入，由片段着色器处理 outTextureCoordinate = textureCoordinate;&#125;// 片段着色器// 从顶点着色器输入in highp vec2 outTextureCoordinate;// 输出out highp vec4 fragColor;// 外部的纹理的数据采样uniform sampler2D samplerRGBA;void main()&#123; // 通过内建函数采样纹理的颜色，第一个参数是纹理采样器，第二个是纹理坐标，texture会根据纹理参数的设定来对纹理进行采样，这样片段着色器的输出就是纹理的(插值)纹理坐标上的(过滤后的)颜色。——来自 learnOpenGL 中对纹理的解释 fragColor = texture(samplerRGBA, outTextureCoordinate);&#125; 为这个view添加摄像头启动和关闭方法： 123456-(void)start &#123; [self.camera start];&#125;-(void)stop &#123; [self.camera stop];&#125; 最后，将它实例化，并添加到ViewController中 12345-(void)viewDidLoad &#123; _cameraView = [[CameraView alloc] initWithFrame:[UISCreen mainScreen].bounds]; [self.view addSubview:_cameraView]; [_cameraView start];&#125;","categories":[{"name":"Objective-C","slug":"Objective-C","permalink":"http://www.zcating.tk/categories/Objective-C/"}],"tags":[]},{"title":"啥是鸭子类型(duck typing)","slug":"啥是鸭子类型(duck-typing)","date":"2019-02-21T11:00:00.000Z","updated":"2019-02-25T13:23:57.832Z","comments":true,"path":"2019/02/21/cjt2znudd000h81l3rv5f7vap/","link":"","permalink":"http://www.zcating.tk/2019/02/21/cjt2znudd000h81l3rv5f7vap/","excerpt":"什么是鸭子类型？《维基百科》上已经说的很明白了： 在程序设计中，鸭子类型（英语：duck typing）是动态类型的一种风格。在这种风格中，一个对象有效的语义，不是由继承自特定的类或实现特定的接口，而是由”当前方法和属性的集合”决定。 然后有意思的一段话就是： “当看到一只鸟走起来像鸭子、游泳起来像鸭子、叫起来也像鸭子，那么这只鸟就可以被称为鸭子。” 这段话就是鸭子类型的由来。","text":"什么是鸭子类型？《维基百科》上已经说的很明白了： 在程序设计中，鸭子类型（英语：duck typing）是动态类型的一种风格。在这种风格中，一个对象有效的语义，不是由继承自特定的类或实现特定的接口，而是由”当前方法和属性的集合”决定。 然后有意思的一段话就是： “当看到一只鸟走起来像鸭子、游泳起来像鸭子、叫起来也像鸭子，那么这只鸟就可以被称为鸭子。” 这段话就是鸭子类型的由来。 特点鸭子类型（风格）的特点是，关注对象能够做什么。看看以下代码其实就能明白个大概了： 1234567891011121314151617181920212223242526272829303132333435363738let cat = &#123; walk: () =&gt; &#123; console.log('walking...'); &#125;&#125;let duck = &#123; swim: () =&gt; &#123; console.log('swimming...'); &#125; call: () =&gt; &#123; console.log('GaGaGa...'); &#125;&#125;let dragon = &#123; swim: () =&gt; &#123; console.log('swimming...'); &#125; call: () =&gt; &#123; console.log('WaWaWa...'); &#125;&#125;function testDuck (bird) &#123; if (bird) &#123; console.log('It is not a duck.'); return; &#125; if (bird &amp;&amp; bird.swim &amp;&amp; bird.call) &#123; console.log('It is a duck.'); bird.swim(); bird.call(); &#125;&#125;testDuck(); // It is not a duck.testDuck(cat); //It is not a duck.testDuck(duck); // It is a duck. swimming... GaGaGa...testDuck(dragon); // It is a duck. swimming... WaWaWa...","categories":[{"name":"data structure","slug":"data-structure","permalink":"http://www.zcating.tk/categories/data-structure/"}],"tags":[]},{"title":"C++模板元编程——量纲分析","slug":"C++模板元编程——量纲分析","date":"2018-12-27T13:00:00.000Z","updated":"2019-02-20T15:10:03.796Z","comments":true,"path":"2018/12/27/cjt2znudn001681l369kojcd2/","link":"","permalink":"http://www.zcating.tk/2018/12/27/cjt2znudn001681l369kojcd2/","excerpt":"《C++模板元编程》一书上的第三章的第一节就是叫你如何进行量纲分析。说到量纲分析，首先要了解其概念，这里引用书中的内容：1理论上，物理计算的首要原则是：数值运算并非是独立的，大多数物理量都是有附带量纲的。…… 当我们将质量和加速度相乘时，我们除了将数量相乘之外还必须将量纲相乘，这可以帮助我们确信结果是有意义的。这种（对量纲的）簿记的正式名称为量纲分析（dimension analysis）。","text":"《C++模板元编程》一书上的第三章的第一节就是叫你如何进行量纲分析。说到量纲分析，首先要了解其概念，这里引用书中的内容：1理论上，物理计算的首要原则是：数值运算并非是独立的，大多数物理量都是有附带量纲的。…… 当我们将质量和加速度相乘时，我们除了将数量相乘之外还必须将量纲相乘，这可以帮助我们确信结果是有意义的。这种（对量纲的）簿记的正式名称为量纲分析（dimension analysis）。 那么简而言之，当我们在做运算的时候，数值需要运算，该数值的单位也要进行运算。那么书上很好的展示了用Boost库结合而做的量纲分析。然而，这个库引入太麻烦了，而且C++11的可变参数模板已能很好的对其进行应用。下面我将用C++11来编写量纲分析。 可变参数模板可变参数模板是C++11的新特性，有了该特性，整形序列外覆类可以变成一下定义： 12345678910111213141516171819template&lt;typename T, T ...arg&gt;class Vector &#123; using Type = Vector&lt;T, arg...&gt;::Type;&#125;// kilo gramusing Mass = Vector&lt;int, 1, 0, 0, 0, 0, 0, 0&gt;;// Meterusing Length = Vector&lt;int, 0, 1, 0, 0, 0, 0, 0&gt;;// Secondusing Time = Vector&lt;int, 0, 0, 1, 0, 0, 0, 0&gt;;// Ampereusing Charge = Vector&lt;int, 0, 0, 0, 1, 0, 0, 0&gt;;// Kelvinusing Temperature = Vector&lt;int, 0, 0, 0, 0, 1, 0, 0&gt;;// Luxusing Intensity = Vector&lt;int, 0, 0, 0, 0, 0, 1, 0&gt;;// Molusing AmountOfSubstance = Vector&lt;int, 0, 0, 0, 0, 0, 0, 1&gt;; 物理量的表示这里就直接引用《C++模板元编程》书中的对物理量的表示的内容： 123456789101112131415template&lt;typename T, typename Dimension&gt;struct Quantity&#123; explicit Quantity(T x) : mValue(x) &#123;&#125;; T value() const &#123; return mValue; &#125;; private: T mValue; &#125;;&#125;// 表示一个物理量可以这样Quantity&lt;double, Mass&gt; m(2.0f); 加减法加减法比较简单，相同量纲直接可以做加减法，不同量纲之间不可以做加减法： 1234567891011template&lt;typename T, typename Dimension&gt;Quantity&lt;T, Dimension&gt; operator + (const Quantity&lt;T, Dimension&gt;&amp; x, const Quantity&lt;T, Dimension&gt;&amp; y)&#123; return Quantity&lt;T, Dimension&gt;(x.value() + y.value());&#125;template&lt;typename T, typename Dimension&gt;Quantity&lt;T, Dimension&gt; operator - (const Quantity&lt;T, Dimension&gt;&amp; x, const Quantity&lt;T, Dimension&gt;&amp; y)&#123; return Quantity&lt;T, Dimension&gt;(x.value() + y.value());&#125; 乘除法不仅仅是对数值的乘除，也要对量纲进行乘除，量纲的乘除可以转化为表示量纲的序列的加减法。以速度为例，我们知道平均速度等于路程除以时间。$$v=s/t$$它的单位是：$$m/s（米每秒）$$用量纲序列表示： 12using Velocity = Vector&lt;int, 0, 1, -1, 0, 0, 0, 0&gt;;Quantity&lt;double, Velocity&gt; v; 也就是说，当我们用路程除以时间的时候，我们想要以下运算成立： 123Quantity&lt;double, Length&gt; s(10.0);Quantity&lt;double, Time&gt; t(2);Quantity&lt;double, Velocity&gt; v = s/t; 为了能对指定的量纲序列进行加减法，我们需要定义一个这样的元函数，它可以两个序列中的对应的位置做指定的二元元函数运算，并且返回的是一个满足要求（长度相同，内容为二元元函数求值的结果）的序列。 1234567891011121314template&lt;typename T1, typename T2, typename MetaFunction&gt;struct Transform &#123;&#125;;template&lt; typename T, T ...args1, T ...args2, template&lt;typename T, T ...args1&gt; class Vector1, template&lt;typename T, T ...args2&gt; class Vector2, typename MetaFunction&gt;struct Transform&lt;Vector1&lt;T, args1...&gt;, Vector2&lt;T, args2...&gt;, MetaFunction&gt;&#123; using Type = List&lt;T, MetaFunction::template Apply&lt;T, args1, args2&gt;::value...&gt;;&#125;; 我们看到元函数Transform的实现的模板比较复杂，在模板中拥有一个模板类，在这里解释一下： 1234567891011121314151617template&lt; // 指定的类型 typename T, // 第一个序列的变参模板 T ...args1, // 第二个序列的变参模板 T ...args2, // 指定的两个序列，我们的量纲序列满足该定义，所以是可行的。 template&lt;typename T, T ...args1&gt; class Vector1, template&lt;typename T, T ...args2&gt; class Vector2, typename MetaFunction&gt;// 实际Transform元函数转发struct Transform&lt;Vector1&lt;T, args1...&gt;, Vector2&lt;T, args2...&gt;, MetaFunction&gt;&#123; // 编译器只会匹配拥有 Apply 的元函数外覆类 using Type = Vector&lt;T, MetaFunction::template Apply&lt;T, args1, args2&gt;::value...&gt;;&#125;; 然后，我们需要实现两个满足我们要求的二元元函数： 12345678910111213141516171819202122232425262728293031// 对两个序列中的对应元素做加法template&lt;typename T, T value1, T value2&gt;struct PlusImplenment&#123; using Type = PlusImplenment&lt;T, value1, value2&gt;; const static T value = value1 + value2;&#125;;// 元函数外覆类struct Plus&#123; // 二元元函数转发 template&lt;typename T, T value1, T value2&gt; struct Apply : PlusImplenment&lt;T, value1, value2&gt;&#123;&#125;;&#125;;// 对两个序列中的对应元素做减法template&lt;typename T, T value1, T value2&gt;struct MinusImplenment&#123; using Type = MinusImplenment&lt;T, value1, value2&gt;; const static T value = value1 - value2;&#125;;// 元函数外覆类struct Minus&#123; // 二元元函数转发 template&lt;typename T, T value1, T value2&gt; struct Apply : MinusImplenment&lt;T, value1, value2&gt;&#123;&#125;;&#125;; 最后，实现乘法和除法： 123456789101112131415template&lt;typename T, typename D1, typename D2&gt;Quantity&lt;T, typename Transform&lt;D1, D2, Plus&gt;::Type&gt; operator * (const Quantity&lt;T, D1&gt;&amp; x, const Quantity&lt;T, D2&gt; y)&#123; // 通过Transform元函数，计算目标类型。 using Dimension = Transform&lt;D1, D2, Plus&gt;::Type; return Quantity&lt;T, Dimension&gt;(x.value() * y.value());&#125;template&lt;typename T, typename D1, typename D2&gt;Quantity&lt;T, typename Transform&lt;D1, D2, Minus&gt;::Type&gt; operator / (const Quantity&lt;T, D1&gt;&amp; x, const Quantity&lt;T, D2&gt; y)&#123; // 通过Transform元函数，计算目标类型。 using Dimension = Transform&lt;D1, D2, Minus&gt;::Type; return Quantity&lt;T, Dimension&gt;(x.value() / y.value());&#125; 这样，就实现了基本的量纲分析功能。 最后本文代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116#pragma oncenamespace td &#123; template&lt;typename T, T ...args&gt; struct Vector &#123; using Type = List&lt;T, args...&gt;; &#125;; // Specialized // kilo gram using Mass = Vector&lt;int, 1, 0, 0, 0, 0, 0, 0&gt;; // Meter using Length = Vector&lt;int, 0, 1, 0, 0, 0, 0, 0&gt;; // Second using Time = Vector&lt;int, 0, 0, 1, 0, 0, 0, 0&gt;; // Ampere using Charge = Vector&lt;int, 0, 0, 0, 1, 0, 0, 0&gt;; // Kelvin using Temperature = Vector&lt;int, 0, 0, 0, 0, 1, 0, 0&gt;; // Lux using Intensity = Vector&lt;int, 0, 0, 0, 0, 0, 1, 0&gt;; // Mol using AmountOfSubstance = Vector&lt;int, 0, 0, 0, 0, 0, 0, 1&gt;; template&lt;typename T, typename Dimension&gt; struct Quantity &#123; explicit Quantity(T x) : mValue(x) &#123;&#125;; T value() const &#123; return mValue; &#125;; private: T mValue; &#125;; template&lt;typename T, typename Dimension&gt; Quantity&lt;T, Dimension&gt; operator + (const Quantity&lt;T, Dimension&gt;&amp; x, const Quantity&lt;T, Dimension&gt;&amp; y) &#123; return Quantity&lt;T, Dimension&gt;(x.value() + y.value()); &#125; template&lt;typename T, typename Dimension&gt; Quantity&lt;T, Dimension&gt; operator - (const Quantity&lt;T, Dimension&gt;&amp; x, const Quantity&lt;T, Dimension&gt;&amp; y) &#123; return Quantity&lt;T, Dimension&gt;(x.value() + y.value()); &#125; template&lt;typename T, T value1, T value2&gt; struct PlusImplenment &#123; using Type = PlusImplenment&lt;T, value1, value2&gt;; const static T value = value1 + value2; &#125;; struct Plus &#123; // Meta function forwards. template&lt;typename T, T value1, T value2&gt; struct Apply : PlusImplenment&lt;T, value1, value2&gt;&#123;&#125;; &#125;; template&lt;typename T, T value1, T value2&gt; struct MinusImplenment &#123; using Type = MinusImplenment&lt;T, value1, value2&gt;; const static T value = value1 - value2; &#125;; struct Minus &#123; // Meta function forwards. template&lt;typename T, T value1, T value2&gt; struct Apply : MinusImplenment&lt;T, value1, value2&gt;&#123;&#125;; &#125;; // Function Signature template&lt;typename T1, typename T2, typename MetaFunction&gt; struct Transform; template&lt; typename T, T ...args1, T ...args2, template&lt;typename T, T ...args1&gt; class Vector1, template&lt;typename T, T ...args2&gt; class Vector2, typename MetaFunction&gt; struct Transform&lt;Vector1&lt;T, args1...&gt;, Vector2&lt;T, args2...&gt;, MetaFunction&gt; &#123; using Type = List&lt;T, MetaFunction::template Apply&lt;T, args1, args2&gt;::value...&gt;; &#125;; template&lt;typename T, typename D1, typename D2&gt; Quantity&lt;T, typename Transform&lt;D1, D2, Plus&gt;::Type&gt; operator * (const Quantity&lt;T, D1&gt;&amp; x, const Quantity&lt;T, D2&gt; y) &#123; // Caculate the quantity. using Dimension = Transform&lt;D1, D2, Plus&gt;::Type; return Quantity&lt;T, Dimension&gt;(x.value() * y.value()); &#125; template&lt;typename T, typename D1, typename D2&gt; Quantity&lt;T, typename Transform&lt;D1, D2, Minus&gt;::Type&gt; operator / (const Quantity&lt;T, D1&gt;&amp; x, const Quantity&lt;T, D2&gt; y) &#123; // Caculate the quantity. using Dimension = Transform&lt;D1, D2, Minus&gt;::Type; return Quantity&lt;T, Dimension&gt;(x.value() / y.value()); &#125;&#125;","categories":[{"name":"C++","slug":"C","permalink":"http://www.zcating.tk/categories/C/"}],"tags":[]},{"title":"Objective-C 对象内存布局","slug":"Objective-C 对象内存布局","date":"2018-12-16T11:00:00.000Z","updated":"2019-03-07T11:31:48.334Z","comments":true,"path":"2018/12/16/cjt2znud1000881l37o7auyy1/","link":"","permalink":"http://www.zcating.tk/2018/12/16/cjt2znud1000881l37o7auyy1/","excerpt":"可能需要以下命令的帮助： 1clang -rewrite-objc main.m 该命令会将 .m文件转成 .cpp文件，这样就能直观的看到Objective-C对象实际的C对象的形式。","text":"可能需要以下命令的帮助： 1clang -rewrite-objc main.m 该命令会将 .m文件转成 .cpp文件，这样就能直观的看到Objective-C对象实际的C对象的形式。 NSObject对于NSObject来说，它实际上是以这种形式出现的。 1234typedef struct objc_class *Class;struct NSObject_IMPL &#123; Class isa;&#125;; 可以看到，一个NSObject对象其实是只存有一个指针类型。我们可以通过以下代码，来观察它在堆上的大小。 123#import&lt;objc/rumtime.h&gt;NSObject *object = [NSObject new];NSLog(@\"NSObject's instance size is %ul.\", Class_getInstanceSize(object)); 很显然，在64位系统下一个指针的大小为8个字节。运行以上代码，可以发现输出如下： 1NSObject&apos;s instance size is 8. 跟我们所认为的是一样的。那么实际占用的字节大小是多少呢，我们可以通过以下代码来获取其实际占用的大小： 12NSObjec *object = [NSObject new];NSLog(@\"NSObject's malloc size is %ul.\", malloc_size((__brige const void *)object)); 以上代码输出如下： 1NSObject&apos;s malloc size is 16. 为什么是16个字节，主要是因为CoreFoundation框架规定，每个对象的大小最小为16字节。 继承下的对象的内存布局举个例子，先给出以下数据结构： 1234567891011@interface A : NSObject &#123; double a;&#125;@end// 省略 implementation@interface B : A &#123; double b;&#125;@end// 省略 implementation 我们不妨将他们转成C数据结构： 12345678910struct A_IMPL &#123; Class isa; double a;&#125;struct B_IMPL &#123; Class isa; double a; double b;&#125; 手动来计算一下，sizeof(isa) + sizeof(a) = 16 ，sizeof(isa) + sizeof(a) + sizeof(b) = 24。 给出打印代码： 1234567A *objectA = [A new];NSLog(@&quot;A&apos;s instance size is %ul.&quot;, Class_getInstanceSize(objectA));// A&apos;s instance size is 16B *objectB = [B new];NSLog(@&quot;B&apos;s instance size is %ul.&quot;, Class_getInstanceSize(objectB));// B&apos;s instance size is 24 Class_getInstanceSize获取的是实例大小，而不是内存中占用的，我们查看这个实例在内存占用的大小，则需要malloc_size(void*) 这个函数来查看： 123456789#import&lt;malloc/malloc.h&gt;A *objectA = [A new];NSLog(@&quot;A&apos;s allocated size is %ul.&quot;, malloc_size((__brige const void *)objectA));// NSObject&apos;s allocated size is 16.B *objectB = [B new];NSLog(@&quot;B&apos;s allocated size is %ul.&quot;, malloc_size((__brige const void *) objectB));// NSObject&apos;s allocated size is 32. 可以看到，打印的结果并不是24，而是32，这是可能是由于Core Foundation内存对齐的原因，所有的内存地址都是16。 NSArray 的内存布局12345NSArray *array = @[[B new], [B new], [B new]];NSLog(@&quot;array&apos;s instance size is %ul.&quot;, Class_getInstanceSize(array));// array&apos;s instance size is 24.NSLog(@&quot;array&apos;s allocated size is %ul.&quot;, malloc_size((__brige const void *) array));// array&apos;s allocated size is 32. 很显然，array中的数据都是在堆上申请的，所以array的实际上存储的是堆上元素的指针，所以大小是三个指针加上一个isa指针——24。","categories":[{"name":"Objective-C","slug":"Objective-C","permalink":"http://www.zcating.tk/categories/Objective-C/"}],"tags":[]},{"title":"使用Webpack为项目配置热更新","slug":"通过Webpack为项目配置热更新","date":"2018-10-05T11:00:00.000Z","updated":"2019-03-07T13:59:40.144Z","comments":true,"path":"2018/10/05/cjt2znudi000w81l341fhvlz9/","link":"","permalink":"http://www.zcating.tk/2018/10/05/cjt2znudi000w81l341fhvlz9/","excerpt":"为了调试代码方便，使用了Webpack来配置热更新功能，现在记录一下如何配置。 上一篇已经说了如何使用webpack打包代码，但是如果我每次改了代码，都要手动去打包，所以这里要使用热更新来进行代码调试，本篇将记录如何配置webpack热更新。","text":"为了调试代码方便，使用了Webpack来配置热更新功能，现在记录一下如何配置。 上一篇已经说了如何使用webpack打包代码，但是如果我每次改了代码，都要手动去打包，所以这里要使用热更新来进行代码调试，本篇将记录如何配置webpack热更新。 步骤一首先是安装各种的plugin以便热更新的时候可以加载到你想要热更的文件，这里我主要使用了html： 1npm install -D html-webpack-plugin webpack-dev-server 步骤二然后就开始编写我们配置文件webpack.dev.config.js。 12345678910111213141516171819202122232425262728const path = require('path');const webpack = require('webpack');const HTMLWebpackPlugin = require('html-webpack-plugin');module.exports = &#123; entry: '写你自己的入口文件的名称', output: &#123; path: path.resolve(__dirname, '写你自己的文件要生成到的文件夹'), filename: \"写你自己的文件的名字\" &#125;, module: &#123; rules: [&#123; test: /\\.js$/, exclude: /node_modules|(其他你想要忽略打包的文件夹)/ loader: 'babel-loader', options: &#123; presets: ['@babel/preset-env'] &#125; &#125;] &#125;, plugins: [ new webpack.HotModuleReplacementPlugin(), new HTMLWebpackPlugin(&#123; template: './dist/index.html' //此处指定的是入口的HTML &#125;) ]&#125; 这里我们大致的目录结构是这样的： 1234567dist index.htmlsrc main.jspackage.jsonwebpack.config.jswebpack.dev.config.js 步骤三在package增加这个script 1&quot;dev&quot;: &quot;npx webpack-dev-server --config webpack.dev.config.js&quot;, 这样当你输入npm run dev的时候，就可以运行项目了。","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://www.zcating.tk/categories/JavaScript/"}],"tags":[]},{"title":"使用Webpack和Babel支持IE-11","slug":"使用Webpack和Babel支持IE-11","date":"2018-09-29T11:00:00.000Z","updated":"2019-03-07T13:29:11.463Z","comments":true,"path":"2018/09/29/cjt2znudk001181l3fbvtlb1d/","link":"","permalink":"http://www.zcating.tk/2018/09/29/cjt2znudk001181l3fbvtlb1d/","excerpt":"是的你没看错，都8012了还有人用IE-11。为了帮助客户可以在IE-11上使用我们的应用，需要将es6的代码打包转化成es5。","text":"是的你没看错，都8012了还有人用IE-11。为了帮助客户可以在IE-11上使用我们的应用，需要将es6的代码打包转化成es5。 步骤一安装一些必备的插件： 1npm install babel-loader@8.0.0-beta.0 @babel/core @babel/preset-env webpack webpack-cli 步骤二配置webpack.config.js： 123456789101112131415161718const path = require(&apos;path&apos;);module.exports = &#123; entry: &apos;写你自己的入口文件的名称&apos;, output: &#123; path: path.resolve(__dirname, &apos;写你自己的文件要生成到的文件夹&apos;), filename: &quot;写你自己的文件的名字&quot; &#125;, module: &#123; rules: [&#123; test: /\\.js$/, exclude: /node_modules|(其他你想要忽略打包的文件夹)/ loader: &apos;babel-loader&apos;, options: &#123; presets: [&apos;@babel/preset-env&apos;] &#125; &#125;] &#125;&#125; 其实到这步，你在终端运行npx webpack --config webpack.config.js的时候，就可以生成可以运行的文件。但是我到IE上运行，还是不行啊！为什么呢？ 原因就是因为babel只支持语法转换，并不支持es6特有对象和方法的转换，这样就需要这个插件 如果你的代码中有以下这些对象、方法，那么就要小心了！ 1234仅仅是列举常用的，其他还需要进一步查询支持不支持。1. 全局对象：Promise等;2. 全局静态函数：Array.from, Object.assign等;3. 实例方法：Array.prototype.includes等; 所以我们需要另外一个插件 polyfill来对对象和方法进行转换。 步骤三安装包： 1npm i -D @babel/polyfill 然后再入口文件（一般为index.js或main.js）中，往第一行添加以下代码： 1import &apos;@babel/polyfill&apos; 这样打包的时候，就会自动将es6特有的对象和方法进行转换。 总结安装以下插件： 1npm install babel-loader@8.0.0-beta.0 @babel/core @babel/preset-env @babel/polyfill webpack webpack-cli 写webpack.config.js配置文件。 在入口文件的头部添加代码：import &#39;@babel/polyfill&#39;。","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://www.zcating.tk/categories/JavaScript/"}],"tags":[]},{"title":"解决跨域的终极方法","slug":"解决跨域的终极方法","date":"2018-07-10T11:00:00.000Z","updated":"2019-03-03T04:15:36.129Z","comments":true,"path":"2018/07/10/cjt2znudg000p81l36m02zxi1/","link":"","permalink":"http://www.zcating.tk/2018/07/10/cjt2znudg000p81l36m02zxi1/","excerpt":"","text":"如果使用前后端分离的架构，肯定会深受跨域的困扰，网上有一大堆的方法来解决跨域，但是你得一个一个试才知道哪个是合适。这个方法就是用nginx来配置跨域请求头部，下面将简单记录这个方法： 安装nginx，一般来说服务器都是用CentOS，使用yum安装。 直接往/etc/nginx/conf.d/文件夹中添加新的配置文件cros.conf。 输入以下配置： 123456789101112131415161718server &#123; listen 80; // 这里输入转发出去的域名或IP server_name localhost; location / &#123; add_header Access-Control-Allow-Origin *; add_header Access-Control-Allow-Methods &apos;GET, POST, PUT, DELETE, OPTIONS&apos;; add_header Access-Control-Allow-Headers &apos;DNT,X-Mx-ReqToken,Keep-Alive,User-Agent,X-Requested-With,If-Modified-Since,Cache-Control,Content-Type,Authorization&apos;; # 这里返回204，意味着无内容。 if ($request_method = &apos;OPTIONS&apos;) &#123; return 204; &#125; # 这里输入后端的域名或IP proxy_pass your.backend.address; &#125;&#125; 之后，启动nginx，输入命令：service nginx restart。 这样，从浏览器请求后端接口的时候，就不会有跨域的问题出现了。","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://www.zcating.tk/categories/JavaScript/"}],"tags":[]},{"title":"如何正确引用THREE.js的example中的代码","slug":"如何正确引用THREE.js的example中的代码","date":"2018-06-01T11:00:00.000Z","updated":"2019-02-23T10:26:10.193Z","comments":true,"path":"2018/06/01/cjt2znudj000y81l367vigi4h/","link":"","permalink":"http://www.zcating.tk/2018/06/01/cjt2znudj000y81l367vigi4h/","excerpt":"如果你是使用THREE.JS作为你3D框架，并且使用Node.js开发，那么肯定会引入example中的代码，一般来说，通用的解决方法是通过的他人写好的node_modules来引入，但是，有很多坑，比如：","text":"如果你是使用THREE.JS作为你3D框架，并且使用Node.js开发，那么肯定会引入example中的代码，一般来说，通用的解决方法是通过的他人写好的node_modules来引入，但是，有很多坑，比如： 1npm i --save three-fbx-loader 这个是通用的fbx加载器，如果你加载静态模型还好，如果你使用这个来加载动态模型，会发现模型不能进行运动。 那么很显然，你需要通过引入example中的代码，example的代码很明显是没有任何问题的，可以自行查看demo。 但是你直接引入到node项目中又会报以下错误： 12// 以 FBXLoader 为例THREE.FBXLoader is not a constructor。 是的，你需要把所有的源码都加上 THREE = require(&#39;three&#39;)，并且，引入的时候以如下形式引入： 1FBXLoader = require(&apos;./js/loaders/FBXLoader&apos;); 如果你引入的example代码太多，显示会异常的烦躁，这么给出一个简单的方法，就是node自带的全局变量global： 12global.THREE = require(&apos;three&apos;);require(&apos;./js/loaders/FBXLoader&apos;); 这样，当你调用FBXLoader模块时，你可以这样调用： 1let loader = new THREE.FBXLoader(&apos;path&apos;); 一些缺陷但是有个问题，IDE会报错，也没有任何的智能提示，只能手工Lint。","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://www.zcating.tk/categories/JavaScript/"}],"tags":[]},{"title":"使用 Jenkins 配置 iOS 持续集成踩坑实录","slug":"使用 Jenkins 配置 iOS 持续集成踩坑实录","date":"2018-05-24T11:00:00.000Z","updated":"2019-02-26T14:29:20.039Z","comments":true,"path":"2018/05/24/cjt2znudf000m81l31em9a36q/","link":"","permalink":"http://www.zcating.tk/2018/05/24/cjt2znudf000m81l31em9a36q/","excerpt":"Jenkins 是一款使用 Java 开发的持续集成工具，下面将介绍如何使用 Jenkins 来进行iOS的持续集成。坑都用粗体标明了。","text":"Jenkins 是一款使用 Java 开发的持续集成工具，下面将介绍如何使用 Jenkins 来进行iOS的持续集成。坑都用粗体标明了。 安装坑在安装 Jenkins 之前，首先要安装 JDK，这里需要注意 JDK 的版本，必须为1.8，过高或者过低均不行。 推荐使用 brew 来安装 Jenkins。 1brew install jenkins 配置坑第一步安装完毕后，直接在命令行中输入以下命令： 1jenkins 在这里需要注意，Jenkins 默认端口是8080，如果该端口被占用，可以使用以下命令切换端口： 1jenkins -httpPort 9090 然后，就可以在浏览器中输入localhost:9090来进入 Jenkins。在起始页面会使用一个起始口令来让你解锁它，这个口令可以在命令行中，或者在其指定的目录下可以找到该口令。输入完毕后，会让你创建一个账户，按照提示来完成操作就好。 第二步创建完毕后，首先要去绑定你SSH密钥，方法如下： 1Jenkins -&gt; Credentials -&gt; global -&gt; add Credentials 第三步绑定完毕后，开始安装以下插件： Keychains and Provisioning Profiles Management 对的，只有一个，不要使用 Xcode 插件来进行 iOS 配置，因为 XCode 8 以后，通过 Archive 生成 ipa 需要包括一个 ExportOption.Plist 文件，这个文件在该插件中并不会提供，所以通过脚本来进行配置，而不是通过 XCode 插件来配置。 安装完毕该插件后，直接通过网上各种渠道的信息来对该插件进行配置，配置该插件基本上不会有太大问题，下面给出 keychains 和 provision 在系统中的路径。 12keychain: /Users/zcating/Library/Keychainsprovision: /Users/zcating/Library/MobileDevice/Provisioning Profiles 需要注意的是，上传的时候，login.keychain-db 会被标记为不合法的文件，login.keychain 实际上跟 login.keychain-db 是一样的，只需要复制一份，然后更改 login.keychain-db 为login.keychain，然后就可以上传了。 第四步完成上传后就可以开始构建了，构建步骤如下： 12341. 新建项目，选择自由风格。2. 勾选 keychain 和 provision。3. 添加 Git 配置。4. 增加构建步骤，选择 Execute shell。 然后添加以下脚本： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#需要自定义参数xcode_project_path=\"/path/to/your/xcode/project\"export_path=\"/path/to/your/export/path\"ipa_name=\"ipa-name\"provision=\"xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx\"# build method，可以输入以下选项: app-store, ad-hoc, enterprise, developmentbuild_method=\"enterprise\"# bundle_id 需要跟项目中的一致bundle_id=\"com.yourCompany.yourApp\"bundle_name=\"provision_name\"# 签名类型，可以选择以下类型: \"iOS Developer\", \"iOS Distribution\"sign_cer=\"iOS Distribution\"# 就是你们团队证书中的用户名team_id=\"XXXXXXXXXX\"#自定义完毕export_option_path=\"$xcode_project_path/ExportOptions.plist\"# 写 ExportOption.plist 文件echo \"&lt;?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?&gt;&lt;!DOCTYPE plist PUBLIC \\\"-//Apple//DTD PLIST 1.0//EN\\\" \\\"http://www.apple.com/DTDs/PropertyList-1.0.dtd\\\"&gt;&lt;plist version=\\\"1.0\\\"&gt;&lt;dict&gt; &lt;key&gt;compileBitcode&lt;/key&gt; &lt;false/&gt; &lt;key&gt;method&lt;/key&gt; &lt;string&gt;$build_method&lt;/string&gt; &lt;key&gt;provisioningProfiles&lt;/key&gt; &lt;dict&gt; &lt;key&gt;$bundle_id&lt;/key&gt; &lt;string&gt;$bundle_name&lt;/string&gt; &lt;/dict&gt; &lt;key&gt;signingCertificate&lt;/key&gt; &lt;string&gt;$sign_cer&lt;/string&gt; &lt;key&gt;signingStyle&lt;/key&gt; &lt;string&gt;manual&lt;/string&gt; &lt;key&gt;stripSwiftSymbols&lt;/key&gt; &lt;true/&gt; &lt;key&gt;teamID&lt;/key&gt; &lt;string&gt;$team_id&lt;/string&gt; &lt;key&gt;thinning&lt;/key&gt; &lt;string&gt;&amp;lt;none&amp;gt;&lt;/string&gt;&lt;/dict&gt;&lt;/plist&gt;\" &gt; $export_option_path;xcodebuild archive \\-archivePath \"$xcode_project_path/build/$&#123;ipa_name&#125;.xcarchive\" \\-project $xcode_project \\-sdk iphoneos \\-scheme $scheme \\-configuration $build_configuration \\CODE_SIGN_IDENTITY=\"钥匙串中的签名的名称\" \\PROVISIONING_PROFILE=$provisionxcodebuild -exportArchive \\-archivePath \"$xcode_project_path/build/$&#123;ipa_name&#125;.xcarchive\" \\-exportPath $export_path \\-exportOptionsPlist $export_option_path \\-allowProvisioningUpdates \\CODE_SIGN_IDENTITY=\"钥匙串中的签名的名称\" \\PROVISIONING_PROFILE=$provisionmv $&#123;export_path&#125;/*.ipa $&#123;export_path&#125;/ipa_name.ipa 需要注意，XCode 项目需要关闭自动签名配置。 到这里，只要在 XCode 打开该项目没有报错，并且可以构建，那么就没有任何问题了。 Unity 特别篇使用 Jenkins 来构建 Unity，有以下几点需要注意的地方。 关闭自动签名，设定provision。 在 Assets 目录下新建以下目录和文件 /Assets/editor/ProcessBuild.cs，并且在cs文件中添加以下代码。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152using System.Collections;using System.IO;using UnityEditor;using UnityEngine;using System.Collections.Generic;using System;class ProjectBuild : Editor&#123; //在这里找出当前工程所有的场景文件. static string[] GetBuildScenes() &#123; List&lt;string&gt; names = new List&lt;string&gt;(); foreach(EditorBuildSettingsScene e in EditorBuildSettings.scenes) &#123; if(e==null) continue; if(e.path == \"Dont_Add\" || e.path == \"post\") if(e.enabled) names.Add(e.path); &#125; return names.ToArray(); &#125; //得到项目的名称 public static string projectName &#123; get &#123; foreach(string arg in System.Environment.GetCommandLineArgs()) &#123; if(arg.StartsWith(\"project\")) &#123; return arg.Split(\"-\"[0])[1]; &#125; &#125; return \"test\"; &#125; &#125; //shell脚本直接调用这个静态方法 static void BuildForIPhone() &#123; PlayerSettings.SetScriptingDefineSymbolsForGroup(BuildTargetGroup.iOS, \"USE_SHARE\"); // 构建xcode工程的核心方法了， // 参数1 需要打包的所有场景 // 参数2 需要打包的名字 // 参数3 打包平台 // 参数4 编译选项 BuildPipeline.BuildPlayer(GetBuildScenes(), \"ios-build\", BuildTarget.iOS, BuildOptions.None); &#125;&#125; 使用以下命令进行自动化构建。 12345678project_dir=\"\"/Applications/Unity/Unity.app/Contents/MacOS/Unity \\-batchmode \\-projectPath $project_dir \\-executeMethod ProjectBuild.BuildForIPhone \\-ios \\-quit \\-logFile $project_dir/BuildXCodeProject.log 这样就会在你指定的目录下生成 XCode 项目。 结语我使用了 Jenkins 生成 iOS 最终的 ipa，感受到了如丝般顺滑的构建流程。生成过程只需一键，一键就能上传Testflight，fir.im 或者蒲公英。感觉以后打包真的会方便很多很多倍，省去了各种复杂的步骤。只是在构建 Jenkins 的时候，遇到了很多问题，最终的解决方案还是决定写一个 Shell 脚本，这样就省去了很多插件的配置问题，之后可能会将脚本转换成可读性更强的 Python 脚本。","categories":[{"name":"Objective-C","slug":"Objective-C","permalink":"http://www.zcating.tk/categories/Objective-C/"}],"tags":[]},{"title":"响应链是如何进行响应的","slug":"iOS中的响应链和点击链简析","date":"2018-05-04T11:00:00.000Z","updated":"2019-02-26T14:38:47.772Z","comments":true,"path":"2018/05/04/cjt2znud5000b81l3e5ju974u/","link":"","permalink":"http://www.zcating.tk/2018/05/04/cjt2znud5000b81l3e5ju974u/","excerpt":"iOS中使用这种方式来实现对对象的响应的： A responder object is any instance of the UIResponder class, and common subclasses include UIView, UIViewController, and UIApplication. 翻译一下： 一个responder对象是这样一种实例，它继承UIResponder类或者是这些子类（UIViewController, UIApplication, UIView）。 对于一个responder对象，它可以响应的事件有以下这些：","text":"iOS中使用这种方式来实现对对象的响应的： A responder object is any instance of the UIResponder class, and common subclasses include UIView, UIViewController, and UIApplication. 翻译一下： 一个responder对象是这样一种实例，它继承UIResponder类或者是这些子类（UIViewController, UIApplication, UIView）。 对于一个responder对象，它可以响应的事件有以下这些： 123456789101112131415// 触摸事件- (void)touchesBegan:(NSSet *)touches withEvent:(UIEvent *)event;- (void)touchesMoved:(NSSet *)touches withEvent:(UIEvent *)event;- (void)touchesEnded:(NSSet *)touches withEvent:(UIEvent *)event;- (void)touchesCancelled:(NSSet *)touches withEvent:(UIEvent *)event;// 加速器事件// 只会处理由CoreMotion传递的事件，不属于响应链。- (void)motionBegan:(UIEventSubtype)motion withEvent:(UIEvent *)event;- (void)motionEnded:(UIEventSubtype)motion withEvent:(UIEvent *)event;- (void)motionCancelled:(UIEventSubtype)motion withEvent:(UIEvent *)event;// 远程控制事件// 主要是用来处理配件的行为，比如耳机插拔、按钮播放等，不属于响应链。- (void)remoteControlReceivedWithEvent:(UIEvent *)event; 我们主要关注的是触摸事件。 Hit-Test 链当你与点击屏幕的时候，会触发UIView中的这两个函数： 12345// 递归地调用 -pointInside:withEvent:. point的坐标是在接收者的坐标系中。-(UIView *)hitTest:(CGPoint)point withEvent:(UIEvent *)event;// 如果点在框内，默认是返回 YES.-(BOOL)pointInside:(CGPoint)point withEvent:(UIEvent *)event; hitTest的逻辑大概如下： 1234567891011121314151617181920212223-(UIView *)hitTest:(CGPoint)point withEvent:(UIEvent *)event;&#123; // 判断这个点是否可以点击 if (!self.isUserInteractionEnabled || self.isHidden || self.alpha &lt;= 0.01) &#123; return nil; &#125; // 然后判断这个点是否在这个视图内部 if ([self pointInside:point event:event]) &#123; // 将 subview 逆序遍历 [self.subviews enumerateObjectsWithOptions:NSEnumerationReverse usingBlock:^(UIView * view, NSUInteger index, BOOL stop) &#123; // 将触摸点所在的父视图坐标系转换到子视图下的坐标系。 CGPoint convertedPoint = [view convertPoint:point fromView:self]; UIView *testedView = [view hitTest:point withEvent:event]; if (testedView) &#123; return testedView; &#125; &#125;]; // 如果没有找到符合的视图，那么就返回当前视图，并处理事件。 return self; &#125; // 点不在视图内，返回nil不处理该视图以及其子视图。 return nil;&#125; 现在，使用Method Swizzling对所有的UIView中的-hitTest:withEvent:进行hook，在hook方法里打印调用该方法的实例。以一个例子，如下图： 上图中的每一个色块都是一个UIView对象，他们的打印都是其对应的颜色。他们是这样添加的： 1234567891011121314UIView *redView = [[UIView alloc] init];redView.backgroundColor = [UIColor redColor];UIView *blueView = [[UIView alloc] init];blueView.backgroundColor = [UIColor blueColor];[redView addSubview:blueView];UIView *greenView = [[UIView alloc] init];greenView.backgroundColor = [UIColor blueColor];[blueView addSubview:blueView];UIView *yellowView = [[UIView alloc] init];yellowView.backgroundColor = [UIColor yellowColor];[redView addSubview:yellowView]; 记住蓝色和黄色添加顺序，当我们的时候点击绿色视图的时候，打印结果如下（你可能会有疑问，为啥会调用两次，因为点击开始是一个事件，结束也是一个事件。）： 1234567891011121314151617第一次hit test &lt;UIWindow: 0x115e0a3d0&gt;hit test controller&apos;s viewhit test redhit test yellowhit test bluehit test greenhit test &lt;UIStatusBarWindow&gt;hit test &lt;UIStatusBar&gt;第二次hit test &lt;UIWindow&gt;hit test controller&apos;s viewhit test redhit test yellowhit test bluehit test green -hitTest:withEvent:的调用链是这样的： 可以看到红色视图调用了它的子视图的hit-test方法，通过逆序遍历来查找蓝色和黄色，如果黄色视图在蓝色视图添加之前，则黄色试图不会调用hit-test方法，因为在调用蓝色视图的hit-test的时候，就会继续调用绿色视图的hit-test，并确认点在绿色视图内并返回绿色视图，那么红色视图hit-test的终结点就是在蓝色视图的返回值，并不会继续去调用黄色视图对应的方法。其实讲这么多就是为了理解hit-test的逻辑，理解多点触控技术是如何去确认点在视图中的位置。 响应链通过hit-test确定了视图之后，该视图将会逆着hit-test链来返回响应的事件，并查找哪个view能处理这个点击事件。为了能够看清响应链的具体过程，我们可以通过分类重写UIView、UIViewController和UIApplication中的-touchBegan:withEvent:这个方法： 1234-(void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event &#123; NSLog(@\"begin, %@\", [self description]); [self.nextResponder touchesBegin:touches withEvent:event];&#125; nextResponder是当前视图的下一个响应者，如果这个视图不能处理当前的事件，那么便会通过nextResponder来响应这个事件，这样，点击绿色视图打印的链条如下： 1234567began: greenbegan: bluebegan: redbegan: controller's viewbegan: &lt;MyViewController&gt;began: &lt;UIWindow&gt;began: &lt;UIApplication&gt; 那么它的响应链如下： 参考文档Using Responders and the Responder Chain to Handle Events Understanding cocoa and cocoa touch responder chain iOS响应链(Responder Chain)","categories":[{"name":"Objective-C","slug":"Objective-C","permalink":"http://www.zcating.tk/categories/Objective-C/"}],"tags":[]},{"title":"用XCode注入动态库到Mac应用中","slug":"用XCode注入动态库到Mac应用中","date":"2018-02-18T11:00:00.000Z","updated":"2019-02-26T14:12:56.606Z","comments":true,"path":"2018/02/18/cjt2znudi000u81l3oo0mfiru/","link":"","permalink":"http://www.zcating.tk/2018/02/18/cjt2znudi000u81l3oo0mfiru/","excerpt":"本文介绍如何将动态库注入到Mac下的二进制文件中，不包含逆向分析，仅作学习使用。 步骤简介以下是具体步骤简介。 使用classdump，解压出Mac版微信下的所有头文件。 新建一个macOS Framework工程。 将Header拖入项目中，并将注入脚本放入Build Phases中，编译项目。","text":"本文介绍如何将动态库注入到Mac下的二进制文件中，不包含逆向分析，仅作学习使用。 步骤简介以下是具体步骤简介。 使用classdump，解压出Mac版微信下的所有头文件。 新建一个macOS Framework工程。 将Header拖入项目中，并将注入脚本放入Build Phases中，编译项目。 本文介绍如何将动态库注入到Mac下的二进制文件中，不包含逆向分析，仅作学习使用。 步骤简介以下是具体步骤简介。 使用classdump，解压出Mac版微信下的所有头文件。 新建一个macOS Framework工程。 将Header拖入项目中，并将注入脚本放入Build Phases中，编译项目。 步骤一我们使用class-dump，要使用class-dump,首先需要下载它，它不是自带的。 下载地址：http://stevenygard.com/projects/class-dump/ 打开终端，运行sudo cp /path/to/class-dump /usr/local/bin （目标地址是可以全局运行项目的地方） 修改权限，运行sudo chmod 777 /usr/local/bin/class-dump 运行以下命令可以获得所有的微信头文件。 1class-dump -H /Applications/WeChat.app/Contents/MacOS/WeChat -o /path/to/your/dir/ 步骤二我们使用xcode创建一个Framework项目，此步略过。 步骤三将Header拖入后，我们需要开始编写tweak代码，首先我们新建一个 tweak.mm，输入以下函数： 1234static void __attribute__((constructor)) tweak(void) &#123; // do hook method... NSLog(@\"****************running hook!************************\");&#125; 这段代码的意思就是，在main函数执行前，运行tweak函数。我们先不管如何hook，把整个注入框架搭起来才是最重要的。 我们通过insert_dylib 将生成的动态库注入到指定的二进制文件中，insert_dylib这个文件可以在这里找到： 1https://github.com/Tyilo/insert_dylib 打开 edit scheme，找到 Excutable，选择 Other，找到WeChat.app并确认。 在Build Phases中，新增一个新的 Run Script，然后添加如下脚本： 123456789101112131415WECHAT_PATH=\"/Applications/wechat.app/Contents/MacOS\"FRAMEWORK_NAME=\"WechatHooker\"UNIX_FILE=\"$&#123;WECHAT_PATH&#125;/Wechat\"FRAMEWORK_PATH=\"$&#123;WECHAT_PATH&#125;/$&#123;FRAMEWORK_NAME&#125;.framework\"if ! [ -f \"$&#123;WECHATPATH&#125;/WeChatCopy\" ]thencp -rf $&#123;UNIX_FILE&#125; \"$&#123;WECHAT_PATH&#125;/WeChatCopy\"ficp -rf \"$&#123;BUILT_PRODUCTS_DIR&#125;/$&#123;FRAMEWORK_NAME&#125;.framework\" $&#123;WECHAT_PATH&#125;./insert_dylib \"$&#123;FRAMEWORK_PATH&#125;/$&#123;FRAMEWORK_NAME&#125;\" $&#123;UNIX_FILE&#125; $&#123;UNIX_FILE&#125; --all-yes 脚本的意思很明确，通过将生成的Framework拷贝到指定目录下，然后通过 insert_dylib 将动态库注入到指定的二进制文件中。在这里，为了不覆盖原有的WeChat二进制文件，生成了WeChatCopy，我们需要将整个WeChat.app复制一份新的，并将生成的WechatCopy，改名覆盖WeChat二进制文件。 最后运行Framework，会发现在 /Applications/wechat.app/Contents/MacOS/ 目录下，会多出一个WeChatCopy。按照上述方法操作后，运行修改后的Wechat.app可以在控制台查看到打印信息。 在这里，我们以“防止消息撤回”为例。消息撤回其实这个功能其实对于有些人来说很不喜欢，现在他们想防止微信消息撤回，我已经通过逆向分析找到了防止消息撤回的目标函数，现在，只要将这个函数改写就好了。类，函数以及函数的参数描述如下： 123Class: MessageServiceMethod: onRevokeMsg: 当消息撤回时，需要做的事情。Parameters: NSString 撤回的消息内容。 使用Aspect对onRevokeMsg:进行替换： 1234567891011#define MYMessageService objc_getClass(&quot;MessageService&quot;)static void __attribute__((constructor)) tweak(void) &#123; // 需要注意的是，编译的时候，编译器是找不到 MessageService 的实现， // 如果直接引入会编译报错，我们需要动态获取该类。 // do hook method... [MYMessageService aspect_hookSelector:NSSelectorFromString(@&quot;onRevokeMsg:&quot;) withOptions:AspectPositionInstead usingBlock:^(id&lt;AspectInfo&gt; info)&#123; // hook method... NSLog(@&quot;revoked message: %@&quot;, [info arguments].firstObject); &#125; error:nil];&#125; 我们打印了撤回的消息的内容，可以看到微信的聊天信息是以XML的形式来进行数据的传输。 12345678&lt;sysmsg type=\"revokemsg\"&gt; &lt;revokemsg&gt; &lt;session&gt;wxid_qdxmce84ueno12&lt;/session&gt; &lt;msgid&gt;1656418240&lt;/msgid&gt; &lt;newmsgid&gt;8250926699869451612&lt;/newmsgid&gt; &lt;replacemsg&gt;&lt;![CDATA[\"sunhay\" 撤回了一条消息]]&gt;&lt;/replacemsg&gt; &lt;/revokemsg&gt;&lt;/sysmsg&gt; 通过逆向，将原本的撤回函数以人类可读的方式展示。 12345678910111213141516171819202122232425262728// self = MessageService 实例-(void)onRevokeMsg:(NSString *)message &#123; // 此处使用原本的 NSString *session = [RegexHelper matchXMLTag:@&quot;session&quot; inXMLText:message]; NSUIntger msgID = [[RegexHelper matchXMLTag:@&quot;msgid&quot; inXMLText:message] longLongValue]; NSUIntger newMsgID = [[RegexHelper matchXMLTag:@&quot;newmsgid&quot; inXMLText:message] longLongValue]; NSString *revokeContent = [RegexHelper matchXMLTag:@&quot;replacemsg&quot; inXMLText:message]; id lastMsgData = [self GetMsgData:session svrId:newMsgID]; if (lastMsgData == nil) &#123; return; &#125; // 匹配 [!CDATA[\\S*]] NSString *receiveMsg = [RegexHelper getChatContent:message]; // 显示谁撤回了消息 id revokingData = [[MessageData alloc] initWithMsgType:0x2710]; [revokingData setMsgStatus:0x4]; [revokingData setMsgContent:receiveMsg]; [revokingData setFromUsrName:[lastMsgData toUsrName]]; [revokingData setToUsrName:[lastMsgData fromUsrName]]; [revokingData setMsgCreateTime:[lastMsgData msgCreateTime]]; [revokingData setMesLocalID:[lastMsgData mesLocalID]]; // 将指定撤回的内容删除 [self DelMsg:session msgList:@[lastMsgData] isDelAll:0 isManual:1]; // 将撤回消息栏添加进指定的聊天列表 [self AddLocalMsg:session msgData:msgData];&#125; 很显然，微信通过删除指定的信息，来实现撤回，那么我们的防止撤回函数如下（都在tweak.mm中）： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#define MYMessageData objc_getClass(&quot;MessageData&quot;)#define MYMessageService objc_getClass(&quot;MessageService&quot;)static void MYPreventRevoking(id service, NSString *message) &#123; NSString *session = [RegexHelper matchXMLTag:@&quot;session&quot; inXMLText:message]; NSUIntger msgID = [[RegexHelper matchXMLTag:@&quot;msgid&quot; inXMLText:message] longLongValue]; NSUIntger newMsgID = [[RegexHelper matchXMLTag:@&quot;newmsgid&quot; inXMLText:message] longLongValue]; id lastMsgData = [service GetMsgData:session svrId:newMsgID]; if (lastMsgData == nil) &#123; return; &#125; NSString *revokeContent = [NSString stringWithFormat:@&quot;Ta 撤回了：%@&quot;, [lastMsgData msgContent]]; NSString *receiveMsg = [RegexHelper getChatContent:message]; id msgData = [[MYMessageData alloc] initWithMsgType:0x2710]; [msgData setMsgStatus:0x4]; [msgData setMsgContent:receiveMsg]; [msgData setFromUsrName:[lastMsgData toUsrName]]; [msgData setToUsrName:[lastMsgData fromUsrName]]; [msgData setMsgCreateTime:[lastMsgData msgCreateTime]]; [msgData setMesLocalID:[lastMsgData mesLocalID]]; id revokingData = [[MYMessageData alloc] initWithMsgType:0x2710]; [revokingData setMsgStatus:0x4]; [revokingData setMsgContent:revokeContent]; [revokingData setFromUsrName:[lastMsgData toUsrName]]; [revokingData setToUsrName:[lastMsgData fromUsrName]]; [revokingData setMsgCreateTime:[lastMsgData msgCreateTime]]; [revokingData setMesLocalID:[lastMsgData mesLocalID]]; // [service DelMsg:session msgList:@[lastMsgData] isDelAll:0 isManual:1]; [service AddLocalMsg:session msgData:msgData]; [service AddLocalMsg:session msgData:revokingData];&#125;// 附上完整的文件static void __attribute__((constructor)) tweak(void) &#123; // 需要注意的是，编译的时候，编译器是找不到 MessageService 的实现， // 如果直接引入会编译报错，我们需要动态获取该类。 // do hook method... [MYMessageService aspect_hookSelector:NSSelectorFromString(@&quot;onRevokeMsg:&quot;) withOptions:AspectPositionInstead usingBlock:^(id&lt;AspectInfo&gt; info)&#123; // hook method... NSLog(@&quot;revoked message: %@&quot;, [info arguments].firstObject); MYPreventRevoking([info instance], [info arguments].firstObject); &#125; error:nil];&#125; 至此我们已经完成了防止消息撤回，这样，在聊天的时候，就能愉快地防止对方偷偷撤回了信息，并且知道对方想要撤回什么信息。 最后简单的介绍如何去对mac应用进行注入，仅作抛砖引玉用。","categories":[{"name":"Objective-C","slug":"Objective-C","permalink":"http://www.zcating.tk/categories/Objective-C/"},{"name":"逆向分析","slug":"Objective-C/逆向分析","permalink":"http://www.zcating.tk/categories/Objective-C/逆向分析/"}],"tags":[]},{"title":"iOS 动态加载非系统的字体","slug":"iOS 动态加载字体","date":"2018-02-16T05:00:00.000Z","updated":"2019-02-20T15:07:52.603Z","comments":true,"path":"2018/02/16/cjt2znucy000781l37w09h792/","link":"","permalink":"http://www.zcating.tk/2018/02/16/cjt2znucy000781l37w09h792/","excerpt":"对于字体文件，普遍的方法是静态加载，静态加载需要将字体文件打包到mainBundle中，但是某些应用如果需要下发字体功能，那么就不是很方便，于是就介绍以下动态加载字体库的方法。","text":"对于字体文件，普遍的方法是静态加载，静态加载需要将字体文件打包到mainBundle中，但是某些应用如果需要下发字体功能，那么就不是很方便，于是就介绍以下动态加载字体库的方法。 静态加载对于字体来说，有两种文件格式，.otf和.ttf。这两种都是可以作为字体格式加载到iOS当中的。 要加载字体，首先要在Info.plist添加如下属性： 接着，打开字体库查找你要加载字体的PostScript name。 然后在你的代码中添加以下代码： 12345//// @param name : PostScript name// @param size : the font size you want to set//[UIFont fontWithName:@&quot;YaHei-Consolas-Hybrid&quot; size:12]; 这样，就可以静态的调用字体。 动态加载但是，有个问题，以上方式直接将字体文件拷贝到mainBundle中，也就是你不能更改字体文件，因此，如果你需要新增或修改字体的时候，是没有办法更改的。所以，需要动态的去加载这个字体文件。 直接给出代码吧，感觉比上面的方法简单多了。 123456789101112131415161718192021222324//首先要 @import CoreText;//字体文件所在路径NSString *fontPath = @&quot;path/to/font/file&quot;;//字体数据NSData *fontData = [NSData dataWithContentsOfFile:fontPath];if (fontData == nil) &#123; return;&#125;//动态加载CFErrorRef error = NULL;CGDataProviderRef providerRef = CGDataProviderCreateWithCFData((CFDataRef)fontData);CGFontRef fontRef = CGFontCreateWithDataProvider(providerRef);// 将文本注册到CoreTextif (!CTFontManagerRegisterGraphicsFont(fontRef, &amp;error)) &#123; NSLog(@&quot;%@&quot;, (__bridge NSString *)CFErrorCopyDescription(error)); return;&#125;NSString *fontName = (__bridge NSString *)CGFontCopyPostScriptName(fontRef);self.label.font = [UIFont fontWithName:fontName size:10];CFRelease(fontRef);CFRelease(providerRef); 这样，就可以动态的去加载了，通过网络下发字体文件，便可以替换字体 。 : )","categories":[{"name":"Objective-C","slug":"Objective-C","permalink":"http://www.zcating.tk/categories/Objective-C/"}],"tags":[]},{"title":"Objective-C 简析（3）—— OC属性 Attributes列举","slug":"Objective-C 简析（3）—— OC属性 Attributes列举","date":"2018-01-10T11:00:00.000Z","updated":"2019-02-26T14:24:16.711Z","comments":true,"path":"2018/01/10/cjt2znucq000481l3rx7aq9a2/","link":"","permalink":"http://www.zcating.tk/2018/01/10/cjt2znucq000481l3rx7aq9a2/","excerpt":"Objective-C属性的主要由四种不同的attribute组成 ： 原子性：atomic，nonatomic； 读写相关：readwrite,readonly； 内存管理相关：assign，strong，weak，unsafe_unretained，copy； 存取方法设定：getter=(name)，setter=(name)；","text":"Objective-C属性的主要由四种不同的attribute组成 ： 原子性：atomic，nonatomic； 读写相关：readwrite,readonly； 内存管理相关：assign，strong，weak，unsafe_unretained，copy； 存取方法设定：getter=(name)，setter=(name)； 原子性原子性主要和线程安全相关，当你定义一个属性的时候，默认是atomic的，它底层使用的是同步锁来保证这个操作属性是原子的。在Objective-C编程中，很少用到的atomic这个属性，原因是同步锁的开销比较大，同时也不能保证线程同步，如果要实现线程同步，一般都是采用GCD等较为底层的机制来实现。一般来说属性以使用nonatomic。 读写相关当你定义一个属性的使用，默认是readwrite的。 readwrite该attribute使属性可以拥有getter和setter，如果我们不在类的@implementation中显式的编写getter和setter，那么编译器会生成一个以下划线加属性名称为名的成员变量，并且自动的生成getter和setter。 readonly该attribute使属性只能拥有getter，如果我们不在类的@implementation中显式的编写getter，那么编译器会生成一个以下划线加属性名称为名的成员变量，并且自动的生成getter。 内存管理相关当你定义一个属性的使用，内存管理的Attribute默认是assign的。 assign仅仅用于内置类型或者简单的结构体，比如float或者CGRect。如果属性的类型是Objective-C类，那么当属性所持有的类实例dealloc的时候，属性的值并并不会自动置为nil。 strong用于Objective-C类，为这种属性调用setter时，会保留新值，然后释放旧的值，并将新值赋上去。 weak用于Objective-C类，为这种属性调用setter时，不会持有新值，也不会释放旧值。但是当它所指的对象dealloc的时候，该属性会被设置为nil。 copy用于Objective-C类，为这种属性调用setter时，会保留新值的拷贝，然后释放旧值，然后将这个拷贝赋值给属性。 unsafe_unretained用于Objective-C类，为这种属性调用setter时，不会持有新值，也不会释放旧值。但是当它所指的对象dealloc的时候，属性的值仍然是该对象未dealloc时在内存的位置，不会自动清空。 存取方法设定这个用的比较少，以两个例子来说明就好了。 1234567891011121314151617181920@interface LightBulb : NSObject &#123; BOOL _onOrOff;&#125;@property (nonatomic, getter=isOn, setter=setIsOn) BOOL on;@end@implementation LightBulb// 因为定义了 getter=isOn，所以getter方法为 -isOn, 而不是 -on.-(BOOL)isOn&#123; return _isOn;&#125;// 因为定义了 setter=setIsOn，所以getter方法为 -setIsOn, 而不是 -setOn.-(void)setIsOn:(BOOL)onOrOff&#123; _onOrOff = onOrOff;&#125;@end 其他标记一个属性为类属性： 1@property(class, nonatomic, strong) UIApplication *sharedApplication; 标记一个属性是否可以为空： 123@property(nonatomic, strong, readonly, nonnull) NSString *loggingString;@property(nonatomic, strong, readonly, nullable) UIResponder *nextResponder;","categories":[{"name":"Objective-C","slug":"Objective-C","permalink":"http://www.zcating.tk/categories/Objective-C/"}],"tags":[]},{"title":"Objective-C简析（2）—— block篇","slug":"Objective-C 简析（2）—— Block篇","date":"2018-01-06T11:00:00.000Z","updated":"2019-02-26T15:02:06.993Z","comments":true,"path":"2018/01/06/cjt2znuck000181l3iy8e1sut/","link":"","permalink":"http://www.zcating.tk/2018/01/06/cjt2znuck000181l3iy8e1sut/","excerpt":"Block是一个非常有用的语法特性。","text":"Block是一个非常有用的语法特性。 如何定义普通变量： 1int (^block)(int) = ^int(int a) &#123;/*implement*/&#125;; 类属性： 1@property (copy) int (^block)(int); 函数参数： 1-(void)function:(int(^)(int))block; 函数参数调用： 1[aClass aFunction:^int(int a)&#123;/*implement*/&#125;]; 类型定义（typedef）： 12typedef int (^BlockType)(int);BlockType aBlock = ^int(int a)&#123;/*implement*/&#125;; Block简单源码剖析通过clang -rewrit-objc可以获得Block的实现的C++源码。 如下代码： 1234567int main(int argc, const char * argv[]) &#123; void (^block)(void) = ^void(void)&#123; printf(&quot;hello, world!&quot;); &#125;; block(); return 0;&#125; 转换后的主要代码如下。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354// 实现 block 的结构体，所以很显然，在OC中block是一个对象。struct __block_impl &#123; void *isa; // isa 指针，即为 id。 int Flags; // int Reserved; // void *FuncPtr; // 函数指针&#125;;// block的具体属性结构体static struct __main_block_desc_0&#123; size_t reserved; size_t Block_size;&#125; __main_block_desc_0_DATA = &#123; 0, sizeof(struct __main_block_impl_0) &#125;;// block主要实现结构体struct __main_block_impl_0&#123; struct __block_impl impl; // block结构体 struct __main_block_desc_0* Desc; // 构造函数 __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, int flags=0) &#123; // 初始化 block 实例属性 isa ，表示是栈类型的代码块。 impl.isa = &amp;_NSConcreteStackBlock; // impl.Flags = flags; // 具体实现匿名功能的函数的指针 impl.FuncPtr = fp; Desc = desc; &#125;&#125;;// block的匿名函数功能。// 一般来说，OC中实现一个类的方法，一般如下：// className_method(className *self, parameters...)// 对于每一个类方法的实现，都要将其引用带入。static void __main_block_func_0(struct __main_block_impl_0 *__cself) &#123; printf(\"hello, world!\");&#125;// main函数int main(int argc, const char * argv[]) &#123; // 对应于block赋值操作。 // 在这里，代码将 __main_block_impl_0 结构体指针赋值给block。 void (*block)(void) = ((void (*)())&amp;__main_block_impl_0((void *)__main_block_func_0, &amp;__main_block_desc_0_DATA)); // 分成以下三步操作。 // __block_impl *theBlock = (__block_impl *)block; // void (*funcPtr)(__block_impl *) = ((void (*)(__block_impl *))(theBlock-&gt;FuncPtr); // funcPtr((__block_impl *)block); ((void (*)(__block_impl *))((__block_impl *)block)-&gt;FuncPtr)((__block_impl *)block); return 0;&#125; 可以看到，该block是在栈上开辟的空间，也就是说，当离开 新增的__block关键字，以下代码： 123456789int main(int argc, const char * argv[]) &#123; __block int a = 1; void (^block)(void) = ^void(void)&#123; a = a + 1; printf(&quot;hello, world! %d&quot;, a); &#125;; block(); return 0;&#125; 可以获得： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091// __block 关键字用来生成了一个结构体，这个结构体是一个拥有指向自身地址的指针的结构体。struct __Block_byref_a_0 &#123;// isa指针 void *__isa;// 指向自身的指针 __Block_byref_a_0 *__forwarding; int __flags; int __size;// int a 原型 int a;&#125;;struct __main_block_impl_0&#123; struct __block_impl impl; struct __main_block_desc_0* Desc; //将外部的变量 a 加入到__main_block_impl_0 中。 __Block_byref_a_0 *a; __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, __Block_byref_a_0 *_a, int flags=0) : a(_a-&gt;__forwarding) &#123; impl.isa = &amp;_NSConcreteStackBlock; impl.Flags = flags; impl.FuncPtr = fp; Desc = desc; &#125;&#125;;static void __main_block_func_0(struct __main_block_impl_0 *__cself)&#123; // 在这里，将 block 的 a(指针) 复制进局部变量中。 // 此处是为了保证其原子性。 __Block_byref_a_0 *a = __cself-&gt;a; // 此处对应于block中的实现 (a-&gt;__forwarding-&gt;a) = (a-&gt;__forwarding-&gt;a) + 1; printf(\"hello, world! %d\", (a-&gt;__forwarding-&gt;a));&#125;// 与之前不同，这里新增了2个静态函数。//这里用来对block中的对象进行内存管理，// 在引用计数情况下，可以视为引用计数 +1static void __main_block_copy_0(struct __main_block_impl_0*dst, struct __main_block_impl_0*src)&#123; _Block_object_assign((void*)&amp;dst-&gt;a, (void*)src-&gt;a, 8/*BLOCK_FIELD_IS_BYREF*/);&#125;// 用来对block中的对象进行内存释放// 在引用计数情况下，可以视为引用计数 -1static void __main_block_dispose_0(struct __main_block_impl_0*src)&#123; _Block_object_dispose((void*)src-&gt;a, 8/*BLOCK_FIELD_IS_BYREF*/);&#125;// desc 新增了两个属性// 这两个属性，帮助其释放static struct __main_block_desc_0&#123; size_t reserved; size_t Block_size; void (*copy)(struct __main_block_impl_0*, struct __main_block_impl_0*); void (*dispose)(struct __main_block_impl_0*);&#125; __main_block_desc_0_DATA = &#123; 0, sizeof(struct __main_block_impl_0), __main_block_copy_0, __main_block_dispose_0&#125;;int main(int argc, const char * argv[])&#123; // 将 __block int a 初始化。 // 这里使用了列表初始化的方式将列表中对应的值赋给 a。 // 这里可以看到，a.__forwarding = &amp;a; // 这样，无论是在堆上还是栈上，都可以保证该变量能够准确的被调用。 __attribute__((__blocks__(byref))) __Block_byref_a_0 a = &#123; (void*)0, (__Block_byref_a_0 *)&amp;a, 0, sizeof(__Block_byref_a_0), 1 &#125;; // 对block的赋值和调用 void (*block)(void) = ((void (*)()) &amp; __main_block_impl_0( (void *)__main_block_func_0, &amp;__main_block_desc_0_DATA, (__Block_byref_a_0 *)&amp;a, 570425344)); ((void (*)(__block_impl *))((__block_impl *)block)-&gt;FuncPtr)((__block_impl *)block); return 0;&#125; 带有__block关键字的变量会生成一个新的结构体。这个结构体会保证，该变量能够正确的在block的作用域内进行变量的操作（特指更改变量）。 Block 循环引用首先，观察一段简单的代码： 123456789101112131415161718192021222324252627@interface HelloPrinter : NSObject-(void)sayHello;@end@implementation HelloPrinter-(void)sayHello &#123; printf(&quot;Hello\\n&quot;);&#125;@end int main(int argc, const char * argv[]) &#123; @autoreleasepool &#123; void (^block)(void); &#123; HelloPrinter *printer = [[HelloPrinter alloc] init]; block = ^void(void) &#123; [printer sayHello]; &#125;; &#125; block(); &#125; return 0;&#125; 这里肯定是打印出了 Hello\\n 。 显然，printer只能在当前的作用域内有效，那么可以肯定的是，block持有了printer。也就是printer的引用计数“+1”了，这样，printer才能在作用域外实行-sayHello方法。 对于循环引用的问题，可以观察以下代码： 12345678910111213141516171819202122232425@interface HelloPrinter : NSObject @property (copy) void (^block)(void);-(void)sayHello;@end@implementation HelloPrinter- (instancetype)init&#123; self = [super init]; if (self) &#123; self.block = ^&#123; [self sayHello]; &#125;; &#125; return self;&#125;-(void)sayHello &#123; printf(&quot;Hello\\n&quot;);&#125;@end 首先我们要确定以下两点： block当中的类会对调用实例方法的实例进行引用。 对带有copy，strong，等关键字的属性初始化时，实例会持有这个属性对应的类的引用。 那么，这就可以构成了循环引用的条件，也就是互相引用对方的实例。 要解决以上代码中的循环引用也很简单，如下： 1234567// 使用 __unsafe_unretained 关键字时，当weakSelf在所在的作用域中运行完后，不会设置为 nil。// __unsafe_unretained typeof(self) weakSelf = self;__weak typeof(self) weakSelf = self;self.block = ^&#123; [weakSelf sayHello];&#125;; 小结本篇主要介绍了如何定义Block这种非常有用的数据结构，分析了其内部实现，最最最主要就是对其产生的循环引用进行简单的分析。","categories":[{"name":"Objective-C","slug":"Objective-C","permalink":"http://www.zcating.tk/categories/Objective-C/"}],"tags":[]},{"title":"Objective-C 简析（1）—— ARC篇","slug":"Objective-C 简析（1）—— ARC篇","date":"2018-01-05T11:00:00.000Z","updated":"2019-02-26T14:56:46.280Z","comments":true,"path":"2018/01/05/cjt2znucp000381l3e9bt6qgk/","link":"","permalink":"http://www.zcating.tk/2018/01/05/cjt2znucp000381l3e9bt6qgk/","excerpt":"ARC（Automatic Reference Counting）——自动引用计数是一个编译器的feature，它提供了对Objective-C对象的内存管理，不用再去对对象进行retain或者release操作。","text":"ARC（Automatic Reference Counting）——自动引用计数是一个编译器的feature，它提供了对Objective-C对象的内存管理，不用再去对对象进行retain或者release操作。 内存管理简述要了解ARC，首先就要了解基本的内存管理机制。对于OOP来说，内存管理机制目前主流的方式有两种： 对其对象实例产生的引用进行计数，当计数变为零的时候，释放对象所持有的内存。 另外一种就是可达性分析算法，通过根对象作为起点来生成一棵引用树，通过不同对象的可达性，来对对象的实例进行内存回收。（可能有误，欢迎指出）。 在这里，Objective-C使用了第一种方式作为内存回收机制。图中展示的是一个简单的引用计数情况，他很好的展示了引用计数是如何运行的。 ARC简述ARC 主要的工作是使得OC对象能够在适当的时机合理地释放其内存。当开启ARC的时候，我们不需要手动的添加retain和release，clang编译器会自动评估所有对象的生命周期需求，并且在编译期自动的插入内联代码，使得几乎每一个对象的实例（循环引用？）都可以正确的分配和释放内存。同时，编译器会自动生成dealloc方法，一般来说，我们只需要在对象生成实例的时候分配其内存就OK了。 下图可以很好的展示ARC和非ARC运行耗时关系。这里主要是因为，ARC自动地在需要增加或减少引用计数的代码段中添加了内联汇编。这样，使得整个运行时的代码运行速度有所提升。 ARC的一些新规定以下是一些ARC的使用新规定，如果硬是要使用以下方法或对象，允许并开启ARC的编译器会对该代码进行错误提示，不会编译通过。 不能显式调用dealloc，或者是实现或调用 retain，release， retainCount， autorelease 。但是可以使用CFRetain和CFRelease等Core Foundation形式的对象。 不能使用NSAllocateObject 或者 NSDeallocateObject。 不能在结构体中使用OC的对象。 id和void*之间不能类型转换。 不能使用NSAutoreleasePool对象。 不能使用内存空间对象。 新增修饰符对于property属性，在ARC中，新增了一些新的生命周期修饰符和弱（Weak）引用。弱引用不会延伸到对象的生命周期，并且，当该对象没有任何强引用的时候，会自动设置为nil。 ARC引入了strong和weak作为property的新的attributes，示例代码如下： 1234//ARC开启时，strong是默认的property属性。@property(strong) NSObject *myObject; @property(weak) NSObject *myObject; 对于变量的修饰符，ARC引入了一下关键字： 1234567891011__strong ：对于所有对象变量，默认是__strong来修饰。__weak：不保留对象，只是简单的引用。当对象没有任何强引用的时候，变量会被设置成nil。 __unsafe_unretained： 不保留对象，只是简单引用。但是，当变量没有任何强引用的时候，不会设置为nil。可能会产生野指针的错误。 __autoreleasing： 用于标识(id*)的引用参数，或者需要自动释放的返回的对象。 要定义变量的修饰符，你需要这样来定义： 12345ClassName * qualifier variableName;举个例子：MyClass * __weak myWeakReference;MyClass * __unsafe_unretained myUnsafeReference; 小结这里我主要简单的介绍了内存管理和ARC的相关知识。","categories":[{"name":"Objective-C","slug":"Objective-C","permalink":"http://www.zcating.tk/categories/Objective-C/"}],"tags":[]},{"title":"简单爬虫，抓取近十年来的美剧的ed2k链接","slug":"简单爬虫，抓取近十年来的美剧的ed2k链接","date":"2017-08-12T11:00:00.000Z","updated":"2019-02-20T15:09:54.706Z","comments":true,"path":"2017/08/12/cjt2znudh000r81l3fkfgdfo9/","link":"","permalink":"http://www.zcating.tk/2017/08/12/cjt2znudh000r81l3fkfgdfo9/","excerpt":"最近剧荒，所以有个简单的想法，就是将某个网站上的所有美剧的下载链接爬出来。这个爬虫使用python来编写，编写的时候，使用到了两个经典的模块：BeautifulSoup和requests。这两个库，可以减轻很多的负担，更加专注于爬虫的内容上，而不是网页解析上。当然，可以尝试一下不用他们的时候，感觉会挺痛苦的。","text":"最近剧荒，所以有个简单的想法，就是将某个网站上的所有美剧的下载链接爬出来。这个爬虫使用python来编写，编写的时候，使用到了两个经典的模块：BeautifulSoup和requests。这两个库，可以减轻很多的负担，更加专注于爬虫的内容上，而不是网页解析上。当然，可以尝试一下不用他们的时候，感觉会挺痛苦的。 简单模拟浏览器行为首先，进入这个网站的下载列表页面需要登录才能浏览，也就是说，要模拟它的登录行为。通过对其登录流程抓包，发现，传输的数据如下：1account=zcating&amp;pwd=(明文)&amp;?_=0.32629091765153717 首先，用账户和密码都是明文传输（厉害了…），然后后面的?_是用js内置的随机数，生成的一个32位的浮点数。（登录流程有点粗糙啊…）登录后，这个浮点数将用于鉴权，观察网页的HTTPHeader，其形式如下：12345&apos;Accept&apos;:&apos;text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8&apos;,&apos;Refer&apos;: &apos;http://(网站的域名)/?_=0.32629091765153717&apos;,&apos;Upgrade-Insecure-Requests&apos;: &apos;1&apos;,&apos;User-Agent&apos;: &apos;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/59.0.3071.115 Safari/537.36&apos;,&apos;Cookie&apos;:&apos;一长串的Cookie&apos; 感觉，这是很多年前就采用的一种超级简单的鉴权模式啊，直接采用Cookie的头部应该就能获取下载页面的HTML了。于是，用上面的头部，作为所有请求的HTTP头部，用过requests模拟浏览器请求，可以请求到数据。解决了下载页面获取不了的问题。 列表请求快速获取已经有方法能够进入到下载页面后，就要抓取想要抓取的东西了。首先通过观察，每个下载页面都是这样的一个路由：1/resource/list/（对应剧集的标识符，数字） 那么思路也就是很明了，需要获取的就是这些一系列的对应的剧集的标识符。在这里，网站自带有一个搜索的路由：1/fresourcelist?page=(第几页)&amp;channel=(电影还是剧集)&amp;area=(发布地区)&amp;category=(分类)&amp;year=(年份)&amp;tvstation=(播出频道)&amp;sort=(排列顺序) 该路由，很显然应该通过get请求数据。在这里，我组装的数据是形式如下：12/fresourcelist?page=&#123;&#125;&amp;channel=tv&amp;area=%E7%BE%8E%E5%9B%BD&amp;category=&amp;year=&amp;tvstation=&amp;sort=PS: area=美国(url encode) 由于其每页展示的数量有限，所以通过对网页观察，获取其最大的页面数，通过page={}这种形式，循环去获取每一个页面。由于每一个页面的展示方式相同，这样我们只要对一个页面进行分析就能够获取所有页面的资料。通过浏览器的页面分析，对获取的HTML用BeautifulSoup进行以下解析:1234567891011soup = BeautifulSoup(response.text, &apos;html.parser&apos;)rawPrograms = soup.find(class_= &apos;resource-showlist has-point&apos;)programs = []for x in rawPrograms.findAll(&apos;a&apos;): href = x.get(&apos;href&apos;) if href != None and &apos;resource&apos; in href and x.find(&apos;img&apos;) == None: programTag = href.split(&apos;/&apos;)[2] name = standardized(x.text) program = &#123;&apos;name&apos;: name, &apos;resource&apos;: rawURL + programTag&#125; programs.append(program) program中，包含了一个剧集的名称和其资源标识符。programs则是我所需要的所有的剧集列表。之后，通过循环请求组装好的剧集下载页面，就可以获得所有下载页面的HTML。这里，需要做以下解析：123456789101112131415soup = BeautifulSoup(response.text, &apos;html.parser&apos;)mediaLists = soup.findAll(class_=&apos;media-list&apos;)for mediaList in mediaLists: h2 = mediaList.find(&apos;h2&apos;) noLink = mediaList.find(style=&apos;display: none;&apos;) # 只保留 HR-HDTV 或者 MP4 的下载列表 if h2 == None and h2.text != &apos;HR-HDTV&apos; and h2.text != &apos;MP4&apos; and noLink == None: continue # 只保留 ed2k 类型的下载链接 programs = mediaList.findAll(type=&apos;ed2k&apos;) for program in programs: ed2k = program.get(&apos;href&apos;) file.write(ed2k + &apos;\\n&apos;) 这样，就大功告成。 展示一下成果吧","categories":[{"name":"python","slug":"python","permalink":"http://www.zcating.tk/categories/python/"}],"tags":[]},{"title":"BLE简单重放攻击","slug":"BLE简单重放攻击","date":"2017-04-13T11:00:00.000Z","updated":"2019-02-26T14:18:36.683Z","comments":true,"path":"2017/04/13/cjt2znua5000081l37xsxn8q5/","link":"","permalink":"http://www.zcating.tk/2017/04/13/cjt2znua5000081l37xsxn8q5/","excerpt":"BLE是什么？BLE全称 Bluetooth Low Energy, 即是低功率蓝牙，它比其他传统的蓝牙设备更能控制能耗和成本，所以在发布后就立刻被广泛的应用于各种低功耗设备：运动手环、蓝牙鼠标、蓝牙键盘等。","text":"BLE是什么？BLE全称 Bluetooth Low Energy, 即是低功率蓝牙，它比其他传统的蓝牙设备更能控制能耗和成本，所以在发布后就立刻被广泛的应用于各种低功耗设备：运动手环、蓝牙鼠标、蓝牙键盘等。 BLE简介BLE是什么？BLE全称 Bluetooth Low Energy, 即是低功率蓝牙，它比其他传统的蓝牙设备更能控制能耗和成本，所以在发布后就立刻被广泛的应用于各种低功耗设备：运动手环、蓝牙鼠标、蓝牙键盘等。 BLE和传统蓝牙有着许多的不同之处。他们使用不同的Modulation参数，使用不同的频道，使用不同的频道跳频，使用不同的包格式。但是它们还是会使用传统的主控设备-从属设备模式。 简单分析下面开始简单的蓝牙分析。 蓝牙特点 高可靠性。 低成本，低功耗。 快速启动、瞬间连接。 传输距离极大提高。 较高的安全性。 低数据传输速率。 蓝牙协议栈 应用层：最上面的部分是应用层，GATT和ATT我们可以把她看作是同一层。 Host层：GAP是通用访问配置配置文件，它保证不同的蓝牙设备可以互相发现对方并且建立连接；SM是安全管理层，负责管理安全；L2CAP是逻辑链路控制和适配协议，它负责适配基带中的上层协议。 控制层：Link Layer是链路层，负责数据的传输。BLE Radio PHY是BLE的广播物理层，负责向频道发送广播。HCI是控制接口，主要负责接收信息。 蓝牙通讯过程 GAP-通用访问规范 BLE设备的链接、加密与签名协议的协商都在GAP建立的，比如BLE的两个安全模式，首先是Security Mode1，这个模式主要负责加密，有三个安全等级： LEVEL 1 无认证无加密 LEVEL 2 带加密的未认证配对 LEVEL 3 带加密的认证配对 其次是Security Mode2，这个模式主要是负责签名，有两个安全等级： LEVEL 1 带数据签名的未认证配对 LEVEL 2 带数据签名的认证配对 GATT-通用属性协议 GATT中的三个要素是Profile、Service、Characteristics以及它们的层级关系。其中比较重要的是Service和Characteristics。 Service可以理解为“类”，即功能对象的集合，Characteristics可以理解为“类中的函数”，是GATT中具体的功能对象，每个Service可以包含一个或多个Characteristics。 其实到这里写得还是有点乱，主要就是介绍了蓝牙的特性和协议，下面开始，就要开始比较重要的逆向的部分了。 BLE嗅探BLE嗅探设备介绍 如图，是一个嗅探器（德州仪器（TI）的CC254x系列蓝牙评估模块，配有官方的嗅探器的程序）。先介绍一下，嗅探器的特点： 在蓝牙设备连接前，其会在三个频道发送广播（channel 37 38 39），嗅探器会接收到。 当接收信号的设备发出CONN_REQ建立连接后，蓝牙设备不再向频道 37、38、39 发送广播，此时，他们的连接会重新建立在新的频道上，也就是会跳频。在这之后，他们之间便会进行资料传输。 嗅探器一次只能监听 三个频道中的任意一个（可以选择），当接收信号的设备发出的CONN_REQ信号在当前监听的频道时，我们才能看到他们跳频后传输的信息。 由以上特点，可以知道： 已经建立连接的主从设备，他们中间的交换数据是不会监听到的。 需要知道建立连接主设备的默认地址。 有三分之一的概率是可以监听到跳频后的信息。 在主从设备连接前就要开始监听。 有以上的嗅探工具，就可开始分析蓝牙设备与接收设备之间到底发送了什么信息，然后，伪造BLE的通信，这样便能完成一次完整的重放攻击。需要使用的软硬件有： CSR8510 蓝牙适配器 BlueZ 官方蓝牙协议栈 KALI Linux 发行版 在KALI Linux上安装BlueZ ，然后通过蓝牙适配器来获取发送或者获取信息，通过这样，我们就可以开始进行对蓝牙设备的分析。具体安装过程这里就不透露了，有心者自然可以找到。 蓝牙设备介绍在这里，我们以小米手环作为简单的学习工具。 可以通过蓝牙控制的硬件： 3个LED，可以调控颜色（现在的貌似移除了颜色这个选项了） 电容触摸传感器 震动器 计时器 内部功能： 显示电池状态 存储用户信息 实时步伐通知 存储步伐通知 睡眠监测 BLE嗅探分析连接： 写入一定的数据后，才能进行控制： 发送震动： 发送定时震动： 蓝牙应用逆向分析作为一个运动手环，肯定要收集信息，传输到主设备上，那么肯定有能够解析运动手环数据的软件。 对嗅探结果进行分析后，我发现，必须往AttHandle 0x0019这个地址写入数据，这样继续对蓝牙设备进行操作。也不用做什么简单的分析，应该可以肯定，这些数据就是用户的信息。首先，要对这个小米手环的软件进行简单的逆向。 对小米运动App进行逆向分析，定位到 UserInfo类。 编写这个软件的程序员估计是个宅男，默认初始化的人名使用的是知名影星冲田杏梨。 对这个类交叉编译，可以定位到一个非常有意思的地方。 再次定位，可以找到一个重要的逻辑，将infoBuffer的数据做了个CRC8处理。这里的GATTUtil应该就是蓝牙工具类，可以看出应该是用这个类去发送各种数据到小米手环上。 这个，CRC8算法，就是一个简单的HASH，它做了如下处理，前十九个字节都都是用户的信息，最后一个字节是校验用的。 字节 意义 1~4 UID 5 性别 6 年龄 7 身高 8 体重 9~10 类型 11~19 昵称（前十个字节） 20 校验字节 由于最后重放攻击是使用一个python脚本，所以用python写了这个CRC8。 这里我抓了两组不同的数据，都是从手机发送到蓝牙上的，跑一下上面的python，得到的结果，跟校验位一致。 好了，有了这些，就可以拿去Kali Linux上跑了。 结语最后，通过以上的分析，我们可以通过BlueZ的python封装，完成一个重放攻击脚本，启动定时震动功能。 附：Bluez API 介绍用这个命令扫描当前所有蓝牙设备。 1hcitool scanf 这里，扫描到的设备地址是 88:0F:10:EF:C4:11。 调用以下命令，连接设备 1gatttool -i hci0 -b 88:0F:10:EF:C4:11 -I 之后，用help ，列出所有命令。","categories":[{"name":"逆向分析","slug":"逆向分析","permalink":"http://www.zcating.tk/categories/逆向分析/"}],"tags":[]},{"title":"LeetCode—62th—Unique-Paths","slug":"LeetCode—62th—Unique-Paths","date":"2017-02-16T11:00:00.000Z","updated":"2019-02-20T15:10:24.314Z","comments":true,"path":"2017/02/16/cjt2znudm001381l3etza3y2k/","link":"","permalink":"http://www.zcating.tk/2017/02/16/cjt2znudm001381l3etza3y2k/","excerpt":"这是LeetCode上，关于动态规划的题目。","text":"这是LeetCode上，关于动态规划的题目。 题目描述A robot is located at the top-left corner of a m x n grid (marked ‘Start’ in the diagram below). The robot can only move either down or right at any point in time. The robot is trying to reach the bottom-right corner of the grid (marked ‘Finish’ in the diagram below). How many possible unique paths are there? Above is a 3 x 7 grid. How many possible unique paths are there? 题目翻译一个机器人坐落在一个 m x n 的矩阵的左上方（如图，标记为 ‘Start’）。 这个机器人可以往下或者右进行任意次移动，这个机器人正在尝试到达矩阵的右下方（如图，标记为’End’）。 那么对于每一个矩阵来说，有多少条独立的路径存在？ 解题思路这是一道简单的动态规划问题，令f(x, y)为从起点到点(x, y)的路径的数量。那么，其状态转移方程如下： 1f(x, y) = f(x-1, y) + f(x, y-1) 由于直接从下或者直接从右移动都只有一条路径，所以我们对f(x, y)的第一行和第一列进行初始化。 代码1234567891011121314151617int uniquePaths(int m, int n) &#123; auto dp = vector&lt;vector&lt;int&gt;&gt;(m, vector&lt;int&gt;(n, 0)); dp[0][0] = 1; for(int i = 0; i &lt; n; i++) &#123; dp[0][i] = 1; &#125; for(int i = 0; i &lt; m; i++) &#123; dp[i][0] = 1; &#125; for(int i = 1; i &lt; m; i++) &#123; for(int j = 1; j &lt; n; j++) &#123; dp[i][j] = dp[i - 1][j] + dp[i][j - 1]; &#125; &#125; return dp[m-1][n-1];&#125;","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://www.zcating.tk/categories/Algorithm/"}],"tags":[]},{"title":"LeetCode—63th—Unique-Paths-II","slug":"LeetCode—63th—Unique-Paths-II","date":"2017-02-16T11:00:00.000Z","updated":"2019-02-20T15:10:13.697Z","comments":true,"path":"2017/02/16/cjt2znucs000581l3c0rzqhbu/","link":"","permalink":"http://www.zcating.tk/2017/02/16/cjt2znucs000581l3c0rzqhbu/","excerpt":"这是LeetCode上，关于动态规划的题目。","text":"这是LeetCode上，关于动态规划的题目。 题目描述Follow up for “Unique Paths”: Now consider if some obstacles are added to the grids. How many unique paths would there be? An obstacle and empty space is marked as 1 and 0 respectively in the grid. For example,There is one obstacle in the middle of a 3x3 grid as illustrated below.12345[ [0,0,0], [0,1,0], [0,0,0]] The total number of unique paths is 2. Note: m and n will be at most 100. 题目翻译这是”Unique Path”的续题： 现在我们不妨考虑往矩阵中添加一些障碍物。那么在矩阵上又会存在多少条独立路径呢？ 障碍标记为1，可行结点标记为0。 例如以下矩阵： 12345[ [0,0,0], [0,1,0], [0,0,0]] 它一共有两条独立路径。 注意：m和n最多不会100。 解题思路这一道题跟上面一道题很类似，只是增加了一个障碍物。令f(x, y)为从起点到终点的独立路径的数量，那么状态转移方程如下： 1f(x, y) = f(x - 1, y) + f(x, y - 1) 由于增加了障碍物，我们需要要判断这一结点是否可达，对于点(x, y)，它可达当且仅当点(x-1, y-1)也是可达的。也就是obstacleGrid[x-1][y-1] == 0时，以上状态转移方程才会成立。 对于边界条件，假设我们第一次往右移动，那么就要令f(0, 1) = 1。 有了边界条件和状态转移方程，我们很容易的写出代码，如下： 代码1234567891011121314151617int uniquePathsWithObstacles(vector&lt;vector&lt;int&gt;&gt;&amp; obstacleGrid) &#123; if (obstacleGrid.size() == 0) &#123; return 0; &#125; int n = (int)obstacleGrid.size(); int m = (int)obstacleGrid[0].size(); std::vector&lt;std::vector&lt;int&gt;&gt; dp(n + 1, std::vector&lt;int&gt;(m + 1, 0)); dp[0][1] = 1; for (int i = 1; i &lt;= n; i++) &#123; for (int j = 1; j &lt;= m; j++) &#123; if (obstacleGrid[i-1][j-1] == 0) &#123; dp[i][j] = dp[i - 1][j] + dp[i][j - 1]; &#125; &#125; &#125; return dp[n][m];&#125;","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://www.zcating.tk/categories/Algorithm/"}],"tags":[]}]}