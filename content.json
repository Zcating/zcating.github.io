{"meta":{"title":"Zcat's Studio","subtitle":null,"description":"Simple Coder","author":"Zcating","url":"http://www.zcating.tk"},"pages":[],"posts":[{"title":"用 Angular 写个扫雷","slug":"用 Angular 写个扫雷","date":"2020-05-14T11:00:00.000Z","updated":"2020-05-28T13:54:25.402Z","comments":true,"path":"2020/05/14/ckaum9y7l001pejl314hgtf59/","link":"","permalink":"http://www.zcating.tk/2020/05/14/ckaum9y7l001pejl314hgtf59/","excerpt":"最近想找些项目练练手，发现去复刻一些小游戏还挺有意思的，于是就做了一个网页版的扫雷。 点击这里看看最终的效果。","text":"最近想找些项目练练手，发现去复刻一些小游戏还挺有意思的，于是就做了一个网页版的扫雷。 点击这里看看最终的效果。 创建应用该项目使用的是 monorepo 的形式来存放代码。在 Angular 中，构建 monorepo 方法如下：12ng new simple-game --createApplication=false ng generate application mine-sweeper 在这里，因为该项目以后还会包含其他各种其他的应用，所以个人觉得使用 monorepo 构建项目是比较正确的选择。如果不想使用 monorepo，使用以下命令创建应用：1ng new mine-sweeper 流程图首先，我们先来看看扫雷的基本流程。 数据结构抽象通过观察流程图，可以得到扫雷基本上有这么几种状态： 开始 进行游戏 胜利 失败 方块的状态如下： 它有雷无雷，取决于它的初始设置； 如果没有雷，那么它需要展示附近地雷的数量； 是否已经被打开； 我们可以先定义好这些状态，之后根据不同的状态，执行不同的逻辑，同时反馈给组件。1234567891011121314151617// model.tsexport enum GameState &#123; BEGINNING = 0x00, PLAYING = 0x01, WIN = 0x02, LOST = 0x03,&#125;export interface IMineBlock &#123; // 当前块是否是的内部是地雷 readonly isMine: boolean; // 附近地雷块的数量 readonly nearestMinesCount: number; // 是否已经被点开 readonly isFound: boolean;&#125; 编写逻辑为了使得扫雷的逻辑不跟组件耦合，我们需要新增一个 service。1ng generate service mine-sweeper 现在开始逻辑编写。首先，要存储游戏状态、地雷块、地雷块边长（目前设计的扫雷是正方形）、雷的数量。123456789101112131415161718192021222324252627282930export class MineSweeperService &#123; private readonly _mineBlocks = new BehaviorSubject&lt;IMineBlock[]&gt;([]); private readonly _side = new BehaviorSubject(10); private readonly _state = new BehaviorSubject&lt;GameState&gt;(GameState.BEGINNING); private readonly _mineCount = new BehaviorSubject&lt;number&gt;(10); readonly side$ = this._side.asObservable(); readonly mineBlock$ = this._mineBlocks.asObservable(); readonly state$ = this._state.asObservable(); readonly mineCount$ = this._mineCount.asObservable(); get side() &#123; return this._side.value; &#125; set side(value: number) &#123; this._side.next(value); &#125; get mineBlocks() &#123; return this._mineBlocks.value; &#125; get state() &#123; return this._state.value; &#125; get mineCount() &#123; return this._mineCount.value; &#125; //...&#125; 得益于 Rxjs，通过使用 BehaviorSubject 使得我们可以很方便的将这些状态变量设计成响应式的。 BehaviorSubject 主要功能是提供了一个响应式的对象，使得逻辑服务可以通过这个对象对数据进行变更，并且，组件也可以通过这些对象来监听数据变化。 通过上面的准备工作，我们可以开始编写逻辑函数 start 和 doNext。start的作用是给状态机重新设置状态；而doNext的作用是根据玩家点击的方块的索引对游戏进行状态转移。12345678910111213141516171819202122232425262728293031323334353637export class MineSweeperService &#123; // ... start() &#123; this._mineBlocks.next(this.createMineBlocks(this.side)); this._state.next(GameState.BEGINNING); &#125; doNext(index: number): boolean &#123; switch (this.state) &#123; case GameState.LOST: case GameState.WIN: return false; case GameState.BEGINNING: this.prepare(index); this._state.next(GameState.PLAYING); break; case GameState.PLAYING: if (this.testIsMine(index)) &#123; this._state.next(GameState.LOST); &#125; break; default: break; &#125; if (this.vitoryVerify()) &#123; this._state.next(GameState.WIN); &#125; return true; &#125; // ...&#125; 上面的代码中包含了 prepare, testIsMine, victoryVerify 这三个函数，他们的作用都是进行一些逻辑运算。 我们先看prepare，因为他是最先运行的。这个函数的主要逻辑是通过随机数生成地雷，并且保证使得用户第一次点击地雷块的时候，不会出现雷。配合着注释，我们一行一行的分析它是怎么运行的。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354export class MineSweeperService &#123; private prepare(index: number) &#123; const blocks = [...this._mineBlocks.value]; // 判断index是否越界了 if (!blocks[index]) &#123; throw Error('Out of index.'); &#125; // 将索引位置的块设置为已经打开的状态。 blocks[index] = &#123; isMine: false, isFound: true, nearestMinesCount: 0 &#125;; // 生成随机数数组，其中的随机数不包含 index。 const numbers = this.generateRandomNumbers(this.mineCount, this.mineBlocks.length, index); // 通过随机数数组，设置指定的块为雷。 for (const num of numbers) &#123; blocks[num] = &#123; isMine: true, isFound: false, nearestMinesCount: 0 &#125;; &#125; // 使用横纵坐标遍历所有的地雷块 // 这样做使得我们可以直接通过对坐标的增减来检测当前块附近雷的数量。 const side = this.side; for (let i = 0; i &lt; side; i++) &#123; for (let j = 0; j &lt; side; j++) &#123; const index = transform(i, j); const block = blocks[index]; // 如果当前块是雷，那么不进行检测 if (block.isMine) &#123; continue; &#125; // 进行地雷块的附近的雷的数量检测，形如这样 // x 1 o // 1 1 o // o o o // let nearestMinesCount = 0; for (let x = -1; x &lt;= 1; x++) &#123; for (let y = -1; y &lt;= 1; y++) &#123; nearestMinesCount += this.getMineCount(blocks[transform(i + x, j + y)]); &#125; &#125; // 对附近的地雷的数量进行更新 blocks[index] = &#123; ...block, nearestMinesCount &#125;; &#125; &#125; // 如果点击的位置附近的地雷数量是 0，则需要遍历附近所有的块，直到所有打开的块附近的地雷数量不为零。 if (blocks[index].nearestMinesCount === 0) &#123; this.cleanZeroCountBlock(blocks, index, this.transformToIndex(this.side)); &#125; // 触发更新 this._mineBlocks.next(blocks); &#125;&#125; 再来看testIsMine，其作用是返回一个布尔值，这个布尔值表示用户点击的块是否为地雷。12345678910111213141516171819202122232425262728private testIsMine(index: number): boolean &#123; const blocks = [...this._mineBlocks.value]; if (!blocks[index]) &#123; throw Error('Out of index.'); &#125; // 当前块为设打开状态 const theBlock = &#123; ...blocks[index], isFound: true &#125;; blocks[index] = theBlock; // 如果当前块是地雷，则找出所有是地雷的地雷块，将其状态设置为打开状态。 // 或者如果点击的位置附近的地雷数量是 0，则需要遍历附近所有的块，直到所有打开的块附近的地雷数量不为零。 if (theBlock.isMine) &#123; for (let i = 0; i &lt; blocks.length; i++) &#123; if (blocks[i].isMine) &#123; blocks[i] = &#123; ...blocks[i], isFound: true &#125;; &#125; &#125; &#125; else if (!theBlock.nearestMinesCount) &#123; this.cleanZeroCountBlock(blocks, index); &#125; // 触发更新 this._mineBlocks.next(blocks); // 返回判定结果 return theBlock.isMine;&#125; 那么到了victoryVerify，它的作用很明显，就是进行胜利判定：当未打开的块的数量等于设定的地雷数量相等的时候，可以被判定为用户胜利。123456private vitoryVerify() &#123; // 对当前地雷块数组进行 reduce 查找。 return this.mineBlocks.reduce((prev, current) =&gt; &#123; return !current.isMine &amp;&amp; current.isFound ? prev + 1 : prev; &#125;, 0) === this.mineBlocks.length - this.mineCount;&#125; 现在我们已经介绍完这三个函数，下面将分析cleanZeroCountBlock是如何运行的。他的作用就是为了打开当前块附近所有为零的块。12345678910111213141516171819202122private cleanZeroCountBlock(blocks: IMineBlock[], index: number) &#123; const i = index % this.side; const j = Math.floor(index / this.side); // 对其附近的8个块进行检测 for (let x = -1; x &lt;= 1; x++) &#123; for (let y = -1; y &lt;= 1; y++) &#123; const currentIndex = this.transformToIndex(i + x, j + y); const block = blocks[currentIndex]; // 不为原始块，且块存在，且未打开，且不是地雷 if (currentIndex === index || !block || block.isFound || block.isMine) &#123; continue; &#125; // 将其设为打开状态 blocks[currentIndex] = &#123; ...block, isFound: true &#125;; // 递归查询 if (blocks[currentIndex].nearestMinesCount === 0) &#123; this.cleanZeroCountBlock(blocks, currentIndex); &#125; &#125; &#125;&#125; 到这里，我们基本已经编写完扫雷的具体逻辑。其他相关函数，可以查阅源码，不再赘述。 实现页面到了这一步，其实就已经完成了大部分的工作，我们根据响应式对象编写组件，然后给dom对象添加点击事件，并触发相关的逻辑函数，之后再做各种的错误处理等等。页面代码就不贴在这里，在Github上可以查看源码。 源码以及参考最后，如果有写得不好或者存在错误的地方，欢迎提出批评和修改建议，感谢您的阅读。 Mine Sweeper 源码 Angular 官方文档 Rxjs 官方文档","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://www.zcating.tk/categories/JavaScript/"}],"tags":[]},{"title":"前端知识点梳理","slug":"前端知识点梳理","date":"2020-04-21T14:06:24.659Z","updated":"2020-04-21T14:06:24.659Z","comments":true,"path":"2020/04/21/ckaum9y7p0021ejl38qzqocvt/","link":"","permalink":"http://www.zcating.tk/2020/04/21/ckaum9y7p0021ejl38qzqocvt/","excerpt":"本文会持续不定期更新。","text":"本文会持续不定期更新。 浏览器渲染原理 将 HTML 解析成 DOM。 将 CSS 解析成 CSSOM。 将 HTML 与 CSS 合成渲染树。 计算渲染树上节点的位置。 绘制每一个渲染树上的节点。 浏览器优化 浏览器本身优化，维护一个操作队列，达到一定数量或者时间的时候，运行操作队列中的操作，并且把队列清空。这样就会让多次回流和重绘变成一个。 直接改变元素的 className 缓存布局信息 离线dom操作（先设置父元素 display:none，然后操作子元素，然后再设置父元素为原来的值。) 优化动画效果（通过设置 transform3d） 重绘和回流当render tree中的一部分(或全部)因为元素的规模尺寸，布局，隐藏等改变而需要重新构建。这就称为回流(其实我觉得叫重新布局更简单明了些)。每个页面至少需要一次回流，就是在页面第一次加载的时候。 当render tree中的一些元素需要更新属性，而这些属性只是影响元素的外观，风格，而不会影响布局的，比如background-color。则就叫称为重绘。 回流一定会触发重绘。 HTMLmeta viewport 是做什么用的，怎么写？meta标签主要是用来标记元数据，他是用来描述数据的数据，不会显示在页面上，但是机器可以识别它。它常用于定义页面的说明，关键字，最后修改日期，和其他。这些元数据将服务于浏览器（如何布局或重载页面），搜索引擎或者其他网络服务。 meta是通过key和content来定义数据，viewport就是meta中的一种数据形式，viewport是可以看到web内容的窗口区域，通常与渲染出来的页面不同，这种情况下浏览器会提供滚动条访问所有内容。 JS 相关知识点总结原型链构造一个对象，其原型链结构如下： 123456789101112131415function Foo() &#123;&#125;const foo = new Foo();foo.__proto__ === Foo.prototype // trueFoo.prototype.__proto__ === Object.prototype // trueObject.prototype.__proto__ === null // trueFoo.__proto__ === Function.prototype // trueFunction.prototype.__proto__ = Object.prototype // true 什么是闭包？什么是匿名函数？闭包是指有权访问另一个函数作用域中的变量的函数。 匿名函数是指 JS垃圾回收机制新生代和老生代，新生代分为两个相等区块，from 和 to。分配对象的时候现在 from 区块进行分配，回收的时候，清理无用对象，将 from 中存活的对象移动到 to 中，然后反转。循环多次后，将多次存活的对象移动到老生代。老生代又有两种方式，一种是标记清除，将所有老生代中的无用对象全部清除，但是会导致内存碎片。一种是标记整理，将无用对象清除后，会将存活的对象移动到一端，减少内存碎片。 Eventloopjs的执行顺序是单线程的，为了使得各个任务之间不阻塞，而使用了异步。又分为浏览器的事件循环和nodejs的事件循环。 浏览器事件循环 首先执行script，script被称为全局任务，也属于宏任务; 每一个宏任务执行完毕后，都会执行所有的微任务； 微任务全部执行完，再取任务队列中的一个宏任务执行； ES6 新特性http://caibaojian.com/es6/generator.html let , const 和 var 的区别 let，const 不会变量提升，而 var 会变量提升。 let 和 var 定义的变量可以再次赋值。 用 const 定义的变量不可再赋值，如果该变量是一个对象，那么其内部的可变性不受 const 影响 。 如何实现深拷贝？简单的做法：const deepCopy = JSON.parse(JSON.stringify(object)); 困难的做法：编写函数，递归拷贝对象。 不用class如何实现继承？用class又是如何实现？直接使用 寄生组合继承 123456789101112131415161718192021222324252627function Person(firstname, lastname) &#123; this.firstname = firstname; this.lastname = lastname;&#125;function Object(o) &#123; function F()&#123;&#125; F.prototype = o; return new F();&#125;// 重点function inheritPrototype(subType, superType) &#123; // create Object var prototype = new superType.prototype(); // enhance Object prototype.constructor = subType; // point Object subType.prototype = prototype; &#125;Student.prototype = Object.create(Person.prototype);function Student(firstname, lastname) &#123; Person.call(this, firstname, lastname);&#125;inheritPrototype(Student, Person); 使用class 123456789101112class Person &#123; constructor (firstname, lastname) &#123; this.firstname = firstname; this.lastname = lasename; &#125;&#125;class Student extend Person &#123; constructor (firstname, lastname) &#123; super(firstname, lastname); &#125;&#125; 实现数组去重？123456789101112131415// ES6:function removeDuplication(array) &#123; return [...( new Set(array))];&#125;// ES5:function removeDuplication(array) &#123; var map = &#123;&#125;; array.forEach(value =&gt; &#123; map[value] = true; &#125;); return Object.keys(map).map(value=&gt;&#123; return value; &#125;);&#125; 手写 call，apply，bind12345678910111213141516171819202122232425262728293031323334Function.prototype.myApply = function (context, args) &#123; args = args ? args : []; if (context) &#123; const key = Symbol(); context[key] = this; // 把 this 挂载到 context const result = context[key](...args); delete context[key]; return result; &#125;&#125;Function.prototype.myCall = function (context, ...args) &#123; args = args ? args : []; if (context) &#123; const key = Symbol(); context[key] = this; // 把 this 挂载到 context const result = context[key](...args); delete context[key]; return result; &#125;&#125;Function.prototype.myBind = function (context, ...args) &#123; const fn = this; args = args ? args : []; return function newFn(...newFnArgs) &#123; if (this instanceof newFn) &#123; return new fn(...args, ...newFnArgs); &#125; return fn.apply(context, [...args, ...newFnArgs]); &#125;&#125; 移动端问题移动端高清 DPR = device pixel / css pixel 1px 解决方案 使用border-image、background-image，缺点：修改颜色麻烦，圆角处理麻烦。 box-shadow，缺点：safari不支持小数设置 伪类 + transform SVG viewport + rem 移动端点击穿透上层元素A绑定了tap事件，下层元素B绑定了click事件，当我们点击A时，A元素隐藏，此时也会触发下层B元素的click事件。原因就是当上层A的tap事件发生后，其实是touchend结束后，会触发click事件，因为这几个事件的触发顺序时touchstart-touchmove-touchend-click。因此，当click事件触发300ms后，上层的A元素已经消失，此时真正点击的就相当于下层B元素，因此会发生点击穿透事件。 解决方案： 都使用click和tap事件， 或者在click事件触发前阻止，在touchend事件中使用e.preventDefault(); 使用 fast-click库 框架React 和 Vue 之间的区别React 和 Vue 都是基于 Virtual DOM 而开发的框架，他们最主要的区别就是在于 DOM 状态变更 的方式，React 采用的是 Push 模式，而 Vue 采用的是 Pull 模式，两个模式各有优缺点。 Push：意味着，开发者需要通过手动调用 setState 来触发状态变更。 Pull：意味着，开发者只需要变更数据即可更新。 那么这最终影响到的是 React 的优化。React 优化通过 React Fiber 来实现，React Fiber 通过时间切片来实现。 Vue 相关问题watch、computed、methods区别？ Watch 用于监听data中的变量的变化。 computed 是计算属性，顾名思异，就是用来获取计算结果的属性，主要的目的是为了简化模板中的声明式逻辑。它是通过以来进行缓存，只有依赖变换，他才会变化。 method是方法属性，它不会对任何返回值进行缓存，就是用来存储函数逻辑。 VUE生命周期钩子函数？ beforeCreate: 在整个应用创建之前的钩子 created：实例化data中的数据，对data中的数据进行监听。 beforeMount: dom加载完毕，Virtual DOM 挂载之前。 mounted: Virtual DOM 挂载完毕。 beforeUpdate: 数据变更， Virtual DOM 开始重渲染前的钩子 update: Virtual DOM渲染完毕 beforeDestroy: vm.$destroy()调用的时候，会执行这个钩子，然后再销毁监听者，组件以及事件监听器 destroyed：销毁完毕后的调用 Nuxt.js 生命周期created 会在服务端调用，而mounted会在客户端调用。 如何做到数据响应式？Vue2通过Object.defineProperty()； Vue3 使用Proxy 。 Vue.set怎么使用？Vue.set(target, key, value)向响应式对象添加一个属性，并且确保这个新属性是响应式的，且触发视图更新。必须用于向响应式对象（$data）对象上添加新属性，因为Vue无法探测新增属性。 路由守卫是什么？是用来管理路由跳转的工具。 导航守卫 Vuex是什么？Vuex是vue的状态管理工具。 网络网络协议层分为以下五层： 物理层 数据链路层 网络层 传输层 应用层 HTTP2特性 是二进制的，代替原有的文本 是多路复用的，代替原来的序列和阻塞机制 所以可以在一个连接中并行处理 压缩头部信息减小开销 允许服务器主动推送应答到客户端的缓存中 Cache-control字段解析 字段 解释 no-cache 当客户端请求时携带这个首部字段的时候，通过中间的缓存服务器时，会不去拿缓存资源，而是让中间服务器转发给资源服务器，资源服务器看看一下这个资源过期没有，如果没有就会告知中间服务器，可以使用缓存资源。否则资源服务器就会直接返回新的资源。 no-store 表示不会将任何信息持久化到任何缓存中，无论是私有与否。任何带有 no-store 指令的资源都将始终命中网络，没有例外。 max-age max-age指令标示了客户端不愿意接收一个age大于设定时间的响应，这个字段表达是最大缓存时长，请求中单单添加这个字段，实现不了缓存时长，必须结合响应的max-age。 max-stale 指客户机可以接收超出超时期间的响应消息。如果指定max-stale消息的值，那么客户机可以接收超出超时期指定值之内的响应消息。 Public 指响应可被任何缓存区缓存。 Private 指对于单个用户的整个或部分响应消息，不能被共享缓存处理。这允许服务器仅仅描述当用户的部分响应消息，此响应消息对于其他用户的请求无效。 安全跨域：原因：浏览器同源策略（同协议、同域名、同端口，）。而这又分为两种不同的策略： DOM同源策略：禁止操作不同源的DOM，主要针对 iframe。 XHR同源策略：禁止使用XHR对象向不同源的服务器地址发起HTTP请求。 解决跨域可以用以下这些方法：跨域资源共享，JSONP，代理服务器、webSocket 等。 跨域资源共享在服务的设置 Access-Control-Allow-Origin：允许查询接口的域 Access-Control-Allow-Credentials：是否允许带上 cookies Access-Control-Request-Method：允许查询接口的方法 JSONP：通过 &lt;script&gt;标签请求不跨域来处理，但是只能处理GET请求。 代理服务器通过 nginx 等代理服务器进行反向代理，然后通过配置代理转发服务器接口到指定域名即可实现跨域资源访问。 WebSocketWebSocket 可以实现跨域访问。 XSS （跨站脚本攻击） 类型 存储区 插入点 攻击方式 存储性 XSS 后端数据库 HTML 1. 攻击者将恶意代码提交到目标网站的数据库中。 2. 用户打开目标网站时，网站服务端将恶意代码从数据库取出，拼接在 HTML 中返回给浏览器。 3. 用户浏览器接收到响应后解析执行，混在其中的恶意代码也被执行。 4. 意代码窃取用户数据并发送到攻击者的网站，或者冒充用户的行为，调用目标网站接口执行攻击者指定的操作。 反射型 XSS URL HTML 1. 攻击者构造出特殊的 URL，其中包含恶意代码。 2. 用户打开带有恶意代码的 URL 时，网站服务端将恶意代码从 URL 中取出，拼接在 HTML 中返回给浏览器。 3. 用户浏览器接收到响应后解析执行，前端 JavaScript 取出 URL 中的恶意代码并执行。 4. 恶意代码窃取用户数据并发送到攻击者的网站，或者冒充用户的行为，调用目标网站接口执行攻击者指定的操作。 DOM型 XSS 后端数据库/前端存储/URL 前端JavaSript 1. 攻击者构造出特殊的 URL，其中包含恶意代码。 2. 用户打开带有恶意代码的 URL。 3. 用户浏览器接收到响应后解析执行，前端 JavaScript 取出 URL 中的恶意代码并执行。 4. 恶意代码窃取用户数据并发送到攻击者的网站，或者冒充用户的行为，调用目标网站接口执行攻击者指定的操作。 防范： 反射型：输入过滤，纯前端渲染，对 HTML 做充分转义。 存储型：输入过滤，纯前端渲染，对 HTML 做充分转义。 DOM型：在使用 .innerHTML、.outerHTML、document.write() 时要特别小心，不要把不可信的数据作为 HTML 插到页面上，而应尽量使用 .textContent、.setAttribute() 等。 CSRF(跨站请求伪造)是指攻击者通过设置好的陷阱，强制对已经完成认证的用户进行非预期的个人信息或者设定信息等某些状态更新，属于被动攻击。主要出现原因是浏览器在发送同源请求的时候会自动带上Cookies 防范： 同源检测 CSRF Token 其他性能优化性能优化的主要目标就是提高用户体验，减少卡顿。 主要思路有这些： 懒加载。 将耗时操作放入到异步队列或者其他线程。 减少或者合并网络请求。 懒加载：将首次需要展示的数据首先展示，不需要展示的数据不请求，当用户触发了需要展示的数据后，才会从服务器请求数据。 异步耗时操作：通过时间分片的形式，把耗时任务分割成不同的小任务，然后将小任务放入 requestAnimationFrame 中，如果不在当前的会话Tab中，requestAnimationFrame不会执行，而setTimeout 和 setInterval 会执行。 web worker 耗时任务：通过将耗时任务放入 web worker 中，使得耗时任务不阻塞 js 线程，不过有限制，该耗时任务不能操作DOM。 WASM：将耗时操作编译成 WASM，然后单独引入到代码中并运行。 使用GraphQL：可以一次获取所有想要的结果。 使用HTTP2：根据HTTP2多路复用、头部压缩等特性，降低请求压力。多路复用意味着多个一个请求可以在同一个 TCP/IP 连接上发送，减轻了服务器的负担。同时 HTTP2 可以对数据进行分帧，这样，数据就可以并行发出，并行接收，同时保证数据不会打乱。头部压缩也有可以提高传输的速度。","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://www.zcating.tk/categories/JavaScript/"}],"tags":[]},{"title":"一文理解 Angular NgZone","slug":"一文理解-Angular-NgZone","date":"2020-01-30T11:00:00.000Z","updated":"2020-05-14T14:51:57.900Z","comments":true,"path":"2020/01/30/ckaum9y7d0013ejl3gqro62vd/","link":"","permalink":"http://www.zcating.tk/2020/01/30/ckaum9y7d0013ejl3gqro62vd/","excerpt":"使用 Angular 开发的过程中，可能会有意想不到的一些性能问题存在，意味着，在一些异步调用比较频繁的代码中，如果不注意就可能就会导致页面卡顿。那么为了解决这个问题，我们需要通过 NgZone 来对某些一些比较频繁的异步操作进行隔离，并对其回调进行特定响应。因为异步操作都会触发变更检测，而变更检测在此时对于我们来说有点多余，尽管文档上说，变更检测的速度很快，但是无用的变更检测对Web的性能仍然使有影响，所以为了减少这些无用的变更检测，就需要 NgZone。","text":"使用 Angular 开发的过程中，可能会有意想不到的一些性能问题存在，意味着，在一些异步调用比较频繁的代码中，如果不注意就可能就会导致页面卡顿。那么为了解决这个问题，我们需要通过 NgZone 来对某些一些比较频繁的异步操作进行隔离，并对其回调进行特定响应。因为异步操作都会触发变更检测，而变更检测在此时对于我们来说有点多余，尽管文档上说，变更检测的速度很快，但是无用的变更检测对Web的性能仍然使有影响，所以为了减少这些无用的变更检测，就需要 NgZone。 NgZone API为了使用NgZone，我们需要了解一些其包含了那些接口，在这里，我们只需要关注以下四个接口。 12345678class NgZone &#123; // ... run&lt;T&gt;(fn: (...args: any[]) =&gt; T, applyThis?: any, applyArgs?: any[]): T; runTask&lt;T&gt;(fn: (...args: any[]) =&gt; T, applyThis?: any, applyArgs?: any[], name?: string): T; runGuarded&lt;T&gt;(fn: (...args: any[]) =&gt; T, applyThis?: any, applyArgs?: any[]): T; runOutsideAngular&lt;T&gt;(fn: (...args: any[]) =&gt; T): T;&#125; runNgZone.run 接受三个参数，fn、applyThis、applyArgs。其中 fn 是具体调用的函数，applyThis 和 applyArgs是 fn 所绑定的上下文和具体传入的参数，其返回值是把 fn 的返回值作为返回值。 这个函数的作用是为了使 fn 中的异步任务能够重新回到 Angular Zone 中。也就是说所有在调用的即将到来的宏任务和微任务都将在 Angular Zone 的上下文中执行（也就是触发变更检测）。并且这个函数使同步运行的。 runTaskNgZone.runTask 接受三个参数，fn、applyThis、applyArgs。其中 fn 是具体调用的函数，applyThis 和 applyArgs是 fn 所绑定的上下文和具体传入的参数，其返回值是把 fn 返回的值作为返回值。 这个函数的作用是仍然是使 fn 中的异步任务能够重新回到 Angular Zone 中。但是有一点，fn这个函数是作为同步任务执行，也就是在执行完毕后，会触发一次变更检测。 runGuardedNgZone.runGuarded 接受三个参数，fn、applyThis、applyArgs。其中 fn 是具体调用的函数，applyThis 和 applyArgs是 fn 所绑定的上下文和具体传入的参数，其返回值是把 fn 返回的值作为返回值。 这个函数跟 run 一样，只不过它将异常捕获，并由 NgZone.onError 发出错误。 runOutsideAngularNgZone.runGuarded 接受三个参数，fn、applyThis、applyArgs。其中 fn 是具体调用的函数，applyThis 和 applyArgs是 fn 所绑定的上下文和具体传入的参数，其返回值是把 fn 返回的值作为返回值。 这个函数作用是将 fn 脱离 Angular Zone 来运行，这样 fn 中的所有任务都不会触发 Angular 变更检测和错误检测。 例子一：拖拽事件这个例子很好的说明了，并不是所有的异步事件都需要触发变更检测。 首先先看看代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849@Component(&#123; selector: 'app-root', template: ` &lt;div #myDiv style=\"position: fixed; top: 100px; left: 100px; width: 100px; height: 100px; background: red;\" draggable=\"true\" &gt;&lt;/div&gt; &lt;span&gt;div top: &#123;&#123;top&#125;&#125;&lt;/span&gt; `, styleUrls: ['./app.component.less']&#125;)export class AppComponent implements OnInit, AfterViewChecked &#123; @ViewChild('myDiv', &#123; static: true &#125;) div?: ElementRef&lt;HTMLDivElement&gt;; top = 100; ngOnInit() &#123; if (this.div) &#123; const div = this.div.nativeElement; let dragged: HTMLDivElement; div.addEventListener('dragstart', (event) =&gt; &#123; const target = (event.target as HTMLDivElement); target.style.opacity = '1'; target.style.cursor = 'pointer'; dragged = target; &#125;); div.addEventListener('drag', (event: DragEvent) =&gt; &#123; event.preventDefault(); const target = (event.target as HTMLDivElement); target.style.opacity = '0'; target.style.cursor = 'pointer'; &#125;); div.addEventListener('dragend', (event: DragEvent) =&gt; &#123; const target = (event.target as HTMLDivElement); target.style.opacity = '1'; target.style.top = `$&#123;event.y&#125;px`; target.style.left = `$&#123;event.x&#125;px`; this.top = event.y; &#125;); &#125; &#125; ngAfterViewChecked() &#123; console.log('hello'); &#125;&#125; 我设计了很简单的一个拖拽的方案，拖拽结束后，会展示这个 div 的 top。虽然这个方案没有正确计算拖拽结束后的位置，但是这并不影响我想要说明的结果。很显然，我只需要在 dragend 中触发一次变更检测，就能完成我们想要的结果，但是可以看看控制台，一次简单的拖拽会触发上百次的变更检测。 那么为了减少拖拽过程中的变更检测，我们通过依赖注入，获取到 NgZone 的实例，并且，将 dragstart &amp; drag事件放入 runOutsideAngular 中： 1234567891011121314151617181920constructor(private zone: NgZone) &#123;&#125;ngOnInit() &#123; ... this.zone.runOutsideAngular(() =&gt; &#123; div.addEventListener('dragstart', (event) =&gt; &#123; const target = (event.target as HTMLDivElement); target.style.opacity = '1'; target.style.cursor = 'pointer'; dragged = target; &#125;); div.addEventListener('drag', (event: DragEvent) =&gt; &#123; event.preventDefault(); const target = (event.target as HTMLDivElement); target.style.opacity = '0'; target.style.cursor = 'pointer'; &#125;); &#125;); ...&#125; 这样再看，每次拖拽都只会打印一次 hello，那也就说明了，只触发了一次变更检测。 例子二：拖拽封装为了更好的提供复用性，有时候我们对外暴露的只是一个简单的Observable，那么使用起来可能就是对Observable 进行 subscribe 。 12345678910111213141516171819202122232425262728293031323334class Dragger &#123; private drag = new BehaviorSubject&lt;DragEvent | null&gt;(null); private dragStart = new BehaviorSubject&lt;DragEvent | null&gt;(null); private dragEnd = new BehaviorSubject&lt;DragEvent | null&gt;(null); drag$: Observerable&lt;DragEvent&gt; = drag.asObservable(); dragStart$: Observerable&lt;DragEvent&gt; = dragStart.asObservable(); dragEnd$: Observerble&lt;DragEvent&gt; = dragEnd.asObservable(); constructor(private div: HTMLDivElement) &#123; div.addEventListener('dragstart', (event) =&gt; &#123; const target = (event.target as HTMLDivElement); target.style.opacity = '1'; target.style.cursor = 'pointer'; dragStart.next(event); &#125;); div.addEventListener('drag', (event: DragEvent) =&gt; &#123; event.preventDefault(); const target = (event.target as HTMLDivElement); target.style.opacity = '0'; target.style.cursor = 'pointer'; drag.next(event); &#125;); div.addEventListener('dragend', (event: DragEvent) =&gt; &#123; const target = (event.target as HTMLDivElement); target.style.opacity = '1'; target.style.top = `$&#123;event.y&#125;px`; target.style.left = `$&#123;event.x&#125;px`; dragEnd.next(event); &#125;); &#125;&#125; 这样进行封装后，我们在组件中就可以这样调用： 123456789101112131415161718// 为了方便，不使用 DIprivate dragger?: Dragger;private readonly unsubscribe$ = new Subject&lt;void&gt;();ngOnInit() &#123; if (this.div) &#123; this.dragger = new Dragger(this.div); this.dragger.dragEnd$.pipe(this.unsubscribe$).subscribe((event) =&gt; &#123; this.top = event.y; &#125;) &#125;&#125;ngOnDestroy() &#123; this.unsubscribe$.next(); this.unsubscribe$.complete();&#125; 但是，例子一的问题仍然存在，所以我们需要这样初始化我们的 dragger 。 12345678ngOnInit() &#123; if (this.div) &#123; this.dragger = this.zone.runOutsideAngular(() =&gt; new Dragger(this.div)); this.dragger.dragEnd$.pipe(this.unsubscribe$).subscribe((event) =&gt; &#123; this.top = event.y; &#125;); &#125;&#125; 但是这样做会有问题，dragEnd$ 并不能触发变更检测，也就是 top 不会在拖拽后更新。为了能够触发同步的变更检测，我们需要这样做。 12345678910111213141516ngOnInit() &#123; if (this.div) &#123; this.dragger = this.zone.runOutsideAngular(() =&gt; &#123; return new Dragger(this.div.nativeElement); &#125;); this.dragger.dragEnd$.pipe( takeUntil(this.unsubscribe$) ).subscribe((event) =&gt; &#123; if (event) &#123; this.zone.run(() =&gt; &#123; this.top = event.y; &#125;); &#125; &#125;); &#125;&#125; 总结本文通过具体的例子总结了 NgZone 的具体使用方法。其主要目的还是为了优化变更检测机制，以便能优化性能。","categories":[],"tags":[]},{"title":"简单介绍NgRx","slug":"简单介绍NgRx","date":"2019-12-10T12:36:46.201Z","updated":"2019-11-18T12:44:09.193Z","comments":true,"path":"2019/12/10/ckaum9y7o001zejl325a2852f/","link":"","permalink":"http://www.zcating.tk/2019/12/10/ckaum9y7o001zejl325a2852f/","excerpt":"深度使用了一个星期的NgRx，虽然感觉很啰嗦，但是实实在在的能够规范代码结构，同时也能够很好的规范其他一同协作的同事的代码。在我看来，管理数据一直都是所有大型应用的挑战，如何有效的管理数据成为了重中之重，因为说到底，我们一直都是在和数据打交道。","text":"深度使用了一个星期的NgRx，虽然感觉很啰嗦，但是实实在在的能够规范代码结构，同时也能够很好的规范其他一同协作的同事的代码。在我看来，管理数据一直都是所有大型应用的挑战，如何有效的管理数据成为了重中之重，因为说到底，我们一直都是在和数据打交道。 在 Angular 中，我们有很多种模式来管理我们的数据。最常用的就是通过依赖注入和 Rxjs 来监听数据变更。使用Rxjs来管理数据在 Angular 中是非常合适的，因为最佳实践就推荐深度的和 Rxjs 结合。通过BehaviorSubject，可以有效的对数据进行监听和变更，然而，它的使用需要写大量这样的模板代码。 12private _some = new BehaviorSubject&lt;any&gt;(&#123;&#125;);public some$ = this._some.asObservable(); 同时，过于碎片化的数据管理，容易使得代码的编写变形，也不适合于协同合作。当然在这列举的只是使用上的一些问题，不过，有更好的响应式状态管理的技术来帮助你进行数据管理，这个解决方案就是 NgRx。 NgRx 是一个为 Angular 应用提供了响应式的状态管理的开源库。因为受到了 Redux 的启发，NgRx 也采用了将 Angular 应用中的数据作为单一数据源进行维护的解决方案。NgRx 使用 Rxjs 来跟 store 进行交互，这个 store 连接到组件（component）和服务（service）上，并最终简化了数据管理的整个流程。它不负责组件间以及组件服务间的通信，而是通过单一数据源来管理它们。使用NgRx，你就可以根据应用程序的整体状态而不是单个组件来处理应用程序。 NgRx是如何工作的NgRx包含了以下五个部分： Store Reducers(和 Meta-Reducers) Actions Selectors Effects 具体实现如下图所示： 应用的状态由 store 维护，store 是不可变的。 应用的组件可以订阅store，同时可以自动更新store通过selectors。 selectors 允许组件去获取应用的一部分状态，同时允许组件用 selector functions 变更状态。 actions 可以通过使用 reducers 来变更 store 的状态，reducers 可以允许变更store 的同时保持它的不可变性。 Meta-Reducers 是可以在预处理 actions 之前调用的 hooks。 Effects 是 actions 的结果，也可以在调用的时候创建actions。Effects 主要的职责是在于创建异步副作用操作，并最终生成其他 actions。 以上这种具体的抽象，解决了传统前端应用的数据管理难题，同时，也提供了一个普适性的架构来帮助开发者构建他们的应用。 NgRx可以简化应用的架构，因为你可以使用它来取代组件或服务中的 property 和 event bindings，显然，它提供了这么一个概念：一切 property都是store的state，一切的 event bindings 都是 store的effect。不过，不同的项目有不同的做法，你可以使用它，当然也可以跟其他方法一起结合使用，或者根本不用NgRx，这取决于你个人使用情况以及项目的大小来决定的。 NgRx 的使用经历了多个版本的变化，NgRx 最新版本的使用方式已经跟之前版本有了很大的变化。但是总体的构建思路还是跟之前的一样，下面将一个获取用户信息的代码为例。 首先，安装 NgRx。 1234ng add @ngrx/store ng add @ngrx/effect ng add @ngrx/store-devtools ng add @ngrx/schematics 其中原理图和开发工具属于可选。输入完命令后，可以看具体目录结构如下。 123456src/app├── components├── reducers│ └── index.ts└── effects └── app.effect.ts 文件结构因人而异，我习惯把action，selector，reducer，和 state 写在同一个文件中，effect 单独写在一个文件中。 action &amp; selector &amp; reducer使用NgRx自带的工厂函数来构建 action，selector，reducer 可以构建出类型安全的代码。 首先构建 AppState 下的各种子 state： （在 index.ts 中) 1234567891011interface AppState &#123; userState: UserInfo;&#125;;export const initAppState: AppState = &#123; userState: initUserState&#125;;export const appReducers: ActionReducerMap&lt;AppState&gt; = &#123; userState: userReducer&#125;; (在 user.recducers.ts 中) 1234interface UserState &#123; userInfo: UserInfo;&#125;export const init 使用createAction 创建 action。 (在 user.recducers.ts 中) 1234567export const getUserInfo = createAction(&apos;[User] get user info&apos;);export const getUserInfoSuccess = createAction( &apos;[User] get user info success&apos;, props&lt;&#123; userInfo: UserInfo &#125;&gt;()) 使用createReducer + on 来构建 reducer。 (在 user.recducers.ts 中) 12345export const userReducer = createReducer( initUserState, on(getUserInfo, state =&gt; state), on(getUserInfoSuccess, (state, action) =&gt; (&#123;...state, ...action&#125;))); 使用 createSelector 创建 selector。 1234export const userInfoSelector = createSelector( (state) =&gt; state.userState, (state) =&gt; state.userInfo); 使用 createEffect 来构建 effect。 (在 app.effect.ts 中) 1234567891011121314@Injectable()export class AppEffects &#123; getUserInfo$ = createEffect(() =&gt; this.actions$.pipe( ofType(getUserInfo), mergeMap(() =&gt; this.userService.getUserInfo$()), map(info =&gt; getUserInfoSuccess(&#123;userInfo: info&#125;)) )); constructor( private actions$: Actions, private userService: UserService ) &#123;&#125;&#125; 最重要的一步，通过组件调用 action，通过监听action调用组件。 1234567891011121314151617181920212223userInfo$ = this.store.pipe(select(userInfoSelector));private destroy$ = new Subject&lt;void&gt;();constructor(private store: Store&lt;AppState&gt;, private actions$: Actions) &#123;&#125;ngOnInit() &#123; this.store.dispatch(getUserInfo()); this.actions$.pipe( ofType(getUserInfoSccess), takeUntil(this.destroy$) ).subscribe(() =&gt; &#123; console.log(&apos;get user info success&apos;); &#125;);&#125;ngOnDestroy() &#123; this.destroy$.next(); this.destroy$.complete();&#125; 这样一个完整的NgRx框架就搭建完毕，之后需要如何更新你的业务数据，也只需要构造state，action，selector 和 reducer。 总结本文简单的描述了 NgRx 框架出现的原因，以及其工作原理，并简单的介绍了其使用方法。在我深度使用完NgRx后，会出下一篇关于 NgRx 相关的技术文章。","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://www.zcating.tk/categories/JavaScript/"}],"tags":[]},{"title":"在 React 中使用 Redux-observable & Redux-rx-creator 来隔离副作用","slug":"在-React-中使用-redux-observable-&-redux-rx-creator-来隔离副作用","date":"2019-11-18T13:36:44.964Z","updated":"2019-11-18T13:36:44.964Z","comments":true,"path":"2019/11/18/ckaum9y7k001nejl3jpulmmwb/","link":"","permalink":"http://www.zcating.tk/2019/11/18/ckaum9y7k001nejl3jpulmmwb/","excerpt":"在开发 React 应用的过程中，我们一般习惯使用 Redux 作为状态管理工具，因为这个工具足够的简单。而在一般的项目中，Redux通过中间件，提供了足够的能力处理同步异步事件。而处理异步事件的中间件有很多，Redux-observable 就是一个，它通过和 Rxjs 深度结合，提供了一种很棒的方式来处理异步事件以及副作用。","text":"在开发 React 应用的过程中，我们一般习惯使用 Redux 作为状态管理工具，因为这个工具足够的简单。而在一般的项目中，Redux通过中间件，提供了足够的能力处理同步异步事件。而处理异步事件的中间件有很多，Redux-observable 就是一个，它通过和 Rxjs 深度结合，提供了一种很棒的方式来处理异步事件以及副作用。 Redux-observable（RO）如果你了解过 NgRx，那么，下面的介绍的方法您肯定不会陌生，首先，我容我“盗用” NgRx 的状态图。 为了解决 Side-Effect，大家都想到很多的方法： Redux-thunk 通过中间件增强了dispatch方法，使得其输入可以包括函数对象，通过输入函数，我们可以在函数中引入副作用，并对其进行处理。然而，action 和 effect 糅杂在一起，并不能很好的管理副作用。同时，action 的数据形式受到了一定程度的破坏，在我看来，action应该是一个纯粹的 plain object，而不是函数对象。 Redux-sega 则是更接近与 Redux-observable 的一种解决方式。使用观察者模式可以对输入的action进行观察，将 Effect 隔离出来。通过 Generator 函数，并将异步操作（代码）同步化。由于是同步操作，可以通过 try/catch 进行错误处理。 RO 跟 Redux-sega 的操作思想类似，但是 RO 引入了我比较喜欢的 Rxjs，通过 Rxjs 的流概念带来的强大的抽象能力，管理副作用变得轻而易举，使得 RO 在管理数据流方面有着天然的优势。 具体写法在 RO 有这么一个概念，叫 Epic。在 RO 的官网上，是这样描述它的： It is a function which takes a stream of actions and returns a stream of actions. Actions in, actions out. 简而言之，Epic就是一个action操作流的函数。这个函数的签名是这样的： 1function (action$: Observable&lt;Action&gt;, state$: StateObservable&lt;State&gt;): Observable&lt;Action&gt;; Epic 操作流的的方式是这样的（直接用了官网的例子了）： 1234const pingEpic = action$ =&gt; action$.pipe( filter(action =&gt; action.type === 'PING'), mapTo(&#123; type: 'PONG' &#125;)); 可以用 ofType() 这个操作符将特定 action 过滤： 123456const fetchActionconst fetchUserEpic = action$ =&gt; action$.pipe( ofType(FETCH_USER), mergeMap(action =&gt; ajax.getJSON(`https://api.github.com/users/$&#123;action.payload&#125;`)), map(response =&gt; fetchUserFulfilled(response)))); 在 Epic 的基础上，RO 引申出了 Root Epic 这个概念，Root Epic 包含了所有的 Epic。每一个 Epic 通过一个 merge 操作符 而它最终会被 epicMiddleware 这个中间件调用。 12345678910111213141516171819const rootEpic = combineEpics( pingEpic, fetchUserEpic);// ... 此处省略 rootReducerconst epicMiddleware = createEpicMiddleware();export default function configureStore() &#123; const store = createStore( rootReducer, applyMiddleware(epicMiddleware) ); epicMiddleware.run(rootEpic); return store;&#125; Redux-rx-creator这个库是将 NgRx 中的 action 和 reducer 工厂函数抽离出来的一个库。 Reducer creator这个库也提供了一个 createReducer 的函数，为了搭配 createReducer，你可能需要简单的改造一下你的 state。 12345678910111213141516// 为 state 提供类型interface PingPongState &#123; pingCount: number; pongCount: number;&#125;const initPingPongState: PingPongState = &#123; pingCount: 0, pongCount: 0&#125;const pingPongReducer = createReducer( initState, on(ping, state =&gt; (&#123;...state, pingCount: state.pingCount + 1&#125;)), on(pong, state =&gt; (&#123;...state, pongCount: state.pongCount + 1&#125;))); 这种方式，比 Redux 常用创建 Reducer 的方式看起来更加的舒畅，它仅仅关注与数据的变化，而不是复杂的 switch 结构，这使得代码更加的清晰。最重要的一点，createReducer 的返回值就是一个 reducer 函数，这也就意味着，你可以直接使用 combineReducer 来做结合。 Action creator一般来说，action 是一个 plain object。为了能够在使用 typescript 开发过程中提供完整的类型支持，这个 action 工厂函数可以提供明显且有效的帮助。 1const doPing = createAction('PING'); 如果这个 action 需要传入参数，那么就可以使用这种方式为 action 提供类型检测。 1const fetchUser = createAction(&apos;FETCH_USER&apos;, props&lt;&#123;payload: string&#125;&gt;()); 在这里 props 仅仅返回了 undefined，不会造成任何影响，但是却给 fetchUser 提供类型检测的机会。fetchUser 的类型是一个函数（也就是所谓的高阶 action），它接受一个参数，这个参数的类型来自于 props 中的泛型接口。那么，当你需要调用这个 fetchUser 的时候，仅仅需要这样。 1store.dispatch(fetchUser(&#123;payload: 'Tony'&#125;)); ofActionType 操作符为了可以结合 RO，我们需要使用这个操作符来强化类型推导，如果直接使用 RO 自带的 ofType，那么会有这种情况发生。 12345678const fetchUserEpic = action$ =&gt; action$.pipe( ofType(fetchUser), // 此处 typescript 会报错，无法转发出正确的类型，导致 action.payload 失效。 mergeMap(action =&gt; &#123; return ajax.getJSON(`https://api.github.com/users/$&#123;action.payload&#125;`)); &#125; map(response =&gt; fetchUserFulfilled(response)))); 因此我们需要使用这个 ofActionType 操作符，来将 ActionCreator 中的数据类型取出。 1234567const fetchUserEpic = action$ =&gt; action$.pipe( ofActionType(fetchUser), mergeMap(action =&gt; &#123; return ajax.getJSON(`https://api.github.com/users/$&#123;action.payload&#125;`)); &#125; map(response =&gt; fetchUserFulfilled(response)))); 总结其实，我就是把 NgRx 中一些有用的地方应用到 Redux，主要就是解决了创建 action 类型安全的问题。本文参考如下。 Vuex、Flux、Redux、Redux-saga、Dva、MobX ngrx 官网 Redux-observable 官网","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://www.zcating.tk/categories/JavaScript/"},{"name":"React","slug":"JavaScript/React","permalink":"http://www.zcating.tk/categories/JavaScript/React/"}],"tags":[]},{"title":"深入理解 mergeMap, switchMap, concatMap, exhaustMap","slug":"深入理解-mergeMap,-switchMap,-concatMap,-exhaustMap","date":"2019-11-18T12:44:09.192Z","updated":"2019-11-18T12:44:09.192Z","comments":true,"path":"2019/11/18/ckaum9y7n001wejl31wbfcfzd/","link":"","permalink":"http://www.zcating.tk/2019/11/18/ckaum9y7n001wejl31wbfcfzd/","excerpt":"因为感觉对这几个观察者映射理解不够充分，所以找到了一个神奇的网站。它可以帮助你充分分辨这些 map。","text":"因为感觉对这几个观察者映射理解不够充分，所以找到了一个神奇的网站。它可以帮助你充分分辨这些 map。 首先我们以这两个源为标准。 A： 012B：101010现在，我们把A和B两个源做一个 乘法操作，也就是源A的每一个输出，都跟源B的每一个输出做乘法。首先我们定义一下我们的源。12345678const &#123; interval&#125; = Rx;const &#123; take, map &#125; = RxOperators;const sourceA = (time) =&gt; interval(time).pipe(take(3));const sourceB = (time, value) =&gt; interval(time).pipe( take(3), map(() =&gt; value * 10))## mergeMap为了研究 mergeMap 是怎么运作的，我们可以通过以下代码来工作：123sourceA(1000).pipe( mergeMap((value) =&gt; sourceB(1500, value)))把上面的代码复制到神奇的网站上，你就可以观察到，它是这样工作的。之后的代码也是通过这种方式展示的。010020100201020我们可以看到，这样看可能不太直观，但是我们将他们分别打印，你就能看出区别了：101010012要理解 mergeMap，第一点就是，它会直到两个源都输出数据的时候才会输出。那么，当源A输出后，需要等 1.5s 的时间等待源B的输出。而后，源A每隔1s就会有下一个输出，源B每隔1.5s后就会有下一个输出，所以，我们可以看到，为了保证后面的时序不被打乱，mergeMap 把合成之后的输出分别按照源A和源B的时序输出了。以源A的角度看，它的每一个输出和源B的三个输出结合的输出的时序是源B的；以源B的角度看，它的每一个输出和源A的三个输出结合的输出的时序是源A的。所以mergeMap的作用是保证输出后的原有叠加的时序不变。## switchMap到了switchMap，我们可以看看输入到网站的代码。123sourceA(1000).pipe( switchMap((value) =&gt; sourceB(1500, value)));然后，看看它的输出是怎么样的。202020 诶，怎么只有这么源A和源B的三个输出结合的输出？改一下时间，我们把源B的时间改成 800ms，再来看看。 010202020 好了，看到源A的前两个输出只和源B结合了一次，源A的最后一个输出却都结合了。我们还是看看他们分别的输出。 012源 A 输出101010源 B 输出我们可以对比看出，每当源A发出一个新的输出，之前源A跟源B结合的输出都被截断。那么，可以看出源B的每次输出与源A的输出结合的输出都依赖于源A的时序，当源A发出新输出的时候，之前结合的所有未完成输出都会被截断。所以，这也解释了，为什么第一次源A只有最后一次的输出与源B结合。因为，源B每次输出的时序用时为1500ms，这个用时大于源A输出的用时。所以，当源A发出的第一次的输出准备与源B结合时（此时，源A需要等待源B运行完），源A的第二次的输出也发出了，由于switchMap的截断机制，便会跳过源A第一次的结合，以此类推。## concatMap惯例，我们还是看看代码。123sourceA(500).pipe( concatMap((value) =&gt; sourceB(1000, value)));下面是 concatMap 的输出。000101010202020 我们可以看到，concatMap 并不会截断，它跟mergeMap的输出内容一样，都是会把所有结合都输出。但是有一点，concatMap 输出结合的方式又跟mergeMap不太一样，它会等待上一次结合输出完毕后，才进行下一次的结合输出。也就是当 0，0，0 输出完毕后，才会输出 10，10，10。在这里， 时序会遵循以下规则，如果源B结合完了源A的数据，源A仍未发送下一条数据，源B将会等到源A的下一条数据的到来。如果源A的数据有堆积（或者A的时序比B的时序小），而源B仍未结合完，那么将会以源B的时序进行下一组结合。 exhaustMap还是惯例，这是最后一个了，看看代码吧。 123sourceA(1000).pipe( exhaustMap((value) =&gt; sourceB(500, value))); 下面是 exhaustMap的输出。 000202020 可以看到，10 这个输出被截断了，它跟concatMap的区别就是，源A与源B的结合输出完毕后，并不会等待下一组结合的输出。如果在第一组结合输出完毕前，第二组结合就要开始输出的时候，exhaustMap会阻止第二组结合的输出，直到第一组结合完全输出完毕。 这样，我们不妨假设在它们开始输出的时候为第0秒，源A与源B的第一组结合完全输出，需要耗费 1.5秒的时间，也就是它会在第1.5秒处完全输出。而源A的第二组结合会在第1秒输出，由于exhaustMap的特性，第二组结合将不会发生，因为，1.5秒大于1秒。而第一组结合完全输出后，第三组结合会在第三秒输出，这样便会输出 20，20，20。 总结本文主要是帮助你深入理解RxJs中的几个概念。下面是一些参考文档和工具。 Rxjs 官方文档 Rxjs 可视化工具","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://www.zcating.tk/categories/JavaScript/"}],"tags":[]},{"title":"Angular 状态检测机制","slug":"Angular-状态检测机制","date":"2019-11-16T01:56:16.209Z","updated":"2019-10-04T15:03:48.163Z","comments":true,"path":"2019/11/16/ckaum9y6t0006ejl30jr5p7zh/","link":"","permalink":"http://www.zcating.tk/2019/11/16/ckaum9y6t0006ejl30jr5p7zh/","excerpt":"Angular 通过对数据的变更检测来实现数据对视图的双向绑定，那么这篇文章将会讲述如何通过内置功能来优化状态检测机制。","text":"Angular 通过对数据的变更检测来实现数据对视图的双向绑定，那么这篇文章将会讲述如何通过内置功能来优化状态检测机制。 变更检测机制为了理解变更检测机制，需要知道这么一些知识： 值类型和引用类型所谓值类型，意味着它只会把值放在当前的栈中，而引用类型，则意味者它把值放在堆内存中。他们俩的区别在于，值类型的每次赋值操作都会拷贝一个新的值，而引用类型的赋值操作仅仅会拷贝堆地址而给新值，而不是重新拷贝一份新的数据给新值。 数据变化异步操作会触发变更检测，他们可以分为这么些类型： 用户输入等事件 服务端请求 定时事件 如何通知变化在 AngularJS 中，通过 $scope.$apply() 或者 $scope.$digest() 来触发变更检测，而 Angular 通过 Zone.js 来监听所有的异步事件。而在 Zone.js 中，通过重写所有的异步API来实现通知 Angular 异步操作发生了，并且可能会产生数据变化，需要检测更新。 策略Angular 提供了两种不同的检测策略，默认策略和 OnPush策略。 一个组件可以通过输入 @Input 的形式来获取输入，那么不同的策略就会根据输入来做出不同的决策。 默认策略这个组件获取的 @Input 无论是值类型还是引用类型，只要改变了，都会触发变更检测。对于引用类型，改变了这个引用的属性也会触发。 OnPush策略对于值类型，只要改变了，就会触发变更检测。对于引用类型，如果只改变属性，不会触发变更检测。只有整个引用变了，才会触发变更检测。 OnPush策略详解尽管 Angular 很快，但是，随着应用的规模日渐增大，如果每次的简单事件都触发大量的变更检测，这便会有很明显的性能问题。所以，为了解决这个问题，使用 OnPush 模式成为了非常必要的选择。 这个策略的主要解释是，在单向数据流的情况下，组件视图变化只会根据外部输入的数据来变化。 那么如何使用 OnPush 来优化状态检测呢，可以看以下代码： 123@Component(&#123; changeDetection: ChangeDetectionStrategy.OnPush&#125;) 这样，在组件的注解中标明变更检测机制为 OnPush，就能开启 OnPush 策略。 ChangeDetectorRefChangeDetectorRef 是组件变更检测器的引用，在组件中，我们可以通过依赖注入的方式来获取该对象。 12345import &#123; ChangeDetectorRef &#125; from '@angular/core';@Component(&#123;&#125;) class MyComponent &#123; constructor(private cdr: ChangeDetectorRef) &#123;&#125;&#125; 检测器引用 主要有以下几个方法： 1234567export abstract class ChangeDetectorRef &#123; abstract markForCheck(): void; abstract detach(): void; abstract detectChanges(): void; abstract reattach(): void; abstract checkNoChanges(): void:&#125; 首先，detach 和 reattach 是用来对解除或者重新绑定当前视图的。原理很简单，就是将当前视图的状态标记为解除，当变更检测进行的时候，判断视图的检测状态。 其次，对于 markForCheck 和 detectChanges 两个API，在OnPush的策略下，组件内部可能还会有外部的用户事件输入，那么这种变化是不触发状态检测，因为不是通过 @Input 输入，那么我们需要通过标记检测来进行视图更新，这里用了官网的例子： 123456789101112131415161718@Component(&#123; selector: 'my-app', template: `Number of ticks: &#123;&#123;numberOfTicks&#125;&#125;`, changeDetection: ChangeDetectionStrategy.OnPush,&#125;)class AppComponent &#123; numberOfTicks = 0; constructor(private ref: ChangeDetectorRef) &#123; // 每秒加一 setInterval(() =&gt; &#123; this.numberOfTicks++; // 此处标记需要进行状态检测，那么就会进行一次检测 this.ref.markForCheck(); &#125;, 1000); &#125;&#125; 至于其他用法，可以参考这里。 结语本文简单的总结了状态检测机制，以及一些优化技巧，希望可以帮助到大家。","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://www.zcating.tk/categories/JavaScript/"}],"tags":[]},{"title":"Angular 日常错误一览","slug":"Angular-日常错误一览","date":"2019-11-05T11:42:19.216Z","updated":"2019-11-05T11:42:19.216Z","comments":true,"path":"2019/11/05/ckaum9y6b0000ejl3ng0llly2/","link":"","permalink":"http://www.zcating.tk/2019/11/05/ckaum9y6b0000ejl3ng0llly2/","excerpt":"这篇文章主要用来记录Angular开发过程中遇到的经典的错误。","text":"这篇文章主要用来记录Angular开发过程中遇到的经典的错误。 Expression has changed after it was checked这个错误主要出现在以下这种情况： 12345678910111213@component(&#123; template: &apos;&lt;div *ngIf=&quot;isLoggingIn&quot;&gt;has logged in&lt;/div&gt;&apos;&#125;)export class UserLogin implements AfterViewInit &#123; ... ngAfterViewInit() &#123; // isLoggingIn 这个值跟 this.isLoggingIn = true; &#125; ...&#125; 这种情况的出现的原因在于对 Angular 的变更机制不了解，以及其生命周期钩子函数具体hook的位置是哪里的不了解。 其实 AfterViewInit 和AfterViewChecked ，这两个钩子函数会在变更检测完毕以及视图被构建后触发。所以，框架开发者希望的是，不要在这两个钩子函数中做改变视图的操作。因为这样的操作会使得视图不跟数据同步。可以看看文档，文档中有这么一段话。 Angular’s unidirectional data flow rule forbids updates to the view after it has been composed. Both of these hooks fire after the component’s view has been composed. Angular throws an error if the hook updates the component’s data-bound comment property immediately (try it!). 翻译一下： Angular 的单向数据流的规则禁止在视图构成完毕后更新视图。构成视图完毕后，这两个钩子函数都会调用。 如果钩子函数立刻更新了组件的数据绑定属性（尝试一下！），那么 Angular 会引发一个错误。 所以要修复这个错误，那么可以这样做： 在OnInit钩子函数中操作视图绑定属性。 在AfterViewInit钩子函数中，将视图操作放入异步操作中。 ViewDestroyedError1ViewDestroyedError: Attempt to use a destroyed view: detectChanges 最近在测试页面的时候发现，有时候点击事件延迟的情况下，会触发上述错误。 通过搜索引擎，我很快就发现了问题的所在。其实还是对状态变更机制的不熟悉导致的。在页面中大量使用 OnPush 模式，那么手动变更操作就会变得比较频繁，这样给出一个样板。 123456789101112131415161718192021@component(&#123; template: ' &lt;button (click)=\"login\"&gt;has logged in&lt;/button&gt; &#123;&#123;userInfo&#125;&#125;' changeDetection: ChangeDetectionStrategy.OnPush&#125;)export class UserLogin implements AfterViewInit &#123; ... constructor(private cdr: ChangeDetectionRef, private http: HttpClient) &#123;&#125; login() &#123; this.http.get('/user/info').subscribe(&#123; next: (userInfo) =&gt; &#123; this.ref.detectChanges(); this.userInfo = userInfo; this.cdr.markForCheck(); &#125; &#125;) &#125;&#125; 看起来，代码没什么什么问题，但是这个 view destroy完成后请求才完成的话，cdr就会报上面的错误。所以，我们需要在销毁钩子函数上添加下面一行代码： 123ngOnDestroy() &#123; this.cdr.detach();&#125; 这样，在销毁视图的时候，cdr 便会取消与该视图的关联，错误也就不会发生。","categories":[],"tags":[]},{"title":"Angular，React，Vue 三大框架简单总结","slug":"Angular，React，Vue-三大框架简单总结","date":"2019-10-31T05:00:00.000Z","updated":"2019-11-05T11:44:26.785Z","comments":true,"path":"2019/10/31/ckaum9y6h0003ejl3jdvabu7i/","link":"","permalink":"http://www.zcating.tk/2019/10/31/ckaum9y6h0003ejl3jdvabu7i/","excerpt":"对前端研究也有一段时间了，从原生、jQuery，到MVC框架，再到现在的MVVM，。三大前端主要的框架也有一些比较简单的了解，说到底，三大框架都都是通过单向数据流的形式来管理视图，双向绑定成为了单纯的语法糖。","text":"对前端研究也有一段时间了，从原生、jQuery，到MVC框架，再到现在的MVVM，。三大前端主要的框架也有一些比较简单的了解，说到底，三大框架都都是通过单向数据流的形式来管理视图，双向绑定成为了单纯的语法糖。 Angular这是我用得比较多的框架，它是有谷歌开发的一款基于状态变更机制的框架，通过TypeScript 、Rxjs 以及 zone.js等库编写而成。它的优点非常的明显，首先是支持了TypeScript，将DI，IoC等概念引入前端开发，同时通过响应式库 Rxjs 完善了数据管理。通过依赖注入，可以很容易的将数据管理模块注入到视图组件中，从而减少编写重复的代码。同时提供了各种最优实践，Router、数据管理等。 在性能上，Angular 通过 zone.js 监听异步事件触发状态变更检测，从而更新视图，这种方式大大减轻了使用者的负担。不过在复杂页面中，大量的异步事件将触发大量的变更检测，会影响页面的性能。那么我们可以通过 OnPush 机制来控制变更检测的触发，从而优化变更检测的时机以及变更检测的数量。 写法上，Angular 推崇通过删除节点的方式隐藏元素或组件，因为这样隐藏的元素或组件就不会触发变更检测。 需要注意一点的是，Angular只能构建出一个SPA。 ReactReact 用的不多，它是Facebook开发的一个基于 Virtual DOM 视图库。React通过引入了一个先进的概念 Virtual DOM，来实现数据到视图的映射。使用 jsx或者tsx来开发视图，React可以说是一门新的语言也不为过。 React聊的最多的还是其Virtual DOM的性能，React通过优化了树的 diff 算法，使得其复杂度从 O(n^3) 降到了O(n)，但是最终得到的不一定是最优解，其思想是：两棵树只比较同级结点，同级结点不一样，则进行patch，如果同级结点一样，则递归比较该结点下的孩子的同级结点。 所以 React 在写法上，DOM树的结构需要尽可能地保持稳定。因此，React推崇通过display: none等方式隐藏元素或结点，因为这样隐藏元素不会导致DOM树结构的。 不过React只是一个视图库(View Library)，搭建框架需要配合一些其他的基础设施，官方不提供。所以会导致一个问题，没有最佳实践。所以会导致有不同的 Router 库，有不同的状态管理库（Redux，Mobx）。 React支持TypeScript，所以对于大型项目来说，是一件非常好的事情。 VueVue是由尤雨溪主导开发的一个框架，它吸收了 React 和 Angular两个框架的特性，并将它们结合在一起，它也使用了Virtual DOM，作为主要的思想。在此基础上，通过数据劫持和依赖追踪实现了最优的patch，所以，其数据变更机制变得异常简单，对数据进行 set 操作的同时，便会更新视图。 跟React一样，Vue的DOM树结构也要尽量保证稳定。不过Vue的生态比React的生态要好，官方也提供Vue-Router，Vuex等最佳实践。 不过，由于使用了数据劫持，IDE提示会不太友好，同时，TypeScript支持较差，多人合作的时候不易规范。 最后给出一个表，可以看看三大框架对一些特性的支持程度。 框架/库 变更机制 指令 TypeScript 状态管理 Router Angular 变更检测 支持 支持 Service/NgRx 自带 React Virtual DOM 不支持 支持 Redux/Mobx/Flux React-Router Vue Virtual DOM 支持 2.0支持效果不好，3.0效果未知 Vuex Vue-Router","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://www.zcating.tk/categories/JavaScript/"}],"tags":[]},{"title":"使用 Webpack 打包 TypeScript 插件","slug":"使用-Webpack-打包-TypeScript-应用","date":"2019-10-25T12:39:21.852Z","updated":"2019-10-25T12:39:21.852Z","comments":true,"path":"2019/10/25/ckaum9y7g001dejl36udlq7kd/","link":"","permalink":"http://www.zcating.tk/2019/10/25/ckaum9y7g001dejl36udlq7kd/","excerpt":"本文将简单介绍如何使用 webpack 打包 TypeScript 应用。","text":"本文将简单介绍如何使用 webpack 打包 TypeScript 应用。 配置 TypeScript使用 npm init 建立一个 npm 应用后，我们此时的目录结构应该只有一个package.json，那么为了方便，我的目录是这样的： 1234├── package.json└── src ├── index.html └── main.ts 步骤一安装webpack、TypeScript 以及 tslint： 1npm install typescript webpack 步骤二安装 ts-loader以及 babel-loader，加 ts-loader 的原因是为了让 webpack 可以输入 ts 并导出 js。 1npm install --save-dev ts-loader babel-loader @babel/core @babel/preset-env 然后添加 webpack.config.js 到根目录，并使用以下样板代码： 123456789101112131415161718192021222324252627282930313233343536const path = require(&apos;path&apos;);const webpack = require(&apos;webpack&apos;);module.exports = &#123; entry: &apos;./src/main.ts&apos;, module: &#123; rules: [ &#123; test: /\\.ts?$/, use: &apos;ts-loader&apos;, exclude: /node_modules|dist/ &#125;, &#123; test: /\\.js$/, exclude: /node_modules|dist/, loader: &apos;babel-loader&apos;, options: &#123; presets: [&apos;@babel/preset-env&apos;] &#125; &#125;] &#125;, resolve: &#123; extensions: [ &apos;.ts&apos;, &apos;.js&apos; ] &#125;, output: &#123; filename: &apos;bundle.js&apos;, path: path.resolve(__dirname, &apos;dist&apos;) &#125;, plugins: [ new webpack.DefinePlugin(&#123; &apos;process.env.NODE_ENV&apos;: &apos;&quot;production&quot;&apos; &#125;), ]&#125;; 步骤三使用 tslint 自带命令创建然后，需要的配置规则，在这里不赘述： 1tslint --init 然后，需要配置tsconfig.json。它的作用是指定编译文件，以及提供编译选项，这里也不再赘述具体内容，详情请看这里。 步骤四完成代码编写后，我们需要把代码打包输出，对于插件，我们需要挂载到 window，这样引入srcipt的时候，才能调用我们的代码。 1(window as any).anycode = YourApp","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://www.zcating.tk/categories/JavaScript/"}],"tags":[]},{"title":"TypeScript使用总结(一)","slug":"TypeScript使用总结(一)","date":"2019-09-14T04:56:01.842Z","updated":"2019-09-14T04:55:43.439Z","comments":true,"path":"2019/09/14/ckaum9y7a000vejl3boceaxjh/","link":"","permalink":"http://www.zcating.tk/2019/09/14/ckaum9y7a000vejl3boceaxjh/","excerpt":"下面是一些TypeScript的总结。","text":"下面是一些TypeScript的总结。 TSLint 配置这一步主要是通过约束TypeScript的编写过程来保证类型安全。在tslint.json中，进行如下配置： 1234\"rule\": &#123; ... \"no-any\": true,&#125; 配置no-any的原因很简单，any并不能使得你的代码变得类型安全，同时使得你的代码直接退化成JavaScript，这样跟直接写JavaScript没什么两样，甚至还多了几个字符。 下一步是对tsconfig.json进行设置，这个配置主要是配置编译选项，下面仅仅给出较为宽松，但是又不失类型安全的配置： 1234567891011\"compilerOptions\": &#123; ... // 在每个文件中添加 'use strict;' \"alwaysStrict\": true, // 在表达式和声明上有隐含的 any类型时报错。 \"noImplicitAny\": true, // 当 this表达式的值为 any类型的时候，生成一个错误。 \"noImplicitThis\": true, // 不是函数的所有返回路径都有返回值时报错。 \"noImplicitReturns\": true&#125; 更多配置，可以参考TypeScript官方编译配置文档。 这里要注意，并不是所有人都能接受strict对于代码的检查，按照官方文档，开启strict会启动以下这几个选项： --noImplicitAny， --noImplicitThis， --alwaysStrict， --strictBindCallApply， --strictNullChecks（这里是主要问题，会开启空检查，未标明非空而为空的代码一律不通过）， --strictFunctionTypes ， --strictPropertyInitialization. 不过建议还是开启strict吧。 类型的使用在这里，主要讲的是一些语法上的技巧，不会讲得太多语法上的东西，因为大部分内容在 官方文档 都有说明。 Null &amp; Undefined &amp; readonly众所周知，null 和 undefined 是不同的两个类型，那么 TS 当然也要区分它们，所以，以下代码会编译不过： 1const data: &#123;&#125; | null = undefined; 所以，为了使得以上代码能够编译通过，需要加上这么 undefined 这个类型： 1const data: &#123;&#125; | null | undefined = undefined; 当然对于 undefined 来说，它还有一些特别的使用方式，注意到问号，其实就是提供一种简单的方式来标识这个对象中的键值可以为未定义。 12345678910111213interface IStudent &#123; firstName?: string; lastName?: string;&#125;const student: IStudent = &#123;&#125;;// 然而上面这种写法跟下面这种写法是不一样的，采用联合类型来编写，编译器会认为这个对象的键是必须存在的。interface ITeacher &#123; firstName: string | undefined; lastName: string | undefined;&#125;const teacher: ITeacher = &#123;&#125;; // Error 那么，在 strict 开启的情况下，在类中任意一个属性的定义都需要初始化： 1234class Student &#123; firstName: string; // Error lastName: string = '';&#125; 如果需要标记不需要初始化，有两种方式 12 Condition Type在TypeScript中，这个是一个非常有用的类型，它可以通过这种方式来定义一个类型： 1type Condition&lt;T&gt; = T extend U ? T : never; 不过请注意：在使用Condition Type的时候，类型的判断不是通过类名，而是通过鸭子辩型来判断的。 Class Type定义一个泛型工厂函数，看起来像是这样的： 123function create&lt;T&gt;(c: &#123;new(...args: any[]): T; &#125;, ...args: any[]): T &#123; return new c();&#125; 但是要写这么一坨{new(...args: any[]): T;}看起来可能不太直观，那么我们可以这样定义一下： 123interface ClassType&lt;T&gt; &#123; new (...args: any[]): T;&#125; 那么这个泛型工厂函数就可以简化成这样： 123function create&lt;T&gt;(c: ClassType&lt;T&gt;, ...args: any[]): T &#123; return new c(...args);&#125; Index Type在 JS 中，我们都知道一个对象是可以随时随地的为对象添加键（只要对象是可扩展的）。所以，为了适配这种情况，TS 使用了索引类型，它看起来像这样： 1type IndexType = &#123; [p: string]: string &#125; 也就是说，它使用了 [] 方括号来表示键的类型，如果一个对象接受了这个类型，那么它可以这样： 123const value: IndexType = &#123;&#125;;value['hello'] = 'world'; 它可以通过配合 infer 关键字，可以推导出某个对象类型中的值的类型的集合： 1type ValueType&lt;T&gt; = T extends &#123;[p in keyof T]: infer V&#125; ? V : never; 一个比较常用的地方是用在 Proxy 中，来避免 get 和 set 操作的 any： 1234567891011class Student &#123; constructor(public name: string = &apos;&apos;) &#123;&#125;&#125;const student = new Proxy(new Student(&apos;Tony&apos;), &#123; // 请看这里： set(target: Student, p: keyof Student, value: ValueType&lt;Student&gt;, receiver: any): boolean &#123; ... return true; &#125;&#125;); Array Type在 JS 中，array 中的数据可以是任意类型的，那么为了配合 JS，它可以这样定义：123const numbers: number[] = [];const anys: [number, string, object] = []; 重载在 TavaScript 中使用了一种非常有意思的方式来实现重载，一开始我还没搞懂怎么运行，但是弄懂了之后，其实就是把应该在编译期的判断放在了运行期。但是这样做会更加符合 ts 的哲学——只在编译期提供类型。这样通过这种形式的重载，在类型擦除的过程中，就不会生成多个不同函数签名以及不同名的函数。 来看看例子，看看这个是如何使用的： 123456789function add(x: number, y: number): number;function add(x: string, y: string): string;function add(x: number | string, y: number | string): number | string &#123; if (typeof x === 'number' &amp;&amp; typeof y === 'number') &#123; return x + y; &#125; else if (typeof x === 'string' &amp;&amp; typeof y === 'string') &#123; return x + y; &#125;&#125; 本篇总结主要说了一些配置技巧、编写技巧，以及重载。下一篇应该会说一下装饰器等进阶功能。","categories":[{"name":"JavaSript","slug":"JavaSript","permalink":"http://www.zcating.tk/categories/JavaSript/"}],"tags":[]},{"title":"了解 Angular Ivy：Incremental DOM 和 Virtual DOM","slug":"了解Angluar-Ivy-Incremental-DOM-和-Virtual-DOM","date":"2019-08-11T06:35:51.548Z","updated":"2019-08-11T06:35:51.548Z","comments":true,"path":"2019/08/11/ckaum9y7f0018ejl3yx3ofytl/","link":"","permalink":"http://www.zcating.tk/2019/08/11/ckaum9y7f0018ejl3yx3ofytl/","excerpt":"本文作者已经分享了很多关于Angular Ivy的见解，因为有很多可以让我们开发者期待的地方。Angular Ivy是一个新的渲染引擎，它跟其他许多主流的渲染引擎有着根本性的区别，因为它使用的是Incremental DOM。现在我们一起来了解一下吧。 什么是 Incremental DOM，它跟 Virtual DOM有什么区别呢？","text":"本文作者已经分享了很多关于Angular Ivy的见解，因为有很多可以让我们开发者期待的地方。Angular Ivy是一个新的渲染引擎，它跟其他许多主流的渲染引擎有着根本性的区别，因为它使用的是Incremental DOM。现在我们一起来了解一下吧。 什么是 Incremental DOM，它跟 Virtual DOM有什么区别呢？ Virtual DOM 是如何工作的React 是第一个使用 Virtual DOM 的主流框架，它的主要思想是： 每一个组件都会在每一次渲染完毕的时候创建一个新的 Virtual DOM。React 通过对比新旧 Vitrual DOM来操作一系列的转换将浏览器的 DOM 跟新的 Virtual DOM 来进行匹配。 Virtual DOM 有两大优点： 我们可以使用任何的编程语言来实现组件渲染函数，所以我们不需要编译任何东西。React开发者习惯用 JSX，但是我们也可以使用JavaScript来开发。 我们可以从渲染组件的结果中获取一个值，它可以用于测试，调试等等。 Incremental DOMIncremental DOM 被用于 Google 内部，它的主要思想是： 每一个组件都会被编译成一系列的指令。这些指令用于创建 DOM 树，并且在数据变化的时候更新它们（DOM树）。 举个例子，请看以下组件： 12345678910111213@Component(&#123; selector: 'todos-cmp', template: ` &lt;div *ngFor=\"let t of todos|async\"&gt; &#123;&#123;t.description&#125;&#125; &lt;/div&gt; `&#125;)class TodosComponent &#123; todos: Observable&lt;Todo[]&gt; = this.store.pipe(select('todos')); constructor(private store: Store&lt;AppState&gt;) &#123;&#125;&#125; 它会被编译成： 123456789101112131415161718192021222324252627var TodosComponent = /** @class */ (function () &#123; function TodosComponent(store) &#123; this.store = store; this.todos = this.store.pipe(select('todos')); &#125; TodosComponent.ngComponentDef = defineComponent(&#123; type: TodosComponent, selectors: [[\"todos-cmp\"]], factory: function TodosComponent_Factory(t) &#123; return new (t || TodosComponent)(directiveInject(Store)); &#125;, consts: 2, vars: 3, template: function TodosComponent_Template(rf, ctx) &#123; if (rf &amp; 1) &#123; // create dom pipe(1, \"async\"); template(0, TodosComponent_div_Template_0, 2, 1, null, _c0); &#125; if (rf &amp; 2) &#123; // update dom elementProperty(0, \"ngForOf\", bind(pipeBind1(1, 1, ctx.todos))); &#125; &#125;, encapsulation: 2 &#125;); return TodosComponent;&#125;()); 模板函数包含着创建和更新的指令。请务必注意的一点是，框架的渲染引擎并不会去解释指令。他们是渲染引擎。 为什么使用 Incremental DOM为什么 GOOGLE 会使用 Incremental DOM，而不是 Vitrual DOM？ 它们的目标是：应用必须要在手机端上表现良好。这意味者需要优化这两个东西：应用打包的大小和内存。 为了优化这两个目标，那么： 渲染引擎本身必须是可以将无用的代码清除的（tree shakable）。 渲染引擎必须占用较低的内存。 为什么 Incremental DOM 是可清除无用代码的（Tree Shakable）当我们使用 Incremental DOM，框架不必去解释组件。相反，组件会引用指令。如果组件不引用一个特定的指令，那么这个组件将不会被使用。所以，我们可以在编译过程中从打包文件（bundle）里忽略未使用的指令。 而 Vitrual DOM 需要解释器。在编译时，解释器并不知道哪个部分是已知的和哪个是未知的，因此我们必须将整个包发送到浏览器。 为什么 Incremental DOM 占用的内存较小每次重新渲染的时候，Virtual DOM 都会从头开始创建整个树。 至于 Incremental DOM，如果页面的DOM没有更改，则不需要任何内存来重新渲染视图。我们仅仅需要在添加或删除DOM节点的时候分配内存，并且大小与DOM变化的大小成正比。 由于大多数渲染或者模板调用不会改变任何东西（或变化很小），因此可以节省大量内存。 它粒度更细（It’s More Nuanced）当然，它（Incremental DOM）的粒度更细。例如，具有渲染返回值可以提供良好的可用性，可以用于测试。 另一方面，它能够使用 Firefox DevTools 逐步执行指令使调试和性能分析更容易。 但是最终谁能更符合人体工程学取决于框架和开发人员的偏好（What ends being more ergonomic depends on the framework and the developer’s preferences.）。 Ivy 和 Incremental DOM?Angular一直在使用html和模板（几年前我写了一篇文章，概述了为什么我认为从长远来看这是正确的选择）。 这就是为什么，Virtual DOM 的主要优势永远不会适用于Angular。鉴于此，加上 无用代码清除性和低内存占用的Incremental DOM ，我认为使用 Incremental DOM 作为新渲染引擎的基础是正确的选择。 参考[1] Understanding Angular Ivy: Incremental DOM and Virtual DOM","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://www.zcating.tk/categories/JavaScript/"},{"name":"Angular","slug":"JavaScript/Angular","permalink":"http://www.zcating.tk/categories/JavaScript/Angular/"}],"tags":[]},{"title":"四个步骤优化您的 Angluar 包体积","slug":"四个步骤优化您的-Angluar-包体积","date":"2019-06-30T10:08:57.648Z","updated":"2019-06-30T10:08:57.648Z","comments":true,"path":"2019/06/30/ckaum9y7j001kejl3v9ywggy7/","link":"","permalink":"http://www.zcating.tk/2019/06/30/ckaum9y7j001kejl3v9ywggy7/","excerpt":"本文翻译自 Optimize Angular bundle size in 4 steps 。 如果首页加载速度太慢了，赶快来了解一下这篇文章吧！ 您是否曾经因为您的网页加载太慢而抱怨？您是否尝试过为加载速度慢的应用“优化性能”？在网上有太多这样关于性能优化的类似的话题了，比如：懒加载、变更检测、服务端渲染等。在这儿，我想聊聊关于优化Angluar Bundle 体积的话题。以下内容对于你来说，将会非常简单和实用。","text":"本文翻译自 Optimize Angular bundle size in 4 steps 。 如果首页加载速度太慢了，赶快来了解一下这篇文章吧！ 您是否曾经因为您的网页加载太慢而抱怨？您是否尝试过为加载速度慢的应用“优化性能”？在网上有太多这样关于性能优化的类似的话题了，比如：懒加载、变更检测、服务端渲染等。在这儿，我想聊聊关于优化Angluar Bundle 体积的话题。以下内容对于你来说，将会非常简单和实用。 步骤一、了解您的包大小不可否认的一点是，首页加载时间跟您的包大小是紧紧联系在一起的。 当你运行npm build --prod的时候，你会发现打包完成后，bundle占用的大小会显示在您的打包服务器中。 多大是合适的？如图所示，四个文件中，最大的就是main.*.js。我查了很多使用了Angluar的网页，基本上企业级的应用打包的出来的main.*.js的大小都在500KB以下，平均在250KB左右。如果你的bundle大小大于500KB，你应该注意了，需要开始优化了。如果小于这个，那么你也许可以在之后再优化也不迟。 步骤二、使用GZIP压缩通常来说，GZIP压缩过的文件的大小通常是源文件的20%左右，这将大大的减少了首页加载时间。 为了知道您的应用是否开启了GZIP压缩，只需要打开浏览器的开发者模式，在network一栏查看Response Headers。如果你看到了Content-Encoding:gzip这个头部，那么您的服务器已经开启了GZIP压缩。 If you don’t see this header, your browser will load the original files. For example, for the Angular bundle in the image below, the browser will load main.0d17aff85f337483317e.js and cost 2.21MB data. However, if you gzip your file, your browser could only load 495.13KB. Such a huge reduction of file size, will obviously reduce the initial page loading time, especially when user has low internet speed. 如果你没有看到这个头部，那么浏览器将会加载源文件。比如说：下面这张图，浏览器会加载main.0d17aff85f337483317e.js并且会花费2.21MB左右的带宽。然而，如果您使用GZIP压缩你的文件，浏览器就仅仅只会加载495.13KB左右的数据。如此巨大的数据减少，会明显地降低首页加载时间，特别是在用户网络不好的情况下。 如何开启GZIP如果你的把你的SPA放在云服务器或者CDN，你应该不用担心这个问题，因为他们会帮你搞定GZIP。然而，如果你使用的是你自己的服务器（NodeJs或者expressJS）来跑你的应用，那么你应该检查所有文件都应该使用GZIP。 下面这个例子是在一个NodeJS + expressJS应用中使用GZIP压缩所有的静态资源。你很难想象到，这么一个简单的中间件compression会使你的包大小从2.21MB减少到495.13KB。 1234const compression = require('compression')const express = require('express')const app = express()app.use(compression()) 步骤三、分析你的 Angluar 包如果你的包大小依旧太大，那么你应该分析你的包，因为你可能是使用不恰当的体积过大的第三方包或者你忘记移除了某些你不再需要使用的包。 Webpack拥有一个非常棒的特性，它可以用来展示你的包是由那些js文件组成的，如图： 获得上面这张图很容易： npm install -g webpack-bundle-analyzer 在你的Angluar应用中，运行ng build --stats-json(不要加上 --prod)。通过加上--stats-json，你将获得一个新的文件——stats.json。 完成之后，你会惊讶： 你忘记移除一些你不再使用的模块。 一些库过大了，他们可以被替换成另外一些库。 不恰当的方式引入了一些库（举个例子：80%的moments.js只是可能不需要的语言环境数据），所以可以提供一些方向来解决问题。 步骤四、监听你的包的大小在 Angluar 7 或者更新的版本，当你使用ng new生成新的应用的时候，在angluar.json中，你可以找到这个配置： 1234567&quot;budgets&quot;: [ &#123; &quot;type&quot;: &quot;initial&quot;, &quot;maximumWarning&quot;: &quot;2mb&quot;, &quot;maximumError&quot;: &quot;5mb&quot; &#125;] This will give you a warning if you build Angular and the bundle size exceeds 2MB and throw an error if the bundle size exceeds 5MB. You can adjust the numbers as per your need. 如果你的包大小超过2MB，那么这个配置会给出警告；如果你的包大小超过5MB，那么它会抛出错误。你可以调整成你合适的配置。 你可以在CI/CD管道中利用这个功能，如果你看到警告/错误，您可能要查看出现了什么问题。 其他减少包大小的方法If your bundle size does get too big because of your app is as big as Facebook, you should really use lazy-loading. This topic is widely covered by the Angular community, so I won’t spread it out here. 如果你的包大小跟Facebook之类的应用一样大，那么你真的应该使用懒加载。Angluar社区广泛地涵盖了这个话题，因此我不会在此去扩展它。 感谢Thank Tsung-Ting Chen for giving me inspiration of this article and help me coming up with the solution.","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://www.zcating.tk/categories/JavaScript/"}],"tags":[]},{"title":"Angluar-模态视图构建简析（A）","slug":"Angluar-模态视图构建简析（A）","date":"2019-06-16T15:49:29.512Z","updated":"2019-06-16T15:49:29.512Z","comments":true,"path":"2019/06/16/ckaum9y6g0002ejl3ci1vzfui/","link":"","permalink":"http://www.zcating.tk/2019/06/16/ckaum9y6g0002ejl3ci1vzfui/","excerpt":"在一般的开发中，如果要创建一个模态视图，基本的思路是创建一个不可见的顶层视图，然后在需要的时候，展示这个顶层视图，那么基本的模态视图就创建完成了。 在Angluar中，我们可以使用CDK(component dev kit)中的Overlay来构建模态视图，它把模态的构建过程抽象出来，形成了一个可复用的组件。","text":"在一般的开发中，如果要创建一个模态视图，基本的思路是创建一个不可见的顶层视图，然后在需要的时候，展示这个顶层视图，那么基本的模态视图就创建完成了。 在Angluar中，我们可以使用CDK(component dev kit)中的Overlay来构建模态视图，它把模态的构建过程抽象出来，形成了一个可复用的组件。 准备工作首先，简单的介绍一下CDK： The Component Dev Kit (CDK) is a set of tools that implement common interaction patterns whilst being unopinionated about their presentation. It represents an abstraction of the core functionalities found in the Angular Material library, without any styling specific to Material Design. Think of the CDK as a blank state of well-tested functionality upon which you can develop your own bespoke components. 简单的翻译一下，就是： CDK 是一个这样的工具集，它实现了一系列通用的交互模式，同时不会去影响他们的展示效果。它是 Angluar Material 组件库中没有特定于 Material Design 样式的核心功能的抽象。将CDK视为经过良好测试的功能的空状态，您在它上构建自己的定制组件。 如果你不使用Angluar Material来构建你的应用，那么需要就引入CDK。 1npm i @angular/cdk --save 引入完毕后，就可以开始我们的空状态模态框的构建。 使用OverlayOverlay是一个工厂类，它每次调用create都会创建一个OverlayRef，然后我们就使用OverlayRef来将要展示的内容附在上面（调用attach）。 那么接下来，就要说明一下，overlayRef创建后如何展示我们的视图。首先，我们通过以下代码来创建一个简单的overlayRef。 1const overlayRef = this.overlay.create(); 创建完毕后，使用overlayRef的attach函数来展示视图。attach函数接受一个参数，这个参数的类型可以是 TemplatePortal或者ComponentPortal。 那么，这两个Portal的作用是显而易见，要么获取已存在的嵌入视图（TemplatePortal），要么动态创建宿主视图（ComponentPortal）。当然，这两个Portal的构造过程也不尽相同。 TemplatePortal：接受两个参数，第一个参数是模板引用，第二个参数是当前的视图容器。 ComponentPortal：接受一个参数，其为组件构造函数。 很显然动态创建组件需要在module或者宿主组件的entryComponents属性添加需要的被创建组件。 创建完后，代码如下： 12345678910// Template形式@ViewChild('someTemplate')templateRef: TemplateRef;...const portal = new TemplatePortal(templateRef, viewContainerRef);overlayRef.attach(portal);// component的形式const portal = new ComponentPortal(YourComponent);overlayRef.attach(portal); 构建可复用Overlay通过依赖注入的方式，我们可以引入Overlay到一个可注入服务或者组件中。这里，为了抽象，引入Overlay到一个可注入服务——ModalService。 123export class ModalService &#123; constructor(private overlay: Overlay) &#123;&#125;&#125; 构建一个通用的调用方法： 1234567891011121314// 这里要注意，// `TemplatePortal` 第二个参数在要视图组件中通过依赖注入才能拿到正确的引用。// 原因也很简单，Angular的`Service`是通过`Injector`来构建的，// `Injector`会在应用初始化的时候创建，此时`Service`已经生成，// 而`ViewContainerRef`仍未生成，从而导致依赖错误。// 所以，我们把`ViewContainerRef`当作参数，而不能当作注入对象。openTemplate&lt;T&gt;(templateRef: TemplateRef&lt;T&gt;, viewContainerRef: ViewContainerRef) &#123; const config = new OverlayConfig(); // ...setup your config const overlayRef = this.overlay.create(config); const portal = new TemplatePortal(templateRef, viewContainerRef); overlayRef.attach(portal); return overlayRef;&#125; 这样，一个通用的ModalService就构建完毕了。 总结简单的介绍了如何使用Overlay，以及一个简单的可复用ModalService的构建。希望能够对你了解整个Overlay的使用过程有所帮助，下一篇将介绍如何构建可复用的Modal组件。","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://www.zcating.tk/categories/JavaScript/"}],"tags":[]},{"title":"Angular 中的 'forwardRef' 是什么","slug":"Angular-中的-forwardRef-是什么","date":"2019-06-03T15:47:50.816Z","updated":"2019-06-03T15:47:50.816Z","comments":true,"path":"2019/06/03/ckaum9y6f0001ejl3rdkdn0y7/","link":"","permalink":"http://www.zcating.tk/2019/06/03/ckaum9y6f0001ejl3rdkdn0y7/","excerpt":"几乎每一篇我所看过的文章都必须用到forwardRef。那么通过阅读本文可以了解如何在合适的时机使用它，以避免代码中不必要的复杂度。","text":"几乎每一篇我所看过的文章都必须用到forwardRef。那么通过阅读本文可以了解如何在合适的时机使用它，以避免代码中不必要的复杂度。 ‘forwardRef’ 定义我们可以从官方文档中了解forwardRef，文档上是这么写到： 允许引用尚未定义的引用。 For instance, forwardRef is used when the token which we need to refer to for the purposes of DI is declared, but not yet defined. It is also used when the token which we use when creating a query is not yet defined. 这个定义讲述了关于对类的引用，以及提及了引用类作为示例的Token。在Angular中，我们一般用这种形式来定义一个依赖： 1234const dependency = &#123; provide: SomeTokenClass, useClass: SomeProviderClass&#125;; 上面的例子中有一个provide和useClass。所以从定义中我们可以知道forwardRef用做token的形式如下： 1234const dependency = &#123; provide: forwardRef(()=&gt;&#123; SomeTokenClass &#125;), useClass: SomeProviderClass&#125;; 但是在useClass中，我们也有一个对类SomeProviderClass的引用。那么，我们能够将这种使用方式用在provider上吗？虽然官方文档上面没有提到这个用法，但是，我们知道useClass持有了SomeTokenClass类的引用，同时，我们了解到forwardRef可以被引用apply。所以，这种使用方法是允许的，我们可以用这种方式应用于provider上。 1234const dependency = &#123; provide: forwardRef(()=&gt;&#123; SomeTokenClass &#125;), useClass: forwardRef(()=&gt;&#123; SomeProviderClass &#125;)&#125;; 此外，如果你通过使用了Inject装饰器的类引用来注入一个token，那么你同样可以使用上面那种方法： 123456export class ADirective &#123; constructor(@Inject(forwardRef(() =&gt; Token)) service) &#123; ... &#125; ...&#125; 使用例子Angluar 的官方文档使用了下面的代码作为例子： 12345678910111213class Door &#123; lock: Lock; // Door attempts to inject Lock, // despite it not being defined yet. // forwardRef makes this possible. constructor(@Inject(forwardRef(() =&gt; Lock)) lock: Lock) &#123; this.lock = lock; &#125;&#125;// Only at this point Lock is defined.class Lock &#123;&#125; 这个例子有点不直观。虽然它很好的描述到了具体问题上，但是当我想要在实际应用中使用forwardRef的时候，这个例子会让我很难去理解这到底解决了什么问题。我只要需要把Lock放在Door前面不就好了吗？为什么还要用这个方法？因此，我从Angular的源码中找到了更加能够便于理解的例子。 你肯定知道Angular的表单有ngModel和formControl这两个指令，这两个指令可以让表单能够输入信息。在表单中的所有的控件都定义了一个允许通过NgModel访问指令实例的Provider。所以，举个例子，如果你需要访问一个与你自定义指令中的输入关联的表单指令，那么可以这样做： 1234567@Directive(&#123; selector: '[mycustom]'&#125;)export class MyCustom &#123; constructor(@Inject(NgControl) directive) &#123;...&lt;input type=\"text\" ngModel mycustom&gt; 为了启动NgModel和formControl，每个指令都定义了一个formControlBinding的Provider，并且，在指令装饰器中注册它。下面是formControl指令做的部分： 1234567891011export const formControlBinding: any = &#123; provide: NgControl, useExisting: FormControlDirective&#125;;@Directive(&#123; selector: '[formControl]', providers: [formControlBinding], ...&#125;)export class FormControlDirective &#123; ... &#125; 下面是NgModel的： 12345678910export const formControlBinding: any = &#123; provide: NgControl, useExisting: NgModel&#125;;@Directive(&#123; selector: &apos;[ngModel]&apos;, providers: [formControlBinding], ...&#125;)export class NgModel &#123; ... &#125; 我们感兴趣的地方在于，formControlBinding是在指令类装饰器之外定义的。所以，当JavaScript Runtime执行到定义formControlBinding对象的代码时，NgModel的代码还未执行到。如果我们将Provider对象打印出来，那么肯定会有以下结果： 1Object &#123;useExisting: undefined, token: function&#125; useExsiting指向了undefined，所以，Angular肯定是处理不了这段代码的。所以，这也是为什么要在这里使用forwardRef： 12345678910111213export const formControlBinding: any = &#123; provide: NgControl, useExisting: forwardRef(() =&gt; FormControlDirective)&#125;;export class FormControlDirective &#123; ... &#125;...export const formControlBinding: any = &#123; provide: NgControl, useExisting: forwardRef(() =&gt; NgModel)&#125;;export class NgModel&#123; ... &#125; 但是，如果我们把formControlBinding 的定义在不使用forwardRef的情况下，放在内部，这段代码还能运行吗？ 123456789101112@Directive(&#123; selector: &apos;[ngModel]&apos;, providers: [ &#123; provide: NgControl, useExisting: NgModel &#125; ], ...&#125;)export class NgModel &#123; ...&#125; 好吧，如果你看一下代码，这看起来就是在类定义前引用了NgModel。但是，你应该知道的一点是，所有类装饰器都是在这个类定义后应用到它身上的。所以即使没有forwardRef，这段代码也应该能够运行。但是通过在Provider中内嵌了另外一个Provider，我们不再导出它，所以这段代码也无法被重用。 为什么forwardRef能够运行所以现在的问题是，forwardRef是如何工作的。实际上它与JavaScript中的闭包工作方式相关。在闭包函数捕获变量时，它会捕获变量引用，而不是变量值。举个例子： 123456789let a;function enclose() &#123; console.log(a);&#125;enclose(); // undefineda = 5;enclose(); // 5 可以看到，尽管变量a在enclose函数创建之前是undefined，但是它捕获的是a的变量的引用，所以，在之后将a设为5的时候，打印出来的值也是5。 同样道理适用于forwardRef，它就是一个函数，它将类引用捕获到闭包中，并在执行这个函数之前定义了这个类。Angular编译器使用这个函数resolveForwardRef在运行时解包token或者provider。 原文地址What is forwardRef in Angular and why we need it","categories":[],"tags":[]},{"title":"FRR（Fast ReRoute)相关知识简析","slug":"FRR（Fast-ReRoute)相关知识简析","date":"2019-05-22T12:59:24.307Z","updated":"2019-05-22T12:59:24.307Z","comments":true,"path":"2019/05/22/ckaum9y700009ejl3ish93770/","link":"","permalink":"http://www.zcating.tk/2019/05/22/ckaum9y700009ejl3ish93770/","excerpt":"FRR（快速重路由）是为了解决这样一个问题：当网络中的链路或节点失效后，如果没有备份，那么数据就会丢失，那么就需要一个机制来对这些节点进行备份，这个机制就是快速重路由。 理解了快速重路由做的事情后，就要分析为什么需要这个机制。","text":"FRR（快速重路由）是为了解决这样一个问题：当网络中的链路或节点失效后，如果没有备份，那么数据就会丢失，那么就需要一个机制来对这些节点进行备份，这个机制就是快速重路由。 理解了快速重路由做的事情后，就要分析为什么需要这个机制。 FRR机制这个机制的背景也很简单，如果网络中的链路或节点失效后，报文不可避免的会出现两种情况： 丢弃 回流到原来的地方。 这样网络就会产生流量中断或者流量回环的现象。整个网络需要重新计算新的拓扑结构（图结构）和路由，才会终止这种现象。然而，重新计算整个拓扑结构需要耗费数秒时间，这样，对一些实时性要求较高的应用是不能接受的，那么，快速恢复的必要性就很高了。 链路失效的时候，流量丢失的过程可以分为两个阶段： 第一阶段：路由器未能立刻发现连接在其上的某条链路失效，导致仍然向失效的链路上转发流量。 第二阶段：路由器发现链路失效，但是网络处于收敛过程中，使得网络中其他路由器和本路由器转发表并不一致，导致出现转发层面的环路。 因此，为了减少中断时间，快速重路由机制必须有以下几个功能： 快速地发现链路失效。 当链路失效后，迅速地提供一条恢复路径。 在后继网络恢复过程中，避免出现转发环路。 FRR工作流程那么快速重路由的工作过程如下： 故障快速检测； 修改转发平面，将流量切换到预先计算好的备份路径上去。 路由重收敛； 重收敛结束后，将流量又重新切换至最优路径； 其实最重要的部分就是路由备份，如果链路中断，那么他就可以从备份中拿出新的路由，从而实现不通过失效的链路或节点到达指定的位置。之后，等待网络路由收敛后，再将流量切换到最优路径上。 FRR实现方式再描述之前，先简单介绍一下MPLS（多协议标签交换）路由技术。 路由决策路由决策是指，路由器决定数据包如何路由转发的过程。每个路由器都需要分析包头，根据网络协议层的数据进行运算，再基于这些分析和运算，独立的为数据包选择下一跳（next hop），最后通过next hop将数据包发送出去。它可以认为是由以下两部分组成的： 分类，将特定的数据包归属为一个等价转发类（Forwarding Equivalence Class，FEC） 查找，查找FEC对应的next hop（下一跳） MPLS解决了什么问题传统的路由决策，路由器需要对网络数据包进行解包，再根据目的IP地址计算归属的FEC。而MPLS提出，当网络数据包进入MPLS网络时，对网络数据包进行解包，计算归属的FEC，生成标签（Label）。当网络数据包在MPLS网络中传输时，路由决策都是基于Label，路由器不再需要对网络数据包进行解包。并且Label是个整数，以整数作为key，可以达到O(1)的查找时间。大大减少了路由决策的时间。这里的Label就是MPLS里面的L。需要注意的是Label在MPLS网络里面，是作为网络数据包的一部分，随着网络数据包传输的。 一些术语 LSR（Label Switching Router）：标记交换路由，支持MPLS转发的路由器。如果一个LSR有一个邻接的节点在MPLS网络之外，那么这个LSR就是LER。注意，这里的MPLS网络之外可以是：1.传统路由网络，2.另一个MPLS网络。 LSP（Label Switching Path）：标记交换路径，是特定的FEC中的IP协议报文所经过的LSR的集合。LSP通常也被称为MPLS tunnel（其实就是链路和节点的抽象）。 FRR的具体实现基本的快速重路由算法有两种实现方式： Detour 方式：One-to-one Backup，分别为每一条被保护 LSP 提供保护，为每一条被保护 LSP 创建一条保护路径，该保护路径称为 Detour LSP。 Bypass 方式：Facility Backup，用一条保护路径保护多条 LSP，该保护路径称为 Bypass LSP。 Detour 方式实现了每条 LSP 的保护，相对需要更大的开销。在实际使用中，Bypass 方式被更广泛使用。 Bypass的实现可以参考论文[2]。 总而言之，Bypass是通过设置一个主LSP隧道，来实现FRR。 参考[1] MPLS基础 [2] MPLS TE快速重路由","categories":[{"name":"计算机网络","slug":"计算机网络","permalink":"http://www.zcating.tk/categories/计算机网络/"}],"tags":[]},{"title":"JWT + Spring Boot Security 解决方案详解","slug":"JWT+Spring Boot Security 解决方案详解","date":"2019-05-04T12:05:49.714Z","updated":"2019-05-04T12:05:49.714Z","comments":true,"path":"2019/05/04/ckaum9y72000aejl3zo46647l/","link":"","permalink":"http://www.zcating.tk/2019/05/04/ckaum9y72000aejl3zo46647l/","excerpt":"首先编写一个简单的Token生成器12345678910111213141516171819202122232425262728293031323334353637383940@Componentpublic class JwtTokenProvider &#123; private Clock clock = DefaultClock.INSTANCE; @Value(\"$&#123;jwt.secret&#125;\") private String secret; @Value(\"$&#123;jwt.expiration&#125;\") private Long expiration; public String generateToken(String id, String username) &#123; var createdDate = clock.now(); var expirationDate = calculateExpirationDate(createdDate); return Jwts.builder() .setId(id) .setSubject(username) .setIssuedAt(createdDate) .setExpiration(expirationDate) .signWith(SignatureAlgorithm.HS512, this.secret) .compact(); &#125; public Boolean isValidated(Claims claims) &#123; return claims != null &amp;&amp; claims.getExpiration().before(clock.now()); &#125; Claims getClaims(String token) &#123; return Jwts.parser() .setSigningKey(secret) .parseClaimsJws(token) .getBody(); &#125; private Date calculateExpirationDate(Date createdDate) &#123; return new Date(createdDate.getTime() + expiration * 1000); &#125;&#125;","text":"首先编写一个简单的Token生成器12345678910111213141516171819202122232425262728293031323334353637383940@Componentpublic class JwtTokenProvider &#123; private Clock clock = DefaultClock.INSTANCE; @Value(\"$&#123;jwt.secret&#125;\") private String secret; @Value(\"$&#123;jwt.expiration&#125;\") private Long expiration; public String generateToken(String id, String username) &#123; var createdDate = clock.now(); var expirationDate = calculateExpirationDate(createdDate); return Jwts.builder() .setId(id) .setSubject(username) .setIssuedAt(createdDate) .setExpiration(expirationDate) .signWith(SignatureAlgorithm.HS512, this.secret) .compact(); &#125; public Boolean isValidated(Claims claims) &#123; return claims != null &amp;&amp; claims.getExpiration().before(clock.now()); &#125; Claims getClaims(String token) &#123; return Jwts.parser() .setSigningKey(secret) .parseClaimsJws(token) .getBody(); &#125; private Date calculateExpirationDate(Date createdDate) &#123; return new Date(createdDate.getTime() + expiration * 1000); &#125;&#125; 从AbstractAuthenticationToken扩展自定义认证令牌123456789101112131415161718192021222324252627282930313233public class BasedAuthenticationToken extends AbstractAuthenticationToken &#123; private String id; private final UserDetails principle; TokenBasedAuthentication(String id, UserDetails principle) &#123; super( principle.getAuthorities() ); this.principle = principle; &#125; public String getId() &#123; return id; &#125; public void setId(String id) &#123; this.id = id; &#125; @Override public boolean isAuthenticated() &#123; return true; &#125; @Override public Object getCredentials() &#123; return token; &#125; @Override public UserDetails getPrincipal() &#123; return principle; &#125;&#125; 从BasicAuthenticationFilter扩展自定义过滤器123456789101112131415161718public class AuthenticationFilter extends BasicAuthenticationFilter &#123; @Override protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain) throws ServletException, IOException &#123; var authorization = request.getHeader(\"Authorization\"); if (!StringUtils.isEmpty(authorization) &amp;&amp; authorization.startsWith(\"Bearer \")) &#123; var token = authorization.substring(\"Bearer \".length()); var claims = jwtTokenProvider.getAllClaims(token); // 判断是否有效 if (!jwtTokenProvider.isValidated(claims)) &#123; var userDetails = jwtService.loadUserByUsername(String.valueOf(claims.get(\"id\")), claims.getSubject()); var basedAuthenticationToken = new TokenBasedAuthentication(userDetails); SecurityContextHolder .getContext() .setAuthentication(basedAuthenticationToken); &#125; &#125; &#125;&#125; 在这里主要做以下事情： 从每个请求header获取token 对token进行合法性验证 解析得到username，并从database取出用户相关信息权限 把用户信息(role等)以UserDetail形式放进SecurityContext以备整个请求过程使用。（例如哪里需要判断用户权限是否足够时可以直接从SecurityContext取出去check） 从 WebSecurityConfigurerAdapter 继承配置适配器123456789101112131415161718192021222324252627282930313233343536373839404142@Configuration@EnableWebSecurity@EnableGlobalMethodSecurity(prePostEnabled = true)public class WebSecurityConfiguration extends WebSecurityConfigurerAdapter &#123; @Override protected void configure(HttpSecurity httpSecurity) throws Exception &#123; httpSecurity // 关闭csrf验证 .csrf().disable() // 对请求进行认证 .authorizeRequests() // 所有请求需要身份认证 .anyRequest().authenticated() // 添加一个过滤器验证Token是否合法 .and().addFilterBefore(jwtAuthenticationFilter(), AuthenticationFilter.class); httpSecurity.headers().cacheControl(); &#125; @Override public void configure(WebSecurity web) throws Exception &#123; // 除了以下接口不用验证以外。 // 此处会跳过各种认证过程。 web.ignoring().antMatchers(); &#125; @Override protected void configure(AuthenticationManagerBuilder auth) throws Exception &#123; auth.userDetailsService(service).passwordEncoder(passwordEncoder()); &#125; @Bean @Override public AuthenticationManager authenticationManagerBean() throws Exception &#123; return super.authenticationManagerBean(); &#125; @Bean AuthenticationFilter authenticationFilter() throws Exception &#123; return new AuthenticationFilter(authenticationManagerBean()); &#125;&#125; 之后，就可以对每个需要验证的请求进行校验。 认证闭环在这里，还需要做一件事情，登录的时候生成Token： 12345678910111213141516public Result login(UserLoginForm form) &#123; var userAuthInfo = userMapper.findAuthUserByName(form.getName()); var map = new HashMap(); if (userAuthInfo == null) &#123; map.put(\"error\", \"User is not exsited.\") return map; &#125; if (!passwordEncoder.matches(form.getPassword(), userAuthInfo.getPassword())) &#123; return map.put(\"error\", \"Passwords are not paired.\"); &#125; var token = tokenProvider.generateToken(userAuthInfo); var map = new HashMap(); map.put(\"token\", token); return map;&#125; 然后，当我们的请求认证成功的时候，需要获取认证成功的用户信息： 123456789101112131415161718 public Result getUserInfo() &#123; // 可以这样获取认证用户的信息 var token = (BaseAuthenticationToken)SecurityContextHolder .getContext() .getAuthentication(); var map = new HashMap(); if (token == null) &#123;map.put(\"error\", \"User is not exsited\"); return map; &#125; var userInfo = userMapper.findUserInfoById(token.getId()); var token = tokenProvider.generateToken(userAuthInfo); var map = new HashMap(); map.put(\"username\", userInfo.getUsername()); // ... return map; &#125; 这样就完成了一个完整的认证闭环，从生成Token到验证Token。","categories":[],"tags":[]},{"title":"Angular Dirty Check 简单实现","slug":"Dirty-Check-简单实现","date":"2019-04-23T11:00:00.000Z","updated":"2019-08-15T15:33:25.242Z","comments":true,"path":"2019/04/23/ckaum9y6w0007ejl3nhhs4mwt/","link":"","permalink":"http://www.zcating.tk/2019/04/23/ckaum9y6w0007ejl3nhhs4mwt/","excerpt":"所谓脏检查，其实是一种实现双向绑定的机制，原理很简单，就是通过指令（dom属性）遍历dom对象，然后为指令所在的dom添加事件或者做其他任何的事情。下面将编写一个Tiny-Angular，来实现一些简单的功能。 DOM文档下面是HTML。 1234567891011&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;test&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h1 ng-bind=&quot;helloText&quot;&gt;hello&lt;/h1&gt; &lt;h2&gt;&lt;input type=&quot;text&quot; ng-model=&quot;helloText&quot;&gt; &lt;/h2&gt; &lt;script src=“./tiny-angular.js” /&gt;&lt;/body&gt; 我们可以看到，h1和h2对象都有一个简单的指令ng-bind和ng-model那么我们将通过这个指令来实现双向绑定。","text":"所谓脏检查，其实是一种实现双向绑定的机制，原理很简单，就是通过指令（dom属性）遍历dom对象，然后为指令所在的dom添加事件或者做其他任何的事情。下面将编写一个Tiny-Angular，来实现一些简单的功能。 DOM文档下面是HTML。 1234567891011&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;test&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h1 ng-bind=&quot;helloText&quot;&gt;hello&lt;/h1&gt; &lt;h2&gt;&lt;input type=&quot;text&quot; ng-model=&quot;helloText&quot;&gt; &lt;/h2&gt; &lt;script src=“./tiny-angular.js” /&gt;&lt;/body&gt; 我们可以看到，h1和h2对象都有一个简单的指令ng-bind和ng-model那么我们将通过这个指令来实现双向绑定。 tiny-angular.js (ES6)首先我们先要定义一个Scope，使得我们所有的操作都在这个作用域下： 123456789101112131415161718192021222324252627282930class Scope &#123; constructor() &#123; this.watchers = []; &#125; watch(watcherFn, listenerFn) &#123; this.watchers.push(&#123; watcherFn, listenerFn, // 记录标记新旧值 last: undefined &#125;) &#125; digest() &#123; this.watchers.forEach((watcher) =&gt; &#123; // 运行我们的观察者函数 const newValue = watcher.watcherFn(); const oldValue = watcher.last; if (newValue !== oldValue) &#123; // 如果新旧值不相等那就运行监听者 watcher.listenerFn(newValue, oldValue); // 保存新值 watcher.last = newValue; &#125; &#125;); &#125;&#125; 在这里，构建了一个简单观察者，这个观察者的作用很简单，就是观察的时候，同时执行监听函数，这样，就实现了一个简单的双向绑定。这个双向绑定是这样调用的： 123456789101112const scope = new Scope();scope.helloText = 'hello';scope.watch(() =&gt; &#123; console.log(scope.helloText); return scope.helloText;&#125;, (newValue, oldValue) =&gt; &#123; console.log(newValue, oldValue);&#125;);scope.digest(); 那么我们就知道，多次运行digest的时候，如果我们监听的值没变，最终结果只会打印一次。 所以我们可以这样： 123456scope.helloText = 'Hello !!';scope.digest();scope.helloText = 'Hello World.';scope.digest(); 当然，我们在Scope类中封装一下，大概这样： 1234567891011121314151617... apply(doing) &#123; try &#123; doing(); &#125; catch (error) &#123; &#125; finally &#123; this.digest(); &#125; &#125;...scope.helloText = 'hello';scope.apply(()=&gt;&#123; scope.helloText = 'hello world!';&#125;);// hello hello world; Compile这一步就是构建我们脏检查。众所周知，我们的DOM是一棵树，为了构建脏检查，我们需要遍历这棵树。 123456function Compile(element, scope) &#123; // 遍历 element中的所有子树 Array.prototype.forEach.call(element.children, (child)=&gt;&#123; Compile(child, scope); &#125;);&#125; 这样，我们就能遍历这颗树，然而，还是不够，为了能够实现我们的指令功能，我们还需要遍历每个节点的属性，并找出对应的指令： 1234567891011121314151617181920212223const $directives = &#123; 'ng-bind': (scope, element, attributes) =&gt; &#123; console.log(scope, element, attributes); &#125;, 'ng-model': (scope, element, attributes) =&gt; &#123; console.log(scope, element, attributes); &#125;&#125;function Compile(element, scope) &#123; // 遍历 element中的所有子树 Array.prototype.forEach.call(element.children, (child)=&gt;&#123; Compile(child, scope); &#125;); // 遍历 element 中的所有属性（指令） Array.prototype.forEach.call(element.attributes, (attribute)=&gt;&#123; const directive = $directives[attribute.name]; console.log(scope); if (directive) &#123; directive(scope, element, element.attributes); &#125; &#125;);&#125; 好了，这样我们就能找到树中的节点的对应的指令，并做一些操作。为了实现简单的双向绑定，我们需要对指令做这些操作： ng-bind需要做的操作是，将该指令指定的scope中的对象赋给这个dom对象的innerText； ng-model需要的操作是，将input输入的值绑定到scope中的对象。 12345678910111213141516171819202122232425262728const $directives = &#123; 'ng-bind': (scope, element, attributes) =&gt; &#123; scope.watch(()=&gt;&#123; return scope[attributes['ng-bind'].value]; &#125;, (newValue) =&gt; &#123; console.log(newValue); element.innerHTML = newValue; &#125;); &#125;, 'ng-model': (scope, element, attributes) =&gt; &#123; scope.watch(()=&gt;&#123; return scope[attributes['ng-model'].value]; &#125;, (newValue) =&gt; &#123; element.value = newValue; &#125;); // 设定初始值 scope.apply(()=&gt;&#123; scope.helloText = 'hello!'; &#125;); element.addEventListener('keyup',()=&gt;&#123; scope.apply(()=&gt;&#123; scope[attributes['ng-model'].value] = element.value; &#125;); &#125;); &#125;&#125; 最终我们需要这样调用： 1Compile(document.body, $scope); 完成！ Demo测试一下，大概的效果： hello 'use strict'; class Scope { constructor() { this.watchers = []; } watch(watcherFn, listenerFn) { this.watchers.push({ watcherFn, listenerFn, last: undefined }) } digest() { this.watchers.forEach((watcher)=>{ const newValue = watcher.watcherFn(); const oldValue = watcher.last; if (newValue !== oldValue) { watcher.listenerFn(newValue, oldValue); watcher.last = newValue; } }); } $apply(doing) { try { doing(); } finally { this.digest(); } } } const $directive = { 'ng-bind': (scope, element, attributes) => { scope.watch(()=>{ console.log(attributes['ng-bind'].value); return scope[attributes['ng-bind'].value]; }, (newValue) => { console.log(newValue); element.innerHTML = newValue; }); }, 'ng-model': (scope, element, attributes) => { scope.watch(()=>{ return scope[attributes['ng-model'].value]; }, (newValue) => { element.value = newValue; }); scope.$apply(()=>{ scope.helloText = 'hello!'; }); element.addEventListener('keyup',()=>{ scope.$apply(()=>{ scope[attributes['ng-model'].value] = element.value; }); }); } } const $scope = new Scope(); function Compile(element, scope) { Array.prototype.forEach.call(element.children, (child)=>{ Compile(child, scope); }); Array.prototype.forEach.call(element.attributes, (attribute)=>{ const directive = $directive[attribute.name]; console.log(scope); if (directive) { directive(scope, element, element.attributes); } }); } Compile(document.body, $scope); $scope.helloText = 'hello111'; FULL CODE下面给出完整的代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;test&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h1 ng-bind=\"helloText\"&gt;hello&lt;/h1&gt; &lt;h2&gt;&lt;input type=\"text\" ng-model=\"helloText\"&gt;&lt;/h2&gt;&lt;/body&gt;&lt;script&gt; 'use strict'; class Scope &#123; constructor() &#123; this.watchers = []; &#125; watch(watcherFn, listenerFn) &#123; this.watchers.push(&#123; watcherFn, listenerFn, last: undefined &#125;) &#125; digest() &#123; this.watchers.forEach((watcher)=&gt;&#123; const newValue = watcher.watcherFn(); const oldValue = watcher.last; if (newValue !== oldValue) &#123; watcher.listenerFn(newValue, oldValue); watcher.last = newValue; &#125; &#125;); &#125; apply(doing) &#123; try &#123; doing(); &#125; catch (error) &#123; &#125; finally &#123; this.digest(); &#125; &#125; &#125; const $directives = &#123; 'ng-bind': (scope, element, attributes) =&gt; &#123; scope.watch(()=&gt;&#123; console.log(attributes['ng-bind'].value); return scope[attributes['ng-bind'].value]; &#125;, (newValue) =&gt; &#123; console.log(newValue); element.innerHTML = newValue; &#125;); &#125;, 'ng-model': (scope, element, attributes) =&gt; &#123; scope.watch(()=&gt;&#123; return scope[attributes['ng-model'].value]; &#125;, (newValue) =&gt; &#123; element.value = newValue; &#125;); scope.apply(()=&gt;&#123; scope.helloText = 'hello!'; &#125;); element.addEventListener('keyup',()=&gt;&#123; scope.apply(()=&gt;&#123; scope[attributes['ng-model'].value] = element.value; &#125;); &#125;); &#125; &#125; const scope = new Scope(); function Compile(element, scope) &#123; Array.prototype.forEach.call(element.children, (child)=&gt;&#123; Compile(child, scope); &#125;); Array.prototype.forEach.call(element.attributes, (attribute)=&gt;&#123; const directive = $directives[attribute.name]; console.log(scope); if (directive) &#123; directive(scope, element, element.attributes); &#125; &#125;); &#125; Compile(document.body, scope); scope.helloText = 'hello!';&lt;/script&gt;&lt;/html&gt;","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://www.zcating.tk/categories/JavaScript/"}],"tags":[]},{"title":"JavaScript 运行机制简记","slug":"JavaScript-运行机制简记","date":"2019-04-14T08:14:56.140Z","updated":"2019-04-14T08:14:56.140Z","comments":true,"path":"2019/04/14/ckaum9y7s002aejl3uosdnjxx/","link":"","permalink":"http://www.zcating.tk/2019/04/14/ckaum9y7s002aejl3uosdnjxx/","excerpt":"在我看来，所有的UI开发都有共同的一点，那就是规定了单一线程控制UI的机制，无论是Android，还是iOS，或者是各种PC端的开发，这条机制已经被前人所规定了。 当然，浏览器中的JavaScript对这一条贯彻得更加彻底，整个语言层面上就是单线程的。","text":"在我看来，所有的UI开发都有共同的一点，那就是规定了单一线程控制UI的机制，无论是Android，还是iOS，或者是各种PC端的开发，这条机制已经被前人所规定了。 当然，浏览器中的JavaScript对这一条贯彻得更加彻底，整个语言层面上就是单线程的。 执行栈、事件队列既然JavaScript是单线程，那么很显然，单线程中的每一个任务按顺序运行的，前一个完成了，后一个才能执行。在运行一个任务的过程中，就由执行栈来运行这个任务。 这个长时间的任务如果是大量的计算而造成的阻塞，那么可以通过分片的机制，将这些计算分配到不同的任务当中形成分片，然后用requestAnimationFrame来执行这些分片；如果是因为I/O等待而消耗的时间，那么可能就需要将这个任务挂起，等到I/0完成后，再来运行挂起的任务。那么这里又有了同步和异步的概念。 那么当异步任务完成后，它会往事件队列中添加回调事件。当执行栈中的任务运行完毕后，主线程会将事件队列中首个事件pop，并放入执行栈中执行这个事件。在执行完这个事件后，开始继续轮询事件队列，并执行他们。这个就是一个 event loop。 macro task 和 micro task异步事件被分为了两类，宏任务和微任务。刚刚也说到了，异步事件的回调会放入事件队列中，然而，实际上，他们时根据不同的任务类型而分配到宏任务队列和微任务。主线程在执行完执行栈上的任务后，会先去轮询微任务队列，直到微任务队列为空。这时，主线程才会从宏任务队列中轮询并执行下一个宏任务。 下面是关于哪些是宏任务微任务的列表。 宏任务： 任务 浏览器 Node I/O √ √ setInterval √ √ setTimeout √ √ requestAnimationFrame √ × setImmediate × √ 微任务： 任务 浏览器 Node Promise then catch finally √ √ MutationObserver √ × process.nextTick × √","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://www.zcating.tk/categories/JavaScript/"}],"tags":[]},{"title":"Three.js移动DecalGeometry","slug":"Three.js移动DecalGeometry","date":"2019-03-27T11:51:24.178Z","updated":"2019-03-17T16:00:54.198Z","comments":true,"path":"2019/03/27/ckaum9y78000rejl38i5x0dpj/","link":"","permalink":"http://www.zcating.tk/2019/03/27/ckaum9y78000rejl38i5x0dpj/","excerpt":"遇到了一个需求是，使得DecalGeometry可以移动，先上个demo","text":"遇到了一个需求是，使得DecalGeometry可以移动，先上个demo #three-container { position: relative; width: 100%; height: 500px; } var container = document.getElementById( 'three-container' ); var renderer; var scene; var camera; var humanModel; var humanModels = []; var raycaster; var line; var intersection = { intersects: false, point: new THREE.Vector3(), normal: new THREE.Vector3() }; var mouse = new THREE.Vector2(); var textureLoader = new THREE.TextureLoader(); var decalDiffuse = textureLoader.load( 'textures/decal-diffuse.png' ); var decalNormal = textureLoader.load( 'textures/decal-normal.jpg' ); var decalMaterial = new THREE.MeshPhongMaterial( { specular: 0x444444, map: decalDiffuse, normalMap: decalNormal, normalScale: new THREE.Vector2( 1, 1 ), shininess: 30, transparent: true, depthTest: true, depthWrite: false, polygonOffset: true, polygonOffsetFactor: - 4, wireframe: false }); var decals = []; var mouseHelper; var position = new THREE.Vector3(); var orientation = new THREE.Euler(); var size = new THREE.Vector3( 10, 10, 10 ); var params = { minScale: 10, maxScale: 20, rotate: true, clear: function () { removeDecals(); } }; var focusDecalObject = { model: null, moving: false } window.addEventListener( 'load', init ); function init() { renderer = new THREE.WebGLRenderer( { antialias: true } ); renderer.setPixelRatio( window.devicePixelRatio ); renderer.setSize( container.offsetWidth, container.offsetHeight ); container.appendChild( renderer.domElement ); scene = new THREE.Scene(); camera = new THREE.PerspectiveCamera( 45, container.offsetWidth / container.offsetHeight, 1, 1000 ); camera.position.z = 120; camera.target = new THREE.Vector3(); var controls = new THREE.OrbitControls( camera, renderer.domElement ); controls.minDistance = 50; controls.maxDistance = 200; scene.add( new THREE.AmbientLight( 0x443333 ) ); var light = new THREE.DirectionalLight( 0xffddcc, 1 ); light.position.set( 1, 0.75, 0.5 ); scene.add( light ); var light = new THREE.DirectionalLight( 0xccccff, 1 ); light.position.set( - 1, 0.75, - 0.5 ); scene.add( light ); var geometry = new THREE.BufferGeometry(); geometry.setFromPoints( [ new THREE.Vector3(), new THREE.Vector3() ] ); line = new THREE.Line( geometry, new THREE.LineBasicMaterial() ); scene.add( line ); loadLeePerrySmith(); raycaster = new THREE.Raycaster(); mouseHelper = new THREE.Mesh(new THREE.BoxBufferGeometry( 1, 1, 10 ), new THREE.MeshNormalMaterial()); mouseHelper.visible = false; scene.add( mouseHelper ); window.addEventListener('resize', onWindowResize, false); controls.addEventListener( 'change', function () { renderer.render( scene, camera ); } ); window.addEventListener( 'mousedown', function (event) { event.preventDefault(); getMousePoint(event); raycaster.setFromCamera(mouse, camera); var intersects = raycaster.intersectObjects(decals); if (intersects.length > 0) { focusDecalObject.moving = true; focusDecalObject.model = intersects[0].object; controls.enabled = false; } else { focusDecalObject.moving = false; controls.enabled = true; } }, false ); window.addEventListener( 'mouseup', function () { event.preventDefault(); if ( !focusDecalObject.moving && intersection.intersects ) { shoot(); } controls.enabled = true; focusDecalObject.moving = false; } ); window.addEventListener( 'mousemove', onTouchMove ); window.addEventListener( 'touchmove', onTouchMove ); function onTouchMove( event ) { getMousePoint(event); event.preventDefault(); if(focusDecalObject.moving) { raycaster.setFromCamera(mouse, camera); var intersects = raycaster.intersectObjects(humanModels); if (intersects.length > 0) { var model = intersects[0].object; var point = intersects[0].point; mouseHelper.position.copy(point); var normal = intersects[0].face.normal.clone(); normal.multiplyScalar(10); normal.add(intersects[0].point); mouseHelper.lookAt(normal); var rotation = mouseHelper.rotation; focusDecalObject.model.geometry.dispose(); focusDecalObject.model.geometry = new THREE.DecalGeometry(model, point, rotation, size); } } checkIntersection(); renderer.render( scene, camera ); } function getMousePoint(event) { mouse.x = (event.offsetX / container.offsetWidth) * 2 - 1; mouse.y = -(event.offsetY / container.offsetHeight) * 2 + 1; } function checkIntersection() { if ( ! humanModel ) { return; } raycaster.setFromCamera( mouse, camera ); var intersects = raycaster.intersectObjects( humanModels ); if ( intersects.length > 0 ) { var point = intersects[ 0 ].point; mouseHelper.position.copy( point ); intersection.point.copy( point ); var normal = intersects[ 0 ].face.normal.clone(); normal.transformDirection( humanModel.matrixWorld ); normal.multiplyScalar( 10 ); normal.add( intersects[ 0 ].point ); intersection.normal.copy( intersects[ 0 ].face.normal ); mouseHelper.lookAt( normal ); var positions = line.geometry.attributes.position; positions.setXYZ( 0, point.x, point.y, point.z ); positions.setXYZ( 1, normal.x, normal.y, normal.z ); positions.needsUpdate = true; intersection.intersects = true; } else { intersection.intersects = false; } } onWindowResize(); } function loadLeePerrySmith() { var loader = new THREE.GLTFLoader(); loader.load( 'LeePerrySmith/LeePerrySmith.glb', function ( gltf ) { humanModel = gltf.scene.children[ 0 ]; humanModel.material = new THREE.MeshPhongMaterial({ specular: 0x111111, map: textureLoader.load( 'LeePerrySmith/Map-COL.jpg' ), specularMap: textureLoader.load( 'LeePerrySmith/Map-SPEC.jpg' ), normalMap: textureLoader.load( 'LeePerrySmith/Infinite-Level_02_Tangent_SmoothUV.jpg' ), shininess: 25 }); scene.add( humanModel ); humanModel.scale.set( 10, 10, 10 ); humanModels.push(humanModel); } ); } function shoot() { position.copy( intersection.point ); orientation.copy( mouseHelper.rotation ); var scale = 10; var material = decalMaterial.clone(); material.color.setHex( Math.random() * 0xffffff ); var decalMesh = new THREE.Mesh( new THREE.DecalGeometry( humanModel, position, orientation, size ), material ); decals.push( decalMesh ); scene.add( decalMesh ); } function onWindowResize() { camera.aspect = container.offsetWidth / container.offsetHeight; camera.updateProjectionMatrix(); renderer.setSize( container.offsetWidth, container.offsetHeight ); renderer.render( scene, camera ); } 代码分析主要分为以下几个步骤： 点击鼠标，然后在生成decal。 点住decal的时候可以拖动decal。 首先要计算鼠标的具体位置，我们可以通过监听鼠标的事件来计算： 12345// container 是 document 对象function getMousePoint(event) &#123; mouse.x = (event.offsetX / container.offsetWidth) * 2 - 1; mouse.y = -(event.offsetY / container.offsetHeight) * 2 + 1;&#125; 通过监听点击事件，在模型上生成decal： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849// 鼠标松开会触发window.addEventListener('mouseup', function () &#123; event.preventDefault(); checkIntersection(); if ( !focusDecalObject.moving &amp;&amp; intersection.intersects ) &#123; // 在模型上进行decal shoot(); &#125; // 松开的时候轨道控制器允许运行 controls.enabled = true; focusDecalObject.moving = false;&#125;);// 鼠标点下会触发window.addEventListener('mousedown', function (event) &#123; event.preventDefault(); // 计算鼠标所在的点在三维中位置 getMousePoint(event); raycaster.setFromCamera(mouse, camera); // 用于判断我们的点是否落在decal上 var intersects = raycaster.intersectObjects(decals); // 如果落在decal上，focusDecalObject将获取点击所在的第一个decal， // 第一个decal意味着这个decal是覆盖在其他decal之上。 if (intersects.length &gt; 0) &#123; focusDecalObject.moving = true; focusDecalObject.model = intersects[0].object; controls.enabled = false; &#125; else &#123; focusDecalObject.moving = false; controls.enabled = true; &#125;&#125;, false );// 具体的将decal展示在模型上function shoot() &#123; position.copy( intersection.point ); orientation.copy( mouseHelper.rotation ); var scale = 10; var material = decalMaterial.clone(); material.color.setHex( Math.random() * 0xffffff ); var decalMesh = new THREE.Mesh( new THREE.DecalGeometry( humanModel, position, orientation, size ), material ); decals.push( decalMesh ); scene.add( decalMesh );&#125; 监听鼠标移动事件需要注意的是，要记录点下鼠标的动作，如果允许移动decal，那么就移动它，如果不，那就忽略，然后使轨道控制器运行。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566// 鼠标移动事件window.addEventListener( 'mousemove', function ( event ) &#123; getMousePoint(); event.preventDefault(); if(focusDecalObject.moving) &#123; // 还是通过raycaster计算鼠标点在3D中的位置。 raycaster.setFromCamera(mouse, camera); var intersects = this.raycaster.intersectObjects(humanModels); // 如果点在模型上，那么允许移动。 if (intersects.length &gt; 0) &#123; // var model = intersects[0].object; var point = intersects[0].point; mouseHelper.position.copy(point); // 这里的目的主要是为了改变 var normal = intersects[0].face.normal.clone(); normal.multiplyScalar(10); normal.add(intersects[0].point); mouseHelper.lookAt(normal); var rotation = mouseHelper.rotation; // 这里最重要，我们使原来的几何结构失效，并重新生成新的几何结构 focusDecalObject.model.dispose(); focusDecalObject.model.geometry = new THREE.DecalGeometry(model, position, rotation, size); &#125; &#125; // 显示点在模型上所在的平面的法线 checkIntersection();&#125;, false);function checkIntersection() &#123; if ( ! humanModel ) &#123; return; &#125; // 我们需要计算鼠标所在的点在三维中位置 raycaster.setFromCamera( mouse, camera ); // 去计算这个点是否在模型上 var intersects = raycaster.intersectObjects( humanModels ); if ( intersects.length &gt; 0 ) &#123; // 这个点在三维中的坐标 var point = intersects[ 0 ].point; mouseHelper.position.copy( point ); intersection.point.copy( point ); // 然后我们找到这个点所在平面的法线 var normal = intersects[ 0 ].face.normal.clone(); normal.transformDirection( humanModel.matrixWorld ); normal.multiplyScalar( 10 ); normal.add( intersects[ 0 ].point ); intersection.normal.copy( intersects[ 0 ].face.normal ); // 调整mouseHelper的角度，使其跟这个平面共面 mouseHelper.lookAt( normal ); // 当我们在模型上移动的时候，会显示该鼠标点上模型所在平面的法线。 var positions = line.geometry.attributes.position; positions.setXYZ( 0, point.x, point.y, point.z ); positions.setXYZ( 1, normal.x, normal.y, normal.z ); positions.needsUpdate = true; intersection.intersects = true; &#125; else &#123; intersection.intersects = false; &#125;&#125;","categories":[{"name":"-JavaScript","slug":"JavaScript","permalink":"http://www.zcating.tk/categories/JavaScript/"}],"tags":[]},{"title":"魔方测试","slug":"魔方测试","date":"2019-03-20T11:00:00.000Z","updated":"2020-05-14T14:49:41.620Z","comments":true,"path":"2019/03/20/ckaum9y85002rejl3126by459/","link":"","permalink":"http://www.zcating.tk/2019/03/20/ckaum9y85002rejl3126by459/","excerpt":"","text":"","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://www.zcating.tk/categories/JavaScript/"}],"tags":[]},{"title":"OpenGL shader 测试","slug":"OpenGL-测试","date":"2019-03-10T11:00:00.000Z","updated":"2019-03-17T15:34:49.576Z","comments":true,"path":"2019/03/10/ckaum9y76000kejl309j4pge4/","link":"","permalink":"http://www.zcating.tk/2019/03/10/ckaum9y76000kejl309j4pge4/","excerpt":"里面包含了一些OpenGL shader的测试代码，由于WebGL的shader代码跟OpenGL ES2类似，所以可以直接用OpenGL的shader代码来渲染，效果也是类似的。","text":"里面包含了一些OpenGL shader的测试代码，由于WebGL的shader代码跟OpenGL ES2类似，所以可以直接用OpenGL的shader代码来渲染，效果也是类似的。 #opengl-container { width: 300px; height: 300px; } #shader-editor { flex: 1; margin-right: 10px; font-size: 16px; } .opengl-items { display: flex; } .error-message-text { } void main() { gl_Position = vec4( position, 1.0 ); } #ifdef GL_ES precision mediump float; #endif uniform vec2 u_resolution; uniform float u_time; // Plot a line on Y using a value between 0.0 - 1.0 float plot(vec2 standard, float pct) { return smoothstep(pct - 0.005, pct, standard.y) - smoothstep(pct, pct + 0.005, standard.y); } void main() { vec2 standard = gl_FragCoord.xy/u_resolution; float y = standard.x; float pct = plot(standard, y); vec3 color = (vec3(1.0) - pct) + pct * vec3(0.0, 0.0, 0.0); gl_FragColor = vec4(color, 1.0); } #ifdef GL_ES precision mediump float; #endif uniform vec2 u_resolution; uniform float u_time; // Plot a line on Y using a value between 0.0 - 1.0 float plot(vec2 standard, float pct) { return smoothstep(pct - 0.005, pct, standard.y) - smoothstep(pct, pct + 0.005, standard.y); } void main() { vec2 standard = gl_FragCoord.xy / u_resolution ; standard.x *= u_resolution.x / u_resolution.y; float alpha = 1.0; float y = cos(alpha * standard.x + u_time); y = 0.5*y + 0.5; float pct = plot(standard, y); vec3 color = (vec3(1.0) - pct) + pct * vec3(0.0, 0.0, 0.0); gl_FragColor = vec4(color, 1.0); } #ifdef GL_ES precision mediump float; #endif uniform vec2 u_resolution; uniform vec2 u_mouse; uniform float u_time; float circle(in vec2 standard, in float radius) { vec2 dist = standard - vec2(0.5); return 1. - smoothstep(radius - (radius * 0.01), radius + (radius * 0.01), dot(dist, dist) * 4.0); } void main(){ vec2 standard = gl_FragCoord.xy / u_resolution ; vec2 translate = vec2(cos(u_time),sin(u_time)); standard += translate * 0.3; vec3 color = vec3(circle(standard, 0.1)); gl_FragColor = vec4( color, 1.0 ); } function GLCanvas(containerId, fragmentShaderText) { var scope = this; this.container = document.getElementById(containerId); this.camera = new THREE.Camera(); this.camera.position.z = 1; this.scene = new THREE.Scene(); this.uniforms = { u_time: { type: \"f\", value: 1.0 }, u_resolution: { type: \"v2\", value: new THREE.Vector2() } }; this.material = new THREE.ShaderMaterial( { uniforms: this.uniforms, vertexShader: document.getElementById( 'vertexShader' ).textContent, fragmentShader: fragmentShaderText }); var geometry = new THREE.PlaneBufferGeometry( 10, 10 ); var mesh = new THREE.Mesh( geometry, this.material ); this.scene.add( mesh ); this.renderer = new THREE.WebGLRenderer(); this.renderer.setPixelRatio( window.devicePixelRatio ); this.container.appendChild( this.renderer.domElement ); this.onWindowResize = function ( event ) { scope.renderer.setSize( scope.container.offsetWidth, scope.container.offsetHeight ); scope.uniforms.u_resolution.value.x = scope.renderer.domElement.width; scope.uniforms.u_resolution.value.y = scope.renderer.domElement.height; } this.animate = function() { requestAnimationFrame( scope.animate ); scope.render(); } this.render = function() { scope.uniforms.u_time.value += 0.05; scope.renderer.render( scope.scene, scope.camera ); } this.onWindowResize(); window.addEventListener( 'resize', this.onWindowResize, false ); this.animate(); } function ShaderEditor (viewId, containerId) { var scope = this; this.editor = ace.edit(viewId); this.editor.resize(true); this.editorDom = document.getElementById(viewId); this.editorDom.style.height = this.editor.getSession().getScreenLength() * (this.editor.renderer.lineHeight + 2) + 'px'; this.canvas = new GLCanvas(containerId, this.editor.getValue()); this.editor.getSession().setUseWrapMode(true); this.editor.setAutoScrollEditorIntoView(true) ; this.editor.getSession().on('change', function (event) { scope.canvas.material.fragmentShader = scope.editor.getValue(); scope.canvas.material.needsUpdate = true; var newHeight = scope.editor.getSession().getScreenLength() * scope.editor.renderer.lineHeight; scope.editorDom.style.height = newHeight + 'px'; scope.editor.resize(); }); this.changeText = function (text) { scope.editor.setValue(text); scope.editor.clearSelection(); } } .selectors { display: flex; flex-wrap: wrap; flex-direction: row; margin-bottom: 10px; } .selectors>.title { line-height:30px; } .selectors>.selector { display: flex; flex-direction: row; align-items: center; margin: 0 10px; } 方程: 直线 三角函数 圆形 #ifdef GL_ES precision mediump float; #endif uniform vec2 u_resolution; uniform float u_time; // Plot a line on Y using a value between 0.0 - 1.0 float plot(vec2 standard, float pct) { return smoothstep(pct - 0.005, pct, standard.y) - smoothstep(pct, pct + 0.005, standard.y); } void main() { vec2 standard = gl_FragCoord.xy/u_resolution; float y = standard.x; float pct = plot(standard, y); vec3 color = (vec3(1.0) - pct) + pct * vec3(0.0, 0.0, 0.0); gl_FragColor = vec4(color, 1.0); } $(document).ready(function () { var shaderEditor = new ShaderEditor('shader-editor', 'opengl-container'); $('.selector input[name=equation]').change(function () { if (this.value === '1') { shaderEditor.changeText(document.getElementById('LineShader').textContent); } else if (this.value === '2') { shaderEditor.changeText(document.getElementById('TriangleFunctionShader').textContent); } else if (this.value === '3') { shaderEditor.changeText(document.getElementById('CircularShader').textContent); } }); })","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://www.zcating.tk/categories/JavaScript/"},{"name":"OpenGL","slug":"JavaScript/OpenGL","permalink":"http://www.zcating.tk/categories/JavaScript/OpenGL/"}],"tags":[]},{"title":"flex布局测试","slug":"flex布局测试","date":"2019-03-09T11:00:00.000Z","updated":"2019-03-17T15:34:49.692Z","comments":true,"path":"2019/03/09/ckaum9y7b000zejl3e33pm7fn/","link":"","permalink":"http://www.zcating.tk/2019/03/09/ckaum9y7b000zejl3e33pm7fn/","excerpt":"一个简单的flex布局测试。","text":"一个简单的flex布局测试。 var isMobile = null; var isPC = null; var isWechat = null; $(document).ready(function () { isMobile = !!navigator.userAgent.match(/AppleWebKit.*Mobile.*/); isWechat = !!navigator.userAgent.match(/MicroMessenger/); if (isMobile || isWechat) { $('.flex-test').css('width', '300px'); } }); .auto-widget { width: 100px; height: auto; color: #fff; } .small-widget { width:50px; height:50px; color:#fff; flex-shrink: 0; } .mid-widget { width:100px; height:100px; color:#fff; flex-shrink: 0; } .big-widget { line-height: 200px; width:200px; height:200px; color:#fff; } .sun { background-size: cover; background-image:url(./Sun.jpg); } .earth { background-size: cover; background-image:url(./Earth.jpg); } .mars { background-size: cover; background-image:url(./Mars.jpg); } .moon { background-size: cover; background-image:url(./Moon.jpg); } .neptune { background-size: cover; background-image:url(./Neptune.jpg); } .saturn { background-size: cover; background-image:url(./Saturn.jpg); } .uranus { background-size: cover; background-image:url(./Uranus.jpg); } .selectors { display: flex; flex-wrap: wrap; flex-direction: row; margin-bottom: 10px; } .selectors>.title { line-height:30px; } .selectors>.selector { display: flex; flex-direction: row; align-items: center; margin: 0 10px; } .flex-test { width: 500px; height:400px; display: flex; flex-direction: row; overflow: auto; border: 1px solid #000000; } .flex-test img { transition: .2s; } .flex-test div { transition: .2s; } .slider { -webkit-appearance: none; appearance: none; width: 300px; height: 20px; background: #d3d3d3; outline: none; opacity: 0.7; -webkit-transition: .2s; transition: opacity .2s; } .slider:hover { opacity: 1; } .slider::-webkit-slider-thumb { -webkit-appearance: none; appearance: none; width: 20px; height: 20px; background: blue; cursor: pointer; } .slider::-moz-range-thumb { width: 20px; height: 20px; background: blue; cursor: pointer; } 容器属性flex-direction $(document).ready(function () { $('input[type=radio][name=flex-direction-selector]').change(function() { $('.body1>.flex-test').first().css('flex-direction', this.value); }); }); flex-direction: row column row-reverse column-reverse flex-wrap $(document).ready(function () { $('input[type=radio][name=flex-wrap-selector]').change(function() { $('.body2>.flex-test').first().css('flex-wrap', this.value); }); }); flex-wrap: nowrap wrap wrap-reverse justify-content $(document).ready(function () { $('input[type=radio][name=flex-justify-content-selector]').change(function() { $('.body3>.flex-test').first().css('justify-content', this.value); }); }); justify-content: flex-start flex-end center space-between space-around align-items $(document).ready(function () { $('.body4 input[type=radio][name=flex-align-items-selector]').change(function() { $('.body4>.flex-test').first().css('align-items', this.value); }); }); align-items: stretch flex-start flex-end center baseline Sun Earth Mars align-content $(document).ready(function () { $('input[type=radio][name=flex-wrap-align-content-selector]').change(function() { $('.body5>.flex-test').first().css('flex-wrap', this.value); }); $('input[type=radio][name=flex-align-content-selector]').change(function() { $('.body5>.flex-test').first().css('align-content', this.value); }); }); flex-wrap: nowrap wrap wrap-reverse align-content: stretch flex-start flex-end center space-between space-around 项目属性order $(document).ready(function () { $('input[type=radio][name=flex-order-selector]').prop({disabled: true}); $('.body6>.flex-test>div').click(function() { $('input[type=radio][name=flex-order-selector]').prop({disabled: false}); $('.body6>.flex-test>div.active').removeClass('active'); $(this).addClass('active'); var value = $(this).css('order'); $('input[type=radio][name=flex-order-selector][value=' + (value || 0) + ']').prop('checked', true); }); $('input[type=radio][name=flex-order-selector]').change(function() { var active = $('.body6>.flex-test>div.active'); active.css('order', this.value); active.text(this.value); }); }); order: 0 1 2 3 4 5 6 7 8 0 0 0 0 0 0 0 .body6>.flex-test { flex-wrap: wrap; } .body6>.flex-test>div.active { margin: 0 10px; border: 2px solid red; } flex-grow $(document).ready(function () { $('input[type=radio][name=flex-grow-selector]').prop({disabled: true}); $('.body7>.flex-test>div').click(function() { $('input[type=radio][name=flex-grow-selector]').prop({disabled: false}); $('.body7>.flex-test>div.active').removeClass('active'); $(this).addClass('active'); var value = $(this).css('flex-grow'); $('input[type=radio][name=flex-grow-selector][value=' + (value || 0) + ']').prop('checked', true); }); $('input[type=radio][name=flex-grow-selector]').change(function() { var active = $('.body7>.flex-test>div.active'); active.css('flex-grow', this.value); active.text(this.value); }); }); grow: 0 1 2 3 4 5 6 7 8 0 0 0 .body7>.flex-test { flex-wrap: wrap; } .body7>.flex-test>div.active { border: 2px solid red; } flex-shrink $(document).ready(function () { $('input[type=radio][name=flex-grow-selector]').prop({disabled: true}); $('.body8>.flex-test>div').click(function() { $('input[type=radio][name=flex-shrink-selector]').prop({disabled: false}); $('.body8>.flex-test>div.active').removeClass('active'); $(this).addClass('active'); var value = $(this).css('flex-shrink'); $('input[type=radio][name=flex-shrink-selector][value=' + (value || 0) + ']').prop('checked', true); }); $('input[type=radio][name=flex-shrink-selector]').change(function() { var active = $('.body8>.flex-test>div.active'); active.css('flex-shrink', this.value); active.text(this.value); }); }); shrink: 0 1 2 3 4 5 6 7 8 1 1 1 1 1 1 1 .body8>.flex-test>div { flex-shrink: 1; } .body8>.flex-test>div.active { border: 2px solid red; } flex-basis $(document).ready(function () { $('input[type=range]').prop({disabled: true}); $('.body9>.flex-test>div').click(function() { $('input[type=range]').prop({disabled: false}); $('.body9>.flex-test>div').removeClass('active'); $(this).addClass('active'); var value = $(this).css('flex-basis'); value = 'auto' ? '50px' : value; $(this).css('flex-basis', value); $('input[type=range]').prop('value', parseInt(value.split('px')[0])); $('#slider-value').text(value); }); $('input[type=range]').on('input', function() { var value = this.value + 'px'; $('#slider-value').text(value); $('.body9>.flex-test>div.active').css('flex-basis', value); }); $('#reset-slider-button').click(function() { $('input[type=range]').prop({disabled: true, value: 50}); $('#slider-value').text('50px'); $('.body9>.flex-test>div').removeClass('active'); $('.body9>.flex-test>div').css('flex-basis', 'auto'); }); }); Reset flex-basis: 50px 1 1 1 1 1 1 1 .body9>.flex-test>div { flex-shrink: 1; } .body9>.flex-test>div.active { border: 2px solid red; } align-selfalign-self的属性有这些： auto（默认） flex-start flex-end center baseline stretch其中auto，跟align-items一样。 $(document).ready(function () { $('input[type=radio][name=flex-align-self-selector]').prop({disabled: true}); $('.body10>.flex-test>div').click(function() { $('input[type=radio][name=flex-align-self-selector]').prop({disabled: false}); $('.body10>.flex-test>div').removeClass('active'); $(this).addClass('active'); var value = $(this).css('align-self'); $('input[type=radio][name=flex-align-self-selector][value=' + value + ']').prop('checked', true); }); $('.body10 input[type=radio][name=flex-align-self-selector]').change(function() { $('.body10>.flex-test>div.active').css('align-self', this.value); }); $('.body10 input[type=radio][name=flex-align-items-selector2]').change(function() { $('.body10>.flex-test').first().css('align-items', this.value); }); }); align-items: stretch flex-start flex-end center baseline align-self: auto flex-start flex-end center baseline stretch Sun Earth Moon Mars Neptune Saturn Uranus .body10>.flex-test>div { flex-shrink: 1; } .body10>.flex-test>div.active { border: 2px solid red; }","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://www.zcating.tk/categories/JavaScript/"}],"tags":[]},{"title":"iOS-用OpenGL渲染相机输出的图像","slug":"iOS-用OpenGL渲染相机输出的图像","date":"2019-03-05T11:00:00.000Z","updated":"2019-03-17T15:34:49.802Z","comments":true,"path":"2019/03/05/ckaum9y7t002cejl3q7td2fon/","link":"","permalink":"http://www.zcating.tk/2019/03/05/ckaum9y7t002cejl3q7td2fon/","excerpt":"相机类相关的类： AVCaptureSession AVCaptureDeviceInput AVCatureDevice AVCaptureDeviceOutput AVCaptureVideoDataOutput","text":"相机类相关的类： AVCaptureSession AVCaptureDeviceInput AVCatureDevice AVCaptureDeviceOutput AVCaptureVideoDataOutput 定义以下properties： 1234@property (nonatomic, strong) AVCaptureSession *session;@property (nonatomic, strong) AVCaptureDeviceInput *frontCameraInput;@property (nonatomic, strong) AVCaptureDeviceInput *backCameraInput;@property (nonatomic, strong) AVCaptureVideoDataOutput *videoOutput; 我们通过session来操作摄像头、摄像头参数以及摄像头数据，使用懒加载初始化session： 123456-(AVCaptureSession *)session &#123; if (_session == nil) &#123; _session = [AVCaptureSession new]; &#125; return _session;&#125; 同样是懒加载初始化设备输入： 123456789101112131415161718192021222324252627282930313233-(AVCaptureDeviceInput *)backCameraInput &#123; if (_backCameraInput == nil) &#123; NSArray *devices = [AVCaptureDevice devicesWithMediaType:AVMediaTypeVideo]; NSError *error; for (AVCaptureDevice *device in devices) &#123; if (device.position == AVCaptureDevicePositionFront) &#123; continue; &#125; _backCameraInput = [AVCaptureDeviceInput deviceInputWithDevice:device error:&amp;error]; if (error) &#123; NSLog(@&quot;[FaceCamera] error: %@&quot;, error.description); &#125; &#125; &#125; return _backCameraInput;&#125;-(AVCaptureDeviceInput *)frontCameraInput &#123; if (_frontCameraInput == nil) &#123; NSArray *devices = [AVCaptureDevice devicesWithMediaType:AVMediaTypeVideo]; NSError *error; for (AVCaptureDevice *device in devices) &#123; if (device.position == AVCaptureDevicePositionBack) &#123; continue; &#125; _frontCameraInput = [AVCaptureDeviceInput deviceInputWithDevice:device error:&amp;error]; if (error) &#123; NSLog(@&quot;[FaceCamera] error: %@&quot;, error.description); &#125; &#125; &#125; return _frontCameraInput;&#125; 因为手机端，只有两个摄像头设备（前置和后置），还可以这样： 1234567891011121314151617181920212223-(AVCaptureDeviceInput *)backCameraInput &#123; if (_backCameraInput == nil) &#123; NSArray *devices = [AVCaptureDevice devicesWithMediaType:AVMediaTypeVideo]; NSError *error; _frontCameraInput = [AVCaptureDeviceInput deviceInputWithDevice:devices[0] error:&amp;error]; if (error) &#123; NSLog(@&quot;[FaceCamera] error: %@&quot;, error.description); &#125; &#125; return _backCameraInput;&#125;-(AVCaptureDeviceInput *)frontCameraInput &#123; if (_frontCameraInput == nil) &#123; NSArray *devices = [AVCaptureDevice devicesWithMediaType:AVMediaTypeVideo]; NSError *error; _frontCameraInput = [AVCaptureDeviceInput deviceInputWithDevice:devices[0] error:&amp;error]; if (error) &#123; NSLog(@&quot;[FaceCamera] error: %@&quot;, error.description); &#125; &#125; return _frontCameraInput;&#125; 然后懒加载视频输出 1234567891011121314-(AVCaptureVideoDataOutput *)videoOutput &#123; if (_videoOutput == nil) &#123; _videoOutput = [AVCaptureVideoDataOutput new]; // 这里的setting可以去看具体的文档 _videoOutput.videoSettings = @&#123; (NSString*)kCVPixelBufferPixelFormatTypeKey: @(kCMPixelFormat_32BGRA) &#125;; // 这里表示，当你处理的这一帧超过一帧的时间，这一帧会做丢失处理 _videoOutput.alwaysDiscardsLateVideoFrames = YES; // 设置输出的委托，并且指定操作队列，这里_videoQueue是自定义的操作队列 [_videoOutput setSampleBufferDelegate:self queue:_videoQueue]; &#125; return _videoOutput;&#125; 将输入输出添加进session： 123456789101112131415161718-(void)updateSession &#123; // 在这里添加主要的输入和输出。 // 摄像头的位置 if (self.devicePosition == AVCaptureDevicePositionFront) &#123; if ([self.session canAddInput:self.frontCameraInput]) &#123; [self.session addInput:self.frontCameraInput]; &#125; &#125; else &#123; if ([self.session canAddInput:self.backCameraInput]) &#123; [self.session addInput:self.backCameraInput]; &#125; &#125; // 摄像头的输出 if ([self.session canAddOutput:self.videoOutput]) &#123; [self.session addOutput:self.videoOutput]; &#125;&#125; 相机启动和关闭相关的函数， 123456789101112131415161718192021222324252627282930313233343536373839404142434445- (void)start &#123; // 如果已经启动，直接返回 if (_running == YES) &#123; return; &#125; // 如果 session 未加载，加载 session if (_sessionLoaded == NO) &#123; [self updateSession]; _sessionLoaded = YES; &#125; // 启动 session [self.session startRunning]; _running = YES;&#125;- (void)stop &#123; // 如果已经关闭，直接返回 if (_running == NO) &#123; return; &#125; // 将所有的输入移除 for (AVCaptureInput *input in self.session.inputs) &#123; [self.session removeInput:input]; &#125; // 将所有的输出移除 for (AVCaptureOutput *output in self.session.outputs) &#123; [self.session removeOutput:output]; &#125; // 停止 session [self.session stopRunning]; _running = NO; // 标记 session 为未加载状态 _sessionLoaded = NO;&#125;-(void)pause &#123; // 普通暂停，只需要直接停止就好 [self.session stopRunning]; _running = NO;&#125; 上面的start和stop非常重要，当你切换摄像头、分辨率或添加其他新的输入输出（比如`AVCaptureMetadataOutput ）的时候，需要这样做： 123456789101112131415161718-(void)switchCameras &#123; // 先保存当前的运行状态 BOOL wasRunning = _running; // 判断当的运行状态 if (wasRunning) &#123; [self stop]; &#125; // 这里是切换摄像头的主要逻辑 // 这里可以换成切换其他的逻辑 if (self.devicePosition == AVCaptureDevicePositionFront) &#123; self.devicePosition = AVCaptureDevicePositionBack; &#125; else &#123; self.devicePosition = AVCaptureDevicePositionFront; &#125; if (wasRunning) &#123; [self start]; &#125;&#125; 编写视频输出的delegate： 1234- (void)captureOutput:(AVCaptureOutput *)output didOutputSampleBuffer:(CMSampleBufferRef)sampleBuffer fromConnection:(AVCaptureConnection *)connection &#123; // 我们将在这里转发这个delegate [self.delegate processFrame:sampleBuffer];&#125; 相机视图类首先，我们要初始化视图： 123456789101112131415161718192021- (id)initWithFrame:(CGRect)frame &#123; self = [super initWithFrame:frame]; if (self) &#123; self.contentScaleFactor = [[UIScreen mainScreen] scale]; self.context = [[EAGLContext alloc] initWithAPI:kEAGLRenderingAPIOpenGLES3]; [EAGLContext setCurrentContext:self.context]; [self setupLayer]; // 可以先忽略 [self setupBuffers]; &#125; return self;&#125;- (void)setupLayer &#123; CAEAGLLayer *eaglLayer = (CAEAGLLayer *)self.layer; eaglLayer.opaque = TRUE; eaglLayer.drawableProperties = @&#123; kEAGLDrawablePropertyRetainedBacking: @(YES), kEAGLDrawablePropertyColorFormat: kEAGLColorFormatRGBA8 &#125;;&#125; 为了能够使用OpenGL来绘制摄像机图像，我们首先需要设定好OpenGL缓冲区： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849enum CameraAttributes &#123; CameraAttributesPosition = 0, CameraAttributesTextureCoordinate = 1,&#125;;- (void)setupBuffers &#123; // 深度测试的目的是为了绘制当前像素组中里屏幕最近的像素。 // 需要绘制透明图层的时候，关闭深度测试，不然透明图层不会透过去。 glDisable(GL_DEPTH_TEST); // 将原色和目标色混合，目的还是用来绘制透明图层。 glEnable(GL_BLEND); // 在图元从远到近的排列下，透明图层的使用以下方法来实现是最佳选择。请注意，此透明度计算不要求alpha位存在于帧缓冲区。 // https://www.khronos.org/registry/OpenGL-Refpages/es2.0/xhtml/glBlendFunc.xml glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA); // 顶点着色的第一个属性。 glEnableVertexAttribArray(CameraAttributesPosition); // 将该属性在CPU和GPU建立上逻辑关系。 glVertexAttribPointer(CameraAttributesPosition, 2, GL_FLOAT, GL_FALSE, 2 * sizeof(GLfloat), 0); // 顶点着色器的第二个属性。 glEnableVertexAttribArray(CameraAttributesTextureCoordinate); // 将该属性在CPU和GPU建立上逻辑关系。 glVertexAttribPointer(CameraAttributesTextureCoordinate, 2, GL_FLOAT, GL_FALSE, 2 * sizeof(GLfloat), 0); // 建立帧缓冲区，并将其绑定到_frameBufferID上，通过_frameBufferID我们可以拿到在OpenGL中的帧缓冲的数据。 glGenFramebuffers(1, &amp;_frameBufferID); glBindFramebuffer(GL_FRAMEBUFFER, _frameBufferID); // 建立渲染缓冲区。 glGenRenderbuffers(1, &amp;_colorBufferID); glBindRenderbuffer(GL_RENDERBUFFER, _colorBufferID); // 将渲染缓冲区 以 GL_COLOR_ATTACHMENT0 的形式绑定到帧缓冲区上。 glFramebufferRenderbuffer(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, GL_RENDERBUFFER, _colorBufferID); // 获取帧缓冲区的状态。 if (glCheckFramebufferStatus(GL_FRAMEBUFFER) != GL_FRAMEBUFFER_COMPLETE) &#123; NSLog(@&quot;Failed to make complete framebuffer object %x&quot;, glCheckFramebufferStatus(GL_FRAMEBUFFER)); &#125; // 将EAGLDrawable的存储绑定到渲染缓冲对象上。 [self.context renderbufferStorage:GL_RENDERBUFFER fromDrawable:(CAEAGLLayer *)self.layer]; // 获取渲染缓冲区的宽高 glGetRenderbufferParameteriv(GL_RENDERBUFFER, GL_RENDERBUFFER_WIDTH, &amp;_renderBufferWidth); glGetRenderbufferParameteriv(GL_RENDERBUFFER, GL_RENDERBUFFER_HEIGHT, &amp;_renderBufferHeight);&#125; 到这里，我们已经设置好了我们的可绘制的图层self.layer，然后我们要将摄像头数据输入到渲染缓冲上，渲染缓冲的数据经过处理后，在上下文会将数据在self.layer中展示，但是在这之前，我们先得编写着色器，通过着色器，摄像头捕捉到的图像数据会在渲染缓冲区中被处理。下面给出一个简单的着色器外覆类，主要的功能是加载顶点着色器和片段着色器，它包含了两个参数，分别是顶点着色器和片段着色器的地址： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100@interface Shader : NSObject@property (nonatomic) GLuint program;@end@implementation Shader- (instancetype)initWithVertexShaderURL:(NSURL *)vertexShaderURL fragmentShaderURL:(NSURL *)fragmentShaderURL &#123; self = [super init]; if (self) &#123; // 编译代码着色器。 GLuint vertexShaderID = [self complieWithType:FCShaderTypeVertex URL:vertexShaderURL]; GLuint fragmentShaderID = [self complieWithType:FCShaderTypeFragment URL:fragmentShaderURL]; // 创建着色器程序，并链接上述的着色器 self.program = glCreateProgram(); glAttachShader(self.program, vertexShaderID); glAttachShader(self.program, fragmentShaderID); glLinkProgram(self.program); GLint status = 0; glGetProgramiv(self.program, GL_LINK_STATUS, &amp;status); if (status == 0) &#123; GLint logLength; glGetProgramiv(self.program, GL_INFO_LOG_LENGTH, &amp;logLength); if (logLength &gt; 0) &#123; GLchar *log = (GLchar *)malloc(logLength); glGetProgramInfoLog(self.program, logLength, &amp;logLength, log); NSLog(@&quot;Program link log: %s&quot;, log); free(log); &#125; &#125; // 链接完毕，program中已经有着色器，将着色器销毁。 if (vertexShaderID) &#123; glDetachShader(self.program, vertexShaderID); glDeleteShader(vertexShaderID); &#125; if (fragmentShaderID) &#123; glDetachShader(self.program, fragmentShaderID); glDeleteShader(fragmentShaderID); &#125; &#125; return self;&#125;#pragma mark - PUBLIC-(void)use &#123; // 运行着色器程序 glUseProgram(self.program);&#125;#pragma mark - PRIVATE// 外覆函数，处理 URL，将URL指向的文件中的代码读取出来。- (GLuint)complieWithType:(ShaderType)type URL:(NSURL *)url &#123; NSError *error; NSString *code = [[NSString alloc] initWithContentsOfURL:url encoding:NSUTF8StringEncoding error:&amp;error]; if (code == nil) &#123; NSLog(@&quot;Failed to load vertex shader: %@&quot;, [error localizedDescription]); return 0; &#125; return [self complieWithType:type code:code];&#125;// 实际操作的函数，直接处理代码- (GLuint)complieWithType:(ShaderType)type code:(NSString *)code &#123; GLenum glType = type == ShaderTypeVertex ? GL_VERTEX_SHADER : GL_FRAGMENT_SHADER; const GLchar* rawCode = [code UTF8String]; // 创建着色器并编译着色器代码。 GLuint shaderID = glCreateShader(glType); glShaderSource(shaderID, 1, &amp;rawCode, NULL); glCompileShader(shaderID); // 一些错误处理。 GLint status = 0; glGetShaderiv(shaderID, GL_COMPILE_STATUS, &amp;status); if (status == 0) &#123; [self showCompileErrorWith:shaderID]; glDeleteShader(shaderID); return 0; &#125; return shaderID;&#125;- (void)showCompileErrorWith:(GLint)shaderID &#123; GLint infoLength; glGetShaderiv(shaderID, GL_INFO_LOG_LENGTH, &amp;infoLength); if (infoLength == 0) &#123; return; &#125; GLchar *info = (GLchar *)malloc(infoLength); glGetShaderInfoLog(shaderID, infoLength, &amp;infoLength, info); NSLog(@&quot;Shader compile log:\\n%s&quot;, info); free(info);&#125;@end 这样，完整的视图构造函数如下： 123456789101112131415- (id)initWithFrame:(CGRect)frame &#123; self = [super initWithFrame:frame]; if (self) &#123; NSURL *vertShaderURL = [[NSBundle mainBundle] URLForResource:@&quot;CameraRGBA&quot; withExtension:@&quot;vsh&quot;]; NSURL *fragShaderURL = [[NSBundle mainBundle] URLForResource:@&quot;CameraRGBA&quot; withExtension:@&quot;fsh&quot;]; _shader = [[Shader alloc] initWithVertexShaderURL:vertShaderURL fragmentShaderURL:fragShaderURL]; self.contentScaleFactor = [[UIScreen mainScreen] scale]; self.context = [[EAGLContext alloc] initWithAPI:kEAGLRenderingAPIOpenGLES3]; [EAGLContext setCurrentContext:self.context]; [self setupLayer]; // 可以先忽略 [self setupBuffers]; &#125; return self;&#125; 这里顶点着色器，片段着色器以及相机的回调将结合在一起编写。为了显示摄像头数据，我们的思路是将相机数据转换成纹理，然后将纹理绑定到指定的点上，先展示顶点数据： 123456789101112131415// 顶点数据GLfloat _imageVertices[8] = &#123; -1, -1, 1, -1, -1, 1, 1, 1&#125;;// Texture 在顶点数据中的位置GLfloat _textureCoordinates[] = &#123; 0, 0, 1, 0, 0, 1, 1, 1&#125;; 画个图，就能明白了： 其中，viewpoint是我们整个渲染的大小，通过这样来设置：glViewport(0, 0, _renderBufferWidth, _renderBufferHeight)。 下面，来处理相机数据，使得数据能够在屏幕上展示。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798- (void)processframe:(CMSampleBufferRef)frame &#123; CVPixelBufferRef pixelBuffer = CMSampleBufferGetImageBuffer(frame); int frameWidth = (int)CVPixelBufferGetWidth(pixelBuffer); int frameHeight = (int)CVPixelBufferGetHeight(pixelBuffer); // 设置全局的EAGLContext为self.context，不设置容易导致渲染失败 if(![[EAGLContext currentContext] isEqual:self.context]) &#123; [EAGLContext setCurrentContext:self.context]; &#125; // 刷新缓存 CVOpenGLESTextureCacheFlush(self.cameraTextureCache, 0); // CVOpenGLESTextureRef cameraTexture; CVReturn err = CVOpenGLESTextureCacheCreateTextureFromImage(kCFAllocatorDefault, self.cameraTextureCache, pixelBuffer, NULL, GL_TEXTURE_2D, GL_RGBA, frameWidth, frameHeight, GL_BGRA, GL_UNSIGNED_BYTE, 0, &amp;cameraTexture); if (err) &#123; NSLog(@&quot;Create Texture Failed: %d&quot;, err); &#125; // 设定渲染屏幕的大小，一个正方形，以左上角为原点，右为x轴正向，下为y轴正向 glViewport(0, 0, _renderBufferWidth, _renderBufferHeight); // 清空当前的缓存值，以便可以渲染下一帧 glClear(GL_COLOR_BUFFER_BIT); // 设置纹理单元 glActiveTexture(GL_TEXTURE0); // 绑定纹理目标(cameraTexture)到指定的纹理单元，该函数会自动把纹理赋给片段着色器上的采样器 glBindTexture(CVOpenGLESTextureGetTarget(cameraTexture), CVOpenGLESTextureGetName(cameraTexture)); // 设定纹理的属性 // 更细节的属性可以查看文档，linear的作用主要是使得渲染出来的图像更为平滑 glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR); glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR); // 设定了GL_CLAMP_TO_EDGE 的纹理会被限制在0到1中，超出的部分会重复纹理坐标边缘的颜色值，产生边缘被拉伸的效果 glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE); glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE); // 绑定帧缓冲区 glBindFramebuffer(GL_FRAMEBUFFER, _frameBufferID); // 启动着色器程序 [_shader use]; // 将图像顶点输入到顶点着色器中 glVertexAttribPointer(CameraAttributesPosition, 2, GL_FLOAT, 0, 0, _imageVertices); glEnableVertexAttribArray(CameraAttributesPosition); // 将纹理的相对于顶点组的坐标输入到顶点着色器中 glVertexAttribPointer(CameraAttributesTextureCoordinate, 2, GL_FLOAT, 0, 0, _textureCoordinates); glEnableVertexAttribArray(CameraAttributesTextureCoordinate); // strip，意味着当存在了三个顶点的时候，每增加一个顶点，新增一个三角形。设三角形第n个结点为V(n)，那么，这个新增的三角形的连接方式为：( V(n), V(n-1), V(n-2) ) (n &gt;= 3) glDrawArrays(GL_TRIANGLE_STRIP, 0, 4); glBindRenderbuffer(GL_RENDERBUFFER, _colorBufferID); // 展示当前的渲染缓冲区 [self.context presentRenderbuffer:GL_RENDERBUFFER]; // 将纹理渲染后，我们要将它销毁，避免内存泄露。 CFRelease(cameraTexture);&#125;// 顶点着色器#version 300 es// 这里是 CameraAttributesPosition，通过glVertexAttribPointer，将值传入到着色器中layout(location = 0) in vec4 position;// 这里是 CameraAttributesTextureCoordinate layout(location = 1) in vec2 textureCoordinate;// 输出到片段着色器out vec2 outTextureCoordinate;void main()&#123; // 标定渲染点元在世界坐标中的位置 gl_Position = position; // 将纹理在点元中的相对坐标传入，由片段着色器处理 outTextureCoordinate = textureCoordinate;&#125;// 片段着色器// 从顶点着色器输入in highp vec2 outTextureCoordinate;// 输出out highp vec4 fragColor;// 外部的纹理的数据采样uniform sampler2D samplerRGBA;void main()&#123; // 通过内建函数采样纹理的颜色，第一个参数是纹理采样器，第二个是纹理坐标，texture会根据纹理参数的设定来对纹理进行采样，这样片段着色器的输出就是纹理的(插值)纹理坐标上的(过滤后的)颜色。——来自 learnOpenGL 中对纹理的解释 fragColor = texture(samplerRGBA, outTextureCoordinate);&#125; 为这个view添加摄像头启动和关闭方法： 123456-(void)start &#123; [self.camera start];&#125;-(void)stop &#123; [self.camera stop];&#125; 最后，将它实例化，并添加到ViewController中 12345-(void)viewDidLoad &#123; _cameraView = [[CameraView alloc] initWithFrame:[UISCreen mainScreen].bounds]; [self.view addSubview:_cameraView]; [_cameraView start];&#125;","categories":[{"name":"Objective-C","slug":"Objective-C","permalink":"http://www.zcating.tk/categories/Objective-C/"}],"tags":[]},{"title":"Vue组件间通信总结","slug":"Vue组件间通信总结","date":"2019-02-27T13:00:00.000Z","updated":"2019-08-11T14:46:34.230Z","comments":true,"path":"2019/02/27/ckaum9y79000sejl3wlmdvqpk/","link":"","permalink":"http://www.zcating.tk/2019/02/27/ckaum9y79000sejl3wlmdvqpk/","excerpt":"","text":"Vue组件间通信其实其实就是不同的ViewModel之间如何通信的。 Props &amp; emit这个Vue中最基本的通信方式：12345678910111213141516171819202122232425262728293031323334353637383940414243// childconst vm1 = new Vue (&#123; name: child, template: `&lt;input v-model=\"value\" @onChange=\"submit\"/&gt;`, props: &#123; current: '' &#125;, data &#123; value: '' &#125;, watch() &#123; &#125;, method: &#123; &#125;&#125;);// parentconst vm2 = new Vue (&#123; template: ` &lt;div&gt; &lt;child :current=\"currentForm\" @finish=\"finish\"/&gt; &#123;&#123;isSuccess&#125;&#125; &lt;/div&gt;`, data: &#123; forms: [ &#123;id: 1, name: 'Tom'&#125; ], currentForm: undefined, isSuccess: false &#125;, mounted () &#123; this.currentForm = this.forms[0]; &#125;, method: &#123; finish(value) &#123; this.currentForm.id = value.id; this.currentForm.name = value.name; &#125; &#125;&#125;); Vue其实也是赞成这种方式进行通信，这种方法可以更加规范的构建通用组件。 使用 $parent 和 $refs1234567891011121314151617181920212223242526272829303132333435363738394041424344454647// childconst vm1 = new Vue (&#123; name: child, template: `&lt;button @click=\"submit\"/&gt;`, data &#123; form: &#123;id: 0, name: ''&#125;, &#125;, method: &#123; setCurrent(value) &#123; this.form = JSON.parse(JSON.stringify(value)); &#125;, submit () &#123; axios.put('/form',this.form).then((result)=&gt;&#123; if (this.$parent &amp;&amp; this.$parent.finish) &#123; this.$parent.finish(this.form); &#125; &#125;); &#125; &#125;&#125;);// parentconst vm2 = new Vue (&#123; template: ` &lt;div&gt; &lt;child ref=\"childComponent\"/&gt; &#123;&#123;isSuccess&#125;&#125; &lt;/div&gt;`, data: &#123; forms: [ &#123;id: 1, name: 'Tom'&#125; ], isSuccess: false &#125;, mounted () &#123; this.$refs.childComponent.setCurrent(forms[0]); &#125;, method: &#123; finish(value) &#123; this.currentForm.id = value.id; this.currentForm.name = value.name; &#125; &#125;&#125;); 这种方法的优点是可以获取所有子组件中的方法和父组件中的方法，缺点是暴露太多的子父组件的细节，子父组件容易强耦合。 Vuex这种方式也是比较推荐的，当你的组件之间是同级关系，使用Props和emit并不会让你的项目清爽起来，因为，你只是把他们（同级组件）的父组件当作一个中间件而已，然而父组件还要处理父组件中的逻辑，所以整个父组件便会变得庞大，如果引入vuex，能够很好的解决这个问题。考虑这种情况，如果，每个同级组件只修改一个同级 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768// vuexconst store = new Vuex.Store(&#123; state: &#123; forms: [ &#123;id: 1, name: 'Tom'&#125; ], currentForm: &#123;&#125; &#125;, mutations: &#123; changeForm(state, value) &#123; state.currentForm.id = value.id; statecurrentForm.name = value.name; &#125; &#125;, actions: &#123; getForm(&#123;state&#125;) &#123; return state.currentForm &#125; &#125;&#125;)// childconst vm1 = new Vue (&#123; name: child, template: `&lt;button @click=\"submit\"/&gt;`, data &#123; form: &#123;id: 0, name: ''&#125;, &#125;, method: &#123; setCurrent(value) &#123; this.form = JSON.parse(JSON.stringify(value)); &#125;, submit () &#123; axios.put('/form',this.form).then((result)=&gt;&#123; if (this.$parent &amp;&amp; this.$parent.finish) &#123; this.$parent.finish(this.form); &#125; &#125;); &#125; &#125;&#125;);// parentconst vm2 = new Vue (&#123; template: ` &lt;div&gt; &lt;child ref=\"childComponent\"/&gt; &#123;&#123;isSuccess&#125;&#125; &lt;/div&gt;`, computed: &#123; mapState(&#123; forms : state =&gt; state.forms, current: state =&gt; state.current &#125;) &#125;, mounted () &#123; this.$refs.childComponent.setCurrent(forms[0]); &#125;, method: &#123; finish(value) &#123; this.currentForm.id = value.id; this.currentForm.name = value.name; &#125; &#125;&#125;);","categories":[],"tags":[]},{"title":"前端小知识","slug":"前端小知识","date":"2019-02-21T11:00:00.000Z","updated":"2020-04-21T14:07:04.462Z","comments":true,"path":"2019/02/21/ckaum9y7h001gejl3ngl4tkoz/","link":"","permalink":"http://www.zcating.tk/2019/02/21/ckaum9y7h001gejl3ngl4tkoz/","excerpt":"本篇是为了记录开发中遇到的一些知识性的东西。","text":"本篇是为了记录开发中遇到的一些知识性的东西。 JS this全局环境下首先要确定是否this的环境，如果所在环境是全局，那么就要分不同的运行环境： 浏览器下，window === this。 nodejs环境下，global === this。 函数环境下普通调用分为严格模式和非严格模式， 非严格模式：如果直接在函数中调用this会直接触发全局变量。 1234function hello() &#123; console.log(this);&#125;hello(); // window 或 global 严格模式： 1234function hello() &#123; console.log(this);&#125;hello(); // undefined 在对象内部调用这种情况比较多，一般就是作为对象的实例来调用，以下两个是最基本的做法： 1234567891011121314151617// 构造函数function Person(name) &#123; this.name = name;&#125; var person = new Person('Tony');console.log(person.name); // Tony// 作为对象的函数function Swim() &#123; console.log(this.name + ' is swimming...');&#125;var duck = &#123; name: 'penny', swim: Swim&#125;duck.swim(); // penny is swimming... 当你想通过外部传递this来调用该函数的时候，那么你应该使用call和apply： 12345678function walk() &#123; console.log(this.name + ' is walking...');&#125;var student = &#123;name: 'Jenny'&#125;;walk(); // Uncaught TypeError: Cannot read property 'name' of undefined.walk.call(student); // 'Jenny is walking...'walk.apply(student); // 'Jenny is walking...' 更进一步的，可以调用bind()，将外部对象绑定到这个函数对象的拷贝中，使得这个函数对象拷贝的内部的this指向这个对象： 1var walkWithStudent = walk.bind(student); 函数表达式和函数声明式区别函数表达式是以下这种情况： 123var personWalks = function() &#123; console.log('walking')&#125; 函数定义式是以下这种形式： 123function personRuns () &#123; console.log('running');&#125; 这俩唯一的区别就是在于他们的作用域，当我们在函数表达式定义前调用表达式的变量，那么会有以下这种情况发生： 123456// Uncaught ReferenceError: personWalk is not definedpersonWalk();var personWalks = function() &#123; console.log('walking')&#125; 当我们在函数声明式定义前调用声明式的声明，那么不会报错： 123456// works.personRuns();function personRuns () &#123; console.log('running');&#125; JS Function关于函数原型中的apply, call, bind的理解。 首先是call和apply：它的作用是调用一个具有给定this值的函数，意思就是，如果这个函数里面有this，那么会将this绑定到call或apply的第一个参数上，然后再调用这个函数。但是两个不同的地方在于，如果这个函数有参数，那么call提供的是一个参数列表，而apply提供的是一个数组。举例： 12345678function drive(isNew) &#123; var adj = isNew ? 'New ' : 'Old '; console.log(adj + this.name + ' is driving...');&#125;var man = &#123;name: 'Tom'&#125;;drive.call(man, true); // New Tom is driving...drive.apply(man, [false]); // Old Tom is driving... bind的作用将对象与函数的this绑定，然后返回一个已经绑定了这个对象的新的函数对象，也就是，这个新的函数内部的this是指向这个对象的。 1234567function drive(isNew) &#123; var adj = isNew ? 'New ' : 'Old '; console.log(adj + this.name + ' is driving...');&#125;var man = &#123;name: 'Tom'&#125;;drive.bind(man)(true); // New Tom is driving... JS new假设你定义了一个SomeObject对象new SomeObject()来创建对象实例的时候，根据标准，会做如下事情： 继承SomeObject.prototype的一个新对象实例会被创建。 使用指定的参数调用构造函数SomeObject()，并将this绑定到新创建的对象。 构造函数返回的对象就是new的结果，如果构造函数没有返回一个对象，那么就用步骤一中生成的对象。 用伪代码表示： 1234567891011121314function SomeObject (name) &#123; this.name = name;&#125;var construct = function (name) &#123; var object = &#123;&#125;; // 继承 object.__proto__ = SomeObject.prototype; var result = SomeObject.call(object, name); return typeof result === 'object' ? result : object;&#125;; JS 继承根据JavaScript ES5的语法，创建一个类，是这样做的。 12345678910111213function Person(firstname, lastname) &#123; this.firstname = firstname; this.lastname = lastname; this.stand = function() &#123; console.log(\"standing\"); &#125;&#125;Person.prototype.walk = function() &#123; console.log(\"walking\");&#125;var person = new Person();person.walk(); // walkingperson.stand(); // standing 然后，如果你想继承，可以这样： 12345678910111213141516171819202122232425262728293031function Person(firstname, lastname) &#123; this.firstname = firstname; this.lastname = lastname; this.stand = function() &#123; console.log(this.firstname + ' ' + this.lastname + ' ' + 'standing'); &#125;&#125;Person.prototype.walk = function() &#123; console.log(this.firstname + ' ' + this.lastname + ' ' + 'walking');&#125;var person = new Person('Tom', 'Bruce');person.walk(); // Tom Bruce is walkingperson.stand(); // Tom Bruce is standingfunction Student(firstname, lastname) &#123; // 这玩意就是调用父构造函数... Person.call(this, firstname, lastname); this.study = function() &#123; console.log(this.firstname + ' ' + this.lastname + ' ' + 'is studing'); &#125;&#125;Student.prototype = Object.create(Person.prototype);Student.prototype.constructor = Person;// 这样 Student 就能调用Person的成员函数了..var student = new Student('Taylor', 'Swift');student.study(); // Taylor Swift is studingstudent.stand(); // Taylor Swift is standingstudent.walk(); // Taylor Swift is walking 以上那一堆prototype的玩意儿就是一个叫原型链的东西。 如果用ES6写继承，是这样的： 123456789101112131415161718class Pet &#123; constructor(id) &#123; this.id = id; &#125; walk() &#123; console.log('walking'); &#125;&#125;class Dog extends Pet &#123; constructor(id) &#123; super(id); this.type = 'dog'; &#125; bark() &#123; console.log('wooooooof!'); &#125;&#125; 是的，继承的时候就不用写原型链这玩意了。 == 和 ===首先一点肯定是建议使用===。 ===：严格相等，直接比较两个对象的值和类型，都一样才返回真。 ==：抽象相等，会对对象进行类型转换，然后再进行比较。 至于真值表，我觉得没必要记吧。 ES6 …(扩展运算符)扩展运算符有以下几种用法： 函数的可变参数12345678910let array = [];function pushAll(...items) &#123; array.push(...items);&#125;function traverse(...items) &#123; for(let i = 0; i &lt; items.length; i++) &#123; console.log(items[i]); &#125;&#125; 数组合并1234567let numbers1 = [1, 2, 3];let numbers2 = [4, 5, 6];let newNumbers = [7, 8, 9];newNumbers = [...newNumbers, ...numbers1, ...numbers2];console.log(newNumbers); // [7, 8, 9, 1, 2, 3, 4, 5, 6] 函数参数映射123456function sum(x, y, z) &#123; console.log(x+y+z);&#125;let array = [1, 2, 3];log(...array); // 6 Object.assign1234let person = &#123;walk:'walking', call:'calling'&#125;let student = &#123;study: 'studing', ...person&#125;console.log(student); // &#123;study: \"studing\", walk: \"walking\", call: \"calling\"&#125; 将各种迭代器转数组12345678910111213let string = 'hello';console.log([...string]); // [\"h\", \"e\", \"l\", \"l\", \"o\"]// 自定义迭代器也是可以的：let mystring = &#123;&#125;;mystring[Symbol.iterator] = function* () &#123; yield 'h'; yield 'e'; yield 'l'; yield 'l'; yield 'o';&#125;console.log([...mystring]); // [\"h\", \"e\", \"l\", \"l\", \"o\"] ES6 Generator（生成器）生成器主要的作用是封装了一套左闭右开的迭代器，避免自定义维护。123456789101112function* numbers() &#123; yield 1; yield 2; yield 3;&#125;let generator = numbers();console.log(generator.next()); // &#123;value: 1, done: false&#125;console.log(generator.next()); // &#123;value: 2, done: false&#125;console.log(generator.next()); // &#123;value: 3, done: false&#125;console.log(generator.next()); // &#123;value: undefined, done: true&#125; 可以看到generator.next()返回了一个对象：{value: Any, done: Boolean}。 value表示每个yield后面的对象或者是函数返回值； done表示是否执行到最末尾； 其他需要注意的地方 yield* 代表返回后面迭代器中的迭代值，考虑下面代码： 12345678910111213141516function* numbers() &#123; yield 1; yield* [2, 3, 4, 5]; yield 6;&#125;const generator = numbers();console.log(generator.next()); // &#123;value: 1, done: false&#125;console.log(generator.next()); // &#123;value: 2, done: false&#125;console.log(generator.next()); // &#123;value: 3, done: false&#125;console.log(generator.next()); // &#123;value: 4, done: false&#125;console.log(generator.next()); // &#123;value: 5, done: false&#125;console.log(generator.next()); // &#123;value: 6, done: false&#125;console.log(generator.next()); // &#123;value: undefined, done: true&#125;// 也就是说，这个关键字会对其后面的参数（迭代器）进行遍历。 在成员函数next(value:Any)中，它是包含了一个value，这个value将作为yield结束后的返回值，考虑以下代码： 123456789101112131415161718function* numbers() &#123; const x = yield 1; const y = yield x + 1; const z = yield 10 / y;&#125;const generator = numbers();console.log(generator.next(9)); // &#123;value: 1, done: false&#125;// x = 9console.log(generator.next(10)); // &#123;value: 10, done: false&#125;// y = 1console.log(generator.next(1)); // &#123;value: 10, done: false&#125;// z = 99console.log(generator.next(99)); // &#123;value: undefined, done: true&#125;// yield 结束后的返回值，意思就是在生成器中，yield的返回值。 ES6 async/await 关键字有了生成器，那么就可以结合Promise，以同步的方式写异步代码。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778// 假设我们去参加铁人三项，我们必须完成每一项之后，才能继续下一项// 定义游泳function startSwimming() &#123; return new Promise(function (resolve) &#123; console.log('Start swimming..'); setTimeout(function () &#123; console.log('Finish swimming..'); resolve(&#123;type: 'swim'&#125;); &#125;, 500); &#125;);&#125;// 定义自行车function startBiking(swimming) &#123; if (swimming.type !== 'swim') &#123; return &#123;type: 'none'&#125;; &#125; return new Promise(function (resolve) &#123; console.log('Start biking..'); setTimeout(function () &#123; console.log('Finish biking..'); resolve(&#123;type: 'bike'&#125;); &#125;, 1000); &#125;);&#125;// 定义马拉松function startMarathon(biking) &#123; if (biking.type !== 'bike') &#123; return &#123;type: 'none'&#125;; &#125; return new Promise(function (resolve) &#123; console.log('Start running..'); setTimeout(function () &#123; console.log('Finish running..'); resolve(&#123;type: 'marathon'&#125;); &#125;, 2000); &#125;);&#125;// 主要看这里，这里是我们的铁人三项生成器function* TriathlonGenerator() &#123; console.log('Welcome to join Triathlon!'); // 游泳 const swimming = yield startSwimming(); console.log(swimming); // 自行车 const biking = yield startBiking(swimming); console.log(biking); // 马拉松 const running = yield startMarathon(biking); console.log(running); if (running &amp;&amp; running.type === 'marathon') &#123; console.log('finish all item..'); &#125; return running;&#125;// 运行我们特定的生成器的函数function doTriathlon(TriathlonGenerator) &#123; const triathlonIter = TriathlonGenerator(); // 这里是递归操作，目的是为了是生成的迭代器能够按顺序执行。 function doing(argument) &#123; const info = triathlonIter.next(argument); console.log(info.value); if (info.done) &#123; return info.value; &#125; else &#123; return Promise.resolve(info.value).then(function (value) &#123; doing(value); &#125;); &#125; &#125; return doing();&#125;doTriathlon(TriathlonGenerator); 那么，以上代码中关于生成器的部分代码可以约等于以下代码： 123456789101112131415161718192021// 主要看这里，这里是我们的铁人三项生成器，async function doTriathlonAsync() &#123; console.log('Welcome to join Triathlon!'); // 游泳 const swimming = await startSwimming(); console.log(swimming); // 自行车 const biking = await startBiking(swimming); console.log(biking); // 马拉松 const running = await startMarathon(biking); console.log(running); if (running &amp;&amp; running.type === 'marathon') &#123; console.log('finish all item..'); &#125; return running;&#125;doTriathlonAsync();","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://www.zcating.tk/categories/JavaScript/"}],"tags":[]},{"title":"啥是鸭子类型(duck typing)","slug":"啥是鸭子类型(duck-typing)","date":"2019-02-21T11:00:00.000Z","updated":"2019-03-17T15:34:49.812Z","comments":true,"path":"2019/02/21/ckaum9y7i001iejl35jm3lqdp/","link":"","permalink":"http://www.zcating.tk/2019/02/21/ckaum9y7i001iejl35jm3lqdp/","excerpt":"什么是鸭子类型？《维基百科》上已经说的很明白了： 在程序设计中，鸭子类型（英语：duck typing）是动态类型的一种风格。在这种风格中，一个对象有效的语义，不是由继承自特定的类或实现特定的接口，而是由”当前方法和属性的集合”决定。 然后有意思的一段话就是： “当看到一只鸟走起来像鸭子、游泳起来像鸭子、叫起来也像鸭子，那么这只鸟就可以被称为鸭子。” 这段话就是鸭子类型的由来。","text":"什么是鸭子类型？《维基百科》上已经说的很明白了： 在程序设计中，鸭子类型（英语：duck typing）是动态类型的一种风格。在这种风格中，一个对象有效的语义，不是由继承自特定的类或实现特定的接口，而是由”当前方法和属性的集合”决定。 然后有意思的一段话就是： “当看到一只鸟走起来像鸭子、游泳起来像鸭子、叫起来也像鸭子，那么这只鸟就可以被称为鸭子。” 这段话就是鸭子类型的由来。 特点鸭子类型（风格）的特点是，关注对象能够做什么。看看以下代码其实就能明白个大概了： 1234567891011121314151617181920212223242526272829303132333435363738let cat = &#123; walk: () =&gt; &#123; console.log('walking...'); &#125;&#125;let duck = &#123; swim: () =&gt; &#123; console.log('swimming...'); &#125; call: () =&gt; &#123; console.log('GaGaGa...'); &#125;&#125;let dragon = &#123; swim: () =&gt; &#123; console.log('swimming...'); &#125; call: () =&gt; &#123; console.log('WaWaWa...'); &#125;&#125;function testDuck (bird) &#123; if (bird) &#123; console.log('It is not a duck.'); return; &#125; if (bird &amp;&amp; bird.swim &amp;&amp; bird.call) &#123; console.log('It is a duck.'); bird.swim(); bird.call(); &#125;&#125;testDuck(); // It is not a duck.testDuck(cat); //It is not a duck.testDuck(duck); // It is a duck. swimming... GaGaGa...testDuck(dragon); // It is a duck. swimming... WaWaWa...","categories":[{"name":"data structure","slug":"data-structure","permalink":"http://www.zcating.tk/categories/data-structure/"}],"tags":[]},{"title":"C++模板元编程——量纲分析","slug":"C++模板元编程——量纲分析","date":"2018-12-27T13:00:00.000Z","updated":"2019-03-17T15:34:49.560Z","comments":true,"path":"2018/12/27/ckaum9y6q0005ejl3v34u4hn2/","link":"","permalink":"http://www.zcating.tk/2018/12/27/ckaum9y6q0005ejl3v34u4hn2/","excerpt":"《C++模板元编程》一书上的第三章的第一节就是叫你如何进行量纲分析。说到量纲分析，首先要了解其概念，这里引用书中的内容：1理论上，物理计算的首要原则是：数值运算并非是独立的，大多数物理量都是有附带量纲的。…… 当我们将质量和加速度相乘时，我们除了将数量相乘之外还必须将量纲相乘，这可以帮助我们确信结果是有意义的。这种（对量纲的）簿记的正式名称为量纲分析（dimension analysis）。","text":"《C++模板元编程》一书上的第三章的第一节就是叫你如何进行量纲分析。说到量纲分析，首先要了解其概念，这里引用书中的内容：1理论上，物理计算的首要原则是：数值运算并非是独立的，大多数物理量都是有附带量纲的。…… 当我们将质量和加速度相乘时，我们除了将数量相乘之外还必须将量纲相乘，这可以帮助我们确信结果是有意义的。这种（对量纲的）簿记的正式名称为量纲分析（dimension analysis）。 那么简而言之，当我们在做运算的时候，数值需要运算，该数值的单位也要进行运算。那么书上很好的展示了用Boost库结合而做的量纲分析。然而，这个库引入太麻烦了，而且C++11的可变参数模板已能很好的对其进行应用。下面我将用C++11来编写量纲分析。 可变参数模板可变参数模板是C++11的新特性，有了该特性，整形序列外覆类可以变成一下定义： 12345678910111213141516171819template&lt;typename T, T ...arg&gt;class Vector &#123; using Type = Vector&lt;T, arg...&gt;::Type;&#125;// kilo gramusing Mass = Vector&lt;int, 1, 0, 0, 0, 0, 0, 0&gt;;// Meterusing Length = Vector&lt;int, 0, 1, 0, 0, 0, 0, 0&gt;;// Secondusing Time = Vector&lt;int, 0, 0, 1, 0, 0, 0, 0&gt;;// Ampereusing Charge = Vector&lt;int, 0, 0, 0, 1, 0, 0, 0&gt;;// Kelvinusing Temperature = Vector&lt;int, 0, 0, 0, 0, 1, 0, 0&gt;;// Luxusing Intensity = Vector&lt;int, 0, 0, 0, 0, 0, 1, 0&gt;;// Molusing AmountOfSubstance = Vector&lt;int, 0, 0, 0, 0, 0, 0, 1&gt;; 物理量的表示这里就直接引用《C++模板元编程》书中的对物理量的表示的内容： 123456789101112131415template&lt;typename T, typename Dimension&gt;struct Quantity&#123; explicit Quantity(T x) : mValue(x) &#123;&#125;; T value() const &#123; return mValue; &#125;; private: T mValue; &#125;;&#125;// 表示一个物理量可以这样Quantity&lt;double, Mass&gt; m(2.0f); 加减法加减法比较简单，相同量纲直接可以做加减法，不同量纲之间不可以做加减法： 1234567891011template&lt;typename T, typename Dimension&gt;Quantity&lt;T, Dimension&gt; operator + (const Quantity&lt;T, Dimension&gt;&amp; x, const Quantity&lt;T, Dimension&gt;&amp; y)&#123; return Quantity&lt;T, Dimension&gt;(x.value() + y.value());&#125;template&lt;typename T, typename Dimension&gt;Quantity&lt;T, Dimension&gt; operator - (const Quantity&lt;T, Dimension&gt;&amp; x, const Quantity&lt;T, Dimension&gt;&amp; y)&#123; return Quantity&lt;T, Dimension&gt;(x.value() + y.value());&#125; 乘除法不仅仅是对数值的乘除，也要对量纲进行乘除，量纲的乘除可以转化为表示量纲的序列的加减法。以速度为例，我们知道平均速度等于路程除以时间。$$v=s/t$$它的单位是：$$m/s（米每秒）$$用量纲序列表示： 12using Velocity = Vector&lt;int, 0, 1, -1, 0, 0, 0, 0&gt;;Quantity&lt;double, Velocity&gt; v; 也就是说，当我们用路程除以时间的时候，我们想要以下运算成立： 123Quantity&lt;double, Length&gt; s(10.0);Quantity&lt;double, Time&gt; t(2);Quantity&lt;double, Velocity&gt; v = s/t; 为了能对指定的量纲序列进行加减法，我们需要定义一个这样的元函数，它可以两个序列中的对应的位置做指定的二元元函数运算，并且返回的是一个满足要求（长度相同，内容为二元元函数求值的结果）的序列。 1234567891011121314template&lt;typename T1, typename T2, typename MetaFunction&gt;struct Transform &#123;&#125;;template&lt; typename T, T ...args1, T ...args2, template&lt;typename T, T ...args1&gt; class Vector1, template&lt;typename T, T ...args2&gt; class Vector2, typename MetaFunction&gt;struct Transform&lt;Vector1&lt;T, args1...&gt;, Vector2&lt;T, args2...&gt;, MetaFunction&gt;&#123; using Type = List&lt;T, MetaFunction::template Apply&lt;T, args1, args2&gt;::value...&gt;;&#125;; 我们看到元函数Transform的实现的模板比较复杂，在模板中拥有一个模板类，在这里解释一下： 1234567891011121314151617template&lt; // 指定的类型 typename T, // 第一个序列的变参模板 T ...args1, // 第二个序列的变参模板 T ...args2, // 指定的两个序列，我们的量纲序列满足该定义，所以是可行的。 template&lt;typename T, T ...args1&gt; class Vector1, template&lt;typename T, T ...args2&gt; class Vector2, typename MetaFunction&gt;// 实际Transform元函数转发struct Transform&lt;Vector1&lt;T, args1...&gt;, Vector2&lt;T, args2...&gt;, MetaFunction&gt;&#123; // 编译器只会匹配拥有 Apply 的元函数外覆类 using Type = Vector&lt;T, MetaFunction::template Apply&lt;T, args1, args2&gt;::value...&gt;;&#125;; 然后，我们需要实现两个满足我们要求的二元元函数： 12345678910111213141516171819202122232425262728293031// 对两个序列中的对应元素做加法template&lt;typename T, T value1, T value2&gt;struct PlusImplenment&#123; using Type = PlusImplenment&lt;T, value1, value2&gt;; const static T value = value1 + value2;&#125;;// 元函数外覆类struct Plus&#123; // 二元元函数转发 template&lt;typename T, T value1, T value2&gt; struct Apply : PlusImplenment&lt;T, value1, value2&gt;&#123;&#125;;&#125;;// 对两个序列中的对应元素做减法template&lt;typename T, T value1, T value2&gt;struct MinusImplenment&#123; using Type = MinusImplenment&lt;T, value1, value2&gt;; const static T value = value1 - value2;&#125;;// 元函数外覆类struct Minus&#123; // 二元元函数转发 template&lt;typename T, T value1, T value2&gt; struct Apply : MinusImplenment&lt;T, value1, value2&gt;&#123;&#125;;&#125;; 最后，实现乘法和除法： 123456789101112131415template&lt;typename T, typename D1, typename D2&gt;Quantity&lt;T, typename Transform&lt;D1, D2, Plus&gt;::Type&gt; operator * (const Quantity&lt;T, D1&gt;&amp; x, const Quantity&lt;T, D2&gt; y)&#123; // 通过Transform元函数，计算目标类型。 using Dimension = Transform&lt;D1, D2, Plus&gt;::Type; return Quantity&lt;T, Dimension&gt;(x.value() * y.value());&#125;template&lt;typename T, typename D1, typename D2&gt;Quantity&lt;T, typename Transform&lt;D1, D2, Minus&gt;::Type&gt; operator / (const Quantity&lt;T, D1&gt;&amp; x, const Quantity&lt;T, D2&gt; y)&#123; // 通过Transform元函数，计算目标类型。 using Dimension = Transform&lt;D1, D2, Minus&gt;::Type; return Quantity&lt;T, Dimension&gt;(x.value() / y.value());&#125; 这样，就实现了基本的量纲分析功能。 最后本文代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116#pragma oncenamespace td &#123; template&lt;typename T, T ...args&gt; struct Vector &#123; using Type = List&lt;T, args...&gt;; &#125;; // Specialized // kilo gram using Mass = Vector&lt;int, 1, 0, 0, 0, 0, 0, 0&gt;; // Meter using Length = Vector&lt;int, 0, 1, 0, 0, 0, 0, 0&gt;; // Second using Time = Vector&lt;int, 0, 0, 1, 0, 0, 0, 0&gt;; // Ampere using Charge = Vector&lt;int, 0, 0, 0, 1, 0, 0, 0&gt;; // Kelvin using Temperature = Vector&lt;int, 0, 0, 0, 0, 1, 0, 0&gt;; // Lux using Intensity = Vector&lt;int, 0, 0, 0, 0, 0, 1, 0&gt;; // Mol using AmountOfSubstance = Vector&lt;int, 0, 0, 0, 0, 0, 0, 1&gt;; template&lt;typename T, typename Dimension&gt; struct Quantity &#123; explicit Quantity(T x) : mValue(x) &#123;&#125;; T value() const &#123; return mValue; &#125;; private: T mValue; &#125;; template&lt;typename T, typename Dimension&gt; Quantity&lt;T, Dimension&gt; operator + (const Quantity&lt;T, Dimension&gt;&amp; x, const Quantity&lt;T, Dimension&gt;&amp; y) &#123; return Quantity&lt;T, Dimension&gt;(x.value() + y.value()); &#125; template&lt;typename T, typename Dimension&gt; Quantity&lt;T, Dimension&gt; operator - (const Quantity&lt;T, Dimension&gt;&amp; x, const Quantity&lt;T, Dimension&gt;&amp; y) &#123; return Quantity&lt;T, Dimension&gt;(x.value() + y.value()); &#125; template&lt;typename T, T value1, T value2&gt; struct PlusImplenment &#123; using Type = PlusImplenment&lt;T, value1, value2&gt;; const static T value = value1 + value2; &#125;; struct Plus &#123; // Meta function forwards. template&lt;typename T, T value1, T value2&gt; struct Apply : PlusImplenment&lt;T, value1, value2&gt;&#123;&#125;; &#125;; template&lt;typename T, T value1, T value2&gt; struct MinusImplenment &#123; using Type = MinusImplenment&lt;T, value1, value2&gt;; const static T value = value1 - value2; &#125;; struct Minus &#123; // Meta function forwards. template&lt;typename T, T value1, T value2&gt; struct Apply : MinusImplenment&lt;T, value1, value2&gt;&#123;&#125;; &#125;; // Function Signature template&lt;typename T1, typename T2, typename MetaFunction&gt; struct Transform; template&lt; typename T, T ...args1, T ...args2, template&lt;typename T, T ...args1&gt; class Vector1, template&lt;typename T, T ...args2&gt; class Vector2, typename MetaFunction&gt; struct Transform&lt;Vector1&lt;T, args1...&gt;, Vector2&lt;T, args2...&gt;, MetaFunction&gt; &#123; using Type = List&lt;T, MetaFunction::template Apply&lt;T, args1, args2&gt;::value...&gt;; &#125;; template&lt;typename T, typename D1, typename D2&gt; Quantity&lt;T, typename Transform&lt;D1, D2, Plus&gt;::Type&gt; operator * (const Quantity&lt;T, D1&gt;&amp; x, const Quantity&lt;T, D2&gt; y) &#123; // Caculate the quantity. using Dimension = Transform&lt;D1, D2, Plus&gt;::Type; return Quantity&lt;T, Dimension&gt;(x.value() * y.value()); &#125; template&lt;typename T, typename D1, typename D2&gt; Quantity&lt;T, typename Transform&lt;D1, D2, Minus&gt;::Type&gt; operator / (const Quantity&lt;T, D1&gt;&amp; x, const Quantity&lt;T, D2&gt; y) &#123; // Caculate the quantity. using Dimension = Transform&lt;D1, D2, Minus&gt;::Type; return Quantity&lt;T, Dimension&gt;(x.value() / y.value()); &#125;&#125;","categories":[{"name":"C++","slug":"C","permalink":"http://www.zcating.tk/categories/C/"}],"tags":[]},{"title":"Objective-C 对象内存布局","slug":"Objective-C 对象内存布局","date":"2018-12-16T11:00:00.000Z","updated":"2019-03-17T15:34:49.563Z","comments":true,"path":"2018/12/16/ckaum9y73000dejl3zw2wmgli/","link":"","permalink":"http://www.zcating.tk/2018/12/16/ckaum9y73000dejl3zw2wmgli/","excerpt":"可能需要以下命令的帮助： 1clang -rewrite-objc main.m 该命令会将 .m文件转成 .cpp文件，这样就能直观的看到Objective-C对象实际的C对象的形式。","text":"可能需要以下命令的帮助： 1clang -rewrite-objc main.m 该命令会将 .m文件转成 .cpp文件，这样就能直观的看到Objective-C对象实际的C对象的形式。 NSObject对于NSObject来说，它实际上是以这种形式出现的。 1234typedef struct objc_class *Class;struct NSObject_IMPL &#123; Class isa;&#125;; 可以看到，一个NSObject对象其实是只存有一个指针类型。我们可以通过以下代码，来观察它在堆上的大小。 123#import&lt;objc/rumtime.h&gt;NSObject *object = [NSObject new];NSLog(@\"NSObject's instance size is %ul.\", Class_getInstanceSize(object)); 很显然，在64位系统下一个指针的大小为8个字节。运行以上代码，可以发现输出如下： 1NSObject&apos;s instance size is 8. 跟我们所认为的是一样的。那么实际占用的字节大小是多少呢，我们可以通过以下代码来获取其实际占用的大小： 12NSObjec *object = [NSObject new];NSLog(@\"NSObject's malloc size is %ul.\", malloc_size((__brige const void *)object)); 以上代码输出如下： 1NSObject&apos;s malloc size is 16. 为什么是16个字节，主要是因为CoreFoundation框架规定，每个对象的大小最小为16字节。 继承下的对象的内存布局举个例子，先给出以下数据结构： 1234567891011@interface A : NSObject &#123; double a;&#125;@end// 省略 implementation@interface B : A &#123; double b;&#125;@end// 省略 implementation 我们不妨将他们转成C数据结构： 12345678910struct A_IMPL &#123; Class isa; double a;&#125;struct B_IMPL &#123; Class isa; double a; double b;&#125; 手动来计算一下，sizeof(isa) + sizeof(a) = 16 ，sizeof(isa) + sizeof(a) + sizeof(b) = 24。 给出打印代码： 1234567A *objectA = [A new];NSLog(@&quot;A&apos;s instance size is %ul.&quot;, Class_getInstanceSize(objectA));// A&apos;s instance size is 16B *objectB = [B new];NSLog(@&quot;B&apos;s instance size is %ul.&quot;, Class_getInstanceSize(objectB));// B&apos;s instance size is 24 Class_getInstanceSize获取的是实例大小，而不是内存中占用的，我们查看这个实例在内存占用的大小，则需要malloc_size(void*) 这个函数来查看： 123456789#import&lt;malloc/malloc.h&gt;A *objectA = [A new];NSLog(@&quot;A&apos;s allocated size is %ul.&quot;, malloc_size((__brige const void *)objectA));// NSObject&apos;s allocated size is 16.B *objectB = [B new];NSLog(@&quot;B&apos;s allocated size is %ul.&quot;, malloc_size((__brige const void *) objectB));// NSObject&apos;s allocated size is 32. 可以看到，打印的结果并不是24，而是32，这是可能是由于Core Foundation内存对齐的原因，所有的内存地址都是16。 NSArray 的内存布局12345NSArray *array = @[[B new], [B new], [B new]];NSLog(@&quot;array&apos;s instance size is %ul.&quot;, Class_getInstanceSize(array));// array&apos;s instance size is 24.NSLog(@&quot;array&apos;s allocated size is %ul.&quot;, malloc_size((__brige const void *) array));// array&apos;s allocated size is 32. 很显然，array中的数据都是在堆上申请的，所以array的实际上存储的是堆上元素的指针，所以大小是三个指针加上一个isa指针——24。","categories":[{"name":"Objective-C","slug":"Objective-C","permalink":"http://www.zcating.tk/categories/Objective-C/"}],"tags":[]},{"title":"使用Webpack为项目配置热更新","slug":"通过Webpack为项目配置热更新","date":"2018-10-05T11:00:00.000Z","updated":"2019-03-18T12:34:49.833Z","comments":true,"path":"2018/10/05/ckaum9y7r0027ejl3frq0on52/","link":"","permalink":"http://www.zcating.tk/2018/10/05/ckaum9y7r0027ejl3frq0on52/","excerpt":"为了调试代码方便，使用了Webpack来配置热更新功能，现在记录一下如何配置。 上一篇已经说了如何使用webpack打包代码，但是如果我每次改了代码，都要手动去打包，所以这里要使用热更新来进行代码调试，本篇将记录如何配置webpack热更新。","text":"为了调试代码方便，使用了Webpack来配置热更新功能，现在记录一下如何配置。 上一篇已经说了如何使用webpack打包代码，但是如果我每次改了代码，都要手动去打包，所以这里要使用热更新来进行代码调试，本篇将记录如何配置webpack热更新。 步骤一首先是安装各种的plugin以便热更新的时候可以加载到你想要热更的文件，这里我主要使用了html： 1234// 如果没有安装npx，请先安装npm install -g npxnpm install -D html-webpack-plugin webpack-dev-server 步骤二然后就开始编写我们配置文件webpack.dev.config.js。 1234567891011121314151617181920212223242526272829303132333435const path = require('path');const webpack = require('webpack');const HTMLWebpackPlugin = require('html-webpack-plugin');module.exports = &#123; entry: '写你自己的入口文件的名称', output: &#123; path: __dirname + '写你自己的文件要生成到的文件夹', filename: \"写你自己的文件的名字\" &#125;, module: &#123; rules: [&#123; test: /\\.js$/, exclude: /node_modules|(其他你想要忽略打包的文件夹)/ loader: 'babel-loader', options: &#123; presets: ['@babel/preset-env'] &#125; &#125;] &#125;, // 以下是一些常用的设置，更多配置请看以下地址： // https://webpack.docschina.org/configuration/dev-server/ devServer: &#123; contentBase: path.join(__dirname, 'dist'), compress: true, port: 8080 &#125;, plugins: [ new webpack.HotModuleReplacementPlugin(), new HTMLWebpackPlugin(&#123; template: './dist/index.html' //此处指定的是入口的HTML &#125;) ]&#125; 这里我们大致的目录结构是这样的： 1234567dist index.htmlsrc main.jspackage.jsonwebpack.config.jswebpack.dev.config.js 步骤三在package增加这个script 1&quot;dev&quot;: &quot;npx webpack-dev-server --config webpack.dev.config.js&quot;, 这样当你输入npm run dev的时候，就可以运行项目了。","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://www.zcating.tk/categories/JavaScript/"}],"tags":[]},{"title":"使用Webpack和Babel支持IE-11","slug":"使用Webpack和Babel支持IE-11","date":"2018-09-29T11:00:00.000Z","updated":"2019-03-18T12:26:49.646Z","comments":true,"path":"2018/09/29/ckaum9y7m001uejl3fl40ohoa/","link":"","permalink":"http://www.zcating.tk/2018/09/29/ckaum9y7m001uejl3fl40ohoa/","excerpt":"是的你没看错，都8012了还有人用IE-11。为了帮助客户可以在IE-11上使用我们的应用，需要将es6的代码打包转化成es5。","text":"是的你没看错，都8012了还有人用IE-11。为了帮助客户可以在IE-11上使用我们的应用，需要将es6的代码打包转化成es5。 步骤一安装一些必备的插件： 1234// 如果没有安装npx，请先安装npm install -g npxnpm install babel-loader@8.0.0-beta.0 @babel/core @babel/preset-env webpack webpack-cli 步骤二配置webpack.config.js： 123456789101112131415161718const path = require(&apos;path&apos;);module.exports = &#123; entry: &apos;写你自己的入口文件的名称&apos;, output: &#123; path: path.resolve(__dirname, &apos;写你自己的文件要生成到的文件夹&apos;), filename: &quot;写你自己的文件的名字&quot; &#125;, module: &#123; rules: [&#123; test: /\\.js$/, exclude: /node_modules|(其他你想要忽略打包的文件夹)/ loader: &apos;babel-loader&apos;, options: &#123; presets: [&apos;@babel/preset-env&apos;] &#125; &#125;] &#125;&#125; 其实到这步，你在终端运行npx webpack --config webpack.config.js的时候，就可以生成可以运行的文件。但是我到IE上运行，还是不行啊！为什么呢？ 原因就是因为babel只支持语法转换，并不支持es6特有对象和方法的转换，这样就需要这个插件 如果你的代码中有以下这些对象、方法，那么就要小心了！ 1234仅仅是列举常用的，其他还需要进一步查询支持不支持。1. 全局对象：Promise等;2. 全局静态函数：Array.from, Object.assign等;3. 实例方法：Array.prototype.includes等; 所以我们需要另外一个插件 polyfill来对对象和方法进行转换。 步骤三安装包： 1npm i -D @babel/polyfill 然后再入口文件（一般为index.js或main.js）中，往第一行添加以下代码： 1import &apos;@babel/polyfill&apos; 这样打包的时候，就会自动将es6特有的对象和方法进行转换。 总结安装以下插件： 1npm install babel-loader@8.0.0-beta.0 @babel/core @babel/preset-env @babel/polyfill webpack webpack-cli 写webpack.config.js配置文件。 在入口文件的头部添加代码：import &#39;@babel/polyfill&#39;。","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://www.zcating.tk/categories/JavaScript/"}],"tags":[]},{"title":"解决跨域的终极方法","slug":"解决跨域的终极方法","date":"2018-07-10T11:00:00.000Z","updated":"2019-03-17T15:34:49.816Z","comments":true,"path":"2018/07/10/ckaum9y7p0023ejl3tvkfpeun/","link":"","permalink":"http://www.zcating.tk/2018/07/10/ckaum9y7p0023ejl3tvkfpeun/","excerpt":"","text":"如果使用前后端分离的架构，肯定会深受跨域的困扰，网上有一大堆的方法来解决跨域，但是你得一个一个试才知道哪个是合适。这个方法就是用nginx来配置跨域请求头部，下面将简单记录这个方法： 安装nginx，一般来说服务器都是用CentOS，使用yum安装。 直接往/etc/nginx/conf.d/文件夹中添加新的配置文件cros.conf。 输入以下配置： 123456789101112131415161718server &#123; listen 80; // 这里输入转发出去的域名或IP server_name localhost; location / &#123; add_header Access-Control-Allow-Origin *; add_header Access-Control-Allow-Methods &apos;GET, POST, PUT, DELETE, OPTIONS&apos;; add_header Access-Control-Allow-Headers &apos;DNT,X-Mx-ReqToken,Keep-Alive,User-Agent,X-Requested-With,If-Modified-Since,Cache-Control,Content-Type,Authorization&apos;; # 这里返回204，意味着无内容。 if ($request_method = &apos;OPTIONS&apos;) &#123; return 204; &#125; # 这里输入后端的域名或IP proxy_pass your.backend.address; &#125;&#125; 之后，启动nginx，输入命令：service nginx restart。 这样，从浏览器请求后端接口的时候，就不会有跨域的问题出现了。","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://www.zcating.tk/categories/JavaScript/"}],"tags":[]},{"title":"使用 Jenkins 配置 iOS 持续集成踩坑实录","slug":"使用 Jenkins 配置 iOS 持续集成踩坑实录","date":"2018-05-24T11:00:00.000Z","updated":"2019-03-17T15:34:49.810Z","comments":true,"path":"2018/05/24/ckaum9y7f001bejl3no2mevgt/","link":"","permalink":"http://www.zcating.tk/2018/05/24/ckaum9y7f001bejl3no2mevgt/","excerpt":"Jenkins 是一款使用 Java 开发的持续集成工具，下面将介绍如何使用 Jenkins 来进行iOS的持续集成。坑都用粗体标明了。","text":"Jenkins 是一款使用 Java 开发的持续集成工具，下面将介绍如何使用 Jenkins 来进行iOS的持续集成。坑都用粗体标明了。 安装坑在安装 Jenkins 之前，首先要安装 JDK，这里需要注意 JDK 的版本，必须为1.8，过高或者过低均不行。 推荐使用 brew 来安装 Jenkins。 1brew install jenkins 配置坑第一步安装完毕后，直接在命令行中输入以下命令： 1jenkins 在这里需要注意，Jenkins 默认端口是8080，如果该端口被占用，可以使用以下命令切换端口： 1jenkins -httpPort 9090 然后，就可以在浏览器中输入localhost:9090来进入 Jenkins。在起始页面会使用一个起始口令来让你解锁它，这个口令可以在命令行中，或者在其指定的目录下可以找到该口令。输入完毕后，会让你创建一个账户，按照提示来完成操作就好。 第二步创建完毕后，首先要去绑定你SSH密钥，方法如下： 1Jenkins -&gt; Credentials -&gt; global -&gt; add Credentials 第三步绑定完毕后，开始安装以下插件： Keychains and Provisioning Profiles Management 对的，只有一个，不要使用 Xcode 插件来进行 iOS 配置，因为 XCode 8 以后，通过 Archive 生成 ipa 需要包括一个 ExportOption.Plist 文件，这个文件在该插件中并不会提供，所以通过脚本来进行配置，而不是通过 XCode 插件来配置。 安装完毕该插件后，直接通过网上各种渠道的信息来对该插件进行配置，配置该插件基本上不会有太大问题，下面给出 keychains 和 provision 在系统中的路径。 12keychain: /Users/zcating/Library/Keychainsprovision: /Users/zcating/Library/MobileDevice/Provisioning Profiles 需要注意的是，上传的时候，login.keychain-db 会被标记为不合法的文件，login.keychain 实际上跟 login.keychain-db 是一样的，只需要复制一份，然后更改 login.keychain-db 为login.keychain，然后就可以上传了。 第四步完成上传后就可以开始构建了，构建步骤如下： 12341. 新建项目，选择自由风格。2. 勾选 keychain 和 provision。3. 添加 Git 配置。4. 增加构建步骤，选择 Execute shell。 然后添加以下脚本： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#需要自定义参数xcode_project_path=\"/path/to/your/xcode/project\"export_path=\"/path/to/your/export/path\"ipa_name=\"ipa-name\"provision=\"xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx\"# build method，可以输入以下选项: app-store, ad-hoc, enterprise, developmentbuild_method=\"enterprise\"# bundle_id 需要跟项目中的一致bundle_id=\"com.yourCompany.yourApp\"bundle_name=\"provision_name\"# 签名类型，可以选择以下类型: \"iOS Developer\", \"iOS Distribution\"sign_cer=\"iOS Distribution\"# 就是你们团队证书中的用户名team_id=\"XXXXXXXXXX\"#自定义完毕export_option_path=\"$xcode_project_path/ExportOptions.plist\"# 写 ExportOption.plist 文件echo \"&lt;?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?&gt;&lt;!DOCTYPE plist PUBLIC \\\"-//Apple//DTD PLIST 1.0//EN\\\" \\\"http://www.apple.com/DTDs/PropertyList-1.0.dtd\\\"&gt;&lt;plist version=\\\"1.0\\\"&gt;&lt;dict&gt; &lt;key&gt;compileBitcode&lt;/key&gt; &lt;false/&gt; &lt;key&gt;method&lt;/key&gt; &lt;string&gt;$build_method&lt;/string&gt; &lt;key&gt;provisioningProfiles&lt;/key&gt; &lt;dict&gt; &lt;key&gt;$bundle_id&lt;/key&gt; &lt;string&gt;$bundle_name&lt;/string&gt; &lt;/dict&gt; &lt;key&gt;signingCertificate&lt;/key&gt; &lt;string&gt;$sign_cer&lt;/string&gt; &lt;key&gt;signingStyle&lt;/key&gt; &lt;string&gt;manual&lt;/string&gt; &lt;key&gt;stripSwiftSymbols&lt;/key&gt; &lt;true/&gt; &lt;key&gt;teamID&lt;/key&gt; &lt;string&gt;$team_id&lt;/string&gt; &lt;key&gt;thinning&lt;/key&gt; &lt;string&gt;&amp;lt;none&amp;gt;&lt;/string&gt;&lt;/dict&gt;&lt;/plist&gt;\" &gt; $export_option_path;xcodebuild archive \\-archivePath \"$xcode_project_path/build/$&#123;ipa_name&#125;.xcarchive\" \\-project $xcode_project \\-sdk iphoneos \\-scheme $scheme \\-configuration $build_configuration \\CODE_SIGN_IDENTITY=\"钥匙串中的签名的名称\" \\PROVISIONING_PROFILE=$provisionxcodebuild -exportArchive \\-archivePath \"$xcode_project_path/build/$&#123;ipa_name&#125;.xcarchive\" \\-exportPath $export_path \\-exportOptionsPlist $export_option_path \\-allowProvisioningUpdates \\CODE_SIGN_IDENTITY=\"钥匙串中的签名的名称\" \\PROVISIONING_PROFILE=$provisionmv $&#123;export_path&#125;/*.ipa $&#123;export_path&#125;/ipa_name.ipa 需要注意，XCode 项目需要关闭自动签名配置。 到这里，只要在 XCode 打开该项目没有报错，并且可以构建，那么就没有任何问题了。 Unity 特别篇使用 Jenkins 来构建 Unity，有以下几点需要注意的地方。 关闭自动签名，设定provision。 在 Assets 目录下新建以下目录和文件 /Assets/editor/ProcessBuild.cs，并且在cs文件中添加以下代码。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152using System.Collections;using System.IO;using UnityEditor;using UnityEngine;using System.Collections.Generic;using System;class ProjectBuild : Editor&#123; //在这里找出当前工程所有的场景文件. static string[] GetBuildScenes() &#123; List&lt;string&gt; names = new List&lt;string&gt;(); foreach(EditorBuildSettingsScene e in EditorBuildSettings.scenes) &#123; if(e==null) continue; if(e.path == \"Dont_Add\" || e.path == \"post\") if(e.enabled) names.Add(e.path); &#125; return names.ToArray(); &#125; //得到项目的名称 public static string projectName &#123; get &#123; foreach(string arg in System.Environment.GetCommandLineArgs()) &#123; if(arg.StartsWith(\"project\")) &#123; return arg.Split(\"-\"[0])[1]; &#125; &#125; return \"test\"; &#125; &#125; //shell脚本直接调用这个静态方法 static void BuildForIPhone() &#123; PlayerSettings.SetScriptingDefineSymbolsForGroup(BuildTargetGroup.iOS, \"USE_SHARE\"); // 构建xcode工程的核心方法了， // 参数1 需要打包的所有场景 // 参数2 需要打包的名字 // 参数3 打包平台 // 参数4 编译选项 BuildPipeline.BuildPlayer(GetBuildScenes(), \"ios-build\", BuildTarget.iOS, BuildOptions.None); &#125;&#125; 使用以下命令进行自动化构建。 12345678project_dir=\"\"/Applications/Unity/Unity.app/Contents/MacOS/Unity \\-batchmode \\-projectPath $project_dir \\-executeMethod ProjectBuild.BuildForIPhone \\-ios \\-quit \\-logFile $project_dir/BuildXCodeProject.log 这样就会在你指定的目录下生成 XCode 项目。 结语我使用了 Jenkins 生成 iOS 最终的 ipa，感受到了如丝般顺滑的构建流程。生成过程只需一键，一键就能上传Testflight，fir.im 或者蒲公英。感觉以后打包真的会方便很多很多倍，省去了各种复杂的步骤。只是在构建 Jenkins 的时候，遇到了很多问题，最终的解决方案还是决定写一个 Shell 脚本，这样就省去了很多插件的配置问题，之后可能会将脚本转换成可读性更强的 Python 脚本。","categories":[{"name":"Objective-C","slug":"Objective-C","permalink":"http://www.zcating.tk/categories/Objective-C/"}],"tags":[]},{"title":"响应链是如何进行响应的","slug":"iOS中的响应链和点击链简析","date":"2018-05-04T11:00:00.000Z","updated":"2019-03-17T15:34:49.805Z","comments":true,"path":"2018/05/04/ckaum9y7c0012ejl3zxjfvqqi/","link":"","permalink":"http://www.zcating.tk/2018/05/04/ckaum9y7c0012ejl3zxjfvqqi/","excerpt":"iOS中使用这种方式来实现对对象的响应的： A responder object is any instance of the UIResponder class, and common subclasses include UIView, UIViewController, and UIApplication. 翻译一下： 一个responder对象是这样一种实例，它继承UIResponder类或者是这些子类（UIViewController, UIApplication, UIView）。 对于一个responder对象，它可以响应的事件有以下这些：","text":"iOS中使用这种方式来实现对对象的响应的： A responder object is any instance of the UIResponder class, and common subclasses include UIView, UIViewController, and UIApplication. 翻译一下： 一个responder对象是这样一种实例，它继承UIResponder类或者是这些子类（UIViewController, UIApplication, UIView）。 对于一个responder对象，它可以响应的事件有以下这些： 123456789101112131415// 触摸事件- (void)touchesBegan:(NSSet *)touches withEvent:(UIEvent *)event;- (void)touchesMoved:(NSSet *)touches withEvent:(UIEvent *)event;- (void)touchesEnded:(NSSet *)touches withEvent:(UIEvent *)event;- (void)touchesCancelled:(NSSet *)touches withEvent:(UIEvent *)event;// 加速器事件// 只会处理由CoreMotion传递的事件，不属于响应链。- (void)motionBegan:(UIEventSubtype)motion withEvent:(UIEvent *)event;- (void)motionEnded:(UIEventSubtype)motion withEvent:(UIEvent *)event;- (void)motionCancelled:(UIEventSubtype)motion withEvent:(UIEvent *)event;// 远程控制事件// 主要是用来处理配件的行为，比如耳机插拔、按钮播放等，不属于响应链。- (void)remoteControlReceivedWithEvent:(UIEvent *)event; 我们主要关注的是触摸事件。 Hit-Test 链当你与点击屏幕的时候，会触发UIView中的这两个函数： 12345// 递归地调用 -pointInside:withEvent:. point的坐标是在接收者的坐标系中。-(UIView *)hitTest:(CGPoint)point withEvent:(UIEvent *)event;// 如果点在框内，默认是返回 YES.-(BOOL)pointInside:(CGPoint)point withEvent:(UIEvent *)event; hitTest的逻辑大概如下： 1234567891011121314151617181920212223-(UIView *)hitTest:(CGPoint)point withEvent:(UIEvent *)event;&#123; // 判断这个点是否可以点击 if (!self.isUserInteractionEnabled || self.isHidden || self.alpha &lt;= 0.01) &#123; return nil; &#125; // 然后判断这个点是否在这个视图内部 if ([self pointInside:point event:event]) &#123; // 将 subview 逆序遍历 [self.subviews enumerateObjectsWithOptions:NSEnumerationReverse usingBlock:^(UIView * view, NSUInteger index, BOOL stop) &#123; // 将触摸点所在的父视图坐标系转换到子视图下的坐标系。 CGPoint convertedPoint = [view convertPoint:point fromView:self]; UIView *testedView = [view hitTest:point withEvent:event]; if (testedView) &#123; return testedView; &#125; &#125;]; // 如果没有找到符合的视图，那么就返回当前视图，并处理事件。 return self; &#125; // 点不在视图内，返回nil不处理该视图以及其子视图。 return nil;&#125; 现在，使用Method Swizzling对所有的UIView中的-hitTest:withEvent:进行hook，在hook方法里打印调用该方法的实例。以一个例子，如下图： 上图中的每一个色块都是一个UIView对象，他们的打印都是其对应的颜色。他们是这样添加的： 1234567891011121314UIView *redView = [[UIView alloc] init];redView.backgroundColor = [UIColor redColor];UIView *blueView = [[UIView alloc] init];blueView.backgroundColor = [UIColor blueColor];[redView addSubview:blueView];UIView *greenView = [[UIView alloc] init];greenView.backgroundColor = [UIColor blueColor];[blueView addSubview:blueView];UIView *yellowView = [[UIView alloc] init];yellowView.backgroundColor = [UIColor yellowColor];[redView addSubview:yellowView]; 记住蓝色和黄色添加顺序，当我们的时候点击绿色视图的时候，打印结果如下（你可能会有疑问，为啥会调用两次，因为点击开始是一个事件，结束也是一个事件。）： 1234567891011121314151617第一次hit test &lt;UIWindow: 0x115e0a3d0&gt;hit test controller&apos;s viewhit test redhit test yellowhit test bluehit test greenhit test &lt;UIStatusBarWindow&gt;hit test &lt;UIStatusBar&gt;第二次hit test &lt;UIWindow&gt;hit test controller&apos;s viewhit test redhit test yellowhit test bluehit test green -hitTest:withEvent:的调用链是这样的： 可以看到红色视图调用了它的子视图的hit-test方法，通过逆序遍历来查找蓝色和黄色，如果黄色视图在蓝色视图添加之前，则黄色试图不会调用hit-test方法，因为在调用蓝色视图的hit-test的时候，就会继续调用绿色视图的hit-test，并确认点在绿色视图内并返回绿色视图，那么红色视图hit-test的终结点就是在蓝色视图的返回值，并不会继续去调用黄色视图对应的方法。其实讲这么多就是为了理解hit-test的逻辑，理解多点触控技术是如何去确认点在视图中的位置。 响应链通过hit-test确定了视图之后，该视图将会逆着hit-test链来返回响应的事件，并查找哪个view能处理这个点击事件。为了能够看清响应链的具体过程，我们可以通过分类重写UIView、UIViewController和UIApplication中的-touchBegan:withEvent:这个方法： 1234-(void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event &#123; NSLog(@\"begin, %@\", [self description]); [self.nextResponder touchesBegin:touches withEvent:event];&#125; nextResponder是当前视图的下一个响应者，如果这个视图不能处理当前的事件，那么便会通过nextResponder来响应这个事件，这样，点击绿色视图打印的链条如下： 1234567began: greenbegan: bluebegan: redbegan: controller's viewbegan: &lt;MyViewController&gt;began: &lt;UIWindow&gt;began: &lt;UIApplication&gt; 那么它的响应链如下： 参考文档Using Responders and the Responder Chain to Handle Events Understanding cocoa and cocoa touch responder chain iOS响应链(Responder Chain)","categories":[{"name":"Objective-C","slug":"Objective-C","permalink":"http://www.zcating.tk/categories/Objective-C/"}],"tags":[]},{"title":"用XCode注入动态库到Mac应用中","slug":"用XCode注入动态库到Mac应用中","date":"2018-02-18T11:00:00.000Z","updated":"2019-03-17T15:34:49.813Z","comments":true,"path":"2018/02/18/ckaum9y7m001rejl3st0fbf3u/","link":"","permalink":"http://www.zcating.tk/2018/02/18/ckaum9y7m001rejl3st0fbf3u/","excerpt":"本文介绍如何将动态库注入到Mac下的二进制文件中，不包含逆向分析，仅作学习使用。 步骤简介以下是具体步骤简介。 使用classdump，解压出Mac版微信下的所有头文件。 新建一个macOS Framework工程。 将Header拖入项目中，并将注入脚本放入Build Phases中，编译项目。","text":"本文介绍如何将动态库注入到Mac下的二进制文件中，不包含逆向分析，仅作学习使用。 步骤简介以下是具体步骤简介。 使用classdump，解压出Mac版微信下的所有头文件。 新建一个macOS Framework工程。 将Header拖入项目中，并将注入脚本放入Build Phases中，编译项目。 本文介绍如何将动态库注入到Mac下的二进制文件中，不包含逆向分析，仅作学习使用。 步骤简介以下是具体步骤简介。 使用classdump，解压出Mac版微信下的所有头文件。 新建一个macOS Framework工程。 将Header拖入项目中，并将注入脚本放入Build Phases中，编译项目。 步骤一我们使用class-dump，要使用class-dump,首先需要下载它，它不是自带的。 下载地址：http://stevenygard.com/projects/class-dump/ 打开终端，运行sudo cp /path/to/class-dump /usr/local/bin （目标地址是可以全局运行项目的地方） 修改权限，运行sudo chmod 777 /usr/local/bin/class-dump 运行以下命令可以获得所有的微信头文件。 1class-dump -H /Applications/WeChat.app/Contents/MacOS/WeChat -o /path/to/your/dir/ 步骤二我们使用xcode创建一个Framework项目，此步略过。 步骤三将Header拖入后，我们需要开始编写tweak代码，首先我们新建一个 tweak.mm，输入以下函数： 1234static void __attribute__((constructor)) tweak(void) &#123; // do hook method... NSLog(@\"****************running hook!************************\");&#125; 这段代码的意思就是，在main函数执行前，运行tweak函数。我们先不管如何hook，把整个注入框架搭起来才是最重要的。 我们通过insert_dylib 将生成的动态库注入到指定的二进制文件中，insert_dylib这个文件可以在这里找到： 1https://github.com/Tyilo/insert_dylib 打开 edit scheme，找到 Excutable，选择 Other，找到WeChat.app并确认。 在Build Phases中，新增一个新的 Run Script，然后添加如下脚本： 123456789101112131415WECHAT_PATH=\"/Applications/wechat.app/Contents/MacOS\"FRAMEWORK_NAME=\"WechatHooker\"UNIX_FILE=\"$&#123;WECHAT_PATH&#125;/Wechat\"FRAMEWORK_PATH=\"$&#123;WECHAT_PATH&#125;/$&#123;FRAMEWORK_NAME&#125;.framework\"if ! [ -f \"$&#123;WECHATPATH&#125;/WeChatCopy\" ]thencp -rf $&#123;UNIX_FILE&#125; \"$&#123;WECHAT_PATH&#125;/WeChatCopy\"ficp -rf \"$&#123;BUILT_PRODUCTS_DIR&#125;/$&#123;FRAMEWORK_NAME&#125;.framework\" $&#123;WECHAT_PATH&#125;./insert_dylib \"$&#123;FRAMEWORK_PATH&#125;/$&#123;FRAMEWORK_NAME&#125;\" $&#123;UNIX_FILE&#125; $&#123;UNIX_FILE&#125; --all-yes 脚本的意思很明确，通过将生成的Framework拷贝到指定目录下，然后通过 insert_dylib 将动态库注入到指定的二进制文件中。在这里，为了不覆盖原有的WeChat二进制文件，生成了WeChatCopy，我们需要将整个WeChat.app复制一份新的，并将生成的WechatCopy，改名覆盖WeChat二进制文件。 最后运行Framework，会发现在 /Applications/wechat.app/Contents/MacOS/ 目录下，会多出一个WeChatCopy。按照上述方法操作后，运行修改后的Wechat.app可以在控制台查看到打印信息。 在这里，我们以“防止消息撤回”为例。消息撤回其实这个功能其实对于有些人来说很不喜欢，现在他们想防止微信消息撤回，我已经通过逆向分析找到了防止消息撤回的目标函数，现在，只要将这个函数改写就好了。类，函数以及函数的参数描述如下： 123Class: MessageServiceMethod: onRevokeMsg: 当消息撤回时，需要做的事情。Parameters: NSString 撤回的消息内容。 使用Aspect对onRevokeMsg:进行替换： 1234567891011#define MYMessageService objc_getClass(&quot;MessageService&quot;)static void __attribute__((constructor)) tweak(void) &#123; // 需要注意的是，编译的时候，编译器是找不到 MessageService 的实现， // 如果直接引入会编译报错，我们需要动态获取该类。 // do hook method... [MYMessageService aspect_hookSelector:NSSelectorFromString(@&quot;onRevokeMsg:&quot;) withOptions:AspectPositionInstead usingBlock:^(id&lt;AspectInfo&gt; info)&#123; // hook method... NSLog(@&quot;revoked message: %@&quot;, [info arguments].firstObject); &#125; error:nil];&#125; 我们打印了撤回的消息的内容，可以看到微信的聊天信息是以XML的形式来进行数据的传输。 12345678&lt;sysmsg type=\"revokemsg\"&gt; &lt;revokemsg&gt; &lt;session&gt;wxid_qdxmce84ueno12&lt;/session&gt; &lt;msgid&gt;1656418240&lt;/msgid&gt; &lt;newmsgid&gt;8250926699869451612&lt;/newmsgid&gt; &lt;replacemsg&gt;&lt;![CDATA[\"sunhay\" 撤回了一条消息]]&gt;&lt;/replacemsg&gt; &lt;/revokemsg&gt;&lt;/sysmsg&gt; 通过逆向，将原本的撤回函数以人类可读的方式展示。 12345678910111213141516171819202122232425262728// self = MessageService 实例-(void)onRevokeMsg:(NSString *)message &#123; // 此处使用原本的 NSString *session = [RegexHelper matchXMLTag:@&quot;session&quot; inXMLText:message]; NSUIntger msgID = [[RegexHelper matchXMLTag:@&quot;msgid&quot; inXMLText:message] longLongValue]; NSUIntger newMsgID = [[RegexHelper matchXMLTag:@&quot;newmsgid&quot; inXMLText:message] longLongValue]; NSString *revokeContent = [RegexHelper matchXMLTag:@&quot;replacemsg&quot; inXMLText:message]; id lastMsgData = [self GetMsgData:session svrId:newMsgID]; if (lastMsgData == nil) &#123; return; &#125; // 匹配 [!CDATA[\\S*]] NSString *receiveMsg = [RegexHelper getChatContent:message]; // 显示谁撤回了消息 id revokingData = [[MessageData alloc] initWithMsgType:0x2710]; [revokingData setMsgStatus:0x4]; [revokingData setMsgContent:receiveMsg]; [revokingData setFromUsrName:[lastMsgData toUsrName]]; [revokingData setToUsrName:[lastMsgData fromUsrName]]; [revokingData setMsgCreateTime:[lastMsgData msgCreateTime]]; [revokingData setMesLocalID:[lastMsgData mesLocalID]]; // 将指定撤回的内容删除 [self DelMsg:session msgList:@[lastMsgData] isDelAll:0 isManual:1]; // 将撤回消息栏添加进指定的聊天列表 [self AddLocalMsg:session msgData:msgData];&#125; 很显然，微信通过删除指定的信息，来实现撤回，那么我们的防止撤回函数如下（都在tweak.mm中）： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#define MYMessageData objc_getClass(&quot;MessageData&quot;)#define MYMessageService objc_getClass(&quot;MessageService&quot;)static void MYPreventRevoking(id service, NSString *message) &#123; NSString *session = [RegexHelper matchXMLTag:@&quot;session&quot; inXMLText:message]; NSUIntger msgID = [[RegexHelper matchXMLTag:@&quot;msgid&quot; inXMLText:message] longLongValue]; NSUIntger newMsgID = [[RegexHelper matchXMLTag:@&quot;newmsgid&quot; inXMLText:message] longLongValue]; id lastMsgData = [service GetMsgData:session svrId:newMsgID]; if (lastMsgData == nil) &#123; return; &#125; NSString *revokeContent = [NSString stringWithFormat:@&quot;Ta 撤回了：%@&quot;, [lastMsgData msgContent]]; NSString *receiveMsg = [RegexHelper getChatContent:message]; id msgData = [[MYMessageData alloc] initWithMsgType:0x2710]; [msgData setMsgStatus:0x4]; [msgData setMsgContent:receiveMsg]; [msgData setFromUsrName:[lastMsgData toUsrName]]; [msgData setToUsrName:[lastMsgData fromUsrName]]; [msgData setMsgCreateTime:[lastMsgData msgCreateTime]]; [msgData setMesLocalID:[lastMsgData mesLocalID]]; id revokingData = [[MYMessageData alloc] initWithMsgType:0x2710]; [revokingData setMsgStatus:0x4]; [revokingData setMsgContent:revokeContent]; [revokingData setFromUsrName:[lastMsgData toUsrName]]; [revokingData setToUsrName:[lastMsgData fromUsrName]]; [revokingData setMsgCreateTime:[lastMsgData msgCreateTime]]; [revokingData setMesLocalID:[lastMsgData mesLocalID]]; // [service DelMsg:session msgList:@[lastMsgData] isDelAll:0 isManual:1]; [service AddLocalMsg:session msgData:msgData]; [service AddLocalMsg:session msgData:revokingData];&#125;// 附上完整的文件static void __attribute__((constructor)) tweak(void) &#123; // 需要注意的是，编译的时候，编译器是找不到 MessageService 的实现， // 如果直接引入会编译报错，我们需要动态获取该类。 // do hook method... [MYMessageService aspect_hookSelector:NSSelectorFromString(@&quot;onRevokeMsg:&quot;) withOptions:AspectPositionInstead usingBlock:^(id&lt;AspectInfo&gt; info)&#123; // hook method... NSLog(@&quot;revoked message: %@&quot;, [info arguments].firstObject); MYPreventRevoking([info instance], [info arguments].firstObject); &#125; error:nil];&#125; 至此我们已经完成了防止消息撤回，这样，在聊天的时候，就能愉快地防止对方偷偷撤回了信息，并且知道对方想要撤回什么信息。 最后简单的介绍如何去对mac应用进行注入，仅作抛砖引玉用。","categories":[{"name":"Objective-C","slug":"Objective-C","permalink":"http://www.zcating.tk/categories/Objective-C/"},{"name":"逆向分析","slug":"Objective-C/逆向分析","permalink":"http://www.zcating.tk/categories/Objective-C/逆向分析/"}],"tags":[]},{"title":"iOS 动态加载非系统的字体","slug":"iOS 动态加载字体","date":"2018-02-16T05:00:00.000Z","updated":"2019-03-17T15:34:49.795Z","comments":true,"path":"2018/02/16/ckaum9y7b000xejl38gyetczp/","link":"","permalink":"http://www.zcating.tk/2018/02/16/ckaum9y7b000xejl38gyetczp/","excerpt":"对于字体文件，普遍的方法是静态加载，静态加载需要将字体文件打包到mainBundle中，但是某些应用如果需要下发字体功能，那么就不是很方便，于是就介绍以下动态加载字体库的方法。","text":"对于字体文件，普遍的方法是静态加载，静态加载需要将字体文件打包到mainBundle中，但是某些应用如果需要下发字体功能，那么就不是很方便，于是就介绍以下动态加载字体库的方法。 静态加载对于字体来说，有两种文件格式，.otf和.ttf。这两种都是可以作为字体格式加载到iOS当中的。 要加载字体，首先要在Info.plist添加如下属性： 接着，打开字体库查找你要加载字体的PostScript name。 然后在你的代码中添加以下代码： 12345//// @param name : PostScript name// @param size : the font size you want to set//[UIFont fontWithName:@&quot;YaHei-Consolas-Hybrid&quot; size:12]; 这样，就可以静态的调用字体。 动态加载但是，有个问题，以上方式直接将字体文件拷贝到mainBundle中，也就是你不能更改字体文件，因此，如果你需要新增或修改字体的时候，是没有办法更改的。所以，需要动态的去加载这个字体文件。 直接给出代码吧，感觉比上面的方法简单多了。 123456789101112131415161718192021222324//首先要 @import CoreText;//字体文件所在路径NSString *fontPath = @&quot;path/to/font/file&quot;;//字体数据NSData *fontData = [NSData dataWithContentsOfFile:fontPath];if (fontData == nil) &#123; return;&#125;//动态加载CFErrorRef error = NULL;CGDataProviderRef providerRef = CGDataProviderCreateWithCFData((CFDataRef)fontData);CGFontRef fontRef = CGFontCreateWithDataProvider(providerRef);// 将文本注册到CoreTextif (!CTFontManagerRegisterGraphicsFont(fontRef, &amp;error)) &#123; NSLog(@&quot;%@&quot;, (__bridge NSString *)CFErrorCopyDescription(error)); return;&#125;NSString *fontName = (__bridge NSString *)CGFontCopyPostScriptName(fontRef);self.label.font = [UIFont fontWithName:fontName size:10];CFRelease(fontRef);CFRelease(providerRef); 这样，就可以动态的去加载了，通过网络下发字体文件，便可以替换字体 。 : )","categories":[{"name":"Objective-C","slug":"Objective-C","permalink":"http://www.zcating.tk/categories/Objective-C/"}],"tags":[]},{"title":"Objective-C 简析（3）—— OC属性 Attributes列举","slug":"Objective-C 简析（3）—— OC属性 Attributes列举","date":"2018-01-10T11:00:00.000Z","updated":"2019-03-17T15:34:49.575Z","comments":true,"path":"2018/01/10/ckaum9y77000nejl37rad43xs/","link":"","permalink":"http://www.zcating.tk/2018/01/10/ckaum9y77000nejl37rad43xs/","excerpt":"Objective-C属性的主要由四种不同的attribute组成 ： 原子性：atomic，nonatomic； 读写相关：readwrite,readonly； 内存管理相关：assign，strong，weak，unsafe_unretained，copy； 存取方法设定：getter=(name)，setter=(name)；","text":"Objective-C属性的主要由四种不同的attribute组成 ： 原子性：atomic，nonatomic； 读写相关：readwrite,readonly； 内存管理相关：assign，strong，weak，unsafe_unretained，copy； 存取方法设定：getter=(name)，setter=(name)； 原子性原子性主要和线程安全相关，当你定义一个属性的时候，默认是atomic的，它底层使用的是同步锁来保证这个操作属性是原子的。在Objective-C编程中，很少用到的atomic这个属性，原因是同步锁的开销比较大，同时也不能保证线程同步，如果要实现线程同步，一般都是采用GCD等较为底层的机制来实现。一般来说属性以使用nonatomic。 读写相关当你定义一个属性的使用，默认是readwrite的。 readwrite该attribute使属性可以拥有getter和setter，如果我们不在类的@implementation中显式的编写getter和setter，那么编译器会生成一个以下划线加属性名称为名的成员变量，并且自动的生成getter和setter。 readonly该attribute使属性只能拥有getter，如果我们不在类的@implementation中显式的编写getter，那么编译器会生成一个以下划线加属性名称为名的成员变量，并且自动的生成getter。 内存管理相关当你定义一个属性的使用，内存管理的Attribute默认是assign的。 assign仅仅用于内置类型或者简单的结构体，比如float或者CGRect。如果属性的类型是Objective-C类，那么当属性所持有的类实例dealloc的时候，属性的值并并不会自动置为nil。 strong用于Objective-C类，为这种属性调用setter时，会保留新值，然后释放旧的值，并将新值赋上去。 weak用于Objective-C类，为这种属性调用setter时，不会持有新值，也不会释放旧值。但是当它所指的对象dealloc的时候，该属性会被设置为nil。 copy用于Objective-C类，为这种属性调用setter时，会保留新值的拷贝，然后释放旧值，然后将这个拷贝赋值给属性。 unsafe_unretained用于Objective-C类，为这种属性调用setter时，不会持有新值，也不会释放旧值。但是当它所指的对象dealloc的时候，属性的值仍然是该对象未dealloc时在内存的位置，不会自动清空。 存取方法设定这个用的比较少，以两个例子来说明就好了。 1234567891011121314151617181920@interface LightBulb : NSObject &#123; BOOL _onOrOff;&#125;@property (nonatomic, getter=isOn, setter=setIsOn) BOOL on;@end@implementation LightBulb// 因为定义了 getter=isOn，所以getter方法为 -isOn, 而不是 -on.-(BOOL)isOn&#123; return _isOn;&#125;// 因为定义了 setter=setIsOn，所以getter方法为 -setIsOn, 而不是 -setOn.-(void)setIsOn:(BOOL)onOrOff&#123; _onOrOff = onOrOff;&#125;@end 其他标记一个属性为类属性： 1@property(class, nonatomic, strong) UIApplication *sharedApplication; 标记一个属性是否可以为空： 123@property(nonatomic, strong, readonly, nonnull) NSString *loggingString;@property(nonatomic, strong, readonly, nullable) UIResponder *nextResponder;","categories":[{"name":"Objective-C","slug":"Objective-C","permalink":"http://www.zcating.tk/categories/Objective-C/"}],"tags":[]},{"title":"Objective-C简析（2）—— Block篇","slug":"Objective-C 简析（2）—— Block篇","date":"2018-01-06T11:00:00.000Z","updated":"2019-11-16T01:58:22.435Z","comments":true,"path":"2018/01/06/ckaum9y77000oejl3akrab0s3/","link":"","permalink":"http://www.zcating.tk/2018/01/06/ckaum9y77000oejl3akrab0s3/","excerpt":"Block是一个非常有用的语法特性。","text":"Block是一个非常有用的语法特性。 如何定义普通变量： 1int (^block)(int) = ^int(int a) &#123;/*implement*/&#125;; 类属性： 1@property (copy) int (^block)(int); 函数参数： 1-(void)function:(int(^)(int))block; 函数参数调用： 1[aClass aFunction:^int(int a)&#123;/*implement*/&#125;]; 类型定义（typedef）： 12typedef int (^BlockType)(int);BlockType aBlock = ^int(int a)&#123;/*implement*/&#125;; Block简单源码剖析通过clang -rewrit-objc可以获得Block的实现的C++源码。 如下代码： 1234567int main(int argc, const char * argv[]) &#123; void (^block)(void) = ^void(void)&#123; printf(&quot;hello, world!&quot;); &#125;; block(); return 0;&#125; 转换后的主要代码如下。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354// 实现 block 的结构体，所以很显然，在OC中block是一个对象。struct __block_impl &#123; void *isa; // isa 指针，即为 id。 int Flags; // int Reserved; // void *FuncPtr; // 函数指针&#125;;// block的具体属性结构体static struct __main_block_desc_0&#123; size_t reserved; size_t Block_size;&#125; __main_block_desc_0_DATA = &#123; 0, sizeof(struct __main_block_impl_0) &#125;;// block主要实现结构体struct __main_block_impl_0&#123; struct __block_impl impl; // block结构体 struct __main_block_desc_0* Desc; // 构造函数 __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, int flags=0) &#123; // 初始化 block 实例属性 isa ，表示是栈类型的代码块。 impl.isa = &amp;_NSConcreteStackBlock; // impl.Flags = flags; // 具体实现匿名功能的函数的指针 impl.FuncPtr = fp; Desc = desc; &#125;&#125;;// block的匿名函数功能。// 一般来说，OC中实现一个类的方法，一般如下：// className_method(className *self, parameters...)// 对于每一个类方法的实现，都要将其引用带入。static void __main_block_func_0(struct __main_block_impl_0 *__cself) &#123; printf(\"hello, world!\");&#125;// main函数int main(int argc, const char * argv[]) &#123; // 对应于block赋值操作。 // 在这里，代码将 __main_block_impl_0 结构体指针赋值给block。 void (*block)(void) = ((void (*)())&amp;__main_block_impl_0((void *)__main_block_func_0, &amp;__main_block_desc_0_DATA)); // 分成以下三步操作。 // __block_impl *theBlock = (__block_impl *)block; // void (*funcPtr)(__block_impl *) = ((void (*)(__block_impl *))(theBlock-&gt;FuncPtr); // funcPtr((__block_impl *)block); ((void (*)(__block_impl *))((__block_impl *)block)-&gt;FuncPtr)((__block_impl *)block); return 0;&#125; 可以看到，该block是在栈上开辟的空间，也就是说，当离开 新增的__block关键字，以下代码： 123456789int main(int argc, const char * argv[]) &#123; __block int a = 1; void (^block)(void) = ^void(void)&#123; a = a + 1; printf(&quot;hello, world! %d&quot;, a); &#125;; block(); return 0;&#125; 可以获得： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091// __block 关键字用来生成了一个结构体，这个结构体是一个拥有指向自身地址的指针的结构体。struct __Block_byref_a_0 &#123;// isa指针 void *__isa;// 指向自身的指针 __Block_byref_a_0 *__forwarding; int __flags; int __size;// int a 原型 int a;&#125;;struct __main_block_impl_0&#123; struct __block_impl impl; struct __main_block_desc_0* Desc; //将外部的变量 a 加入到__main_block_impl_0 中。 __Block_byref_a_0 *a; __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, __Block_byref_a_0 *_a, int flags=0) : a(_a-&gt;__forwarding) &#123; impl.isa = &amp;_NSConcreteStackBlock; impl.Flags = flags; impl.FuncPtr = fp; Desc = desc; &#125;&#125;;static void __main_block_func_0(struct __main_block_impl_0 *__cself)&#123; // 在这里，将 block 的 a(指针) 复制进局部变量中。 // 此处是为了保证其原子性。 __Block_byref_a_0 *a = __cself-&gt;a; // 此处对应于block中的实现 (a-&gt;__forwarding-&gt;a) = (a-&gt;__forwarding-&gt;a) + 1; printf(\"hello, world! %d\", (a-&gt;__forwarding-&gt;a));&#125;// 与之前不同，这里新增了2个静态函数。//这里用来对block中的对象进行内存管理，// 在引用计数情况下，可以视为引用计数 +1static void __main_block_copy_0(struct __main_block_impl_0*dst, struct __main_block_impl_0*src)&#123; _Block_object_assign((void*)&amp;dst-&gt;a, (void*)src-&gt;a, 8/*BLOCK_FIELD_IS_BYREF*/);&#125;// 用来对block中的对象进行内存释放// 在引用计数情况下，可以视为引用计数 -1static void __main_block_dispose_0(struct __main_block_impl_0*src)&#123; _Block_object_dispose((void*)src-&gt;a, 8/*BLOCK_FIELD_IS_BYREF*/);&#125;// desc 新增了两个属性// 这两个属性，帮助其释放static struct __main_block_desc_0&#123; size_t reserved; size_t Block_size; void (*copy)(struct __main_block_impl_0*, struct __main_block_impl_0*); void (*dispose)(struct __main_block_impl_0*);&#125; __main_block_desc_0_DATA = &#123; 0, sizeof(struct __main_block_impl_0), __main_block_copy_0, __main_block_dispose_0&#125;;int main(int argc, const char * argv[])&#123; // 将 __block int a 初始化。 // 这里使用了列表初始化的方式将列表中对应的值赋给 a。 // 这里可以看到，a.__forwarding = &amp;a; // 这样，无论是在堆上还是栈上，都可以保证该变量能够准确的被调用。 __attribute__((__blocks__(byref))) __Block_byref_a_0 a = &#123; (void*)0, (__Block_byref_a_0 *)&amp;a, 0, sizeof(__Block_byref_a_0), 1 &#125;; // 对block的赋值和调用 void (*block)(void) = ((void (*)()) &amp; __main_block_impl_0( (void *)__main_block_func_0, &amp;__main_block_desc_0_DATA, (__Block_byref_a_0 *)&amp;a, 570425344)); ((void (*)(__block_impl *))((__block_impl *)block)-&gt;FuncPtr)((__block_impl *)block); return 0;&#125; 带有__block关键字的变量会生成一个新的结构体。这个结构体会保证，该变量能够正确的在block的作用域内进行变量的操作（特指更改变量）。 Block 循环引用首先，观察一段简单的代码： 123456789101112131415161718192021222324252627@interface HelloPrinter : NSObject-(void)sayHello;@end@implementation HelloPrinter-(void)sayHello &#123; printf(&quot;Hello\\n&quot;);&#125;@end int main(int argc, const char * argv[]) &#123; @autoreleasepool &#123; void (^block)(void); &#123; HelloPrinter *printer = [[HelloPrinter alloc] init]; block = ^void(void) &#123; [printer sayHello]; &#125;; &#125; block(); &#125; return 0;&#125; 这里肯定是打印出了 Hello\\n 。 显然，printer只能在当前的作用域内有效，那么可以肯定的是，block持有了printer。也就是printer的引用计数“+1”了，这样，printer才能在作用域外实行-sayHello方法。 对于循环引用的问题，可以观察以下代码： 12345678910111213141516171819202122232425@interface HelloPrinter : NSObject @property (copy) void (^block)(void);-(void)sayHello;@end@implementation HelloPrinter- (instancetype)init&#123; self = [super init]; if (self) &#123; self.block = ^&#123; [self sayHello]; &#125;; &#125; return self;&#125;-(void)sayHello &#123; printf(&quot;Hello\\n&quot;);&#125;@end 首先我们要确定以下两点： block当中的类会对调用实例方法的实例进行引用。 对带有copy，strong，等关键字的属性初始化时，实例会持有这个属性对应的类的引用。 那么，这就可以构成了循环引用的条件，也就是互相引用对方的实例。 要解决以上代码中的循环引用也很简单，如下： 1234567// 使用 __unsafe_unretained 关键字时，当weakSelf在所在的作用域中运行完后，不会设置为 nil。// __unsafe_unretained typeof(self) weakSelf = self;__weak typeof(self) weakSelf = self;self.block = ^&#123; [weakSelf sayHello];&#125;; 小结本篇主要介绍了如何定义Block这种非常有用的数据结构，分析了其内部实现，最最最主要就是对其产生的循环引用进行简单的分析。","categories":[{"name":"Objective-C","slug":"Objective-C","permalink":"http://www.zcating.tk/categories/Objective-C/"}],"tags":[]},{"title":"Objective-C 简析（1）—— ARC篇","slug":"Objective-C 简析（1）—— ARC篇","date":"2018-01-05T11:00:00.000Z","updated":"2019-03-17T15:34:49.563Z","comments":true,"path":"2018/01/05/ckaum9y74000fejl30x1343x2/","link":"","permalink":"http://www.zcating.tk/2018/01/05/ckaum9y74000fejl30x1343x2/","excerpt":"ARC（Automatic Reference Counting）——自动引用计数是一个编译器的feature，它提供了对Objective-C对象的内存管理，不用再去对对象进行retain或者release操作。","text":"ARC（Automatic Reference Counting）——自动引用计数是一个编译器的feature，它提供了对Objective-C对象的内存管理，不用再去对对象进行retain或者release操作。 内存管理简述要了解ARC，首先就要了解基本的内存管理机制。对于OOP来说，内存管理机制目前主流的方式有两种： 对其对象实例产生的引用进行计数，当计数变为零的时候，释放对象所持有的内存。 另外一种就是可达性分析算法，通过根对象作为起点来生成一棵引用树，通过不同对象的可达性，来对对象的实例进行内存回收。（可能有误，欢迎指出）。 在这里，Objective-C使用了第一种方式作为内存回收机制。图中展示的是一个简单的引用计数情况，他很好的展示了引用计数是如何运行的。 ARC简述ARC 主要的工作是使得OC对象能够在适当的时机合理地释放其内存。当开启ARC的时候，我们不需要手动的添加retain和release，clang编译器会自动评估所有对象的生命周期需求，并且在编译期自动的插入内联代码，使得几乎每一个对象的实例（循环引用？）都可以正确的分配和释放内存。同时，编译器会自动生成dealloc方法，一般来说，我们只需要在对象生成实例的时候分配其内存就OK了。 下图可以很好的展示ARC和非ARC运行耗时关系。这里主要是因为，ARC自动地在需要增加或减少引用计数的代码段中添加了内联汇编。这样，使得整个运行时的代码运行速度有所提升。 ARC的一些新规定以下是一些ARC的使用新规定，如果硬是要使用以下方法或对象，允许并开启ARC的编译器会对该代码进行错误提示，不会编译通过。 不能显式调用dealloc，或者是实现或调用 retain，release， retainCount， autorelease 。但是可以使用CFRetain和CFRelease等Core Foundation形式的对象。 不能使用NSAllocateObject 或者 NSDeallocateObject。 不能在结构体中使用OC的对象。 id和void*之间不能类型转换。 不能使用NSAutoreleasePool对象。 不能使用内存空间对象。 新增修饰符对于property属性，在ARC中，新增了一些新的生命周期修饰符和弱（Weak）引用。弱引用不会延伸到对象的生命周期，并且，当该对象没有任何强引用的时候，会自动设置为nil。 ARC引入了strong和weak作为property的新的attributes，示例代码如下： 1234//ARC开启时，strong是默认的property属性。@property(strong) NSObject *myObject; @property(weak) NSObject *myObject; 对于变量的修饰符，ARC引入了一下关键字： 1234567891011__strong ：对于所有对象变量，默认是__strong来修饰。__weak：不保留对象，只是简单的引用。当对象没有任何强引用的时候，变量会被设置成nil。 __unsafe_unretained： 不保留对象，只是简单引用。但是，当变量没有任何强引用的时候，不会设置为nil。可能会产生野指针的错误。 __autoreleasing： 用于标识(id*)的引用参数，或者需要自动释放的返回的对象。 要定义变量的修饰符，你需要这样来定义： 12345ClassName * qualifier variableName;举个例子：MyClass * __weak myWeakReference;MyClass * __unsafe_unretained myUnsafeReference; 小结这里我主要简单的介绍了内存管理和ARC的相关知识。","categories":[{"name":"Objective-C","slug":"Objective-C","permalink":"http://www.zcating.tk/categories/Objective-C/"}],"tags":[]},{"title":"简单爬虫，抓取近十年来的美剧的ed2k链接","slug":"简单爬虫，抓取近十年来的美剧的ed2k链接","date":"2017-08-12T11:00:00.000Z","updated":"2019-11-16T01:56:59.804Z","comments":true,"path":"2017/08/12/ckaum9y7q0025ejl32btchfna/","link":"","permalink":"http://www.zcating.tk/2017/08/12/ckaum9y7q0025ejl32btchfna/","excerpt":"最近剧荒，所以有个简单的想法，就是将某个网站上的所有美剧的下载链接爬出来。这个爬虫使用python来编写，编写的时候，使用到了两个经典的模块：BeautifulSoup和requests。这两个库，可以减轻很多的负担，更加专注于爬虫的内容上，而不是网页解析上。当然，可以尝试一下不用他们的时候，感觉会挺痛苦的。","text":"最近剧荒，所以有个简单的想法，就是将某个网站上的所有美剧的下载链接爬出来。这个爬虫使用python来编写，编写的时候，使用到了两个经典的模块：BeautifulSoup和requests。这两个库，可以减轻很多的负担，更加专注于爬虫的内容上，而不是网页解析上。当然，可以尝试一下不用他们的时候，感觉会挺痛苦的。 简单模拟浏览器行为首先，进入这个网站的下载列表页面需要登录才能浏览，也就是说，要模拟它的登录行为。通过对其登录流程抓包，发现，传输的数据如下：1account=zcating&amp;pwd=(明文)&amp;?_=0.32629091765153717 首先，用账户和密码都是明文传输（厉害了…），然后后面的?_是用js内置的随机数，生成的一个32位的浮点数。（登录流程有点粗糙啊…）登录后，这个浮点数将用于鉴权，观察网页的HTTPHeader，其形式如下：12345&apos;Accept&apos;:&apos;text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8&apos;,&apos;Refer&apos;: &apos;http://(网站的域名)/?_=0.32629091765153717&apos;,&apos;Upgrade-Insecure-Requests&apos;: &apos;1&apos;,&apos;User-Agent&apos;: &apos;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/59.0.3071.115 Safari/537.36&apos;,&apos;Cookie&apos;:&apos;一长串的Cookie&apos; 感觉，这是很多年前就采用的一种超级简单的鉴权模式啊，直接采用Cookie的头部应该就能获取下载页面的HTML了。于是，用上面的头部，作为所有请求的HTTP头部，用过requests模拟浏览器请求，可以请求到数据。解决了下载页面获取不了的问题。 列表请求快速获取已经有方法能够进入到下载页面后，就要抓取想要抓取的东西了。首先通过观察，每个下载页面都是这样的一个路由：1/resource/list/（对应剧集的标识符，数字） 那么思路也就是很明了，需要获取的就是这些一系列的对应的剧集的标识符。在这里，网站自带有一个搜索的路由：1/fresourcelist?page=(第几页)&amp;channel=(电影还是剧集)&amp;area=(发布地区)&amp;category=(分类)&amp;year=(年份)&amp;tvstation=(播出频道)&amp;sort=(排列顺序) 该路由，很显然应该通过get请求数据。在这里，我组装的数据是形式如下：12/fresourcelist?page=&#123;&#125;&amp;channel=tv&amp;area=%E7%BE%8E%E5%9B%BD&amp;category=&amp;year=&amp;tvstation=&amp;sort=PS: area=美国(url encode) 由于其每页展示的数量有限，所以通过对网页观察，获取其最大的页面数，通过page={}这种形式，循环去获取每一个页面。由于每一个页面的展示方式相同，这样我们只要对一个页面进行分析就能够获取所有页面的资料。通过浏览器的页面分析，对获取的HTML用BeautifulSoup进行以下解析:1234567891011soup = BeautifulSoup(response.text, &apos;html.parser&apos;)rawPrograms = soup.find(class_= &apos;resource-showlist has-point&apos;)programs = []for x in rawPrograms.findAll(&apos;a&apos;): href = x.get(&apos;href&apos;) if href != None and &apos;resource&apos; in href and x.find(&apos;img&apos;) == None: programTag = href.split(&apos;/&apos;)[2] name = standardized(x.text) program = &#123;&apos;name&apos;: name, &apos;resource&apos;: rawURL + programTag&#125; programs.append(program) program中，包含了一个剧集的名称和其资源标识符。programs则是我所需要的所有的剧集列表。之后，通过循环请求组装好的剧集下载页面，就可以获得所有下载页面的HTML。这里，需要做以下解析：123456789101112131415soup = BeautifulSoup(response.text, &apos;html.parser&apos;)mediaLists = soup.findAll(class_=&apos;media-list&apos;)for mediaList in mediaLists: h2 = mediaList.find(&apos;h2&apos;) noLink = mediaList.find(style=&apos;display: none;&apos;) # 只保留 HR-HDTV 或者 MP4 的下载列表 if h2 == None and h2.text != &apos;HR-HDTV&apos; and h2.text != &apos;MP4&apos; and noLink == None: continue # 只保留 ed2k 类型的下载链接 programs = mediaList.findAll(type=&apos;ed2k&apos;) for program in programs: ed2k = program.get(&apos;href&apos;) file.write(ed2k + &apos;\\n&apos;) 这样，就大功告成。 展示一下成果吧","categories":[{"name":"python","slug":"python","permalink":"http://www.zcating.tk/categories/python/"}],"tags":[]},{"title":"BLE简单重放攻击","slug":"BLE简单重放攻击","date":"2017-04-13T11:00:00.000Z","updated":"2019-03-17T15:34:49.473Z","comments":true,"path":"2017/04/13/ckaum9y7u002eejl3mnbpts2v/","link":"","permalink":"http://www.zcating.tk/2017/04/13/ckaum9y7u002eejl3mnbpts2v/","excerpt":"BLE是什么？BLE全称 Bluetooth Low Energy, 即是低功率蓝牙，它比其他传统的蓝牙设备更能控制能耗和成本，所以在发布后就立刻被广泛的应用于各种低功耗设备：运动手环、蓝牙鼠标、蓝牙键盘等。","text":"BLE是什么？BLE全称 Bluetooth Low Energy, 即是低功率蓝牙，它比其他传统的蓝牙设备更能控制能耗和成本，所以在发布后就立刻被广泛的应用于各种低功耗设备：运动手环、蓝牙鼠标、蓝牙键盘等。 BLE简介BLE是什么？BLE全称 Bluetooth Low Energy, 即是低功率蓝牙，它比其他传统的蓝牙设备更能控制能耗和成本，所以在发布后就立刻被广泛的应用于各种低功耗设备：运动手环、蓝牙鼠标、蓝牙键盘等。 BLE和传统蓝牙有着许多的不同之处。他们使用不同的Modulation参数，使用不同的频道，使用不同的频道跳频，使用不同的包格式。但是它们还是会使用传统的主控设备-从属设备模式。 简单分析下面开始简单的蓝牙分析。 蓝牙特点 高可靠性。 低成本，低功耗。 快速启动、瞬间连接。 传输距离极大提高。 较高的安全性。 低数据传输速率。 蓝牙协议栈 应用层：最上面的部分是应用层，GATT和ATT我们可以把她看作是同一层。 Host层：GAP是通用访问配置配置文件，它保证不同的蓝牙设备可以互相发现对方并且建立连接；SM是安全管理层，负责管理安全；L2CAP是逻辑链路控制和适配协议，它负责适配基带中的上层协议。 控制层：Link Layer是链路层，负责数据的传输。BLE Radio PHY是BLE的广播物理层，负责向频道发送广播。HCI是控制接口，主要负责接收信息。 蓝牙通讯过程 GAP-通用访问规范 BLE设备的链接、加密与签名协议的协商都在GAP建立的，比如BLE的两个安全模式，首先是Security Mode1，这个模式主要负责加密，有三个安全等级： LEVEL 1 无认证无加密 LEVEL 2 带加密的未认证配对 LEVEL 3 带加密的认证配对 其次是Security Mode2，这个模式主要是负责签名，有两个安全等级： LEVEL 1 带数据签名的未认证配对 LEVEL 2 带数据签名的认证配对 GATT-通用属性协议 GATT中的三个要素是Profile、Service、Characteristics以及它们的层级关系。其中比较重要的是Service和Characteristics。 Service可以理解为“类”，即功能对象的集合，Characteristics可以理解为“类中的函数”，是GATT中具体的功能对象，每个Service可以包含一个或多个Characteristics。 其实到这里写得还是有点乱，主要就是介绍了蓝牙的特性和协议，下面开始，就要开始比较重要的逆向的部分了。 BLE嗅探BLE嗅探设备介绍 如图，是一个嗅探器（德州仪器（TI）的CC254x系列蓝牙评估模块，配有官方的嗅探器的程序）。先介绍一下，嗅探器的特点： 在蓝牙设备连接前，其会在三个频道发送广播（channel 37 38 39），嗅探器会接收到。 当接收信号的设备发出CONN_REQ建立连接后，蓝牙设备不再向频道 37、38、39 发送广播，此时，他们的连接会重新建立在新的频道上，也就是会跳频。在这之后，他们之间便会进行资料传输。 嗅探器一次只能监听 三个频道中的任意一个（可以选择），当接收信号的设备发出的CONN_REQ信号在当前监听的频道时，我们才能看到他们跳频后传输的信息。 由以上特点，可以知道： 已经建立连接的主从设备，他们中间的交换数据是不会监听到的。 需要知道建立连接主设备的默认地址。 有三分之一的概率是可以监听到跳频后的信息。 在主从设备连接前就要开始监听。 有以上的嗅探工具，就可开始分析蓝牙设备与接收设备之间到底发送了什么信息，然后，伪造BLE的通信，这样便能完成一次完整的重放攻击。需要使用的软硬件有： CSR8510 蓝牙适配器 BlueZ 官方蓝牙协议栈 KALI Linux 发行版 在KALI Linux上安装BlueZ ，然后通过蓝牙适配器来获取发送或者获取信息，通过这样，我们就可以开始进行对蓝牙设备的分析。具体安装过程这里就不透露了，有心者自然可以找到。 蓝牙设备介绍在这里，我们以小米手环作为简单的学习工具。 可以通过蓝牙控制的硬件： 3个LED，可以调控颜色（现在的貌似移除了颜色这个选项了） 电容触摸传感器 震动器 计时器 内部功能： 显示电池状态 存储用户信息 实时步伐通知 存储步伐通知 睡眠监测 BLE嗅探分析连接： 写入一定的数据后，才能进行控制： 发送震动： 发送定时震动： 蓝牙应用逆向分析作为一个运动手环，肯定要收集信息，传输到主设备上，那么肯定有能够解析运动手环数据的软件。 对嗅探结果进行分析后，我发现，必须往AttHandle 0x0019这个地址写入数据，这样继续对蓝牙设备进行操作。也不用做什么简单的分析，应该可以肯定，这些数据就是用户的信息。首先，要对这个小米手环的软件进行简单的逆向。 对小米运动App进行逆向分析，定位到 UserInfo类。 编写这个软件的程序员估计是个宅男，默认初始化的人名使用的是知名影星冲田杏梨。 对这个类交叉编译，可以定位到一个非常有意思的地方。 再次定位，可以找到一个重要的逻辑，将infoBuffer的数据做了个CRC8处理。这里的GATTUtil应该就是蓝牙工具类，可以看出应该是用这个类去发送各种数据到小米手环上。 这个，CRC8算法，就是一个简单的HASH，它做了如下处理，前十九个字节都都是用户的信息，最后一个字节是校验用的。 字节 意义 1~4 UID 5 性别 6 年龄 7 身高 8 体重 9~10 类型 11~19 昵称（前十个字节） 20 校验字节 由于最后重放攻击是使用一个python脚本，所以用python写了这个CRC8。 这里我抓了两组不同的数据，都是从手机发送到蓝牙上的，跑一下上面的python，得到的结果，跟校验位一致。 好了，有了这些，就可以拿去Kali Linux上跑了。 结语最后，通过以上的分析，我们可以通过BlueZ的python封装，完成一个重放攻击脚本，启动定时震动功能。 附：Bluez API 介绍用这个命令扫描当前所有蓝牙设备。 1hcitool scanf 这里，扫描到的设备地址是 88:0F:10:EF:C4:11。 调用以下命令，连接设备 1gatttool -i hci0 -b 88:0F:10:EF:C4:11 -I 之后，用help ，列出所有命令。","categories":[{"name":"逆向分析","slug":"逆向分析","permalink":"http://www.zcating.tk/categories/逆向分析/"}],"tags":[]},{"title":"LeetCode—62th—Unique-Paths","slug":"LeetCode—62th—Unique-Paths","date":"2017-02-16T11:00:00.000Z","updated":"2019-03-17T15:34:49.560Z","comments":true,"path":"2017/02/16/ckaum9y75000iejl3c4bthhbi/","link":"","permalink":"http://www.zcating.tk/2017/02/16/ckaum9y75000iejl3c4bthhbi/","excerpt":"这是LeetCode上，关于动态规划的题目。","text":"这是LeetCode上，关于动态规划的题目。 题目描述A robot is located at the top-left corner of a m x n grid (marked ‘Start’ in the diagram below). The robot can only move either down or right at any point in time. The robot is trying to reach the bottom-right corner of the grid (marked ‘Finish’ in the diagram below). How many possible unique paths are there? Above is a 3 x 7 grid. How many possible unique paths are there? 题目翻译一个机器人坐落在一个 m x n 的矩阵的左上方（如图，标记为 ‘Start’）。 这个机器人可以往下或者右进行任意次移动，这个机器人正在尝试到达矩阵的右下方（如图，标记为’End’）。 那么对于每一个矩阵来说，有多少条独立的路径存在？ 解题思路这是一道简单的动态规划问题，令f(x, y)为从起点到点(x, y)的路径的数量。那么，其状态转移方程如下： 1f(x, y) = f(x-1, y) + f(x, y-1) 由于直接从下或者直接从右移动都只有一条路径，所以我们对f(x, y)的第一行和第一列进行初始化。 代码1234567891011121314151617int uniquePaths(int m, int n) &#123; auto dp = vector&lt;vector&lt;int&gt;&gt;(m, vector&lt;int&gt;(n, 0)); dp[0][0] = 1; for(int i = 0; i &lt; n; i++) &#123; dp[0][i] = 1; &#125; for(int i = 0; i &lt; m; i++) &#123; dp[i][0] = 1; &#125; for(int i = 1; i &lt; m; i++) &#123; for(int j = 1; j &lt; n; j++) &#123; dp[i][j] = dp[i - 1][j] + dp[i][j - 1]; &#125; &#125; return dp[m-1][n-1];&#125;","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://www.zcating.tk/categories/Algorithm/"}],"tags":[]},{"title":"LeetCode—63th—Unique-Paths-II","slug":"LeetCode—63th—Unique-Paths-II","date":"2017-02-16T11:00:00.000Z","updated":"2019-03-17T15:34:49.562Z","comments":true,"path":"2017/02/16/ckaum9y7e0016ejl3bbkdmfm0/","link":"","permalink":"http://www.zcating.tk/2017/02/16/ckaum9y7e0016ejl3bbkdmfm0/","excerpt":"这是LeetCode上，关于动态规划的题目。","text":"这是LeetCode上，关于动态规划的题目。 题目描述Follow up for “Unique Paths”: Now consider if some obstacles are added to the grids. How many unique paths would there be? An obstacle and empty space is marked as 1 and 0 respectively in the grid. For example,There is one obstacle in the middle of a 3x3 grid as illustrated below.12345[ [0,0,0], [0,1,0], [0,0,0]] The total number of unique paths is 2. Note: m and n will be at most 100. 题目翻译这是”Unique Path”的续题： 现在我们不妨考虑往矩阵中添加一些障碍物。那么在矩阵上又会存在多少条独立路径呢？ 障碍标记为1，可行结点标记为0。 例如以下矩阵： 12345[ [0,0,0], [0,1,0], [0,0,0]] 它一共有两条独立路径。 注意：m和n最多不会100。 解题思路这一道题跟上面一道题很类似，只是增加了一个障碍物。令f(x, y)为从起点到终点的独立路径的数量，那么状态转移方程如下： 1f(x, y) = f(x - 1, y) + f(x, y - 1) 由于增加了障碍物，我们需要要判断这一结点是否可达，对于点(x, y)，它可达当且仅当点(x-1, y-1)也是可达的。也就是obstacleGrid[x-1][y-1] == 0时，以上状态转移方程才会成立。 对于边界条件，假设我们第一次往右移动，那么就要令f(0, 1) = 1。 有了边界条件和状态转移方程，我们很容易的写出代码，如下： 代码1234567891011121314151617int uniquePathsWithObstacles(vector&lt;vector&lt;int&gt;&gt;&amp; obstacleGrid) &#123; if (obstacleGrid.size() == 0) &#123; return 0; &#125; int n = (int)obstacleGrid.size(); int m = (int)obstacleGrid[0].size(); std::vector&lt;std::vector&lt;int&gt;&gt; dp(n + 1, std::vector&lt;int&gt;(m + 1, 0)); dp[0][1] = 1; for (int i = 1; i &lt;= n; i++) &#123; for (int j = 1; j &lt;= m; j++) &#123; if (obstacleGrid[i-1][j-1] == 0) &#123; dp[i][j] = dp[i - 1][j] + dp[i][j - 1]; &#125; &#125; &#125; return dp[n][m];&#125;","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://www.zcating.tk/categories/Algorithm/"}],"tags":[]}]}