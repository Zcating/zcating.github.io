{"meta":{"title":"Zcat's Studio","subtitle":null,"description":"Simple Coder","author":"Zcating","url":"http://www.zcating.tk"},"pages":[],"posts":[{"title":"了解 Angular Ivy：Incremental DOM 和 Virtual DOM","slug":"了解Angluar-Ivy-Incremental-DOM-和-Virtual-DOM","date":"2019-08-11T06:35:51.548Z","updated":"2019-08-11T06:35:51.548Z","comments":true,"path":"2019/08/11/cjzjryk04000y2pl3kwggiwui/","link":"","permalink":"http://www.zcating.tk/2019/08/11/cjzjryk04000y2pl3kwggiwui/","excerpt":"本文作者已经分享了很多关于Angular Ivy的见解，因为有很多可以让我们开发者期待的地方。Angular Ivy是一个新的渲染引擎，它跟其他许多主流的渲染引擎有着根本性的区别，因为它使用的是Incremental DOM。现在我们一起来了解一下吧。 什么是 Incremental DOM，它跟 Virtual DOM有什么区别呢？","text":"本文作者已经分享了很多关于Angular Ivy的见解，因为有很多可以让我们开发者期待的地方。Angular Ivy是一个新的渲染引擎，它跟其他许多主流的渲染引擎有着根本性的区别，因为它使用的是Incremental DOM。现在我们一起来了解一下吧。 什么是 Incremental DOM，它跟 Virtual DOM有什么区别呢？ Virtual DOM 是如何工作的React 是第一个使用 Virtual DOM 的主流框架，它的主要思想是： 每一个组件都会在每一次渲染完毕的时候创建一个新的 Virtual DOM。React 通过对比新旧 Vitrual DOM来操作一系列的转换将浏览器的 DOM 跟新的 Virtual DOM 来进行匹配。 Virtual DOM 有两大优点： 我们可以使用任何的编程语言来实现组件渲染函数，所以我们不需要编译任何东西。React开发者习惯用 JSX，但是我们也可以使用JavaScript来开发。 我们可以从渲染组件的结果中获取一个值，它可以用于测试，调试等等。 Incremental DOMIncremental DOM 被用于 Google 内部，它的主要思想是： 每一个组件都会被编译成一系列的指令。这些指令用于创建 DOM 树，并且在数据变化的时候更新它们（DOM树）。 举个例子，请看以下组件： 12345678910111213@Component(&#123; selector: 'todos-cmp', template: ` &lt;div *ngFor=\"let t of todos|async\"&gt; &#123;&#123;t.description&#125;&#125; &lt;/div&gt; `&#125;)class TodosComponent &#123; todos: Observable&lt;Todo[]&gt; = this.store.pipe(select('todos')); constructor(private store: Store&lt;AppState&gt;) &#123;&#125;&#125; 它会被编译成： 123456789101112131415161718192021222324252627var TodosComponent = /** @class */ (function () &#123; function TodosComponent(store) &#123; this.store = store; this.todos = this.store.pipe(select('todos')); &#125; TodosComponent.ngComponentDef = defineComponent(&#123; type: TodosComponent, selectors: [[\"todos-cmp\"]], factory: function TodosComponent_Factory(t) &#123; return new (t || TodosComponent)(directiveInject(Store)); &#125;, consts: 2, vars: 3, template: function TodosComponent_Template(rf, ctx) &#123; if (rf &amp; 1) &#123; // create dom pipe(1, \"async\"); template(0, TodosComponent_div_Template_0, 2, 1, null, _c0); &#125; if (rf &amp; 2) &#123; // update dom elementProperty(0, \"ngForOf\", bind(pipeBind1(1, 1, ctx.todos))); &#125; &#125;, encapsulation: 2 &#125;); return TodosComponent;&#125;()); 模板函数包含着创建和更新的指令。请务必注意的一点是，框架的渲染引擎并不会去解释指令。他们是渲染引擎。 为什么使用 Incremental DOM为什么 GOOGLE 会使用 Incremental DOM，而不是 Vitrual DOM？ 它们的目标是：应用必须要在手机端上表现良好。这意味者需要优化这两个东西：应用打包的大小和内存。 为了优化这两个目标，那么： 渲染引擎本身必须是可以将无用的代码清除的（tree shakable）。 渲染引擎必须占用较低的内存。 为什么 Incremental DOM 是可清除无用代码的（Tree Shakable）当我们使用 Incremental DOM，框架不必去解释组件。相反，组件会引用指令。如果组件不引用一个特定的指令，那么这个组件将不会被使用。所以，我们可以在编译过程中从打包文件（bundle）里忽略未使用的指令。 而 Vitrual DOM 需要解释器。在编译时，解释器并不知道哪个部分是已知的和哪个是未知的，因此我们必须将整个包发送到浏览器。 为什么 Incremental DOM 占用的内存较小每次重新渲染的时候，Virtual DOM 都会从头开始创建整个树。 至于 Incremental DOM，如果页面的DOM没有更改，则不需要任何内存来重新渲染视图。我们仅仅需要在添加或删除DOM节点的时候分配内存，并且大小与DOM变化的大小成正比。 由于大多数渲染或者模板调用不会改变任何东西（或变化很小），因此可以节省大量内存。 它粒度更细（It’s More Nuanced）当然，它（Incremental DOM）的粒度更细。例如，具有渲染返回值可以提供良好的可用性，可以用于测试。 另一方面，它能够使用 Firefox DevTools 逐步执行指令使调试和性能分析更容易。 但是最终谁能更符合人体工程学取决于框架和开发人员的偏好（What ends being more ergonomic depends on the framework and the developer’s preferences.）。 Ivy 和 Incremental DOM?Angular一直在使用html和模板（几年前我写了一篇文章，概述了为什么我认为从长远来看这是正确的选择）。 这就是为什么，Virtual DOM 的主要优势永远不会适用于Angular。鉴于此，加上 无用代码清除性和低内存占用的Incremental DOM ，我认为使用 Incremental DOM 作为新渲染引擎的基础是正确的选择。 参考[1] Understanding Angular Ivy: Incremental DOM and Virtual DOM","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://www.zcating.tk/categories/JavaScript/"},{"name":"Angular","slug":"JavaScript/Angular","permalink":"http://www.zcating.tk/categories/JavaScript/Angular/"}],"tags":[]},{"title":"四个步骤优化您的 Angluar 包体积","slug":"四个步骤优化您的-Angluar-包体积","date":"2019-06-30T10:08:57.648Z","updated":"2019-06-30T10:08:57.648Z","comments":true,"path":"2019/06/30/cjzjryk1d001w2pl3cb0ws5x5/","link":"","permalink":"http://www.zcating.tk/2019/06/30/cjzjryk1d001w2pl3cb0ws5x5/","excerpt":"本文翻译自 Optimize Angular bundle size in 4 steps 。 如果首页加载速度太慢了，赶快来了解一下这篇文章吧！ 您是否曾经因为您的网页加载太慢而抱怨？您是否尝试过为加载速度慢的应用“优化性能”？在网上有太多这样关于性能优化的类似的话题了，比如：懒加载、变更检测、服务端渲染等。在这儿，我想聊聊关于优化Angluar Bundle 体积的话题。以下内容对于你来说，将会非常简单和实用。","text":"本文翻译自 Optimize Angular bundle size in 4 steps 。 如果首页加载速度太慢了，赶快来了解一下这篇文章吧！ 您是否曾经因为您的网页加载太慢而抱怨？您是否尝试过为加载速度慢的应用“优化性能”？在网上有太多这样关于性能优化的类似的话题了，比如：懒加载、变更检测、服务端渲染等。在这儿，我想聊聊关于优化Angluar Bundle 体积的话题。以下内容对于你来说，将会非常简单和实用。 步骤一、了解您的包大小不可否认的一点是，首页加载时间跟您的包大小是紧紧联系在一起的。 当你运行npm build --prod的时候，你会发现打包完成后，bundle占用的大小会显示在您的打包服务器中。 多大是合适的？如图所示，四个文件中，最大的就是main.*.js。我查了很多使用了Angluar的网页，基本上企业级的应用打包的出来的main.*.js的大小都在500KB以下，平均在250KB左右。如果你的bundle大小大于500KB，你应该注意了，需要开始优化了。如果小于这个，那么你也许可以在之后再优化也不迟。 步骤二、使用GZIP压缩通常来说，GZIP压缩过的文件的大小通常是源文件的20%左右，这将大大的减少了首页加载时间。 为了知道您的应用是否开启了GZIP压缩，只需要打开浏览器的开发者模式，在network一栏查看Response Headers。如果你看到了Content-Encoding:gzip这个头部，那么您的服务器已经开启了GZIP压缩。 If you don’t see this header, your browser will load the original files. For example, for the Angular bundle in the image below, the browser will load main.0d17aff85f337483317e.js and cost 2.21MB data. However, if you gzip your file, your browser could only load 495.13KB. Such a huge reduction of file size, will obviously reduce the initial page loading time, especially when user has low internet speed. 如果你没有看到这个头部，那么浏览器将会加载源文件。比如说：下面这张图，浏览器会加载main.0d17aff85f337483317e.js并且会花费2.21MB左右的带宽。然而，如果您使用GZIP压缩你的文件，浏览器就仅仅只会加载495.13KB左右的数据。如此巨大的数据减少，会明显地降低首页加载时间，特别是在用户网络不好的情况下。 如何开启GZIP如果你的把你的SPA放在云服务器或者CDN，你应该不用担心这个问题，因为他们会帮你搞定GZIP。然而，如果你使用的是你自己的服务器（NodeJs或者expressJS）来跑你的应用，那么你应该检查所有文件都应该使用GZIP。 下面这个例子是在一个NodeJS + expressJS应用中使用GZIP压缩所有的静态资源。你很难想象到，这么一个简单的中间件compression会使你的包大小从2.21MB减少到495.13KB。 1234const compression = require('compression')const express = require('express')const app = express()app.use(compression()) 步骤三、分析你的 Angluar 包如果你的包大小依旧太大，那么你应该分析你的包，因为你可能是使用不恰当的体积过大的第三方包或者你忘记移除了某些你不再需要使用的包。 Webpack拥有一个非常棒的特性，它可以用来展示你的包是由那些js文件组成的，如图： 获得上面这张图很容易： npm install -g webpack-bundle-analyzer 在你的Angluar应用中，运行ng build --stats-json(不要加上 --prod)。通过加上--stats-json，你将获得一个新的文件——stats.json。 完成之后，你会惊讶： 你忘记移除一些你不再使用的模块。 一些库过大了，他们可以被替换成另外一些库。 不恰当的方式引入了一些库（举个例子：80%的moments.js只是可能不需要的语言环境数据），所以可以提供一些方向来解决问题。 步骤四、监听你的包的大小在 Angluar 7 或者更新的版本，当你使用ng new生成新的应用的时候，在angluar.json中，你可以找到这个配置： 1234567&quot;budgets&quot;: [ &#123; &quot;type&quot;: &quot;initial&quot;, &quot;maximumWarning&quot;: &quot;2mb&quot;, &quot;maximumError&quot;: &quot;5mb&quot; &#125;] This will give you a warning if you build Angular and the bundle size exceeds 2MB and throw an error if the bundle size exceeds 5MB. You can adjust the numbers as per your need. 如果你的包大小超过2MB，那么这个配置会给出警告；如果你的包大小超过5MB，那么它会抛出错误。你可以调整成你合适的配置。 你可以在CI/CD管道中利用这个功能，如果你看到警告/错误，您可能要查看出现了什么问题。 其他减少包大小的方法If your bundle size does get too big because of your app is as big as Facebook, you should really use lazy-loading. This topic is widely covered by the Angular community, so I won’t spread it out here. 如果你的包大小跟Facebook之类的应用一样大，那么你真的应该使用懒加载。Angluar社区广泛地涵盖了这个话题，因此我不会在此去扩展它。 感谢Thank Tsung-Ting Chen for giving me inspiration of this article and help me coming up with the solution.","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://www.zcating.tk/categories/JavaScript/"}],"tags":[]},{"title":"Angluar-模态视图构建简析（A）","slug":"Angluar-模态视图构建简析（A）","date":"2019-06-16T15:49:29.512Z","updated":"2019-06-16T15:49:29.512Z","comments":true,"path":"2019/06/16/cjzjryjz700002pl32xm4ayxc/","link":"","permalink":"http://www.zcating.tk/2019/06/16/cjzjryjz700002pl32xm4ayxc/","excerpt":"在一般的开发中，如果要创建一个模态视图，基本的思路是创建一个不可见的顶层视图，然后在需要的时候，展示这个顶层视图，那么基本的模态视图就创建完成了。 在Angluar中，我们可以使用CDK(component dev kit)中的Overlay来构建模态视图，它把模态的构建过程抽象出来，形成了一个可复用的组件。","text":"在一般的开发中，如果要创建一个模态视图，基本的思路是创建一个不可见的顶层视图，然后在需要的时候，展示这个顶层视图，那么基本的模态视图就创建完成了。 在Angluar中，我们可以使用CDK(component dev kit)中的Overlay来构建模态视图，它把模态的构建过程抽象出来，形成了一个可复用的组件。 准备工作首先，简单的介绍一下CDK： The Component Dev Kit (CDK) is a set of tools that implement common interaction patterns whilst being unopinionated about their presentation. It represents an abstraction of the core functionalities found in the Angular Material library, without any styling specific to Material Design. Think of the CDK as a blank state of well-tested functionality upon which you can develop your own bespoke components. 简单的翻译一下，就是： CDK 是一个这样的工具集，它实现了一系列通用的交互模式，同时不会去影响他们的展示效果。它是 Angluar Material 组件库中没有特定于 Material Design 样式的核心功能的抽象。将CDK视为经过良好测试的功能的空状态，您在它上构建自己的定制组件。 如果你不使用Angluar Material来构建你的应用，那么需要就引入CDK。 1npm i @angular/cdk --save 引入完毕后，就可以开始我们的空状态模态框的构建。 使用OverlayOverlay是一个工厂类，它每次调用create都会创建一个OverlayRef，然后我们就使用OverlayRef来将要展示的内容附在上面（调用attach）。 那么接下来，就要说明一下，overlayRef创建后如何展示我们的视图。首先，我们通过以下代码来创建一个简单的overlayRef。 1const overlayRef = this.overlay.create(); 创建完毕后，使用overlayRef的attach函数来展示视图。attach函数接受一个参数，这个参数的类型可以是 TemplatePortal或者ComponentPortal。 那么，这两个Portal的作用是显而易见，要么获取已存在的嵌入视图（TemplatePortal），要么动态创建宿主视图（ComponentPortal）。当然，这两个Portal的构造过程也不尽相同。 TemplatePortal：接受两个参数，第一个参数是模板引用，第二个参数是当前的视图容器。 ComponentPortal：接受一个参数，其为组件构造函数。 很显然动态创建组件需要在module或者宿主组件的entryComponents属性添加需要的被创建组件。 创建完后，代码如下： 12345678910// Template形式@ViewChild('someTemplate')templateRef: TemplateRef;...const portal = new TemplatePortal(templateRef, viewContainerRef);overlayRef.attach(portal);// component的形式const portal = new ComponentPortal(YourComponent);overlayRef.attach(portal); 构建可复用Overlay通过依赖注入的方式，我们可以引入Overlay到一个可注入服务或者组件中。这里，为了抽象，引入Overlay到一个可注入服务——ModalService。 123export class ModalService &#123; constructor(private overlay: Overlay) &#123;&#125;&#125; 构建一个通用的调用方法： 1234567891011121314// 这里要注意，// `TemplatePortal` 第二个参数在要视图组件中通过依赖注入才能拿到正确的引用。// 原因也很简单，Angular的`Service`是通过`Injector`来构建的，// `Injector`会在应用初始化的时候创建，此时`Service`已经生成，// 而`ViewContainerRef`仍未生成，从而导致依赖错误。// 所以，我们把`ViewContainerRef`当作参数，而不能当作注入对象。openTemplate&lt;T&gt;(templateRef: TemplateRef&lt;T&gt;, viewContainerRef: ViewContainerRef) &#123; const config = new OverlayConfig(); // ...setup your config const overlayRef = this.overlay.create(config); const portal = new TemplatePortal(templateRef, viewContainerRef); overlayRef.attach(portal); return overlayRef;&#125; 这样，一个通用的ModalService就构建完毕了。 总结简单的介绍了如何使用Overlay，以及一个简单的可复用ModalService的构建。希望能够对你了解整个Overlay的使用过程有所帮助，下一篇将介绍如何构建可复用的Modal组件。","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://www.zcating.tk/categories/JavaScript/"}],"tags":[]},{"title":"Angular 中的 'forwardRef' 是什么","slug":"Angular-中的-forwardRef-是什么","date":"2019-06-03T15:47:50.816Z","updated":"2019-06-03T15:47:50.816Z","comments":true,"path":"2019/06/03/cjzjryjzc00012pl3ua7b5sse/","link":"","permalink":"http://www.zcating.tk/2019/06/03/cjzjryjzc00012pl3ua7b5sse/","excerpt":"几乎每一篇我所看过的文章都必须用到forwardRef。那么通过阅读本文可以了解如何在合适的时机使用它，以避免代码中不必要的复杂度。","text":"几乎每一篇我所看过的文章都必须用到forwardRef。那么通过阅读本文可以了解如何在合适的时机使用它，以避免代码中不必要的复杂度。 ‘forwardRef’ 定义我们可以从官方文档中了解forwardRef，文档上是这么写到： 允许引用尚未定义的引用。 For instance, forwardRef is used when the token which we need to refer to for the purposes of DI is declared, but not yet defined. It is also used when the token which we use when creating a query is not yet defined. 这个定义讲述了关于对类的引用，以及提及了引用类作为示例的Token。在Angular中，我们一般用这种形式来定义一个依赖： 1234const dependency = &#123; provide: SomeTokenClass, useClass: SomeProviderClass&#125;; 上面的例子中有一个provide和useClass。所以从定义中我们可以知道forwardRef用做token的形式如下： 1234const dependency = &#123; provide: forwardRef(()=&gt;&#123; SomeTokenClass &#125;), useClass: SomeProviderClass&#125;; 但是在useClass中，我们也有一个对类SomeProviderClass的引用。那么，我们能够将这种使用方式用在provider上吗？虽然官方文档上面没有提到这个用法，但是，我们知道useClass持有了SomeTokenClass类的引用，同时，我们了解到forwardRef可以被引用apply。所以，这种使用方法是允许的，我们可以用这种方式应用于provider上。 1234const dependency = &#123; provide: forwardRef(()=&gt;&#123; SomeTokenClass &#125;), useClass: forwardRef(()=&gt;&#123; SomeProviderClass &#125;)&#125;; 此外，如果你通过使用了Inject装饰器的类引用来注入一个token，那么你同样可以使用上面那种方法： 123456export class ADirective &#123; constructor(@Inject(forwardRef(() =&gt; Token)) service) &#123; ... &#125; ...&#125; 使用例子Angluar 的官方文档使用了下面的代码作为例子： 12345678910111213class Door &#123; lock: Lock; // Door attempts to inject Lock, // despite it not being defined yet. // forwardRef makes this possible. constructor(@Inject(forwardRef(() =&gt; Lock)) lock: Lock) &#123; this.lock = lock; &#125;&#125;// Only at this point Lock is defined.class Lock &#123;&#125; 这个例子有点不直观。虽然它很好的描述到了具体问题上，但是当我想要在实际应用中使用forwardRef的时候，这个例子会让我很难去理解这到底解决了什么问题。我只要需要把Lock放在Door前面不就好了吗？为什么还要用这个方法？因此，我从Angular的源码中找到了更加能够便于理解的例子。 你肯定知道Angular的表单有ngModel和formControl这两个指令，这两个指令可以让表单能够输入信息。在表单中的所有的控件都定义了一个允许通过NgModel访问指令实例的Provider。所以，举个例子，如果你需要访问一个与你自定义指令中的输入关联的表单指令，那么可以这样做： 1234567@Directive(&#123; selector: '[mycustom]'&#125;)export class MyCustom &#123; constructor(@Inject(NgControl) directive) &#123;...&lt;input type=\"text\" ngModel mycustom&gt; 为了启动NgModel和formControl，每个指令都定义了一个formControlBinding的Provider，并且，在指令装饰器中注册它。下面是formControl指令做的部分： 1234567891011export const formControlBinding: any = &#123; provide: NgControl, useExisting: FormControlDirective&#125;;@Directive(&#123; selector: '[formControl]', providers: [formControlBinding], ...&#125;)export class FormControlDirective &#123; ... &#125; 下面是NgModel的： 12345678910export const formControlBinding: any = &#123; provide: NgControl, useExisting: NgModel&#125;;@Directive(&#123; selector: &apos;[ngModel]&apos;, providers: [formControlBinding], ...&#125;)export class NgModel &#123; ... &#125; 我们感兴趣的地方在于，formControlBinding是在指令类装饰器之外定义的。所以，当JavaScript Runtime执行到定义formControlBinding对象的代码时，NgModel的代码还未执行到。如果我们将Provider对象打印出来，那么肯定会有以下结果： 1Object &#123;useExisting: undefined, token: function&#125; useExsiting指向了undefined，所以，Angular肯定是处理不了这段代码的。所以，这也是为什么要在这里使用forwardRef： 12345678910111213export const formControlBinding: any = &#123; provide: NgControl, useExisting: forwardRef(() =&gt; FormControlDirective)&#125;;export class FormControlDirective &#123; ... &#125;...export const formControlBinding: any = &#123; provide: NgControl, useExisting: forwardRef(() =&gt; NgModel)&#125;;export class NgModel&#123; ... &#125; 但是，如果我们把formControlBinding 的定义在不使用forwardRef的情况下，放在内部，这段代码还能运行吗？ 123456789101112@Directive(&#123; selector: &apos;[ngModel]&apos;, providers: [ &#123; provide: NgControl, useExisting: NgModel &#125; ], ...&#125;)export class NgModel &#123; ...&#125; 好吧，如果你看一下代码，这看起来就是在类定义前引用了NgModel。但是，你应该知道的一点是，所有类装饰器都是在这个类定义后应用到它身上的。所以即使没有forwardRef，这段代码也应该能够运行。但是通过在Provider中内嵌了另外一个Provider，我们不再导出它，所以这段代码也无法被重用。 为什么forwardRef能够运行所以现在的问题是，forwardRef是如何工作的。实际上它与JavaScript中的闭包工作方式相关。在闭包函数捕获变量时，它会捕获变量引用，而不是变量值。举个例子： 123456789let a;function enclose() &#123; console.log(a);&#125;enclose(); // undefineda = 5;enclose(); // 5 可以看到，尽管变量a在enclose函数创建之前是undefined，但是它捕获的是a的变量的引用，所以，在之后将a设为5的时候，打印出来的值也是5。 同样道理适用于forwardRef，它就是一个函数，它将类引用捕获到闭包中，并在执行这个函数之前定义了这个类。Angular编译器使用这个函数resolveForwardRef在运行时解包token或者provider。 原文地址What is forwardRef in Angular and why we need it","categories":[],"tags":[]},{"title":"FRR（Fast ReRoute)相关知识简析","slug":"FRR（Fast-ReRoute)相关知识简析","date":"2019-05-22T12:59:24.307Z","updated":"2019-05-22T12:59:24.307Z","comments":true,"path":"2019/05/22/cjzjryjzf00032pl3sc63e2cs/","link":"","permalink":"http://www.zcating.tk/2019/05/22/cjzjryjzf00032pl3sc63e2cs/","excerpt":"FRR（快速重路由）是为了解决这样一个问题：当网络中的链路或节点失效后，如果没有备份，那么数据就会丢失，那么就需要一个机制来对这些节点进行备份，这个机制就是快速重路由。 理解了快速重路由做的事情后，就要分析为什么需要这个机制。","text":"FRR（快速重路由）是为了解决这样一个问题：当网络中的链路或节点失效后，如果没有备份，那么数据就会丢失，那么就需要一个机制来对这些节点进行备份，这个机制就是快速重路由。 理解了快速重路由做的事情后，就要分析为什么需要这个机制。 FRR机制这个机制的背景也很简单，如果网络中的链路或节点失效后，报文不可避免的会出现两种情况： 丢弃 回流到原来的地方。 这样网络就会产生流量中断或者流量回环的现象。整个网络需要重新计算新的拓扑结构（图结构）和路由，才会终止这种现象。然而，重新计算整个拓扑结构需要耗费数秒时间，这样，对一些实时性要求较高的应用是不能接受的，那么，快速恢复的必要性就很高了。 链路失效的时候，流量丢失的过程可以分为两个阶段： 第一阶段：路由器未能立刻发现连接在其上的某条链路失效，导致仍然向失效的链路上转发流量。 第二阶段：路由器发现链路失效，但是网络处于收敛过程中，使得网络中其他路由器和本路由器转发表并不一致，导致出现转发层面的环路。 因此，为了减少中断时间，快速重路由机制必须有以下几个功能： 快速地发现链路失效。 当链路失效后，迅速地提供一条恢复路径。 在后继网络恢复过程中，避免出现转发环路。 FRR工作流程那么快速重路由的工作过程如下： 故障快速检测； 修改转发平面，将流量切换到预先计算好的备份路径上去。 路由重收敛； 重收敛结束后，将流量又重新切换至最优路径； 其实最重要的部分就是路由备份，如果链路中断，那么他就可以从备份中拿出新的路由，从而实现不通过失效的链路或节点到达指定的位置。之后，等待网络路由收敛后，再将流量切换到最优路径上。 FRR实现方式再描述之前，先简单介绍一下MPLS（多协议标签交换）路由技术。 路由决策路由决策是指，路由器决定数据包如何路由转发的过程。每个路由器都需要分析包头，根据网络协议层的数据进行运算，再基于这些分析和运算，独立的为数据包选择下一跳（next hop），最后通过next hop将数据包发送出去。它可以认为是由以下两部分组成的： 分类，将特定的数据包归属为一个等价转发类（Forwarding Equivalence Class，FEC） 查找，查找FEC对应的next hop（下一跳） MPLS解决了什么问题传统的路由决策，路由器需要对网络数据包进行解包，再根据目的IP地址计算归属的FEC。而MPLS提出，当网络数据包进入MPLS网络时，对网络数据包进行解包，计算归属的FEC，生成标签（Label）。当网络数据包在MPLS网络中传输时，路由决策都是基于Label，路由器不再需要对网络数据包进行解包。并且Label是个整数，以整数作为key，可以达到O(1)的查找时间。大大减少了路由决策的时间。这里的Label就是MPLS里面的L。需要注意的是Label在MPLS网络里面，是作为网络数据包的一部分，随着网络数据包传输的。 一些术语 LSR（Label Switching Router）：标记交换路由，支持MPLS转发的路由器。如果一个LSR有一个邻接的节点在MPLS网络之外，那么这个LSR就是LER。注意，这里的MPLS网络之外可以是：1.传统路由网络，2.另一个MPLS网络。 LSP（Label Switching Path）：标记交换路径，是特定的FEC中的IP协议报文所经过的LSR的集合。LSP通常也被称为MPLS tunnel（其实就是链路和节点的抽象）。 FRR的具体实现基本的快速重路由算法有两种实现方式： Detour 方式：One-to-one Backup，分别为每一条被保护 LSP 提供保护，为每一条被保护 LSP 创建一条保护路径，该保护路径称为 Detour LSP。 Bypass 方式：Facility Backup，用一条保护路径保护多条 LSP，该保护路径称为 Bypass LSP。 Detour 方式实现了每条 LSP 的保护，相对需要更大的开销。在实际使用中，Bypass 方式被更广泛使用。 Bypass的实现可以参考论文[2]。 总而言之，Bypass是通过设置一个主LSP隧道，来实现FRR。 参考[1] MPLS基础 [2] MPLS TE快速重路由","categories":[{"name":"计算机网络","slug":"计算机网络","permalink":"http://www.zcating.tk/categories/计算机网络/"}],"tags":[]},{"title":"JWT + Spring Boot Security 解决方案详解","slug":"JWT+Spring Boot Security 解决方案详解","date":"2019-05-04T12:05:49.714Z","updated":"2019-05-04T12:05:49.714Z","comments":true,"path":"2019/05/04/cjzjryk09001a2pl365mw2u47/","link":"","permalink":"http://www.zcating.tk/2019/05/04/cjzjryk09001a2pl365mw2u47/","excerpt":"首先编写一个简单的Token生成器12345678910111213141516171819202122232425262728293031323334353637383940@Componentpublic class JwtTokenProvider &#123; private Clock clock = DefaultClock.INSTANCE; @Value(\"$&#123;jwt.secret&#125;\") private String secret; @Value(\"$&#123;jwt.expiration&#125;\") private Long expiration; public String generateToken(String id, String username) &#123; var createdDate = clock.now(); var expirationDate = calculateExpirationDate(createdDate); return Jwts.builder() .setId(id) .setSubject(username) .setIssuedAt(createdDate) .setExpiration(expirationDate) .signWith(SignatureAlgorithm.HS512, this.secret) .compact(); &#125; public Boolean isValidated(Claims claims) &#123; return claims != null &amp;&amp; claims.getExpiration().before(clock.now()); &#125; Claims getClaims(String token) &#123; return Jwts.parser() .setSigningKey(secret) .parseClaimsJws(token) .getBody(); &#125; private Date calculateExpirationDate(Date createdDate) &#123; return new Date(createdDate.getTime() + expiration * 1000); &#125;&#125;","text":"首先编写一个简单的Token生成器12345678910111213141516171819202122232425262728293031323334353637383940@Componentpublic class JwtTokenProvider &#123; private Clock clock = DefaultClock.INSTANCE; @Value(\"$&#123;jwt.secret&#125;\") private String secret; @Value(\"$&#123;jwt.expiration&#125;\") private Long expiration; public String generateToken(String id, String username) &#123; var createdDate = clock.now(); var expirationDate = calculateExpirationDate(createdDate); return Jwts.builder() .setId(id) .setSubject(username) .setIssuedAt(createdDate) .setExpiration(expirationDate) .signWith(SignatureAlgorithm.HS512, this.secret) .compact(); &#125; public Boolean isValidated(Claims claims) &#123; return claims != null &amp;&amp; claims.getExpiration().before(clock.now()); &#125; Claims getClaims(String token) &#123; return Jwts.parser() .setSigningKey(secret) .parseClaimsJws(token) .getBody(); &#125; private Date calculateExpirationDate(Date createdDate) &#123; return new Date(createdDate.getTime() + expiration * 1000); &#125;&#125; 从AbstractAuthenticationToken扩展自定义认证令牌123456789101112131415161718192021222324252627282930313233public class BasedAuthenticationToken extends AbstractAuthenticationToken &#123; private String id; private final UserDetails principle; TokenBasedAuthentication(String id, UserDetails principle) &#123; super( principle.getAuthorities() ); this.principle = principle; &#125; public String getId() &#123; return id; &#125; public void setId(String id) &#123; this.id = id; &#125; @Override public boolean isAuthenticated() &#123; return true; &#125; @Override public Object getCredentials() &#123; return token; &#125; @Override public UserDetails getPrincipal() &#123; return principle; &#125;&#125; 从BasicAuthenticationFilter扩展自定义过滤器123456789101112131415161718public class AuthenticationFilter extends BasicAuthenticationFilter &#123; @Override protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain) throws ServletException, IOException &#123; var authorization = request.getHeader(\"Authorization\"); if (!StringUtils.isEmpty(authorization) &amp;&amp; authorization.startsWith(\"Bearer \")) &#123; var token = authorization.substring(\"Bearer \".length()); var claims = jwtTokenProvider.getAllClaims(token); // 判断是否有效 if (!jwtTokenProvider.isValidated(claims)) &#123; var userDetails = jwtService.loadUserByUsername(String.valueOf(claims.get(\"id\")), claims.getSubject()); var basedAuthenticationToken = new TokenBasedAuthentication(userDetails); SecurityContextHolder .getContext() .setAuthentication(basedAuthenticationToken); &#125; &#125; &#125;&#125; 在这里主要做以下事情： 从每个请求header获取token 对token进行合法性验证 解析得到username，并从database取出用户相关信息权限 把用户信息(role等)以UserDetail形式放进SecurityContext以备整个请求过程使用。（例如哪里需要判断用户权限是否足够时可以直接从SecurityContext取出去check） 从 WebSecurityConfigurerAdapter 继承配置适配器123456789101112131415161718192021222324252627282930313233343536373839404142@Configuration@EnableWebSecurity@EnableGlobalMethodSecurity(prePostEnabled = true)public class WebSecurityConfiguration extends WebSecurityConfigurerAdapter &#123; @Override protected void configure(HttpSecurity httpSecurity) throws Exception &#123; httpSecurity // 关闭csrf验证 .csrf().disable() // 对请求进行认证 .authorizeRequests() // 所有请求需要身份认证 .anyRequest().authenticated() // 添加一个过滤器验证Token是否合法 .and().addFilterBefore(jwtAuthenticationFilter(), AuthenticationFilter.class); httpSecurity.headers().cacheControl(); &#125; @Override public void configure(WebSecurity web) throws Exception &#123; // 除了以下接口不用验证以外。 // 此处会跳过各种认证过程。 web.ignoring().antMatchers(); &#125; @Override protected void configure(AuthenticationManagerBuilder auth) throws Exception &#123; auth.userDetailsService(service).passwordEncoder(passwordEncoder()); &#125; @Bean @Override public AuthenticationManager authenticationManagerBean() throws Exception &#123; return super.authenticationManagerBean(); &#125; @Bean AuthenticationFilter authenticationFilter() throws Exception &#123; return new AuthenticationFilter(authenticationManagerBean()); &#125;&#125; 之后，就可以对每个需要验证的请求进行校验。 认证闭环在这里，还需要做一件事情，登录的时候生成Token： 12345678910111213141516public Result login(UserLoginForm form) &#123; var userAuthInfo = userMapper.findAuthUserByName(form.getName()); var map = new HashMap(); if (userAuthInfo == null) &#123; map.put(\"error\", \"User is not exsited.\") return map; &#125; if (!passwordEncoder.matches(form.getPassword(), userAuthInfo.getPassword())) &#123; return map.put(\"error\", \"Passwords are not paired.\"); &#125; var token = tokenProvider.generateToken(userAuthInfo); var map = new HashMap(); map.put(\"token\", token); return map;&#125; 然后，当我们的请求认证成功的时候，需要获取认证成功的用户信息： 123456789101112131415161718 public Result getUserInfo() &#123; // 可以这样获取认证用户的信息 var token = (BaseAuthenticationToken)SecurityContextHolder .getContext() .getAuthentication(); var map = new HashMap(); if (token == null) &#123;map.put(\"error\", \"User is not exsited\"); return map; &#125; var userInfo = userMapper.findUserInfoById(token.getId()); var token = tokenProvider.generateToken(userAuthInfo); var map = new HashMap(); map.put(\"username\", userInfo.getUsername()); // ... return map; &#125; 这样就完成了一个完整的认证闭环，从生成Token到验证Token。","categories":[],"tags":[]},{"title":"Angular Dirty Check 简单实现","slug":"Dirty-Check-简单实现","date":"2019-04-23T11:00:00.000Z","updated":"2019-08-15T15:33:25.242Z","comments":true,"path":"2019/04/23/cjzjryjzh00042pl3f39ch0fy/","link":"","permalink":"http://www.zcating.tk/2019/04/23/cjzjryjzh00042pl3f39ch0fy/","excerpt":"所谓脏检查，其实是一种实现双向绑定的机制，原理很简单，就是通过指令（dom属性）遍历dom对象，然后为指令所在的dom添加事件或者做其他任何的事情。下面将编写一个Tiny-Angular，来实现一些简单的功能。 DOM文档下面是HTML。 1234567891011&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;test&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h1 ng-bind=&quot;helloText&quot;&gt;hello&lt;/h1&gt; &lt;h2&gt;&lt;input type=&quot;text&quot; ng-model=&quot;helloText&quot;&gt; &lt;/h2&gt; &lt;script src=“./tiny-angular.js” /&gt;&lt;/body&gt; 我们可以看到，h1和h2对象都有一个简单的指令ng-bind和ng-model那么我们将通过这个指令来实现双向绑定。","text":"所谓脏检查，其实是一种实现双向绑定的机制，原理很简单，就是通过指令（dom属性）遍历dom对象，然后为指令所在的dom添加事件或者做其他任何的事情。下面将编写一个Tiny-Angular，来实现一些简单的功能。 DOM文档下面是HTML。 1234567891011&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;test&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h1 ng-bind=&quot;helloText&quot;&gt;hello&lt;/h1&gt; &lt;h2&gt;&lt;input type=&quot;text&quot; ng-model=&quot;helloText&quot;&gt; &lt;/h2&gt; &lt;script src=“./tiny-angular.js” /&gt;&lt;/body&gt; 我们可以看到，h1和h2对象都有一个简单的指令ng-bind和ng-model那么我们将通过这个指令来实现双向绑定。 tiny-angular.js (ES6)首先我们先要定义一个Scope，使得我们所有的操作都在这个作用域下： 123456789101112131415161718192021222324252627282930class Scope &#123; constructor() &#123; this.watchers = []; &#125; watch(watcherFn, listenerFn) &#123; this.watchers.push(&#123; watcherFn, listenerFn, // 记录标记新旧值 last: undefined &#125;) &#125; digest() &#123; this.watchers.forEach((watcher) =&gt; &#123; // 运行我们的观察者函数 const newValue = watcher.watcherFn(); const oldValue = watcher.last; if (newValue !== oldValue) &#123; // 如果新旧值不相等那就运行监听者 watcher.listenerFn(newValue, oldValue); // 保存新值 watcher.last = newValue; &#125; &#125;); &#125;&#125; 在这里，构建了一个简单观察者，这个观察者的作用很简单，就是观察的时候，同时执行监听函数，这样，就实现了一个简单的双向绑定。这个双向绑定是这样调用的： 123456789101112const scope = new Scope();scope.helloText = 'hello';scope.watch(() =&gt; &#123; console.log(scope.helloText); return scope.helloText;&#125;, (newValue, oldValue) =&gt; &#123; console.log(newValue, oldValue);&#125;);scope.digest(); 那么我们就知道，多次运行digest的时候，如果我们监听的值没变，最终结果只会打印一次。 所以我们可以这样： 123456scope.helloText = 'Hello !!';scope.digest();scope.helloText = 'Hello World.';scope.digest(); 当然，我们在Scope类中封装一下，大概这样： 1234567891011121314151617... apply(doing) &#123; try &#123; doing(); &#125; catch (error) &#123; &#125; finally &#123; this.digest(); &#125; &#125;...scope.helloText = 'hello';scope.apply(()=&gt;&#123; scope.helloText = 'hello world!';&#125;);// hello hello world; Compile这一步就是构建我们脏检查。众所周知，我们的DOM是一棵树，为了构建脏检查，我们需要遍历这棵树。 123456function Compile(element, scope) &#123; // 遍历 element中的所有子树 Array.prototype.forEach.call(element.children, (child)=&gt;&#123; Compile(child, scope); &#125;);&#125; 这样，我们就能遍历这颗树，然而，还是不够，为了能够实现我们的指令功能，我们还需要遍历每个节点的属性，并找出对应的指令： 1234567891011121314151617181920212223const $directives = &#123; 'ng-bind': (scope, element, attributes) =&gt; &#123; console.log(scope, element, attributes); &#125;, 'ng-model': (scope, element, attributes) =&gt; &#123; console.log(scope, element, attributes); &#125;&#125;function Compile(element, scope) &#123; // 遍历 element中的所有子树 Array.prototype.forEach.call(element.children, (child)=&gt;&#123; Compile(child, scope); &#125;); // 遍历 element 中的所有属性（指令） Array.prototype.forEach.call(element.attributes, (attribute)=&gt;&#123; const directive = $directives[attribute.name]; console.log(scope); if (directive) &#123; directive(scope, element, element.attributes); &#125; &#125;);&#125; 好了，这样我们就能找到树中的节点的对应的指令，并做一些操作。为了实现简单的双向绑定，我们需要对指令做这些操作： ng-bind需要做的操作是，将该指令指定的scope中的对象赋给这个dom对象的innerText； ng-model需要的操作是，将input输入的值绑定到scope中的对象。 12345678910111213141516171819202122232425262728const $directives = &#123; 'ng-bind': (scope, element, attributes) =&gt; &#123; scope.watch(()=&gt;&#123; return scope[attributes['ng-bind'].value]; &#125;, (newValue) =&gt; &#123; console.log(newValue); element.innerHTML = newValue; &#125;); &#125;, 'ng-model': (scope, element, attributes) =&gt; &#123; scope.watch(()=&gt;&#123; return scope[attributes['ng-model'].value]; &#125;, (newValue) =&gt; &#123; element.value = newValue; &#125;); // 设定初始值 scope.apply(()=&gt;&#123; scope.helloText = 'hello!'; &#125;); element.addEventListener('keyup',()=&gt;&#123; scope.apply(()=&gt;&#123; scope[attributes['ng-model'].value] = element.value; &#125;); &#125;); &#125;&#125; 最终我们需要这样调用： 1Compile(document.body, $scope); 完成！ Demo测试一下，大概的效果： hello 'use strict'; class Scope { constructor() { this.watchers = []; } watch(watcherFn, listenerFn) { this.watchers.push({ watcherFn, listenerFn, last: undefined }) } digest() { this.watchers.forEach((watcher)=>{ const newValue = watcher.watcherFn(); const oldValue = watcher.last; if (newValue !== oldValue) { watcher.listenerFn(newValue, oldValue); watcher.last = newValue; } }); } $apply(doing) { try { doing(); } finally { this.digest(); } } } const $directive = { 'ng-bind': (scope, element, attributes) => { scope.watch(()=>{ console.log(attributes['ng-bind'].value); return scope[attributes['ng-bind'].value]; }, (newValue) => { console.log(newValue); element.innerHTML = newValue; }); }, 'ng-model': (scope, element, attributes) => { scope.watch(()=>{ return scope[attributes['ng-model'].value]; }, (newValue) => { element.value = newValue; }); scope.$apply(()=>{ scope.helloText = 'hello!'; }); element.addEventListener('keyup',()=>{ scope.$apply(()=>{ scope[attributes['ng-model'].value] = element.value; }); }); } } const $scope = new Scope(); function Compile(element, scope) { Array.prototype.forEach.call(element.children, (child)=>{ Compile(child, scope); }); Array.prototype.forEach.call(element.attributes, (attribute)=>{ const directive = $directive[attribute.name]; console.log(scope); if (directive) { directive(scope, element, element.attributes); } }); } Compile(document.body, $scope); $scope.helloText = 'hello111'; FULL CODE下面给出完整的代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;test&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h1 ng-bind=\"helloText\"&gt;hello&lt;/h1&gt; &lt;h2&gt;&lt;input type=\"text\" ng-model=\"helloText\"&gt;&lt;/h2&gt;&lt;/body&gt;&lt;script&gt; 'use strict'; class Scope &#123; constructor() &#123; this.watchers = []; &#125; watch(watcherFn, listenerFn) &#123; this.watchers.push(&#123; watcherFn, listenerFn, last: undefined &#125;) &#125; digest() &#123; this.watchers.forEach((watcher)=&gt;&#123; const newValue = watcher.watcherFn(); const oldValue = watcher.last; if (newValue !== oldValue) &#123; watcher.listenerFn(newValue, oldValue); watcher.last = newValue; &#125; &#125;); &#125; apply(doing) &#123; try &#123; doing(); &#125; catch (error) &#123; &#125; finally &#123; this.digest(); &#125; &#125; &#125; const $directives = &#123; 'ng-bind': (scope, element, attributes) =&gt; &#123; scope.watch(()=&gt;&#123; console.log(attributes['ng-bind'].value); return scope[attributes['ng-bind'].value]; &#125;, (newValue) =&gt; &#123; console.log(newValue); element.innerHTML = newValue; &#125;); &#125;, 'ng-model': (scope, element, attributes) =&gt; &#123; scope.watch(()=&gt;&#123; return scope[attributes['ng-model'].value]; &#125;, (newValue) =&gt; &#123; element.value = newValue; &#125;); scope.apply(()=&gt;&#123; scope.helloText = 'hello!'; &#125;); element.addEventListener('keyup',()=&gt;&#123; scope.apply(()=&gt;&#123; scope[attributes['ng-model'].value] = element.value; &#125;); &#125;); &#125; &#125; const scope = new Scope(); function Compile(element, scope) &#123; Array.prototype.forEach.call(element.children, (child)=&gt;&#123; Compile(child, scope); &#125;); Array.prototype.forEach.call(element.attributes, (attribute)=&gt;&#123; const directive = $directives[attribute.name]; console.log(scope); if (directive) &#123; directive(scope, element, element.attributes); &#125; &#125;); &#125; Compile(document.body, scope); scope.helloText = 'hello!';&lt;/script&gt;&lt;/html&gt;","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://www.zcating.tk/categories/JavaScript/"}],"tags":[]},{"title":"JavaScript 运行机制简记","slug":"JavaScript-运行机制简记","date":"2019-04-14T08:14:56.140Z","updated":"2019-04-14T08:14:56.140Z","comments":true,"path":"2019/04/14/cjzjryjzu000h2pl3vk6a8swx/","link":"","permalink":"http://www.zcating.tk/2019/04/14/cjzjryjzu000h2pl3vk6a8swx/","excerpt":"在我看来，所有的UI开发都有共同的一点，那就是规定了单一线程控制UI的机制，无论是Android，还是iOS，或者是各种PC端的开发，这条机制已经被前人所规定了。 当然，浏览器中的JavaScript对这一条贯彻得更加彻底，整个语言层面上就是单线程的。","text":"在我看来，所有的UI开发都有共同的一点，那就是规定了单一线程控制UI的机制，无论是Android，还是iOS，或者是各种PC端的开发，这条机制已经被前人所规定了。 当然，浏览器中的JavaScript对这一条贯彻得更加彻底，整个语言层面上就是单线程的。 执行栈、事件队列既然JavaScript是单线程，那么很显然，单线程中的每一个任务按顺序运行的，前一个完成了，后一个才能执行。在运行一个任务的过程中，就由执行栈来运行这个任务。 这个长时间的任务如果是大量的计算而造成的阻塞，那么可以通过分片的机制，将这些计算分配到不同的任务当中形成分片，然后用requestAnimationFrame来执行这些分片；如果是因为I/O等待而消耗的时间，那么可能就需要将这个任务挂起，等到I/0完成后，再来运行挂起的任务。那么这里又有了同步和异步的概念。 那么当异步任务完成后，它会往事件队列中添加回调事件。当执行栈中的任务运行完毕后，主线程会将事件队列中首个事件pop，并放入执行栈中执行这个事件。在执行完这个事件后，开始继续轮询事件队列，并执行他们。这个就是一个 event loop。 macro task 和 micro task异步事件被分为了两类，宏任务和微任务。刚刚也说到了，异步事件的回调会放入事件队列中，然而，实际上，他们时根据不同的任务类型而分配到宏任务队列和微任务。主线程在执行完执行栈上的任务后，会先去轮询微任务队列，直到微任务队列为空。这时，主线程才会从宏任务队列中轮询并执行下一个宏任务。 下面是关于哪些是宏任务微任务的列表。 宏任务： 任务 浏览器 Node I/O √ √ setInterval √ √ setTimeout √ √ requestAnimationFrame √ × setImmediate × √ 微任务： 任务 浏览器 Node Promise then catch finally √ √ MutationObserver √ × process.nextTick × √","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://www.zcating.tk/categories/JavaScript/"}],"tags":[]},{"title":"前端小知识","slug":"前端小知识","date":"2019-04-07T12:34:58.780Z","updated":"2019-04-07T12:34:58.780Z","comments":true,"path":"2019/04/07/cjzjryk1e001x2pl32j5p0aah/","link":"","permalink":"http://www.zcating.tk/2019/04/07/cjzjryk1e001x2pl32j5p0aah/","excerpt":"本篇是为了记录开发中遇到的一些知识性的东西。","text":"本篇是为了记录开发中遇到的一些知识性的东西。 JS this全局环境下首先要确定是否this的环境，如果所在环境是全局，那么就要分不同的运行环境： 浏览器下，window === this。 nodejs环境下，global === this。 函数环境下普通调用分为严格模式和非严格模式， 非严格模式：如果直接在函数中调用this会直接触发全局变量。 1234function hello() &#123; console.log(this);&#125;hello(); // window 或 global 严格模式： 1234function hello() &#123; console.log(this);&#125;hello(); // undefined 在对象内部调用这种情况比较多，一般就是作为对象的实例来调用，以下两个是最基本的做法： 1234567891011121314151617// 构造函数function Person(name) &#123; this.name = name;&#125; var person = new Person('Tony');console.log(person.name); // Tony// 作为对象的函数function Swim() &#123; console.log(this.name + ' is swimming...');&#125;var duck = &#123; name: 'penny', swim: Swim&#125;duck.swim(); // penny is swimming... 当你想通过外部传递this来调用该函数的时候，那么你应该使用call和apply： 12345678function walk() &#123; console.log(this.name + ' is walking...');&#125;var student = &#123;name: 'Jenny'&#125;;walk(); // Uncaught TypeError: Cannot read property 'name' of undefined.walk.call(student); // 'Jenny is walking...'walk.apply(student); // 'Jenny is walking...' 更进一步的，可以调用bind()，将外部对象绑定到这个函数对象的拷贝中，使得这个函数对象拷贝的内部的this指向这个对象： 1var walkWithStudent = walk.bind(student); 函数表达式和函数声明式区别函数表达式是以下这种情况： 123var personWalks = function() &#123; console.log('walking')&#125; 函数定义式是以下这种形式： 123function personRuns () &#123; console.log('running');&#125; 这俩唯一的区别就是在于他们的作用域，当我们在函数表达式定义前调用表达式的变量，那么会有以下这种情况发生： 123456// Uncaught ReferenceError: personWalk is not definedpersonWalk();var personWalks = function() &#123; console.log('walking')&#125; 当我们在函数声明式定义前调用声明式的声明，那么不会报错： 123456// works.personRuns();function personRuns () &#123; console.log('running');&#125; JS Function关于函数原型中的apply, call, bind的理解。 首先是call和apply：它的作用是调用一个具有给定this值的函数，意思就是，如果这个函数里面有this，那么会将this绑定到call或apply的第一个参数上，然后再调用这个函数。但是两个不同的地方在于，如果这个函数有参数，那么call提供的是一个参数列表，而apply提供的是一个数组。举例： 12345678function drive(isNew) &#123; var adj = isNew ? 'New ' : 'Old '; console.log(adj + this.name + ' is driving...');&#125;var man = &#123;name: 'Tom'&#125;;drive.call(man, true); // New Tom is driving...drive.apply(man, [false]); // Old Tom is driving... bind的作用将对象与函数的this绑定，然后返回一个已经绑定了这个对象的新的函数对象，也就是，这个新的函数内部的this是指向这个对象的。 1234567function drive(isNew) &#123; var adj = isNew ? 'New ' : 'Old '; console.log(adj + this.name + ' is driving...');&#125;var man = &#123;name: 'Tom'&#125;;drive.bind(man)(true); // New Tom is driving... JS new假设你定义了一个SomeObject对象new SomeObject()来创建对象实例的时候，根据标准，会做如下事情： 继承SomeObject.prototype的一个新对象实例会被创建。 使用指定的参数调用构造函数SomeObject()，并将this绑定到新创建的对象。 构造函数返回的对象就是new的结果，如果构造函数没有返回一个对象，那么就用步骤一中生成的对象。 用伪代码表示： 1234567891011121314function SomeObject (name) &#123; this.name = name;&#125;var construct = function (name) &#123; var object = &#123;&#125;; // 继承 object.__proto__ = SomeObject.prototype; var result = SomeObject.call(object, name); return typeof result === 'object' ? result : object;&#125;; JS 继承根据JavaScript ES5的语法，创建一个类，是这样做的。 12345678910111213function Person(firstname, lastname) &#123; this.firstname = firstname; this.lastname = lastname; this.stand = function() &#123; console.log(\"standing\"); &#125;&#125;Person.prototype.walk = function() &#123; console.log(\"walking\");&#125;var person = new Person();person.walk(); // walkingperson.stand(); // standing 然后，如果你想继承，可以这样： 12345678910111213141516171819202122232425262728293031function Person(firstname, lastname) &#123; this.firstname = firstname; this.lastname = lastname; this.stand = function() &#123; console.log(this.firstname + ' ' + this.lastname + ' ' + 'standing'); &#125;&#125;Person.prototype.walk = function() &#123; console.log(this.firstname + ' ' + this.lastname + ' ' + 'walking');&#125;var person = new Person('Tom', 'Bruce');person.walk(); // Tom Bruce is walkingperson.stand(); // Tom Bruce is standingfunction Student(firstname, lastname) &#123; // 这玩意就是调用父构造函数... Person.call(this, firstname, lastname); this.study = function() &#123; console.log(this.firstname + ' ' + this.lastname + ' ' + 'is studing'); &#125;&#125;Student.prototype = Object.create(Person.prototype);Student.prototype.constructor = Person;// 这样 Student 就能调用Person的成员函数了..var student = new Student('Taylor', 'Swift');student.study(); // Taylor Swift is studingstudent.stand(); // Taylor Swift is standingstudent.walk(); // Taylor Swift is walking 以上那一堆prototype的玩意儿就是一个叫原型链的东西。 如果用ES6写继承，是这样的： 123456789101112131415161718class Pet &#123; constructor(id) &#123; this.id = id; &#125; walk() &#123; console.log('walking'); &#125;&#125;class Dog extends Pet &#123; constructor(id) &#123; super(id); this.type = 'dog'; &#125; bark() &#123; console.log('wooooooof!'); &#125;&#125; 是的，继承的时候就不用写原型链这玩意了。 == 和 ===首先一点肯定是建议使用===。 ===：严格相等，直接比较两个对象的值和类型，都一样才返回真。 ==：抽象相等，会对对象进行类型转换，然后再进行比较。 至于真值表，我觉得没必要记吧。 ES6 …(扩展运算符)扩展运算符有以下几种用法： 函数的可变参数12345678910let array = [];function pushAll(...items) &#123; array.push(...items);&#125;function traverse(...items) &#123; for(let i = 0; i &lt; items.length; i++) &#123; console.log(items[i]); &#125;&#125; 数组合并1234567let numbers1 = [1, 2, 3];let numbers2 = [4, 5, 6];let newNumbers = [7, 8, 9];newNumbers = [...newNumbers, ...numbers1, ...numbers2];console.log(newNumbers); // [7, 8, 9, 1, 2, 3, 4, 5, 6] 函数参数映射123456function sum(x, y, z) &#123; console.log(x+y+z);&#125;let array = [1, 2, 3];log(...array); // 6 Object.assign1234let person = &#123;walk:'walking', call:'calling'&#125;let student = &#123;study: 'studing', ...person&#125;console.log(student); // &#123;study: \"studing\", walk: \"walking\", call: \"calling\"&#125; 将各种迭代器转数组12345678910111213let string = 'hello';console.log([...string]); // [\"h\", \"e\", \"l\", \"l\", \"o\"]// 自定义迭代器也是可以的：let mystring = &#123;&#125;;mystring[Symbol.iterator] = function* () &#123; yield 'h'; yield 'e'; yield 'l'; yield 'l'; yield 'o';&#125;console.log([...mystring]); // [\"h\", \"e\", \"l\", \"l\", \"o\"] ES6 Generator（生成器）生成器主要的作用是封装了一套左闭右开的迭代器，避免自定义维护。123456789101112function* numbers() &#123; yield 1; yield 2; yield 3;&#125;let generator = numbers();console.log(generator.next()); // &#123;value: 1, done: false&#125;console.log(generator.next()); // &#123;value: 2, done: false&#125;console.log(generator.next()); // &#123;value: 3, done: false&#125;console.log(generator.next()); // &#123;value: undefined, done: true&#125; 可以看到generator.next()返回了一个对象：{value: Any, done: Boolean}。 value表示每个yield后面的对象或者是函数返回值； done表示是否执行到最末尾； 其他需要注意的地方 yield* 代表返回后面迭代器中的迭代值，考虑下面代码： 12345678910111213141516function* numbers() &#123; yield 1; yield* [2, 3, 4, 5]; yield 6;&#125;const generator = numbers();console.log(generator.next()); // &#123;value: 1, done: false&#125;console.log(generator.next()); // &#123;value: 2, done: false&#125;console.log(generator.next()); // &#123;value: 3, done: false&#125;console.log(generator.next()); // &#123;value: 4, done: false&#125;console.log(generator.next()); // &#123;value: 5, done: false&#125;console.log(generator.next()); // &#123;value: 6, done: false&#125;console.log(generator.next()); // &#123;value: undefined, done: true&#125;// 也就是说，这个关键字会对其后面的参数（迭代器）进行遍历。 在成员函数next(value:Any)中，它是包含了一个value，这个value将作为yield结束后的返回值，考虑以下代码： 123456789101112131415161718function* numbers() &#123; const x = yield 1; const y = yield x + 1; const z = yield 10 / y;&#125;const generator = numbers();console.log(generator.next(9)); // &#123;value: 1, done: false&#125;// x = 9console.log(generator.next(10)); // &#123;value: 10, done: false&#125;// y = 1console.log(generator.next(1)); // &#123;value: 10, done: false&#125;// z = 99console.log(generator.next(99)); // &#123;value: undefined, done: true&#125;// yield 结束后的返回值，意思就是在生成器中，yield的返回值。 ES6 async/await 关键字有了生成器，那么就可以结合Promise，以同步的方式写异步代码。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778// 假设我们去参加铁人三项，我们必须完成每一项之后，才能继续下一项// 定义游泳function startSwimming() &#123; return new Promise(function (resolve) &#123; console.log('Start swimming..'); setTimeout(function () &#123; console.log('Finish swimming..'); resolve(&#123;type: 'swim'&#125;); &#125;, 500); &#125;);&#125;// 定义自行车function startBiking(swimming) &#123; if (swimming.type !== 'swim') &#123; return &#123;type: 'none'&#125;; &#125; return new Promise(function (resolve) &#123; console.log('Start biking..'); setTimeout(function () &#123; console.log('Finish biking..'); resolve(&#123;type: 'bike'&#125;); &#125;, 1000); &#125;);&#125;// 定义马拉松function startMarathon(biking) &#123; if (biking.type !== 'bike') &#123; return &#123;type: 'none'&#125;; &#125; return new Promise(function (resolve) &#123; console.log('Start running..'); setTimeout(function () &#123; console.log('Finish running..'); resolve(&#123;type: 'marathon'&#125;); &#125;, 2000); &#125;);&#125;// 主要看这里，这里是我们的铁人三项生成器function* TriathlonGenerator() &#123; console.log('Welcome to join Triathlon!'); // 游泳 const swimming = yield startSwimming(); console.log(swimming); // 自行车 const biking = yield startBiking(swimming); console.log(biking); // 马拉松 const running = yield startMarathon(biking); console.log(running); if (running &amp;&amp; running.type === 'marathon') &#123; console.log('finish all item..'); &#125; return running;&#125;// 运行我们特定的生成器的函数function doTriathlon(TriathlonGenerator) &#123; const triathlonIter = TriathlonGenerator(); // 这里是递归操作，目的是为了是生成的迭代器能够按顺序执行。 function doing(argument) &#123; const info = triathlonIter.next(argument); console.log(info.value); if (info.done) &#123; return info.value; &#125; else &#123; return Promise.resolve(info.value).then(function (value) &#123; doing(value); &#125;); &#125; &#125; return doing();&#125;doTriathlon(TriathlonGenerator); 那么，以上代码中关于生成器的部分代码可以约等于以下代码： 123456789101112131415161718192021// 主要看这里，这里是我们的铁人三项生成器，async function doTriathlonAsync() &#123; console.log('Welcome to join Triathlon!'); // 游泳 const swimming = await startSwimming(); console.log(swimming); // 自行车 const biking = await startBiking(swimming); console.log(biking); // 马拉松 const running = await startMarathon(biking); console.log(running); if (running &amp;&amp; running.type === 'marathon') &#123; console.log('finish all item..'); &#125; return running;&#125;doTriathlonAsync();","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://www.zcating.tk/categories/JavaScript/"}],"tags":[]},{"title":"Three.js移动DecalGeometry","slug":"Three.js移动DecalGeometry","date":"2019-03-27T11:51:24.178Z","updated":"2019-03-17T16:00:54.198Z","comments":true,"path":"2019/03/27/cjzjryjzy000l2pl3puofcymp/","link":"","permalink":"http://www.zcating.tk/2019/03/27/cjzjryjzy000l2pl3puofcymp/","excerpt":"遇到了一个需求是，使得DecalGeometry可以移动，先上个demo","text":"遇到了一个需求是，使得DecalGeometry可以移动，先上个demo #three-container { position: relative; width: 100%; height: 500px; } var container = document.getElementById( 'three-container' ); var renderer; var scene; var camera; var humanModel; var humanModels = []; var raycaster; var line; var intersection = { intersects: false, point: new THREE.Vector3(), normal: new THREE.Vector3() }; var mouse = new THREE.Vector2(); var textureLoader = new THREE.TextureLoader(); var decalDiffuse = textureLoader.load( 'textures/decal-diffuse.png' ); var decalNormal = textureLoader.load( 'textures/decal-normal.jpg' ); var decalMaterial = new THREE.MeshPhongMaterial( { specular: 0x444444, map: decalDiffuse, normalMap: decalNormal, normalScale: new THREE.Vector2( 1, 1 ), shininess: 30, transparent: true, depthTest: true, depthWrite: false, polygonOffset: true, polygonOffsetFactor: - 4, wireframe: false }); var decals = []; var mouseHelper; var position = new THREE.Vector3(); var orientation = new THREE.Euler(); var size = new THREE.Vector3( 10, 10, 10 ); var params = { minScale: 10, maxScale: 20, rotate: true, clear: function () { removeDecals(); } }; var focusDecalObject = { model: null, moving: false } window.addEventListener( 'load', init ); function init() { renderer = new THREE.WebGLRenderer( { antialias: true } ); renderer.setPixelRatio( window.devicePixelRatio ); renderer.setSize( container.offsetWidth, container.offsetHeight ); container.appendChild( renderer.domElement ); scene = new THREE.Scene(); camera = new THREE.PerspectiveCamera( 45, container.offsetWidth / container.offsetHeight, 1, 1000 ); camera.position.z = 120; camera.target = new THREE.Vector3(); var controls = new THREE.OrbitControls( camera, renderer.domElement ); controls.minDistance = 50; controls.maxDistance = 200; scene.add( new THREE.AmbientLight( 0x443333 ) ); var light = new THREE.DirectionalLight( 0xffddcc, 1 ); light.position.set( 1, 0.75, 0.5 ); scene.add( light ); var light = new THREE.DirectionalLight( 0xccccff, 1 ); light.position.set( - 1, 0.75, - 0.5 ); scene.add( light ); var geometry = new THREE.BufferGeometry(); geometry.setFromPoints( [ new THREE.Vector3(), new THREE.Vector3() ] ); line = new THREE.Line( geometry, new THREE.LineBasicMaterial() ); scene.add( line ); loadLeePerrySmith(); raycaster = new THREE.Raycaster(); mouseHelper = new THREE.Mesh(new THREE.BoxBufferGeometry( 1, 1, 10 ), new THREE.MeshNormalMaterial()); mouseHelper.visible = false; scene.add( mouseHelper ); window.addEventListener('resize', onWindowResize, false); controls.addEventListener( 'change', function () { renderer.render( scene, camera ); } ); window.addEventListener( 'mousedown', function (event) { event.preventDefault(); getMousePoint(event); raycaster.setFromCamera(mouse, camera); var intersects = raycaster.intersectObjects(decals); if (intersects.length > 0) { focusDecalObject.moving = true; focusDecalObject.model = intersects[0].object; controls.enabled = false; } else { focusDecalObject.moving = false; controls.enabled = true; } }, false ); window.addEventListener( 'mouseup', function () { event.preventDefault(); if ( !focusDecalObject.moving && intersection.intersects ) { shoot(); } controls.enabled = true; focusDecalObject.moving = false; } ); window.addEventListener( 'mousemove', onTouchMove ); window.addEventListener( 'touchmove', onTouchMove ); function onTouchMove( event ) { getMousePoint(event); event.preventDefault(); if(focusDecalObject.moving) { raycaster.setFromCamera(mouse, camera); var intersects = raycaster.intersectObjects(humanModels); if (intersects.length > 0) { var model = intersects[0].object; var point = intersects[0].point; mouseHelper.position.copy(point); var normal = intersects[0].face.normal.clone(); normal.multiplyScalar(10); normal.add(intersects[0].point); mouseHelper.lookAt(normal); var rotation = mouseHelper.rotation; focusDecalObject.model.geometry.dispose(); focusDecalObject.model.geometry = new THREE.DecalGeometry(model, point, rotation, size); } } checkIntersection(); renderer.render( scene, camera ); } function getMousePoint(event) { mouse.x = (event.offsetX / container.offsetWidth) * 2 - 1; mouse.y = -(event.offsetY / container.offsetHeight) * 2 + 1; } function checkIntersection() { if ( ! humanModel ) { return; } raycaster.setFromCamera( mouse, camera ); var intersects = raycaster.intersectObjects( humanModels ); if ( intersects.length > 0 ) { var point = intersects[ 0 ].point; mouseHelper.position.copy( point ); intersection.point.copy( point ); var normal = intersects[ 0 ].face.normal.clone(); normal.transformDirection( humanModel.matrixWorld ); normal.multiplyScalar( 10 ); normal.add( intersects[ 0 ].point ); intersection.normal.copy( intersects[ 0 ].face.normal ); mouseHelper.lookAt( normal ); var positions = line.geometry.attributes.position; positions.setXYZ( 0, point.x, point.y, point.z ); positions.setXYZ( 1, normal.x, normal.y, normal.z ); positions.needsUpdate = true; intersection.intersects = true; } else { intersection.intersects = false; } } onWindowResize(); } function loadLeePerrySmith() { var loader = new THREE.GLTFLoader(); loader.load( 'LeePerrySmith/LeePerrySmith.glb', function ( gltf ) { humanModel = gltf.scene.children[ 0 ]; humanModel.material = new THREE.MeshPhongMaterial({ specular: 0x111111, map: textureLoader.load( 'LeePerrySmith/Map-COL.jpg' ), specularMap: textureLoader.load( 'LeePerrySmith/Map-SPEC.jpg' ), normalMap: textureLoader.load( 'LeePerrySmith/Infinite-Level_02_Tangent_SmoothUV.jpg' ), shininess: 25 }); scene.add( humanModel ); humanModel.scale.set( 10, 10, 10 ); humanModels.push(humanModel); } ); } function shoot() { position.copy( intersection.point ); orientation.copy( mouseHelper.rotation ); var scale = 10; var material = decalMaterial.clone(); material.color.setHex( Math.random() * 0xffffff ); var decalMesh = new THREE.Mesh( new THREE.DecalGeometry( humanModel, position, orientation, size ), material ); decals.push( decalMesh ); scene.add( decalMesh ); } function onWindowResize() { camera.aspect = container.offsetWidth / container.offsetHeight; camera.updateProjectionMatrix(); renderer.setSize( container.offsetWidth, container.offsetHeight ); renderer.render( scene, camera ); } 代码分析主要分为以下几个步骤： 点击鼠标，然后在生成decal。 点住decal的时候可以拖动decal。 首先要计算鼠标的具体位置，我们可以通过监听鼠标的事件来计算： 12345// container 是 document 对象function getMousePoint(event) &#123; mouse.x = (event.offsetX / container.offsetWidth) * 2 - 1; mouse.y = -(event.offsetY / container.offsetHeight) * 2 + 1;&#125; 通过监听点击事件，在模型上生成decal： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849// 鼠标松开会触发window.addEventListener('mouseup', function () &#123; event.preventDefault(); checkIntersection(); if ( !focusDecalObject.moving &amp;&amp; intersection.intersects ) &#123; // 在模型上进行decal shoot(); &#125; // 松开的时候轨道控制器允许运行 controls.enabled = true; focusDecalObject.moving = false;&#125;);// 鼠标点下会触发window.addEventListener('mousedown', function (event) &#123; event.preventDefault(); // 计算鼠标所在的点在三维中位置 getMousePoint(event); raycaster.setFromCamera(mouse, camera); // 用于判断我们的点是否落在decal上 var intersects = raycaster.intersectObjects(decals); // 如果落在decal上，focusDecalObject将获取点击所在的第一个decal， // 第一个decal意味着这个decal是覆盖在其他decal之上。 if (intersects.length &gt; 0) &#123; focusDecalObject.moving = true; focusDecalObject.model = intersects[0].object; controls.enabled = false; &#125; else &#123; focusDecalObject.moving = false; controls.enabled = true; &#125;&#125;, false );// 具体的将decal展示在模型上function shoot() &#123; position.copy( intersection.point ); orientation.copy( mouseHelper.rotation ); var scale = 10; var material = decalMaterial.clone(); material.color.setHex( Math.random() * 0xffffff ); var decalMesh = new THREE.Mesh( new THREE.DecalGeometry( humanModel, position, orientation, size ), material ); decals.push( decalMesh ); scene.add( decalMesh );&#125; 监听鼠标移动事件需要注意的是，要记录点下鼠标的动作，如果允许移动decal，那么就移动它，如果不，那就忽略，然后使轨道控制器运行。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566// 鼠标移动事件window.addEventListener( 'mousemove', function ( event ) &#123; getMousePoint(); event.preventDefault(); if(focusDecalObject.moving) &#123; // 还是通过raycaster计算鼠标点在3D中的位置。 raycaster.setFromCamera(mouse, camera); var intersects = this.raycaster.intersectObjects(humanModels); // 如果点在模型上，那么允许移动。 if (intersects.length &gt; 0) &#123; // var model = intersects[0].object; var point = intersects[0].point; mouseHelper.position.copy(point); // 这里的目的主要是为了改变 var normal = intersects[0].face.normal.clone(); normal.multiplyScalar(10); normal.add(intersects[0].point); mouseHelper.lookAt(normal); var rotation = mouseHelper.rotation; // 这里最重要，我们使原来的几何结构失效，并重新生成新的几何结构 focusDecalObject.model.dispose(); focusDecalObject.model.geometry = new THREE.DecalGeometry(model, position, rotation, size); &#125; &#125; // 显示点在模型上所在的平面的法线 checkIntersection();&#125;, false);function checkIntersection() &#123; if ( ! humanModel ) &#123; return; &#125; // 我们需要计算鼠标所在的点在三维中位置 raycaster.setFromCamera( mouse, camera ); // 去计算这个点是否在模型上 var intersects = raycaster.intersectObjects( humanModels ); if ( intersects.length &gt; 0 ) &#123; // 这个点在三维中的坐标 var point = intersects[ 0 ].point; mouseHelper.position.copy( point ); intersection.point.copy( point ); // 然后我们找到这个点所在平面的法线 var normal = intersects[ 0 ].face.normal.clone(); normal.transformDirection( humanModel.matrixWorld ); normal.multiplyScalar( 10 ); normal.add( intersects[ 0 ].point ); intersection.normal.copy( intersects[ 0 ].face.normal ); // 调整mouseHelper的角度，使其跟这个平面共面 mouseHelper.lookAt( normal ); // 当我们在模型上移动的时候，会显示该鼠标点上模型所在平面的法线。 var positions = line.geometry.attributes.position; positions.setXYZ( 0, point.x, point.y, point.z ); positions.setXYZ( 1, normal.x, normal.y, normal.z ); positions.needsUpdate = true; intersection.intersects = true; &#125; else &#123; intersection.intersects = false; &#125;&#125;","categories":[{"name":"-JavaScript","slug":"JavaScript","permalink":"http://www.zcating.tk/categories/JavaScript/"}],"tags":[]},{"title":"魔方测试","slug":"魔方测试","date":"2019-03-20T11:00:00.000Z","updated":"2019-03-20T15:49:24.487Z","comments":true,"path":"2019/03/20/cjzjryk1f001y2pl3t2c9anzf/","link":"","permalink":"http://www.zcating.tk/2019/03/20/cjzjryk1f001y2pl3t2c9anzf/","excerpt":"","text":"","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://www.zcating.tk/categories/JavaScript/"}],"tags":[]},{"title":"OpenGL shader 测试","slug":"OpenGL-测试","date":"2019-03-10T11:00:00.000Z","updated":"2019-03-17T15:34:49.576Z","comments":true,"path":"2019/03/10/cjzjryk0a001d2pl338d7mfm9/","link":"","permalink":"http://www.zcating.tk/2019/03/10/cjzjryk0a001d2pl338d7mfm9/","excerpt":"里面包含了一些OpenGL shader的测试代码，由于WebGL的shader代码跟OpenGL ES2类似，所以可以直接用OpenGL的shader代码来渲染，效果也是类似的。","text":"里面包含了一些OpenGL shader的测试代码，由于WebGL的shader代码跟OpenGL ES2类似，所以可以直接用OpenGL的shader代码来渲染，效果也是类似的。 #opengl-container { width: 300px; height: 300px; } #shader-editor { flex: 1; margin-right: 10px; font-size: 16px; } .opengl-items { display: flex; } .error-message-text { } void main() { gl_Position = vec4( position, 1.0 ); } #ifdef GL_ES precision mediump float; #endif uniform vec2 u_resolution; uniform float u_time; // Plot a line on Y using a value between 0.0 - 1.0 float plot(vec2 standard, float pct) { return smoothstep(pct - 0.005, pct, standard.y) - smoothstep(pct, pct + 0.005, standard.y); } void main() { vec2 standard = gl_FragCoord.xy/u_resolution; float y = standard.x; float pct = plot(standard, y); vec3 color = (vec3(1.0) - pct) + pct * vec3(0.0, 0.0, 0.0); gl_FragColor = vec4(color, 1.0); } #ifdef GL_ES precision mediump float; #endif uniform vec2 u_resolution; uniform float u_time; // Plot a line on Y using a value between 0.0 - 1.0 float plot(vec2 standard, float pct) { return smoothstep(pct - 0.005, pct, standard.y) - smoothstep(pct, pct + 0.005, standard.y); } void main() { vec2 standard = gl_FragCoord.xy / u_resolution ; standard.x *= u_resolution.x / u_resolution.y; float alpha = 1.0; float y = cos(alpha * standard.x + u_time); y = 0.5*y + 0.5; float pct = plot(standard, y); vec3 color = (vec3(1.0) - pct) + pct * vec3(0.0, 0.0, 0.0); gl_FragColor = vec4(color, 1.0); } #ifdef GL_ES precision mediump float; #endif uniform vec2 u_resolution; uniform vec2 u_mouse; uniform float u_time; float circle(in vec2 standard, in float radius) { vec2 dist = standard - vec2(0.5); return 1. - smoothstep(radius - (radius * 0.01), radius + (radius * 0.01), dot(dist, dist) * 4.0); } void main(){ vec2 standard = gl_FragCoord.xy / u_resolution ; vec2 translate = vec2(cos(u_time),sin(u_time)); standard += translate * 0.3; vec3 color = vec3(circle(standard, 0.1)); gl_FragColor = vec4( color, 1.0 ); } function GLCanvas(containerId, fragmentShaderText) { var scope = this; this.container = document.getElementById(containerId); this.camera = new THREE.Camera(); this.camera.position.z = 1; this.scene = new THREE.Scene(); this.uniforms = { u_time: { type: \"f\", value: 1.0 }, u_resolution: { type: \"v2\", value: new THREE.Vector2() } }; this.material = new THREE.ShaderMaterial( { uniforms: this.uniforms, vertexShader: document.getElementById( 'vertexShader' ).textContent, fragmentShader: fragmentShaderText }); var geometry = new THREE.PlaneBufferGeometry( 10, 10 ); var mesh = new THREE.Mesh( geometry, this.material ); this.scene.add( mesh ); this.renderer = new THREE.WebGLRenderer(); this.renderer.setPixelRatio( window.devicePixelRatio ); this.container.appendChild( this.renderer.domElement ); this.onWindowResize = function ( event ) { scope.renderer.setSize( scope.container.offsetWidth, scope.container.offsetHeight ); scope.uniforms.u_resolution.value.x = scope.renderer.domElement.width; scope.uniforms.u_resolution.value.y = scope.renderer.domElement.height; } this.animate = function() { requestAnimationFrame( scope.animate ); scope.render(); } this.render = function() { scope.uniforms.u_time.value += 0.05; scope.renderer.render( scope.scene, scope.camera ); } this.onWindowResize(); window.addEventListener( 'resize', this.onWindowResize, false ); this.animate(); } function ShaderEditor (viewId, containerId) { var scope = this; this.editor = ace.edit(viewId); this.editor.resize(true); this.editorDom = document.getElementById(viewId); this.editorDom.style.height = this.editor.getSession().getScreenLength() * (this.editor.renderer.lineHeight + 2) + 'px'; this.canvas = new GLCanvas(containerId, this.editor.getValue()); this.editor.getSession().setUseWrapMode(true); this.editor.setAutoScrollEditorIntoView(true) ; this.editor.getSession().on('change', function (event) { scope.canvas.material.fragmentShader = scope.editor.getValue(); scope.canvas.material.needsUpdate = true; var newHeight = scope.editor.getSession().getScreenLength() * scope.editor.renderer.lineHeight; scope.editorDom.style.height = newHeight + 'px'; scope.editor.resize(); }); this.changeText = function (text) { scope.editor.setValue(text); scope.editor.clearSelection(); } } .selectors { display: flex; flex-wrap: wrap; flex-direction: row; margin-bottom: 10px; } .selectors>.title { line-height:30px; } .selectors>.selector { display: flex; flex-direction: row; align-items: center; margin: 0 10px; } 方程: 直线 三角函数 圆形 #ifdef GL_ES precision mediump float; #endif uniform vec2 u_resolution; uniform float u_time; // Plot a line on Y using a value between 0.0 - 1.0 float plot(vec2 standard, float pct) { return smoothstep(pct - 0.005, pct, standard.y) - smoothstep(pct, pct + 0.005, standard.y); } void main() { vec2 standard = gl_FragCoord.xy/u_resolution; float y = standard.x; float pct = plot(standard, y); vec3 color = (vec3(1.0) - pct) + pct * vec3(0.0, 0.0, 0.0); gl_FragColor = vec4(color, 1.0); } $(document).ready(function () { var shaderEditor = new ShaderEditor('shader-editor', 'opengl-container'); $('.selector input[name=equation]').change(function () { if (this.value === '1') { shaderEditor.changeText(document.getElementById('LineShader').textContent); } else if (this.value === '2') { shaderEditor.changeText(document.getElementById('TriangleFunctionShader').textContent); } else if (this.value === '3') { shaderEditor.changeText(document.getElementById('CircularShader').textContent); } }); })","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://www.zcating.tk/categories/JavaScript/"},{"name":"OpenGL","slug":"JavaScript/OpenGL","permalink":"http://www.zcating.tk/categories/JavaScript/OpenGL/"}],"tags":[]},{"title":"flex布局测试","slug":"flex布局测试","date":"2019-03-09T11:00:00.000Z","updated":"2019-03-17T15:34:49.692Z","comments":true,"path":"2019/03/09/cjzjryk03000v2pl3uw821bw3/","link":"","permalink":"http://www.zcating.tk/2019/03/09/cjzjryk03000v2pl3uw821bw3/","excerpt":"一个简单的flex布局测试。","text":"一个简单的flex布局测试。 var isMobile = null; var isPC = null; var isWechat = null; $(document).ready(function () { isMobile = !!navigator.userAgent.match(/AppleWebKit.*Mobile.*/); isWechat = !!navigator.userAgent.match(/MicroMessenger/); if (isMobile || isWechat) { $('.flex-test').css('width', '300px'); } }); .auto-widget { width: 100px; height: auto; color: #fff; } .small-widget { width:50px; height:50px; color:#fff; flex-shrink: 0; } .mid-widget { width:100px; height:100px; color:#fff; flex-shrink: 0; } .big-widget { line-height: 200px; width:200px; height:200px; color:#fff; } .sun { background-size: cover; background-image:url(./Sun.jpg); } .earth { background-size: cover; background-image:url(./Earth.jpg); } .mars { background-size: cover; background-image:url(./Mars.jpg); } .moon { background-size: cover; background-image:url(./Moon.jpg); } .neptune { background-size: cover; background-image:url(./Neptune.jpg); } .saturn { background-size: cover; background-image:url(./Saturn.jpg); } .uranus { background-size: cover; background-image:url(./Uranus.jpg); } .selectors { display: flex; flex-wrap: wrap; flex-direction: row; margin-bottom: 10px; } .selectors>.title { line-height:30px; } .selectors>.selector { display: flex; flex-direction: row; align-items: center; margin: 0 10px; } .flex-test { width: 500px; height:400px; display: flex; flex-direction: row; overflow: auto; border: 1px solid #000000; } .flex-test img { transition: .2s; } .flex-test div { transition: .2s; } .slider { -webkit-appearance: none; appearance: none; width: 300px; height: 20px; background: #d3d3d3; outline: none; opacity: 0.7; -webkit-transition: .2s; transition: opacity .2s; } .slider:hover { opacity: 1; } .slider::-webkit-slider-thumb { -webkit-appearance: none; appearance: none; width: 20px; height: 20px; background: blue; cursor: pointer; } .slider::-moz-range-thumb { width: 20px; height: 20px; background: blue; cursor: pointer; } 容器属性flex-direction $(document).ready(function () { $('input[type=radio][name=flex-direction-selector]').change(function() { $('.body1>.flex-test').first().css('flex-direction', this.value); }); }); flex-direction: row column row-reverse column-reverse flex-wrap $(document).ready(function () { $('input[type=radio][name=flex-wrap-selector]').change(function() { $('.body2>.flex-test').first().css('flex-wrap', this.value); }); }); flex-wrap: nowrap wrap wrap-reverse justify-content $(document).ready(function () { $('input[type=radio][name=flex-justify-content-selector]').change(function() { $('.body3>.flex-test').first().css('justify-content', this.value); }); }); justify-content: flex-start flex-end center space-between space-around align-items $(document).ready(function () { $('.body4 input[type=radio][name=flex-align-items-selector]').change(function() { $('.body4>.flex-test').first().css('align-items', this.value); }); }); align-items: stretch flex-start flex-end center baseline Sun Earth Mars align-content $(document).ready(function () { $('input[type=radio][name=flex-wrap-align-content-selector]').change(function() { $('.body5>.flex-test').first().css('flex-wrap', this.value); }); $('input[type=radio][name=flex-align-content-selector]').change(function() { $('.body5>.flex-test').first().css('align-content', this.value); }); }); flex-wrap: nowrap wrap wrap-reverse align-content: stretch flex-start flex-end center space-between space-around 项目属性order $(document).ready(function () { $('input[type=radio][name=flex-order-selector]').prop({disabled: true}); $('.body6>.flex-test>div').click(function() { $('input[type=radio][name=flex-order-selector]').prop({disabled: false}); $('.body6>.flex-test>div.active').removeClass('active'); $(this).addClass('active'); var value = $(this).css('order'); $('input[type=radio][name=flex-order-selector][value=' + (value || 0) + ']').prop('checked', true); }); $('input[type=radio][name=flex-order-selector]').change(function() { var active = $('.body6>.flex-test>div.active'); active.css('order', this.value); active.text(this.value); }); }); order: 0 1 2 3 4 5 6 7 8 0 0 0 0 0 0 0 .body6>.flex-test { flex-wrap: wrap; } .body6>.flex-test>div.active { margin: 0 10px; border: 2px solid red; } flex-grow $(document).ready(function () { $('input[type=radio][name=flex-grow-selector]').prop({disabled: true}); $('.body7>.flex-test>div').click(function() { $('input[type=radio][name=flex-grow-selector]').prop({disabled: false}); $('.body7>.flex-test>div.active').removeClass('active'); $(this).addClass('active'); var value = $(this).css('flex-grow'); $('input[type=radio][name=flex-grow-selector][value=' + (value || 0) + ']').prop('checked', true); }); $('input[type=radio][name=flex-grow-selector]').change(function() { var active = $('.body7>.flex-test>div.active'); active.css('flex-grow', this.value); active.text(this.value); }); }); grow: 0 1 2 3 4 5 6 7 8 0 0 0 .body7>.flex-test { flex-wrap: wrap; } .body7>.flex-test>div.active { border: 2px solid red; } flex-shrink $(document).ready(function () { $('input[type=radio][name=flex-grow-selector]').prop({disabled: true}); $('.body8>.flex-test>div').click(function() { $('input[type=radio][name=flex-shrink-selector]').prop({disabled: false}); $('.body8>.flex-test>div.active').removeClass('active'); $(this).addClass('active'); var value = $(this).css('flex-shrink'); $('input[type=radio][name=flex-shrink-selector][value=' + (value || 0) + ']').prop('checked', true); }); $('input[type=radio][name=flex-shrink-selector]').change(function() { var active = $('.body8>.flex-test>div.active'); active.css('flex-shrink', this.value); active.text(this.value); }); }); shrink: 0 1 2 3 4 5 6 7 8 1 1 1 1 1 1 1 .body8>.flex-test>div { flex-shrink: 1; } .body8>.flex-test>div.active { border: 2px solid red; } flex-basis $(document).ready(function () { $('input[type=range]').prop({disabled: true}); $('.body9>.flex-test>div').click(function() { $('input[type=range]').prop({disabled: false}); $('.body9>.flex-test>div').removeClass('active'); $(this).addClass('active'); var value = $(this).css('flex-basis'); value = 'auto' ? '50px' : value; $(this).css('flex-basis', value); $('input[type=range]').prop('value', parseInt(value.split('px')[0])); $('#slider-value').text(value); }); $('input[type=range]').on('input', function() { var value = this.value + 'px'; $('#slider-value').text(value); $('.body9>.flex-test>div.active').css('flex-basis', value); }); $('#reset-slider-button').click(function() { $('input[type=range]').prop({disabled: true, value: 50}); $('#slider-value').text('50px'); $('.body9>.flex-test>div').removeClass('active'); $('.body9>.flex-test>div').css('flex-basis', 'auto'); }); }); Reset flex-basis: 50px 1 1 1 1 1 1 1 .body9>.flex-test>div { flex-shrink: 1; } .body9>.flex-test>div.active { border: 2px solid red; } align-selfalign-self的属性有这些： auto（默认） flex-start flex-end center baseline stretch其中auto，跟align-items一样。 $(document).ready(function () { $('input[type=radio][name=flex-align-self-selector]').prop({disabled: true}); $('.body10>.flex-test>div').click(function() { $('input[type=radio][name=flex-align-self-selector]').prop({disabled: false}); $('.body10>.flex-test>div').removeClass('active'); $(this).addClass('active'); var value = $(this).css('align-self'); $('input[type=radio][name=flex-align-self-selector][value=' + value + ']').prop('checked', true); }); $('.body10 input[type=radio][name=flex-align-self-selector]').change(function() { $('.body10>.flex-test>div.active').css('align-self', this.value); }); $('.body10 input[type=radio][name=flex-align-items-selector2]').change(function() { $('.body10>.flex-test').first().css('align-items', this.value); }); }); align-items: stretch flex-start flex-end center baseline align-self: auto flex-start flex-end center baseline stretch Sun Earth Moon Mars Neptune Saturn Uranus .body10>.flex-test>div { flex-shrink: 1; } .body10>.flex-test>div.active { border: 2px solid red; }","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://www.zcating.tk/categories/JavaScript/"}],"tags":[]},{"title":"iOS-用OpenGL渲染相机输出的图像","slug":"iOS-用OpenGL渲染相机输出的图像","date":"2019-03-05T11:00:00.000Z","updated":"2019-03-17T15:34:49.802Z","comments":true,"path":"2019/03/05/cjzjryk01000s2pl3sw302c4o/","link":"","permalink":"http://www.zcating.tk/2019/03/05/cjzjryk01000s2pl3sw302c4o/","excerpt":"相机类相关的类： AVCaptureSession AVCaptureDeviceInput AVCatureDevice AVCaptureDeviceOutput AVCaptureVideoDataOutput","text":"相机类相关的类： AVCaptureSession AVCaptureDeviceInput AVCatureDevice AVCaptureDeviceOutput AVCaptureVideoDataOutput 定义以下properties： 1234@property (nonatomic, strong) AVCaptureSession *session;@property (nonatomic, strong) AVCaptureDeviceInput *frontCameraInput;@property (nonatomic, strong) AVCaptureDeviceInput *backCameraInput;@property (nonatomic, strong) AVCaptureVideoDataOutput *videoOutput; 我们通过session来操作摄像头、摄像头参数以及摄像头数据，使用懒加载初始化session： 123456-(AVCaptureSession *)session &#123; if (_session == nil) &#123; _session = [AVCaptureSession new]; &#125; return _session;&#125; 同样是懒加载初始化设备输入： 123456789101112131415161718192021222324252627282930313233-(AVCaptureDeviceInput *)backCameraInput &#123; if (_backCameraInput == nil) &#123; NSArray *devices = [AVCaptureDevice devicesWithMediaType:AVMediaTypeVideo]; NSError *error; for (AVCaptureDevice *device in devices) &#123; if (device.position == AVCaptureDevicePositionFront) &#123; continue; &#125; _backCameraInput = [AVCaptureDeviceInput deviceInputWithDevice:device error:&amp;error]; if (error) &#123; NSLog(@&quot;[FaceCamera] error: %@&quot;, error.description); &#125; &#125; &#125; return _backCameraInput;&#125;-(AVCaptureDeviceInput *)frontCameraInput &#123; if (_frontCameraInput == nil) &#123; NSArray *devices = [AVCaptureDevice devicesWithMediaType:AVMediaTypeVideo]; NSError *error; for (AVCaptureDevice *device in devices) &#123; if (device.position == AVCaptureDevicePositionBack) &#123; continue; &#125; _frontCameraInput = [AVCaptureDeviceInput deviceInputWithDevice:device error:&amp;error]; if (error) &#123; NSLog(@&quot;[FaceCamera] error: %@&quot;, error.description); &#125; &#125; &#125; return _frontCameraInput;&#125; 因为手机端，只有两个摄像头设备（前置和后置），还可以这样： 1234567891011121314151617181920212223-(AVCaptureDeviceInput *)backCameraInput &#123; if (_backCameraInput == nil) &#123; NSArray *devices = [AVCaptureDevice devicesWithMediaType:AVMediaTypeVideo]; NSError *error; _frontCameraInput = [AVCaptureDeviceInput deviceInputWithDevice:devices[0] error:&amp;error]; if (error) &#123; NSLog(@&quot;[FaceCamera] error: %@&quot;, error.description); &#125; &#125; return _backCameraInput;&#125;-(AVCaptureDeviceInput *)frontCameraInput &#123; if (_frontCameraInput == nil) &#123; NSArray *devices = [AVCaptureDevice devicesWithMediaType:AVMediaTypeVideo]; NSError *error; _frontCameraInput = [AVCaptureDeviceInput deviceInputWithDevice:devices[0] error:&amp;error]; if (error) &#123; NSLog(@&quot;[FaceCamera] error: %@&quot;, error.description); &#125; &#125; return _frontCameraInput;&#125; 然后懒加载视频输出 1234567891011121314-(AVCaptureVideoDataOutput *)videoOutput &#123; if (_videoOutput == nil) &#123; _videoOutput = [AVCaptureVideoDataOutput new]; // 这里的setting可以去看具体的文档 _videoOutput.videoSettings = @&#123; (NSString*)kCVPixelBufferPixelFormatTypeKey: @(kCMPixelFormat_32BGRA) &#125;; // 这里表示，当你处理的这一帧超过一帧的时间，这一帧会做丢失处理 _videoOutput.alwaysDiscardsLateVideoFrames = YES; // 设置输出的委托，并且指定操作队列，这里_videoQueue是自定义的操作队列 [_videoOutput setSampleBufferDelegate:self queue:_videoQueue]; &#125; return _videoOutput;&#125; 将输入输出添加进session： 123456789101112131415161718-(void)updateSession &#123; // 在这里添加主要的输入和输出。 // 摄像头的位置 if (self.devicePosition == AVCaptureDevicePositionFront) &#123; if ([self.session canAddInput:self.frontCameraInput]) &#123; [self.session addInput:self.frontCameraInput]; &#125; &#125; else &#123; if ([self.session canAddInput:self.backCameraInput]) &#123; [self.session addInput:self.backCameraInput]; &#125; &#125; // 摄像头的输出 if ([self.session canAddOutput:self.videoOutput]) &#123; [self.session addOutput:self.videoOutput]; &#125;&#125; 相机启动和关闭相关的函数， 123456789101112131415161718192021222324252627282930313233343536373839404142434445- (void)start &#123; // 如果已经启动，直接返回 if (_running == YES) &#123; return; &#125; // 如果 session 未加载，加载 session if (_sessionLoaded == NO) &#123; [self updateSession]; _sessionLoaded = YES; &#125; // 启动 session [self.session startRunning]; _running = YES;&#125;- (void)stop &#123; // 如果已经关闭，直接返回 if (_running == NO) &#123; return; &#125; // 将所有的输入移除 for (AVCaptureInput *input in self.session.inputs) &#123; [self.session removeInput:input]; &#125; // 将所有的输出移除 for (AVCaptureOutput *output in self.session.outputs) &#123; [self.session removeOutput:output]; &#125; // 停止 session [self.session stopRunning]; _running = NO; // 标记 session 为未加载状态 _sessionLoaded = NO;&#125;-(void)pause &#123; // 普通暂停，只需要直接停止就好 [self.session stopRunning]; _running = NO;&#125; 上面的start和stop非常重要，当你切换摄像头、分辨率或添加其他新的输入输出（比如`AVCaptureMetadataOutput ）的时候，需要这样做： 123456789101112131415161718-(void)switchCameras &#123; // 先保存当前的运行状态 BOOL wasRunning = _running; // 判断当的运行状态 if (wasRunning) &#123; [self stop]; &#125; // 这里是切换摄像头的主要逻辑 // 这里可以换成切换其他的逻辑 if (self.devicePosition == AVCaptureDevicePositionFront) &#123; self.devicePosition = AVCaptureDevicePositionBack; &#125; else &#123; self.devicePosition = AVCaptureDevicePositionFront; &#125; if (wasRunning) &#123; [self start]; &#125;&#125; 编写视频输出的delegate： 1234- (void)captureOutput:(AVCaptureOutput *)output didOutputSampleBuffer:(CMSampleBufferRef)sampleBuffer fromConnection:(AVCaptureConnection *)connection &#123; // 我们将在这里转发这个delegate [self.delegate processFrame:sampleBuffer];&#125; 相机视图类首先，我们要初始化视图： 123456789101112131415161718192021- (id)initWithFrame:(CGRect)frame &#123; self = [super initWithFrame:frame]; if (self) &#123; self.contentScaleFactor = [[UIScreen mainScreen] scale]; self.context = [[EAGLContext alloc] initWithAPI:kEAGLRenderingAPIOpenGLES3]; [EAGLContext setCurrentContext:self.context]; [self setupLayer]; // 可以先忽略 [self setupBuffers]; &#125; return self;&#125;- (void)setupLayer &#123; CAEAGLLayer *eaglLayer = (CAEAGLLayer *)self.layer; eaglLayer.opaque = TRUE; eaglLayer.drawableProperties = @&#123; kEAGLDrawablePropertyRetainedBacking: @(YES), kEAGLDrawablePropertyColorFormat: kEAGLColorFormatRGBA8 &#125;;&#125; 为了能够使用OpenGL来绘制摄像机图像，我们首先需要设定好OpenGL缓冲区： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849enum CameraAttributes &#123; CameraAttributesPosition = 0, CameraAttributesTextureCoordinate = 1,&#125;;- (void)setupBuffers &#123; // 深度测试的目的是为了绘制当前像素组中里屏幕最近的像素。 // 需要绘制透明图层的时候，关闭深度测试，不然透明图层不会透过去。 glDisable(GL_DEPTH_TEST); // 将原色和目标色混合，目的还是用来绘制透明图层。 glEnable(GL_BLEND); // 在图元从远到近的排列下，透明图层的使用以下方法来实现是最佳选择。请注意，此透明度计算不要求alpha位存在于帧缓冲区。 // https://www.khronos.org/registry/OpenGL-Refpages/es2.0/xhtml/glBlendFunc.xml glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA); // 顶点着色的第一个属性。 glEnableVertexAttribArray(CameraAttributesPosition); // 将该属性在CPU和GPU建立上逻辑关系。 glVertexAttribPointer(CameraAttributesPosition, 2, GL_FLOAT, GL_FALSE, 2 * sizeof(GLfloat), 0); // 顶点着色器的第二个属性。 glEnableVertexAttribArray(CameraAttributesTextureCoordinate); // 将该属性在CPU和GPU建立上逻辑关系。 glVertexAttribPointer(CameraAttributesTextureCoordinate, 2, GL_FLOAT, GL_FALSE, 2 * sizeof(GLfloat), 0); // 建立帧缓冲区，并将其绑定到_frameBufferID上，通过_frameBufferID我们可以拿到在OpenGL中的帧缓冲的数据。 glGenFramebuffers(1, &amp;_frameBufferID); glBindFramebuffer(GL_FRAMEBUFFER, _frameBufferID); // 建立渲染缓冲区。 glGenRenderbuffers(1, &amp;_colorBufferID); glBindRenderbuffer(GL_RENDERBUFFER, _colorBufferID); // 将渲染缓冲区 以 GL_COLOR_ATTACHMENT0 的形式绑定到帧缓冲区上。 glFramebufferRenderbuffer(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, GL_RENDERBUFFER, _colorBufferID); // 获取帧缓冲区的状态。 if (glCheckFramebufferStatus(GL_FRAMEBUFFER) != GL_FRAMEBUFFER_COMPLETE) &#123; NSLog(@&quot;Failed to make complete framebuffer object %x&quot;, glCheckFramebufferStatus(GL_FRAMEBUFFER)); &#125; // 将EAGLDrawable的存储绑定到渲染缓冲对象上。 [self.context renderbufferStorage:GL_RENDERBUFFER fromDrawable:(CAEAGLLayer *)self.layer]; // 获取渲染缓冲区的宽高 glGetRenderbufferParameteriv(GL_RENDERBUFFER, GL_RENDERBUFFER_WIDTH, &amp;_renderBufferWidth); glGetRenderbufferParameteriv(GL_RENDERBUFFER, GL_RENDERBUFFER_HEIGHT, &amp;_renderBufferHeight);&#125; 到这里，我们已经设置好了我们的可绘制的图层self.layer，然后我们要将摄像头数据输入到渲染缓冲上，渲染缓冲的数据经过处理后，在上下文会将数据在self.layer中展示，但是在这之前，我们先得编写着色器，通过着色器，摄像头捕捉到的图像数据会在渲染缓冲区中被处理。下面给出一个简单的着色器外覆类，主要的功能是加载顶点着色器和片段着色器，它包含了两个参数，分别是顶点着色器和片段着色器的地址： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100@interface Shader : NSObject@property (nonatomic) GLuint program;@end@implementation Shader- (instancetype)initWithVertexShaderURL:(NSURL *)vertexShaderURL fragmentShaderURL:(NSURL *)fragmentShaderURL &#123; self = [super init]; if (self) &#123; // 编译代码着色器。 GLuint vertexShaderID = [self complieWithType:FCShaderTypeVertex URL:vertexShaderURL]; GLuint fragmentShaderID = [self complieWithType:FCShaderTypeFragment URL:fragmentShaderURL]; // 创建着色器程序，并链接上述的着色器 self.program = glCreateProgram(); glAttachShader(self.program, vertexShaderID); glAttachShader(self.program, fragmentShaderID); glLinkProgram(self.program); GLint status = 0; glGetProgramiv(self.program, GL_LINK_STATUS, &amp;status); if (status == 0) &#123; GLint logLength; glGetProgramiv(self.program, GL_INFO_LOG_LENGTH, &amp;logLength); if (logLength &gt; 0) &#123; GLchar *log = (GLchar *)malloc(logLength); glGetProgramInfoLog(self.program, logLength, &amp;logLength, log); NSLog(@&quot;Program link log: %s&quot;, log); free(log); &#125; &#125; // 链接完毕，program中已经有着色器，将着色器销毁。 if (vertexShaderID) &#123; glDetachShader(self.program, vertexShaderID); glDeleteShader(vertexShaderID); &#125; if (fragmentShaderID) &#123; glDetachShader(self.program, fragmentShaderID); glDeleteShader(fragmentShaderID); &#125; &#125; return self;&#125;#pragma mark - PUBLIC-(void)use &#123; // 运行着色器程序 glUseProgram(self.program);&#125;#pragma mark - PRIVATE// 外覆函数，处理 URL，将URL指向的文件中的代码读取出来。- (GLuint)complieWithType:(ShaderType)type URL:(NSURL *)url &#123; NSError *error; NSString *code = [[NSString alloc] initWithContentsOfURL:url encoding:NSUTF8StringEncoding error:&amp;error]; if (code == nil) &#123; NSLog(@&quot;Failed to load vertex shader: %@&quot;, [error localizedDescription]); return 0; &#125; return [self complieWithType:type code:code];&#125;// 实际操作的函数，直接处理代码- (GLuint)complieWithType:(ShaderType)type code:(NSString *)code &#123; GLenum glType = type == ShaderTypeVertex ? GL_VERTEX_SHADER : GL_FRAGMENT_SHADER; const GLchar* rawCode = [code UTF8String]; // 创建着色器并编译着色器代码。 GLuint shaderID = glCreateShader(glType); glShaderSource(shaderID, 1, &amp;rawCode, NULL); glCompileShader(shaderID); // 一些错误处理。 GLint status = 0; glGetShaderiv(shaderID, GL_COMPILE_STATUS, &amp;status); if (status == 0) &#123; [self showCompileErrorWith:shaderID]; glDeleteShader(shaderID); return 0; &#125; return shaderID;&#125;- (void)showCompileErrorWith:(GLint)shaderID &#123; GLint infoLength; glGetShaderiv(shaderID, GL_INFO_LOG_LENGTH, &amp;infoLength); if (infoLength == 0) &#123; return; &#125; GLchar *info = (GLchar *)malloc(infoLength); glGetShaderInfoLog(shaderID, infoLength, &amp;infoLength, info); NSLog(@&quot;Shader compile log:\\n%s&quot;, info); free(info);&#125;@end 这样，完整的视图构造函数如下： 123456789101112131415- (id)initWithFrame:(CGRect)frame &#123; self = [super initWithFrame:frame]; if (self) &#123; NSURL *vertShaderURL = [[NSBundle mainBundle] URLForResource:@&quot;CameraRGBA&quot; withExtension:@&quot;vsh&quot;]; NSURL *fragShaderURL = [[NSBundle mainBundle] URLForResource:@&quot;CameraRGBA&quot; withExtension:@&quot;fsh&quot;]; _shader = [[Shader alloc] initWithVertexShaderURL:vertShaderURL fragmentShaderURL:fragShaderURL]; self.contentScaleFactor = [[UIScreen mainScreen] scale]; self.context = [[EAGLContext alloc] initWithAPI:kEAGLRenderingAPIOpenGLES3]; [EAGLContext setCurrentContext:self.context]; [self setupLayer]; // 可以先忽略 [self setupBuffers]; &#125; return self;&#125; 这里顶点着色器，片段着色器以及相机的回调将结合在一起编写。为了显示摄像头数据，我们的思路是将相机数据转换成纹理，然后将纹理绑定到指定的点上，先展示顶点数据： 123456789101112131415// 顶点数据GLfloat _imageVertices[8] = &#123; -1, -1, 1, -1, -1, 1, 1, 1&#125;;// Texture 在顶点数据中的位置GLfloat _textureCoordinates[] = &#123; 0, 0, 1, 0, 0, 1, 1, 1&#125;; 画个图，就能明白了： 其中，viewpoint是我们整个渲染的大小，通过这样来设置：glViewport(0, 0, _renderBufferWidth, _renderBufferHeight)。 下面，来处理相机数据，使得数据能够在屏幕上展示。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798- (void)processframe:(CMSampleBufferRef)frame &#123; CVPixelBufferRef pixelBuffer = CMSampleBufferGetImageBuffer(frame); int frameWidth = (int)CVPixelBufferGetWidth(pixelBuffer); int frameHeight = (int)CVPixelBufferGetHeight(pixelBuffer); // 设置全局的EAGLContext为self.context，不设置容易导致渲染失败 if(![[EAGLContext currentContext] isEqual:self.context]) &#123; [EAGLContext setCurrentContext:self.context]; &#125; // 刷新缓存 CVOpenGLESTextureCacheFlush(self.cameraTextureCache, 0); // CVOpenGLESTextureRef cameraTexture; CVReturn err = CVOpenGLESTextureCacheCreateTextureFromImage(kCFAllocatorDefault, self.cameraTextureCache, pixelBuffer, NULL, GL_TEXTURE_2D, GL_RGBA, frameWidth, frameHeight, GL_BGRA, GL_UNSIGNED_BYTE, 0, &amp;cameraTexture); if (err) &#123; NSLog(@&quot;Create Texture Failed: %d&quot;, err); &#125; // 设定渲染屏幕的大小，一个正方形，以左上角为原点，右为x轴正向，下为y轴正向 glViewport(0, 0, _renderBufferWidth, _renderBufferHeight); // 清空当前的缓存值，以便可以渲染下一帧 glClear(GL_COLOR_BUFFER_BIT); // 设置纹理单元 glActiveTexture(GL_TEXTURE0); // 绑定纹理目标(cameraTexture)到指定的纹理单元，该函数会自动把纹理赋给片段着色器上的采样器 glBindTexture(CVOpenGLESTextureGetTarget(cameraTexture), CVOpenGLESTextureGetName(cameraTexture)); // 设定纹理的属性 // 更细节的属性可以查看文档，linear的作用主要是使得渲染出来的图像更为平滑 glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR); glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR); // 设定了GL_CLAMP_TO_EDGE 的纹理会被限制在0到1中，超出的部分会重复纹理坐标边缘的颜色值，产生边缘被拉伸的效果 glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE); glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE); // 绑定帧缓冲区 glBindFramebuffer(GL_FRAMEBUFFER, _frameBufferID); // 启动着色器程序 [_shader use]; // 将图像顶点输入到顶点着色器中 glVertexAttribPointer(CameraAttributesPosition, 2, GL_FLOAT, 0, 0, _imageVertices); glEnableVertexAttribArray(CameraAttributesPosition); // 将纹理的相对于顶点组的坐标输入到顶点着色器中 glVertexAttribPointer(CameraAttributesTextureCoordinate, 2, GL_FLOAT, 0, 0, _textureCoordinates); glEnableVertexAttribArray(CameraAttributesTextureCoordinate); // strip，意味着当存在了三个顶点的时候，每增加一个顶点，新增一个三角形。设三角形第n个结点为V(n)，那么，这个新增的三角形的连接方式为：( V(n), V(n-1), V(n-2) ) (n &gt;= 3) glDrawArrays(GL_TRIANGLE_STRIP, 0, 4); glBindRenderbuffer(GL_RENDERBUFFER, _colorBufferID); // 展示当前的渲染缓冲区 [self.context presentRenderbuffer:GL_RENDERBUFFER]; // 将纹理渲染后，我们要将它销毁，避免内存泄露。 CFRelease(cameraTexture);&#125;// 顶点着色器#version 300 es// 这里是 CameraAttributesPosition，通过glVertexAttribPointer，将值传入到着色器中layout(location = 0) in vec4 position;// 这里是 CameraAttributesTextureCoordinate layout(location = 1) in vec2 textureCoordinate;// 输出到片段着色器out vec2 outTextureCoordinate;void main()&#123; // 标定渲染点元在世界坐标中的位置 gl_Position = position; // 将纹理在点元中的相对坐标传入，由片段着色器处理 outTextureCoordinate = textureCoordinate;&#125;// 片段着色器// 从顶点着色器输入in highp vec2 outTextureCoordinate;// 输出out highp vec4 fragColor;// 外部的纹理的数据采样uniform sampler2D samplerRGBA;void main()&#123; // 通过内建函数采样纹理的颜色，第一个参数是纹理采样器，第二个是纹理坐标，texture会根据纹理参数的设定来对纹理进行采样，这样片段着色器的输出就是纹理的(插值)纹理坐标上的(过滤后的)颜色。——来自 learnOpenGL 中对纹理的解释 fragColor = texture(samplerRGBA, outTextureCoordinate);&#125; 为这个view添加摄像头启动和关闭方法： 123456-(void)start &#123; [self.camera start];&#125;-(void)stop &#123; [self.camera stop];&#125; 最后，将它实例化，并添加到ViewController中 12345-(void)viewDidLoad &#123; _cameraView = [[CameraView alloc] initWithFrame:[UISCreen mainScreen].bounds]; [self.view addSubview:_cameraView]; [_cameraView start];&#125;","categories":[{"name":"Objective-C","slug":"Objective-C","permalink":"http://www.zcating.tk/categories/Objective-C/"}],"tags":[]},{"title":"Vue组件间通信总结","slug":"Vue组件间通信总结","date":"2019-02-27T13:00:00.000Z","updated":"2019-08-11T14:46:34.230Z","comments":true,"path":"2019/02/27/cjzjryjzz000o2pl31fqw1eyt/","link":"","permalink":"http://www.zcating.tk/2019/02/27/cjzjryjzz000o2pl31fqw1eyt/","excerpt":"","text":"Vue组件间通信其实其实就是不同的ViewModel之间如何通信的。 Props &amp; emit这个Vue中最基本的通信方式：12345678910111213141516171819202122232425262728293031323334353637383940414243// childconst vm1 = new Vue (&#123; name: child, template: `&lt;input v-model=\"value\" @onChange=\"submit\"/&gt;`, props: &#123; current: '' &#125;, data &#123; value: '' &#125;, watch() &#123; &#125;, method: &#123; &#125;&#125;);// parentconst vm2 = new Vue (&#123; template: ` &lt;div&gt; &lt;child :current=\"currentForm\" @finish=\"finish\"/&gt; &#123;&#123;isSuccess&#125;&#125; &lt;/div&gt;`, data: &#123; forms: [ &#123;id: 1, name: 'Tom'&#125; ], currentForm: undefined, isSuccess: false &#125;, mounted () &#123; this.currentForm = this.forms[0]; &#125;, method: &#123; finish(value) &#123; this.currentForm.id = value.id; this.currentForm.name = value.name; &#125; &#125;&#125;); Vue其实也是赞成这种方式进行通信，这种方法可以更加规范的构建通用组件。 使用 $parent 和 $refs1234567891011121314151617181920212223242526272829303132333435363738394041424344454647// childconst vm1 = new Vue (&#123; name: child, template: `&lt;button @click=\"submit\"/&gt;`, data &#123; form: &#123;id: 0, name: ''&#125;, &#125;, method: &#123; setCurrent(value) &#123; this.form = JSON.parse(JSON.stringify(value)); &#125;, submit () &#123; axios.put('/form',this.form).then((result)=&gt;&#123; if (this.$parent &amp;&amp; this.$parent.finish) &#123; this.$parent.finish(this.form); &#125; &#125;); &#125; &#125;&#125;);// parentconst vm2 = new Vue (&#123; template: ` &lt;div&gt; &lt;child ref=\"childComponent\"/&gt; &#123;&#123;isSuccess&#125;&#125; &lt;/div&gt;`, data: &#123; forms: [ &#123;id: 1, name: 'Tom'&#125; ], isSuccess: false &#125;, mounted () &#123; this.$refs.childComponent.setCurrent(forms[0]); &#125;, method: &#123; finish(value) &#123; this.currentForm.id = value.id; this.currentForm.name = value.name; &#125; &#125;&#125;); 这种方法的优点是可以获取所有子组件中的方法和父组件中的方法，缺点是暴露太多的子父组件的细节，子父组件容易强耦合。 Vuex这种方式也是比较推荐的，当你的组件之间是同级关系，使用Props和emit并不会让你的项目清爽起来，因为，你只是把他们（同级组件）的父组件当作一个中间件而已，然而父组件还要处理父组件中的逻辑，所以整个父组件便会变得庞大，如果引入vuex，能够很好的解决这个问题。考虑这种情况，如果，每个同级组件只修改一个同级 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768// vuexconst store = new Vuex.Store(&#123; state: &#123; forms: [ &#123;id: 1, name: 'Tom'&#125; ], currentForm: &#123;&#125; &#125;, mutations: &#123; changeForm(state, value) &#123; state.currentForm.id = value.id; statecurrentForm.name = value.name; &#125; &#125;, actions: &#123; getForm(&#123;state&#125;) &#123; return state.currentForm &#125; &#125;&#125;)// childconst vm1 = new Vue (&#123; name: child, template: `&lt;button @click=\"submit\"/&gt;`, data &#123; form: &#123;id: 0, name: ''&#125;, &#125;, method: &#123; setCurrent(value) &#123; this.form = JSON.parse(JSON.stringify(value)); &#125;, submit () &#123; axios.put('/form',this.form).then((result)=&gt;&#123; if (this.$parent &amp;&amp; this.$parent.finish) &#123; this.$parent.finish(this.form); &#125; &#125;); &#125; &#125;&#125;);// parentconst vm2 = new Vue (&#123; template: ` &lt;div&gt; &lt;child ref=\"childComponent\"/&gt; &#123;&#123;isSuccess&#125;&#125; &lt;/div&gt;`, computed: &#123; mapState(&#123; forms : state =&gt; state.forms, current: state =&gt; state.current &#125;) &#125;, mounted () &#123; this.$refs.childComponent.setCurrent(forms[0]); &#125;, method: &#123; finish(value) &#123; this.currentForm.id = value.id; this.currentForm.name = value.name; &#125; &#125;&#125;);","categories":[],"tags":[]},{"title":"啥是鸭子类型(duck typing)","slug":"啥是鸭子类型(duck-typing)","date":"2019-02-21T11:00:00.000Z","updated":"2019-03-17T15:34:49.812Z","comments":true,"path":"2019/02/21/cjzjryk0700152pl3nop51hr7/","link":"","permalink":"http://www.zcating.tk/2019/02/21/cjzjryk0700152pl3nop51hr7/","excerpt":"什么是鸭子类型？《维基百科》上已经说的很明白了： 在程序设计中，鸭子类型（英语：duck typing）是动态类型的一种风格。在这种风格中，一个对象有效的语义，不是由继承自特定的类或实现特定的接口，而是由”当前方法和属性的集合”决定。 然后有意思的一段话就是： “当看到一只鸟走起来像鸭子、游泳起来像鸭子、叫起来也像鸭子，那么这只鸟就可以被称为鸭子。” 这段话就是鸭子类型的由来。","text":"什么是鸭子类型？《维基百科》上已经说的很明白了： 在程序设计中，鸭子类型（英语：duck typing）是动态类型的一种风格。在这种风格中，一个对象有效的语义，不是由继承自特定的类或实现特定的接口，而是由”当前方法和属性的集合”决定。 然后有意思的一段话就是： “当看到一只鸟走起来像鸭子、游泳起来像鸭子、叫起来也像鸭子，那么这只鸟就可以被称为鸭子。” 这段话就是鸭子类型的由来。 特点鸭子类型（风格）的特点是，关注对象能够做什么。看看以下代码其实就能明白个大概了： 1234567891011121314151617181920212223242526272829303132333435363738let cat = &#123; walk: () =&gt; &#123; console.log('walking...'); &#125;&#125;let duck = &#123; swim: () =&gt; &#123; console.log('swimming...'); &#125; call: () =&gt; &#123; console.log('GaGaGa...'); &#125;&#125;let dragon = &#123; swim: () =&gt; &#123; console.log('swimming...'); &#125; call: () =&gt; &#123; console.log('WaWaWa...'); &#125;&#125;function testDuck (bird) &#123; if (bird) &#123; console.log('It is not a duck.'); return; &#125; if (bird &amp;&amp; bird.swim &amp;&amp; bird.call) &#123; console.log('It is a duck.'); bird.swim(); bird.call(); &#125;&#125;testDuck(); // It is not a duck.testDuck(cat); //It is not a duck.testDuck(duck); // It is a duck. swimming... GaGaGa...testDuck(dragon); // It is a duck. swimming... WaWaWa...","categories":[{"name":"data structure","slug":"data-structure","permalink":"http://www.zcating.tk/categories/data-structure/"}],"tags":[]},{"title":"C++模板元编程——量纲分析","slug":"C++模板元编程——量纲分析","date":"2018-12-27T13:00:00.000Z","updated":"2019-03-17T15:34:49.560Z","comments":true,"path":"2018/12/27/cjzjryk0b001f2pl3jdz6ldxd/","link":"","permalink":"http://www.zcating.tk/2018/12/27/cjzjryk0b001f2pl3jdz6ldxd/","excerpt":"《C++模板元编程》一书上的第三章的第一节就是叫你如何进行量纲分析。说到量纲分析，首先要了解其概念，这里引用书中的内容：1理论上，物理计算的首要原则是：数值运算并非是独立的，大多数物理量都是有附带量纲的。…… 当我们将质量和加速度相乘时，我们除了将数量相乘之外还必须将量纲相乘，这可以帮助我们确信结果是有意义的。这种（对量纲的）簿记的正式名称为量纲分析（dimension analysis）。","text":"《C++模板元编程》一书上的第三章的第一节就是叫你如何进行量纲分析。说到量纲分析，首先要了解其概念，这里引用书中的内容：1理论上，物理计算的首要原则是：数值运算并非是独立的，大多数物理量都是有附带量纲的。…… 当我们将质量和加速度相乘时，我们除了将数量相乘之外还必须将量纲相乘，这可以帮助我们确信结果是有意义的。这种（对量纲的）簿记的正式名称为量纲分析（dimension analysis）。 那么简而言之，当我们在做运算的时候，数值需要运算，该数值的单位也要进行运算。那么书上很好的展示了用Boost库结合而做的量纲分析。然而，这个库引入太麻烦了，而且C++11的可变参数模板已能很好的对其进行应用。下面我将用C++11来编写量纲分析。 可变参数模板可变参数模板是C++11的新特性，有了该特性，整形序列外覆类可以变成一下定义： 12345678910111213141516171819template&lt;typename T, T ...arg&gt;class Vector &#123; using Type = Vector&lt;T, arg...&gt;::Type;&#125;// kilo gramusing Mass = Vector&lt;int, 1, 0, 0, 0, 0, 0, 0&gt;;// Meterusing Length = Vector&lt;int, 0, 1, 0, 0, 0, 0, 0&gt;;// Secondusing Time = Vector&lt;int, 0, 0, 1, 0, 0, 0, 0&gt;;// Ampereusing Charge = Vector&lt;int, 0, 0, 0, 1, 0, 0, 0&gt;;// Kelvinusing Temperature = Vector&lt;int, 0, 0, 0, 0, 1, 0, 0&gt;;// Luxusing Intensity = Vector&lt;int, 0, 0, 0, 0, 0, 1, 0&gt;;// Molusing AmountOfSubstance = Vector&lt;int, 0, 0, 0, 0, 0, 0, 1&gt;; 物理量的表示这里就直接引用《C++模板元编程》书中的对物理量的表示的内容： 123456789101112131415template&lt;typename T, typename Dimension&gt;struct Quantity&#123; explicit Quantity(T x) : mValue(x) &#123;&#125;; T value() const &#123; return mValue; &#125;; private: T mValue; &#125;;&#125;// 表示一个物理量可以这样Quantity&lt;double, Mass&gt; m(2.0f); 加减法加减法比较简单，相同量纲直接可以做加减法，不同量纲之间不可以做加减法： 1234567891011template&lt;typename T, typename Dimension&gt;Quantity&lt;T, Dimension&gt; operator + (const Quantity&lt;T, Dimension&gt;&amp; x, const Quantity&lt;T, Dimension&gt;&amp; y)&#123; return Quantity&lt;T, Dimension&gt;(x.value() + y.value());&#125;template&lt;typename T, typename Dimension&gt;Quantity&lt;T, Dimension&gt; operator - (const Quantity&lt;T, Dimension&gt;&amp; x, const Quantity&lt;T, Dimension&gt;&amp; y)&#123; return Quantity&lt;T, Dimension&gt;(x.value() + y.value());&#125; 乘除法不仅仅是对数值的乘除，也要对量纲进行乘除，量纲的乘除可以转化为表示量纲的序列的加减法。以速度为例，我们知道平均速度等于路程除以时间。$$v=s/t$$它的单位是：$$m/s（米每秒）$$用量纲序列表示： 12using Velocity = Vector&lt;int, 0, 1, -1, 0, 0, 0, 0&gt;;Quantity&lt;double, Velocity&gt; v; 也就是说，当我们用路程除以时间的时候，我们想要以下运算成立： 123Quantity&lt;double, Length&gt; s(10.0);Quantity&lt;double, Time&gt; t(2);Quantity&lt;double, Velocity&gt; v = s/t; 为了能对指定的量纲序列进行加减法，我们需要定义一个这样的元函数，它可以两个序列中的对应的位置做指定的二元元函数运算，并且返回的是一个满足要求（长度相同，内容为二元元函数求值的结果）的序列。 1234567891011121314template&lt;typename T1, typename T2, typename MetaFunction&gt;struct Transform &#123;&#125;;template&lt; typename T, T ...args1, T ...args2, template&lt;typename T, T ...args1&gt; class Vector1, template&lt;typename T, T ...args2&gt; class Vector2, typename MetaFunction&gt;struct Transform&lt;Vector1&lt;T, args1...&gt;, Vector2&lt;T, args2...&gt;, MetaFunction&gt;&#123; using Type = List&lt;T, MetaFunction::template Apply&lt;T, args1, args2&gt;::value...&gt;;&#125;; 我们看到元函数Transform的实现的模板比较复杂，在模板中拥有一个模板类，在这里解释一下： 1234567891011121314151617template&lt; // 指定的类型 typename T, // 第一个序列的变参模板 T ...args1, // 第二个序列的变参模板 T ...args2, // 指定的两个序列，我们的量纲序列满足该定义，所以是可行的。 template&lt;typename T, T ...args1&gt; class Vector1, template&lt;typename T, T ...args2&gt; class Vector2, typename MetaFunction&gt;// 实际Transform元函数转发struct Transform&lt;Vector1&lt;T, args1...&gt;, Vector2&lt;T, args2...&gt;, MetaFunction&gt;&#123; // 编译器只会匹配拥有 Apply 的元函数外覆类 using Type = Vector&lt;T, MetaFunction::template Apply&lt;T, args1, args2&gt;::value...&gt;;&#125;; 然后，我们需要实现两个满足我们要求的二元元函数： 12345678910111213141516171819202122232425262728293031// 对两个序列中的对应元素做加法template&lt;typename T, T value1, T value2&gt;struct PlusImplenment&#123; using Type = PlusImplenment&lt;T, value1, value2&gt;; const static T value = value1 + value2;&#125;;// 元函数外覆类struct Plus&#123; // 二元元函数转发 template&lt;typename T, T value1, T value2&gt; struct Apply : PlusImplenment&lt;T, value1, value2&gt;&#123;&#125;;&#125;;// 对两个序列中的对应元素做减法template&lt;typename T, T value1, T value2&gt;struct MinusImplenment&#123; using Type = MinusImplenment&lt;T, value1, value2&gt;; const static T value = value1 - value2;&#125;;// 元函数外覆类struct Minus&#123; // 二元元函数转发 template&lt;typename T, T value1, T value2&gt; struct Apply : MinusImplenment&lt;T, value1, value2&gt;&#123;&#125;;&#125;; 最后，实现乘法和除法： 123456789101112131415template&lt;typename T, typename D1, typename D2&gt;Quantity&lt;T, typename Transform&lt;D1, D2, Plus&gt;::Type&gt; operator * (const Quantity&lt;T, D1&gt;&amp; x, const Quantity&lt;T, D2&gt; y)&#123; // 通过Transform元函数，计算目标类型。 using Dimension = Transform&lt;D1, D2, Plus&gt;::Type; return Quantity&lt;T, Dimension&gt;(x.value() * y.value());&#125;template&lt;typename T, typename D1, typename D2&gt;Quantity&lt;T, typename Transform&lt;D1, D2, Minus&gt;::Type&gt; operator / (const Quantity&lt;T, D1&gt;&amp; x, const Quantity&lt;T, D2&gt; y)&#123; // 通过Transform元函数，计算目标类型。 using Dimension = Transform&lt;D1, D2, Minus&gt;::Type; return Quantity&lt;T, Dimension&gt;(x.value() / y.value());&#125; 这样，就实现了基本的量纲分析功能。 最后本文代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116#pragma oncenamespace td &#123; template&lt;typename T, T ...args&gt; struct Vector &#123; using Type = List&lt;T, args...&gt;; &#125;; // Specialized // kilo gram using Mass = Vector&lt;int, 1, 0, 0, 0, 0, 0, 0&gt;; // Meter using Length = Vector&lt;int, 0, 1, 0, 0, 0, 0, 0&gt;; // Second using Time = Vector&lt;int, 0, 0, 1, 0, 0, 0, 0&gt;; // Ampere using Charge = Vector&lt;int, 0, 0, 0, 1, 0, 0, 0&gt;; // Kelvin using Temperature = Vector&lt;int, 0, 0, 0, 0, 1, 0, 0&gt;; // Lux using Intensity = Vector&lt;int, 0, 0, 0, 0, 0, 1, 0&gt;; // Mol using AmountOfSubstance = Vector&lt;int, 0, 0, 0, 0, 0, 0, 1&gt;; template&lt;typename T, typename Dimension&gt; struct Quantity &#123; explicit Quantity(T x) : mValue(x) &#123;&#125;; T value() const &#123; return mValue; &#125;; private: T mValue; &#125;; template&lt;typename T, typename Dimension&gt; Quantity&lt;T, Dimension&gt; operator + (const Quantity&lt;T, Dimension&gt;&amp; x, const Quantity&lt;T, Dimension&gt;&amp; y) &#123; return Quantity&lt;T, Dimension&gt;(x.value() + y.value()); &#125; template&lt;typename T, typename Dimension&gt; Quantity&lt;T, Dimension&gt; operator - (const Quantity&lt;T, Dimension&gt;&amp; x, const Quantity&lt;T, Dimension&gt;&amp; y) &#123; return Quantity&lt;T, Dimension&gt;(x.value() + y.value()); &#125; template&lt;typename T, T value1, T value2&gt; struct PlusImplenment &#123; using Type = PlusImplenment&lt;T, value1, value2&gt;; const static T value = value1 + value2; &#125;; struct Plus &#123; // Meta function forwards. template&lt;typename T, T value1, T value2&gt; struct Apply : PlusImplenment&lt;T, value1, value2&gt;&#123;&#125;; &#125;; template&lt;typename T, T value1, T value2&gt; struct MinusImplenment &#123; using Type = MinusImplenment&lt;T, value1, value2&gt;; const static T value = value1 - value2; &#125;; struct Minus &#123; // Meta function forwards. template&lt;typename T, T value1, T value2&gt; struct Apply : MinusImplenment&lt;T, value1, value2&gt;&#123;&#125;; &#125;; // Function Signature template&lt;typename T1, typename T2, typename MetaFunction&gt; struct Transform; template&lt; typename T, T ...args1, T ...args2, template&lt;typename T, T ...args1&gt; class Vector1, template&lt;typename T, T ...args2&gt; class Vector2, typename MetaFunction&gt; struct Transform&lt;Vector1&lt;T, args1...&gt;, Vector2&lt;T, args2...&gt;, MetaFunction&gt; &#123; using Type = List&lt;T, MetaFunction::template Apply&lt;T, args1, args2&gt;::value...&gt;; &#125;; template&lt;typename T, typename D1, typename D2&gt; Quantity&lt;T, typename Transform&lt;D1, D2, Plus&gt;::Type&gt; operator * (const Quantity&lt;T, D1&gt;&amp; x, const Quantity&lt;T, D2&gt; y) &#123; // Caculate the quantity. using Dimension = Transform&lt;D1, D2, Plus&gt;::Type; return Quantity&lt;T, Dimension&gt;(x.value() * y.value()); &#125; template&lt;typename T, typename D1, typename D2&gt; Quantity&lt;T, typename Transform&lt;D1, D2, Minus&gt;::Type&gt; operator / (const Quantity&lt;T, D1&gt;&amp; x, const Quantity&lt;T, D2&gt; y) &#123; // Caculate the quantity. using Dimension = Transform&lt;D1, D2, Minus&gt;::Type; return Quantity&lt;T, Dimension&gt;(x.value() / y.value()); &#125;&#125;","categories":[{"name":"C++","slug":"C","permalink":"http://www.zcating.tk/categories/C/"}],"tags":[]},{"title":"Objective-C 对象内存布局","slug":"Objective-C 对象内存布局","date":"2018-12-16T11:00:00.000Z","updated":"2019-03-17T15:34:49.563Z","comments":true,"path":"2018/12/16/cjzjryjzm000b2pl3nnb4ke2l/","link":"","permalink":"http://www.zcating.tk/2018/12/16/cjzjryjzm000b2pl3nnb4ke2l/","excerpt":"可能需要以下命令的帮助： 1clang -rewrite-objc main.m 该命令会将 .m文件转成 .cpp文件，这样就能直观的看到Objective-C对象实际的C对象的形式。","text":"可能需要以下命令的帮助： 1clang -rewrite-objc main.m 该命令会将 .m文件转成 .cpp文件，这样就能直观的看到Objective-C对象实际的C对象的形式。 NSObject对于NSObject来说，它实际上是以这种形式出现的。 1234typedef struct objc_class *Class;struct NSObject_IMPL &#123; Class isa;&#125;; 可以看到，一个NSObject对象其实是只存有一个指针类型。我们可以通过以下代码，来观察它在堆上的大小。 123#import&lt;objc/rumtime.h&gt;NSObject *object = [NSObject new];NSLog(@\"NSObject's instance size is %ul.\", Class_getInstanceSize(object)); 很显然，在64位系统下一个指针的大小为8个字节。运行以上代码，可以发现输出如下： 1NSObject&apos;s instance size is 8. 跟我们所认为的是一样的。那么实际占用的字节大小是多少呢，我们可以通过以下代码来获取其实际占用的大小： 12NSObjec *object = [NSObject new];NSLog(@\"NSObject's malloc size is %ul.\", malloc_size((__brige const void *)object)); 以上代码输出如下： 1NSObject&apos;s malloc size is 16. 为什么是16个字节，主要是因为CoreFoundation框架规定，每个对象的大小最小为16字节。 继承下的对象的内存布局举个例子，先给出以下数据结构： 1234567891011@interface A : NSObject &#123; double a;&#125;@end// 省略 implementation@interface B : A &#123; double b;&#125;@end// 省略 implementation 我们不妨将他们转成C数据结构： 12345678910struct A_IMPL &#123; Class isa; double a;&#125;struct B_IMPL &#123; Class isa; double a; double b;&#125; 手动来计算一下，sizeof(isa) + sizeof(a) = 16 ，sizeof(isa) + sizeof(a) + sizeof(b) = 24。 给出打印代码： 1234567A *objectA = [A new];NSLog(@&quot;A&apos;s instance size is %ul.&quot;, Class_getInstanceSize(objectA));// A&apos;s instance size is 16B *objectB = [B new];NSLog(@&quot;B&apos;s instance size is %ul.&quot;, Class_getInstanceSize(objectB));// B&apos;s instance size is 24 Class_getInstanceSize获取的是实例大小，而不是内存中占用的，我们查看这个实例在内存占用的大小，则需要malloc_size(void*) 这个函数来查看： 123456789#import&lt;malloc/malloc.h&gt;A *objectA = [A new];NSLog(@&quot;A&apos;s allocated size is %ul.&quot;, malloc_size((__brige const void *)objectA));// NSObject&apos;s allocated size is 16.B *objectB = [B new];NSLog(@&quot;B&apos;s allocated size is %ul.&quot;, malloc_size((__brige const void *) objectB));// NSObject&apos;s allocated size is 32. 可以看到，打印的结果并不是24，而是32，这是可能是由于Core Foundation内存对齐的原因，所有的内存地址都是16。 NSArray 的内存布局12345NSArray *array = @[[B new], [B new], [B new]];NSLog(@&quot;array&apos;s instance size is %ul.&quot;, Class_getInstanceSize(array));// array&apos;s instance size is 24.NSLog(@&quot;array&apos;s allocated size is %ul.&quot;, malloc_size((__brige const void *) array));// array&apos;s allocated size is 32. 很显然，array中的数据都是在堆上申请的，所以array的实际上存储的是堆上元素的指针，所以大小是三个指针加上一个isa指针——24。","categories":[{"name":"Objective-C","slug":"Objective-C","permalink":"http://www.zcating.tk/categories/Objective-C/"}],"tags":[]},{"title":"使用Webpack为项目配置热更新","slug":"通过Webpack为项目配置热更新","date":"2018-10-05T11:00:00.000Z","updated":"2019-03-18T12:34:49.833Z","comments":true,"path":"2018/10/05/cjzjryk1c001v2pl3xl5z5e0y/","link":"","permalink":"http://www.zcating.tk/2018/10/05/cjzjryk1c001v2pl3xl5z5e0y/","excerpt":"为了调试代码方便，使用了Webpack来配置热更新功能，现在记录一下如何配置。 上一篇已经说了如何使用webpack打包代码，但是如果我每次改了代码，都要手动去打包，所以这里要使用热更新来进行代码调试，本篇将记录如何配置webpack热更新。","text":"为了调试代码方便，使用了Webpack来配置热更新功能，现在记录一下如何配置。 上一篇已经说了如何使用webpack打包代码，但是如果我每次改了代码，都要手动去打包，所以这里要使用热更新来进行代码调试，本篇将记录如何配置webpack热更新。 步骤一首先是安装各种的plugin以便热更新的时候可以加载到你想要热更的文件，这里我主要使用了html： 1234// 如果没有安装npx，请先安装npm install -g npxnpm install -D html-webpack-plugin webpack-dev-server 步骤二然后就开始编写我们配置文件webpack.dev.config.js。 1234567891011121314151617181920212223242526272829303132333435const path = require('path');const webpack = require('webpack');const HTMLWebpackPlugin = require('html-webpack-plugin');module.exports = &#123; entry: '写你自己的入口文件的名称', output: &#123; path: __dirname + '写你自己的文件要生成到的文件夹', filename: \"写你自己的文件的名字\" &#125;, module: &#123; rules: [&#123; test: /\\.js$/, exclude: /node_modules|(其他你想要忽略打包的文件夹)/ loader: 'babel-loader', options: &#123; presets: ['@babel/preset-env'] &#125; &#125;] &#125;, // 以下是一些常用的设置，更多配置请看以下地址： // https://webpack.docschina.org/configuration/dev-server/ devServer: &#123; contentBase: path.join(__dirname, 'dist'), compress: true, port: 8080 &#125;, plugins: [ new webpack.HotModuleReplacementPlugin(), new HTMLWebpackPlugin(&#123; template: './dist/index.html' //此处指定的是入口的HTML &#125;) ]&#125; 这里我们大致的目录结构是这样的： 1234567dist index.htmlsrc main.jspackage.jsonwebpack.config.jswebpack.dev.config.js 步骤三在package增加这个script 1&quot;dev&quot;: &quot;npx webpack-dev-server --config webpack.dev.config.js&quot;, 这样当你输入npm run dev的时候，就可以运行项目了。","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://www.zcating.tk/categories/JavaScript/"}],"tags":[]},{"title":"使用Webpack和Babel支持IE-11","slug":"使用Webpack和Babel支持IE-11","date":"2018-09-29T11:00:00.000Z","updated":"2019-03-18T12:26:49.646Z","comments":true,"path":"2018/09/29/cjzjryk0600132pl3hwliopzr/","link":"","permalink":"http://www.zcating.tk/2018/09/29/cjzjryk0600132pl3hwliopzr/","excerpt":"是的你没看错，都8012了还有人用IE-11。为了帮助客户可以在IE-11上使用我们的应用，需要将es6的代码打包转化成es5。","text":"是的你没看错，都8012了还有人用IE-11。为了帮助客户可以在IE-11上使用我们的应用，需要将es6的代码打包转化成es5。 步骤一安装一些必备的插件： 1234// 如果没有安装npx，请先安装npm install -g npxnpm install babel-loader@8.0.0-beta.0 @babel/core @babel/preset-env webpack webpack-cli 步骤二配置webpack.config.js： 123456789101112131415161718const path = require(&apos;path&apos;);module.exports = &#123; entry: &apos;写你自己的入口文件的名称&apos;, output: &#123; path: path.resolve(__dirname, &apos;写你自己的文件要生成到的文件夹&apos;), filename: &quot;写你自己的文件的名字&quot; &#125;, module: &#123; rules: [&#123; test: /\\.js$/, exclude: /node_modules|(其他你想要忽略打包的文件夹)/ loader: &apos;babel-loader&apos;, options: &#123; presets: [&apos;@babel/preset-env&apos;] &#125; &#125;] &#125;&#125; 其实到这步，你在终端运行npx webpack --config webpack.config.js的时候，就可以生成可以运行的文件。但是我到IE上运行，还是不行啊！为什么呢？ 原因就是因为babel只支持语法转换，并不支持es6特有对象和方法的转换，这样就需要这个插件 如果你的代码中有以下这些对象、方法，那么就要小心了！ 1234仅仅是列举常用的，其他还需要进一步查询支持不支持。1. 全局对象：Promise等;2. 全局静态函数：Array.from, Object.assign等;3. 实例方法：Array.prototype.includes等; 所以我们需要另外一个插件 polyfill来对对象和方法进行转换。 步骤三安装包： 1npm i -D @babel/polyfill 然后再入口文件（一般为index.js或main.js）中，往第一行添加以下代码： 1import &apos;@babel/polyfill&apos; 这样打包的时候，就会自动将es6特有的对象和方法进行转换。 总结安装以下插件： 1npm install babel-loader@8.0.0-beta.0 @babel/core @babel/preset-env @babel/polyfill webpack webpack-cli 写webpack.config.js配置文件。 在入口文件的头部添加代码：import &#39;@babel/polyfill&#39;。","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://www.zcating.tk/categories/JavaScript/"}],"tags":[]},{"title":"解决跨域的终极方法","slug":"解决跨域的终极方法","date":"2018-07-10T11:00:00.000Z","updated":"2019-03-17T15:34:49.816Z","comments":true,"path":"2018/07/10/cjzjryk1r00222pl34a4veq17/","link":"","permalink":"http://www.zcating.tk/2018/07/10/cjzjryk1r00222pl34a4veq17/","excerpt":"","text":"如果使用前后端分离的架构，肯定会深受跨域的困扰，网上有一大堆的方法来解决跨域，但是你得一个一个试才知道哪个是合适。这个方法就是用nginx来配置跨域请求头部，下面将简单记录这个方法： 安装nginx，一般来说服务器都是用CentOS，使用yum安装。 直接往/etc/nginx/conf.d/文件夹中添加新的配置文件cros.conf。 输入以下配置： 123456789101112131415161718server &#123; listen 80; // 这里输入转发出去的域名或IP server_name localhost; location / &#123; add_header Access-Control-Allow-Origin *; add_header Access-Control-Allow-Methods &apos;GET, POST, PUT, DELETE, OPTIONS&apos;; add_header Access-Control-Allow-Headers &apos;DNT,X-Mx-ReqToken,Keep-Alive,User-Agent,X-Requested-With,If-Modified-Since,Cache-Control,Content-Type,Authorization&apos;; # 这里返回204，意味着无内容。 if ($request_method = &apos;OPTIONS&apos;) &#123; return 204; &#125; # 这里输入后端的域名或IP proxy_pass your.backend.address; &#125;&#125; 之后，启动nginx，输入命令：service nginx restart。 这样，从浏览器请求后端接口的时候，就不会有跨域的问题出现了。","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://www.zcating.tk/categories/JavaScript/"}],"tags":[]},{"title":"使用 Jenkins 配置 iOS 持续集成踩坑实录","slug":"使用 Jenkins 配置 iOS 持续集成踩坑实录","date":"2018-05-24T11:00:00.000Z","updated":"2019-03-17T15:34:49.810Z","comments":true,"path":"2018/05/24/cjzjryk0500102pl3g6d414pl/","link":"","permalink":"http://www.zcating.tk/2018/05/24/cjzjryk0500102pl3g6d414pl/","excerpt":"Jenkins 是一款使用 Java 开发的持续集成工具，下面将介绍如何使用 Jenkins 来进行iOS的持续集成。坑都用粗体标明了。","text":"Jenkins 是一款使用 Java 开发的持续集成工具，下面将介绍如何使用 Jenkins 来进行iOS的持续集成。坑都用粗体标明了。 安装坑在安装 Jenkins 之前，首先要安装 JDK，这里需要注意 JDK 的版本，必须为1.8，过高或者过低均不行。 推荐使用 brew 来安装 Jenkins。 1brew install jenkins 配置坑第一步安装完毕后，直接在命令行中输入以下命令： 1jenkins 在这里需要注意，Jenkins 默认端口是8080，如果该端口被占用，可以使用以下命令切换端口： 1jenkins -httpPort 9090 然后，就可以在浏览器中输入localhost:9090来进入 Jenkins。在起始页面会使用一个起始口令来让你解锁它，这个口令可以在命令行中，或者在其指定的目录下可以找到该口令。输入完毕后，会让你创建一个账户，按照提示来完成操作就好。 第二步创建完毕后，首先要去绑定你SSH密钥，方法如下： 1Jenkins -&gt; Credentials -&gt; global -&gt; add Credentials 第三步绑定完毕后，开始安装以下插件： Keychains and Provisioning Profiles Management 对的，只有一个，不要使用 Xcode 插件来进行 iOS 配置，因为 XCode 8 以后，通过 Archive 生成 ipa 需要包括一个 ExportOption.Plist 文件，这个文件在该插件中并不会提供，所以通过脚本来进行配置，而不是通过 XCode 插件来配置。 安装完毕该插件后，直接通过网上各种渠道的信息来对该插件进行配置，配置该插件基本上不会有太大问题，下面给出 keychains 和 provision 在系统中的路径。 12keychain: /Users/zcating/Library/Keychainsprovision: /Users/zcating/Library/MobileDevice/Provisioning Profiles 需要注意的是，上传的时候，login.keychain-db 会被标记为不合法的文件，login.keychain 实际上跟 login.keychain-db 是一样的，只需要复制一份，然后更改 login.keychain-db 为login.keychain，然后就可以上传了。 第四步完成上传后就可以开始构建了，构建步骤如下： 12341. 新建项目，选择自由风格。2. 勾选 keychain 和 provision。3. 添加 Git 配置。4. 增加构建步骤，选择 Execute shell。 然后添加以下脚本： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#需要自定义参数xcode_project_path=\"/path/to/your/xcode/project\"export_path=\"/path/to/your/export/path\"ipa_name=\"ipa-name\"provision=\"xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx\"# build method，可以输入以下选项: app-store, ad-hoc, enterprise, developmentbuild_method=\"enterprise\"# bundle_id 需要跟项目中的一致bundle_id=\"com.yourCompany.yourApp\"bundle_name=\"provision_name\"# 签名类型，可以选择以下类型: \"iOS Developer\", \"iOS Distribution\"sign_cer=\"iOS Distribution\"# 就是你们团队证书中的用户名team_id=\"XXXXXXXXXX\"#自定义完毕export_option_path=\"$xcode_project_path/ExportOptions.plist\"# 写 ExportOption.plist 文件echo \"&lt;?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?&gt;&lt;!DOCTYPE plist PUBLIC \\\"-//Apple//DTD PLIST 1.0//EN\\\" \\\"http://www.apple.com/DTDs/PropertyList-1.0.dtd\\\"&gt;&lt;plist version=\\\"1.0\\\"&gt;&lt;dict&gt; &lt;key&gt;compileBitcode&lt;/key&gt; &lt;false/&gt; &lt;key&gt;method&lt;/key&gt; &lt;string&gt;$build_method&lt;/string&gt; &lt;key&gt;provisioningProfiles&lt;/key&gt; &lt;dict&gt; &lt;key&gt;$bundle_id&lt;/key&gt; &lt;string&gt;$bundle_name&lt;/string&gt; &lt;/dict&gt; &lt;key&gt;signingCertificate&lt;/key&gt; &lt;string&gt;$sign_cer&lt;/string&gt; &lt;key&gt;signingStyle&lt;/key&gt; &lt;string&gt;manual&lt;/string&gt; &lt;key&gt;stripSwiftSymbols&lt;/key&gt; &lt;true/&gt; &lt;key&gt;teamID&lt;/key&gt; &lt;string&gt;$team_id&lt;/string&gt; &lt;key&gt;thinning&lt;/key&gt; &lt;string&gt;&amp;lt;none&amp;gt;&lt;/string&gt;&lt;/dict&gt;&lt;/plist&gt;\" &gt; $export_option_path;xcodebuild archive \\-archivePath \"$xcode_project_path/build/$&#123;ipa_name&#125;.xcarchive\" \\-project $xcode_project \\-sdk iphoneos \\-scheme $scheme \\-configuration $build_configuration \\CODE_SIGN_IDENTITY=\"钥匙串中的签名的名称\" \\PROVISIONING_PROFILE=$provisionxcodebuild -exportArchive \\-archivePath \"$xcode_project_path/build/$&#123;ipa_name&#125;.xcarchive\" \\-exportPath $export_path \\-exportOptionsPlist $export_option_path \\-allowProvisioningUpdates \\CODE_SIGN_IDENTITY=\"钥匙串中的签名的名称\" \\PROVISIONING_PROFILE=$provisionmv $&#123;export_path&#125;/*.ipa $&#123;export_path&#125;/ipa_name.ipa 需要注意，XCode 项目需要关闭自动签名配置。 到这里，只要在 XCode 打开该项目没有报错，并且可以构建，那么就没有任何问题了。 Unity 特别篇使用 Jenkins 来构建 Unity，有以下几点需要注意的地方。 关闭自动签名，设定provision。 在 Assets 目录下新建以下目录和文件 /Assets/editor/ProcessBuild.cs，并且在cs文件中添加以下代码。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152using System.Collections;using System.IO;using UnityEditor;using UnityEngine;using System.Collections.Generic;using System;class ProjectBuild : Editor&#123; //在这里找出当前工程所有的场景文件. static string[] GetBuildScenes() &#123; List&lt;string&gt; names = new List&lt;string&gt;(); foreach(EditorBuildSettingsScene e in EditorBuildSettings.scenes) &#123; if(e==null) continue; if(e.path == \"Dont_Add\" || e.path == \"post\") if(e.enabled) names.Add(e.path); &#125; return names.ToArray(); &#125; //得到项目的名称 public static string projectName &#123; get &#123; foreach(string arg in System.Environment.GetCommandLineArgs()) &#123; if(arg.StartsWith(\"project\")) &#123; return arg.Split(\"-\"[0])[1]; &#125; &#125; return \"test\"; &#125; &#125; //shell脚本直接调用这个静态方法 static void BuildForIPhone() &#123; PlayerSettings.SetScriptingDefineSymbolsForGroup(BuildTargetGroup.iOS, \"USE_SHARE\"); // 构建xcode工程的核心方法了， // 参数1 需要打包的所有场景 // 参数2 需要打包的名字 // 参数3 打包平台 // 参数4 编译选项 BuildPipeline.BuildPlayer(GetBuildScenes(), \"ios-build\", BuildTarget.iOS, BuildOptions.None); &#125;&#125; 使用以下命令进行自动化构建。 12345678project_dir=\"\"/Applications/Unity/Unity.app/Contents/MacOS/Unity \\-batchmode \\-projectPath $project_dir \\-executeMethod ProjectBuild.BuildForIPhone \\-ios \\-quit \\-logFile $project_dir/BuildXCodeProject.log 这样就会在你指定的目录下生成 XCode 项目。 结语我使用了 Jenkins 生成 iOS 最终的 ipa，感受到了如丝般顺滑的构建流程。生成过程只需一键，一键就能上传Testflight，fir.im 或者蒲公英。感觉以后打包真的会方便很多很多倍，省去了各种复杂的步骤。只是在构建 Jenkins 的时候，遇到了很多问题，最终的解决方案还是决定写一个 Shell 脚本，这样就省去了很多插件的配置问题，之后可能会将脚本转换成可读性更强的 Python 脚本。","categories":[{"name":"Objective-C","slug":"Objective-C","permalink":"http://www.zcating.tk/categories/Objective-C/"}],"tags":[]},{"title":"响应链是如何进行响应的","slug":"iOS中的响应链和点击链简析","date":"2018-05-04T11:00:00.000Z","updated":"2019-03-17T15:34:49.805Z","comments":true,"path":"2018/05/04/cjzjryk02000u2pl3r1gh0cxa/","link":"","permalink":"http://www.zcating.tk/2018/05/04/cjzjryk02000u2pl3r1gh0cxa/","excerpt":"iOS中使用这种方式来实现对对象的响应的： A responder object is any instance of the UIResponder class, and common subclasses include UIView, UIViewController, and UIApplication. 翻译一下： 一个responder对象是这样一种实例，它继承UIResponder类或者是这些子类（UIViewController, UIApplication, UIView）。 对于一个responder对象，它可以响应的事件有以下这些：","text":"iOS中使用这种方式来实现对对象的响应的： A responder object is any instance of the UIResponder class, and common subclasses include UIView, UIViewController, and UIApplication. 翻译一下： 一个responder对象是这样一种实例，它继承UIResponder类或者是这些子类（UIViewController, UIApplication, UIView）。 对于一个responder对象，它可以响应的事件有以下这些： 123456789101112131415// 触摸事件- (void)touchesBegan:(NSSet *)touches withEvent:(UIEvent *)event;- (void)touchesMoved:(NSSet *)touches withEvent:(UIEvent *)event;- (void)touchesEnded:(NSSet *)touches withEvent:(UIEvent *)event;- (void)touchesCancelled:(NSSet *)touches withEvent:(UIEvent *)event;// 加速器事件// 只会处理由CoreMotion传递的事件，不属于响应链。- (void)motionBegan:(UIEventSubtype)motion withEvent:(UIEvent *)event;- (void)motionEnded:(UIEventSubtype)motion withEvent:(UIEvent *)event;- (void)motionCancelled:(UIEventSubtype)motion withEvent:(UIEvent *)event;// 远程控制事件// 主要是用来处理配件的行为，比如耳机插拔、按钮播放等，不属于响应链。- (void)remoteControlReceivedWithEvent:(UIEvent *)event; 我们主要关注的是触摸事件。 Hit-Test 链当你与点击屏幕的时候，会触发UIView中的这两个函数： 12345// 递归地调用 -pointInside:withEvent:. point的坐标是在接收者的坐标系中。-(UIView *)hitTest:(CGPoint)point withEvent:(UIEvent *)event;// 如果点在框内，默认是返回 YES.-(BOOL)pointInside:(CGPoint)point withEvent:(UIEvent *)event; hitTest的逻辑大概如下： 1234567891011121314151617181920212223-(UIView *)hitTest:(CGPoint)point withEvent:(UIEvent *)event;&#123; // 判断这个点是否可以点击 if (!self.isUserInteractionEnabled || self.isHidden || self.alpha &lt;= 0.01) &#123; return nil; &#125; // 然后判断这个点是否在这个视图内部 if ([self pointInside:point event:event]) &#123; // 将 subview 逆序遍历 [self.subviews enumerateObjectsWithOptions:NSEnumerationReverse usingBlock:^(UIView * view, NSUInteger index, BOOL stop) &#123; // 将触摸点所在的父视图坐标系转换到子视图下的坐标系。 CGPoint convertedPoint = [view convertPoint:point fromView:self]; UIView *testedView = [view hitTest:point withEvent:event]; if (testedView) &#123; return testedView; &#125; &#125;]; // 如果没有找到符合的视图，那么就返回当前视图，并处理事件。 return self; &#125; // 点不在视图内，返回nil不处理该视图以及其子视图。 return nil;&#125; 现在，使用Method Swizzling对所有的UIView中的-hitTest:withEvent:进行hook，在hook方法里打印调用该方法的实例。以一个例子，如下图： 上图中的每一个色块都是一个UIView对象，他们的打印都是其对应的颜色。他们是这样添加的： 1234567891011121314UIView *redView = [[UIView alloc] init];redView.backgroundColor = [UIColor redColor];UIView *blueView = [[UIView alloc] init];blueView.backgroundColor = [UIColor blueColor];[redView addSubview:blueView];UIView *greenView = [[UIView alloc] init];greenView.backgroundColor = [UIColor blueColor];[blueView addSubview:blueView];UIView *yellowView = [[UIView alloc] init];yellowView.backgroundColor = [UIColor yellowColor];[redView addSubview:yellowView]; 记住蓝色和黄色添加顺序，当我们的时候点击绿色视图的时候，打印结果如下（你可能会有疑问，为啥会调用两次，因为点击开始是一个事件，结束也是一个事件。）： 1234567891011121314151617第一次hit test &lt;UIWindow: 0x115e0a3d0&gt;hit test controller&apos;s viewhit test redhit test yellowhit test bluehit test greenhit test &lt;UIStatusBarWindow&gt;hit test &lt;UIStatusBar&gt;第二次hit test &lt;UIWindow&gt;hit test controller&apos;s viewhit test redhit test yellowhit test bluehit test green -hitTest:withEvent:的调用链是这样的： 可以看到红色视图调用了它的子视图的hit-test方法，通过逆序遍历来查找蓝色和黄色，如果黄色视图在蓝色视图添加之前，则黄色试图不会调用hit-test方法，因为在调用蓝色视图的hit-test的时候，就会继续调用绿色视图的hit-test，并确认点在绿色视图内并返回绿色视图，那么红色视图hit-test的终结点就是在蓝色视图的返回值，并不会继续去调用黄色视图对应的方法。其实讲这么多就是为了理解hit-test的逻辑，理解多点触控技术是如何去确认点在视图中的位置。 响应链通过hit-test确定了视图之后，该视图将会逆着hit-test链来返回响应的事件，并查找哪个view能处理这个点击事件。为了能够看清响应链的具体过程，我们可以通过分类重写UIView、UIViewController和UIApplication中的-touchBegan:withEvent:这个方法： 1234-(void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event &#123; NSLog(@\"begin, %@\", [self description]); [self.nextResponder touchesBegin:touches withEvent:event];&#125; nextResponder是当前视图的下一个响应者，如果这个视图不能处理当前的事件，那么便会通过nextResponder来响应这个事件，这样，点击绿色视图打印的链条如下： 1234567began: greenbegan: bluebegan: redbegan: controller's viewbegan: &lt;MyViewController&gt;began: &lt;UIWindow&gt;began: &lt;UIApplication&gt; 那么它的响应链如下： 参考文档Using Responders and the Responder Chain to Handle Events Understanding cocoa and cocoa touch responder chain iOS响应链(Responder Chain)","categories":[{"name":"Objective-C","slug":"Objective-C","permalink":"http://www.zcating.tk/categories/Objective-C/"}],"tags":[]},{"title":"用XCode注入动态库到Mac应用中","slug":"用XCode注入动态库到Mac应用中","date":"2018-02-18T11:00:00.000Z","updated":"2019-03-17T15:34:49.813Z","comments":true,"path":"2018/02/18/cjzjryk0800182pl3go9npai8/","link":"","permalink":"http://www.zcating.tk/2018/02/18/cjzjryk0800182pl3go9npai8/","excerpt":"本文介绍如何将动态库注入到Mac下的二进制文件中，不包含逆向分析，仅作学习使用。 步骤简介以下是具体步骤简介。 使用classdump，解压出Mac版微信下的所有头文件。 新建一个macOS Framework工程。 将Header拖入项目中，并将注入脚本放入Build Phases中，编译项目。","text":"本文介绍如何将动态库注入到Mac下的二进制文件中，不包含逆向分析，仅作学习使用。 步骤简介以下是具体步骤简介。 使用classdump，解压出Mac版微信下的所有头文件。 新建一个macOS Framework工程。 将Header拖入项目中，并将注入脚本放入Build Phases中，编译项目。 本文介绍如何将动态库注入到Mac下的二进制文件中，不包含逆向分析，仅作学习使用。 步骤简介以下是具体步骤简介。 使用classdump，解压出Mac版微信下的所有头文件。 新建一个macOS Framework工程。 将Header拖入项目中，并将注入脚本放入Build Phases中，编译项目。 步骤一我们使用class-dump，要使用class-dump,首先需要下载它，它不是自带的。 下载地址：http://stevenygard.com/projects/class-dump/ 打开终端，运行sudo cp /path/to/class-dump /usr/local/bin （目标地址是可以全局运行项目的地方） 修改权限，运行sudo chmod 777 /usr/local/bin/class-dump 运行以下命令可以获得所有的微信头文件。 1class-dump -H /Applications/WeChat.app/Contents/MacOS/WeChat -o /path/to/your/dir/ 步骤二我们使用xcode创建一个Framework项目，此步略过。 步骤三将Header拖入后，我们需要开始编写tweak代码，首先我们新建一个 tweak.mm，输入以下函数： 1234static void __attribute__((constructor)) tweak(void) &#123; // do hook method... NSLog(@\"****************running hook!************************\");&#125; 这段代码的意思就是，在main函数执行前，运行tweak函数。我们先不管如何hook，把整个注入框架搭起来才是最重要的。 我们通过insert_dylib 将生成的动态库注入到指定的二进制文件中，insert_dylib这个文件可以在这里找到： 1https://github.com/Tyilo/insert_dylib 打开 edit scheme，找到 Excutable，选择 Other，找到WeChat.app并确认。 在Build Phases中，新增一个新的 Run Script，然后添加如下脚本： 123456789101112131415WECHAT_PATH=\"/Applications/wechat.app/Contents/MacOS\"FRAMEWORK_NAME=\"WechatHooker\"UNIX_FILE=\"$&#123;WECHAT_PATH&#125;/Wechat\"FRAMEWORK_PATH=\"$&#123;WECHAT_PATH&#125;/$&#123;FRAMEWORK_NAME&#125;.framework\"if ! [ -f \"$&#123;WECHATPATH&#125;/WeChatCopy\" ]thencp -rf $&#123;UNIX_FILE&#125; \"$&#123;WECHAT_PATH&#125;/WeChatCopy\"ficp -rf \"$&#123;BUILT_PRODUCTS_DIR&#125;/$&#123;FRAMEWORK_NAME&#125;.framework\" $&#123;WECHAT_PATH&#125;./insert_dylib \"$&#123;FRAMEWORK_PATH&#125;/$&#123;FRAMEWORK_NAME&#125;\" $&#123;UNIX_FILE&#125; $&#123;UNIX_FILE&#125; --all-yes 脚本的意思很明确，通过将生成的Framework拷贝到指定目录下，然后通过 insert_dylib 将动态库注入到指定的二进制文件中。在这里，为了不覆盖原有的WeChat二进制文件，生成了WeChatCopy，我们需要将整个WeChat.app复制一份新的，并将生成的WechatCopy，改名覆盖WeChat二进制文件。 最后运行Framework，会发现在 /Applications/wechat.app/Contents/MacOS/ 目录下，会多出一个WeChatCopy。按照上述方法操作后，运行修改后的Wechat.app可以在控制台查看到打印信息。 在这里，我们以“防止消息撤回”为例。消息撤回其实这个功能其实对于有些人来说很不喜欢，现在他们想防止微信消息撤回，我已经通过逆向分析找到了防止消息撤回的目标函数，现在，只要将这个函数改写就好了。类，函数以及函数的参数描述如下： 123Class: MessageServiceMethod: onRevokeMsg: 当消息撤回时，需要做的事情。Parameters: NSString 撤回的消息内容。 使用Aspect对onRevokeMsg:进行替换： 1234567891011#define MYMessageService objc_getClass(&quot;MessageService&quot;)static void __attribute__((constructor)) tweak(void) &#123; // 需要注意的是，编译的时候，编译器是找不到 MessageService 的实现， // 如果直接引入会编译报错，我们需要动态获取该类。 // do hook method... [MYMessageService aspect_hookSelector:NSSelectorFromString(@&quot;onRevokeMsg:&quot;) withOptions:AspectPositionInstead usingBlock:^(id&lt;AspectInfo&gt; info)&#123; // hook method... NSLog(@&quot;revoked message: %@&quot;, [info arguments].firstObject); &#125; error:nil];&#125; 我们打印了撤回的消息的内容，可以看到微信的聊天信息是以XML的形式来进行数据的传输。 12345678&lt;sysmsg type=\"revokemsg\"&gt; &lt;revokemsg&gt; &lt;session&gt;wxid_qdxmce84ueno12&lt;/session&gt; &lt;msgid&gt;1656418240&lt;/msgid&gt; &lt;newmsgid&gt;8250926699869451612&lt;/newmsgid&gt; &lt;replacemsg&gt;&lt;![CDATA[\"sunhay\" 撤回了一条消息]]&gt;&lt;/replacemsg&gt; &lt;/revokemsg&gt;&lt;/sysmsg&gt; 通过逆向，将原本的撤回函数以人类可读的方式展示。 12345678910111213141516171819202122232425262728// self = MessageService 实例-(void)onRevokeMsg:(NSString *)message &#123; // 此处使用原本的 NSString *session = [RegexHelper matchXMLTag:@&quot;session&quot; inXMLText:message]; NSUIntger msgID = [[RegexHelper matchXMLTag:@&quot;msgid&quot; inXMLText:message] longLongValue]; NSUIntger newMsgID = [[RegexHelper matchXMLTag:@&quot;newmsgid&quot; inXMLText:message] longLongValue]; NSString *revokeContent = [RegexHelper matchXMLTag:@&quot;replacemsg&quot; inXMLText:message]; id lastMsgData = [self GetMsgData:session svrId:newMsgID]; if (lastMsgData == nil) &#123; return; &#125; // 匹配 [!CDATA[\\S*]] NSString *receiveMsg = [RegexHelper getChatContent:message]; // 显示谁撤回了消息 id revokingData = [[MessageData alloc] initWithMsgType:0x2710]; [revokingData setMsgStatus:0x4]; [revokingData setMsgContent:receiveMsg]; [revokingData setFromUsrName:[lastMsgData toUsrName]]; [revokingData setToUsrName:[lastMsgData fromUsrName]]; [revokingData setMsgCreateTime:[lastMsgData msgCreateTime]]; [revokingData setMesLocalID:[lastMsgData mesLocalID]]; // 将指定撤回的内容删除 [self DelMsg:session msgList:@[lastMsgData] isDelAll:0 isManual:1]; // 将撤回消息栏添加进指定的聊天列表 [self AddLocalMsg:session msgData:msgData];&#125; 很显然，微信通过删除指定的信息，来实现撤回，那么我们的防止撤回函数如下（都在tweak.mm中）： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#define MYMessageData objc_getClass(&quot;MessageData&quot;)#define MYMessageService objc_getClass(&quot;MessageService&quot;)static void MYPreventRevoking(id service, NSString *message) &#123; NSString *session = [RegexHelper matchXMLTag:@&quot;session&quot; inXMLText:message]; NSUIntger msgID = [[RegexHelper matchXMLTag:@&quot;msgid&quot; inXMLText:message] longLongValue]; NSUIntger newMsgID = [[RegexHelper matchXMLTag:@&quot;newmsgid&quot; inXMLText:message] longLongValue]; id lastMsgData = [service GetMsgData:session svrId:newMsgID]; if (lastMsgData == nil) &#123; return; &#125; NSString *revokeContent = [NSString stringWithFormat:@&quot;Ta 撤回了：%@&quot;, [lastMsgData msgContent]]; NSString *receiveMsg = [RegexHelper getChatContent:message]; id msgData = [[MYMessageData alloc] initWithMsgType:0x2710]; [msgData setMsgStatus:0x4]; [msgData setMsgContent:receiveMsg]; [msgData setFromUsrName:[lastMsgData toUsrName]]; [msgData setToUsrName:[lastMsgData fromUsrName]]; [msgData setMsgCreateTime:[lastMsgData msgCreateTime]]; [msgData setMesLocalID:[lastMsgData mesLocalID]]; id revokingData = [[MYMessageData alloc] initWithMsgType:0x2710]; [revokingData setMsgStatus:0x4]; [revokingData setMsgContent:revokeContent]; [revokingData setFromUsrName:[lastMsgData toUsrName]]; [revokingData setToUsrName:[lastMsgData fromUsrName]]; [revokingData setMsgCreateTime:[lastMsgData msgCreateTime]]; [revokingData setMesLocalID:[lastMsgData mesLocalID]]; // [service DelMsg:session msgList:@[lastMsgData] isDelAll:0 isManual:1]; [service AddLocalMsg:session msgData:msgData]; [service AddLocalMsg:session msgData:revokingData];&#125;// 附上完整的文件static void __attribute__((constructor)) tweak(void) &#123; // 需要注意的是，编译的时候，编译器是找不到 MessageService 的实现， // 如果直接引入会编译报错，我们需要动态获取该类。 // do hook method... [MYMessageService aspect_hookSelector:NSSelectorFromString(@&quot;onRevokeMsg:&quot;) withOptions:AspectPositionInstead usingBlock:^(id&lt;AspectInfo&gt; info)&#123; // hook method... NSLog(@&quot;revoked message: %@&quot;, [info arguments].firstObject); MYPreventRevoking([info instance], [info arguments].firstObject); &#125; error:nil];&#125; 至此我们已经完成了防止消息撤回，这样，在聊天的时候，就能愉快地防止对方偷偷撤回了信息，并且知道对方想要撤回什么信息。 最后简单的介绍如何去对mac应用进行注入，仅作抛砖引玉用。","categories":[{"name":"Objective-C","slug":"Objective-C","permalink":"http://www.zcating.tk/categories/Objective-C/"},{"name":"逆向分析","slug":"Objective-C/逆向分析","permalink":"http://www.zcating.tk/categories/Objective-C/逆向分析/"}],"tags":[]},{"title":"iOS 动态加载非系统的字体","slug":"iOS 动态加载字体","date":"2018-02-16T05:00:00.000Z","updated":"2019-03-17T15:34:49.795Z","comments":true,"path":"2018/02/16/cjzjryk00000q2pl3yyyqv03t/","link":"","permalink":"http://www.zcating.tk/2018/02/16/cjzjryk00000q2pl3yyyqv03t/","excerpt":"对于字体文件，普遍的方法是静态加载，静态加载需要将字体文件打包到mainBundle中，但是某些应用如果需要下发字体功能，那么就不是很方便，于是就介绍以下动态加载字体库的方法。","text":"对于字体文件，普遍的方法是静态加载，静态加载需要将字体文件打包到mainBundle中，但是某些应用如果需要下发字体功能，那么就不是很方便，于是就介绍以下动态加载字体库的方法。 静态加载对于字体来说，有两种文件格式，.otf和.ttf。这两种都是可以作为字体格式加载到iOS当中的。 要加载字体，首先要在Info.plist添加如下属性： 接着，打开字体库查找你要加载字体的PostScript name。 然后在你的代码中添加以下代码： 12345//// @param name : PostScript name// @param size : the font size you want to set//[UIFont fontWithName:@&quot;YaHei-Consolas-Hybrid&quot; size:12]; 这样，就可以静态的调用字体。 动态加载但是，有个问题，以上方式直接将字体文件拷贝到mainBundle中，也就是你不能更改字体文件，因此，如果你需要新增或修改字体的时候，是没有办法更改的。所以，需要动态的去加载这个字体文件。 直接给出代码吧，感觉比上面的方法简单多了。 123456789101112131415161718192021222324//首先要 @import CoreText;//字体文件所在路径NSString *fontPath = @&quot;path/to/font/file&quot;;//字体数据NSData *fontData = [NSData dataWithContentsOfFile:fontPath];if (fontData == nil) &#123; return;&#125;//动态加载CFErrorRef error = NULL;CGDataProviderRef providerRef = CGDataProviderCreateWithCFData((CFDataRef)fontData);CGFontRef fontRef = CGFontCreateWithDataProvider(providerRef);// 将文本注册到CoreTextif (!CTFontManagerRegisterGraphicsFont(fontRef, &amp;error)) &#123; NSLog(@&quot;%@&quot;, (__bridge NSString *)CFErrorCopyDescription(error)); return;&#125;NSString *fontName = (__bridge NSString *)CGFontCopyPostScriptName(fontRef);self.label.font = [UIFont fontWithName:fontName size:10];CFRelease(fontRef);CFRelease(providerRef); 这样，就可以动态的去加载了，通过网络下发字体文件，便可以替换字体 。 : )","categories":[{"name":"Objective-C","slug":"Objective-C","permalink":"http://www.zcating.tk/categories/Objective-C/"}],"tags":[]},{"title":"Objective-C 简析（3）—— OC属性 Attributes列举","slug":"Objective-C 简析（3）—— OC属性 Attributes列举","date":"2018-01-10T11:00:00.000Z","updated":"2019-03-17T15:34:49.575Z","comments":true,"path":"2018/01/10/cjzjryjzw000k2pl3wkddsgu7/","link":"","permalink":"http://www.zcating.tk/2018/01/10/cjzjryjzw000k2pl3wkddsgu7/","excerpt":"Objective-C属性的主要由四种不同的attribute组成 ： 原子性：atomic，nonatomic； 读写相关：readwrite,readonly； 内存管理相关：assign，strong，weak，unsafe_unretained，copy； 存取方法设定：getter=(name)，setter=(name)；","text":"Objective-C属性的主要由四种不同的attribute组成 ： 原子性：atomic，nonatomic； 读写相关：readwrite,readonly； 内存管理相关：assign，strong，weak，unsafe_unretained，copy； 存取方法设定：getter=(name)，setter=(name)； 原子性原子性主要和线程安全相关，当你定义一个属性的时候，默认是atomic的，它底层使用的是同步锁来保证这个操作属性是原子的。在Objective-C编程中，很少用到的atomic这个属性，原因是同步锁的开销比较大，同时也不能保证线程同步，如果要实现线程同步，一般都是采用GCD等较为底层的机制来实现。一般来说属性以使用nonatomic。 读写相关当你定义一个属性的使用，默认是readwrite的。 readwrite该attribute使属性可以拥有getter和setter，如果我们不在类的@implementation中显式的编写getter和setter，那么编译器会生成一个以下划线加属性名称为名的成员变量，并且自动的生成getter和setter。 readonly该attribute使属性只能拥有getter，如果我们不在类的@implementation中显式的编写getter，那么编译器会生成一个以下划线加属性名称为名的成员变量，并且自动的生成getter。 内存管理相关当你定义一个属性的使用，内存管理的Attribute默认是assign的。 assign仅仅用于内置类型或者简单的结构体，比如float或者CGRect。如果属性的类型是Objective-C类，那么当属性所持有的类实例dealloc的时候，属性的值并并不会自动置为nil。 strong用于Objective-C类，为这种属性调用setter时，会保留新值，然后释放旧的值，并将新值赋上去。 weak用于Objective-C类，为这种属性调用setter时，不会持有新值，也不会释放旧值。但是当它所指的对象dealloc的时候，该属性会被设置为nil。 copy用于Objective-C类，为这种属性调用setter时，会保留新值的拷贝，然后释放旧值，然后将这个拷贝赋值给属性。 unsafe_unretained用于Objective-C类，为这种属性调用setter时，不会持有新值，也不会释放旧值。但是当它所指的对象dealloc的时候，属性的值仍然是该对象未dealloc时在内存的位置，不会自动清空。 存取方法设定这个用的比较少，以两个例子来说明就好了。 1234567891011121314151617181920@interface LightBulb : NSObject &#123; BOOL _onOrOff;&#125;@property (nonatomic, getter=isOn, setter=setIsOn) BOOL on;@end@implementation LightBulb// 因为定义了 getter=isOn，所以getter方法为 -isOn, 而不是 -on.-(BOOL)isOn&#123; return _isOn;&#125;// 因为定义了 setter=setIsOn，所以getter方法为 -setIsOn, 而不是 -setOn.-(void)setIsOn:(BOOL)onOrOff&#123; _onOrOff = onOrOff;&#125;@end 其他标记一个属性为类属性： 1@property(class, nonatomic, strong) UIApplication *sharedApplication; 标记一个属性是否可以为空： 123@property(nonatomic, strong, readonly, nonnull) NSString *loggingString;@property(nonatomic, strong, readonly, nullable) UIResponder *nextResponder;","categories":[{"name":"Objective-C","slug":"Objective-C","permalink":"http://www.zcating.tk/categories/Objective-C/"}],"tags":[]},{"title":"Objective-C简析（2）—— block篇","slug":"Objective-C 简析（2）—— Block篇","date":"2018-01-06T11:00:00.000Z","updated":"2019-03-17T15:34:49.575Z","comments":true,"path":"2018/01/06/cjzjryjzt000g2pl313oya5ol/","link":"","permalink":"http://www.zcating.tk/2018/01/06/cjzjryjzt000g2pl313oya5ol/","excerpt":"Block是一个非常有用的语法特性。","text":"Block是一个非常有用的语法特性。 如何定义普通变量： 1int (^block)(int) = ^int(int a) &#123;/*implement*/&#125;; 类属性： 1@property (copy) int (^block)(int); 函数参数： 1-(void)function:(int(^)(int))block; 函数参数调用： 1[aClass aFunction:^int(int a)&#123;/*implement*/&#125;]; 类型定义（typedef）： 12typedef int (^BlockType)(int);BlockType aBlock = ^int(int a)&#123;/*implement*/&#125;; Block简单源码剖析通过clang -rewrit-objc可以获得Block的实现的C++源码。 如下代码： 1234567int main(int argc, const char * argv[]) &#123; void (^block)(void) = ^void(void)&#123; printf(&quot;hello, world!&quot;); &#125;; block(); return 0;&#125; 转换后的主要代码如下。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354// 实现 block 的结构体，所以很显然，在OC中block是一个对象。struct __block_impl &#123; void *isa; // isa 指针，即为 id。 int Flags; // int Reserved; // void *FuncPtr; // 函数指针&#125;;// block的具体属性结构体static struct __main_block_desc_0&#123; size_t reserved; size_t Block_size;&#125; __main_block_desc_0_DATA = &#123; 0, sizeof(struct __main_block_impl_0) &#125;;// block主要实现结构体struct __main_block_impl_0&#123; struct __block_impl impl; // block结构体 struct __main_block_desc_0* Desc; // 构造函数 __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, int flags=0) &#123; // 初始化 block 实例属性 isa ，表示是栈类型的代码块。 impl.isa = &amp;_NSConcreteStackBlock; // impl.Flags = flags; // 具体实现匿名功能的函数的指针 impl.FuncPtr = fp; Desc = desc; &#125;&#125;;// block的匿名函数功能。// 一般来说，OC中实现一个类的方法，一般如下：// className_method(className *self, parameters...)// 对于每一个类方法的实现，都要将其引用带入。static void __main_block_func_0(struct __main_block_impl_0 *__cself) &#123; printf(\"hello, world!\");&#125;// main函数int main(int argc, const char * argv[]) &#123; // 对应于block赋值操作。 // 在这里，代码将 __main_block_impl_0 结构体指针赋值给block。 void (*block)(void) = ((void (*)())&amp;__main_block_impl_0((void *)__main_block_func_0, &amp;__main_block_desc_0_DATA)); // 分成以下三步操作。 // __block_impl *theBlock = (__block_impl *)block; // void (*funcPtr)(__block_impl *) = ((void (*)(__block_impl *))(theBlock-&gt;FuncPtr); // funcPtr((__block_impl *)block); ((void (*)(__block_impl *))((__block_impl *)block)-&gt;FuncPtr)((__block_impl *)block); return 0;&#125; 可以看到，该block是在栈上开辟的空间，也就是说，当离开 新增的__block关键字，以下代码： 123456789int main(int argc, const char * argv[]) &#123; __block int a = 1; void (^block)(void) = ^void(void)&#123; a = a + 1; printf(&quot;hello, world! %d&quot;, a); &#125;; block(); return 0;&#125; 可以获得： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091// __block 关键字用来生成了一个结构体，这个结构体是一个拥有指向自身地址的指针的结构体。struct __Block_byref_a_0 &#123;// isa指针 void *__isa;// 指向自身的指针 __Block_byref_a_0 *__forwarding; int __flags; int __size;// int a 原型 int a;&#125;;struct __main_block_impl_0&#123; struct __block_impl impl; struct __main_block_desc_0* Desc; //将外部的变量 a 加入到__main_block_impl_0 中。 __Block_byref_a_0 *a; __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, __Block_byref_a_0 *_a, int flags=0) : a(_a-&gt;__forwarding) &#123; impl.isa = &amp;_NSConcreteStackBlock; impl.Flags = flags; impl.FuncPtr = fp; Desc = desc; &#125;&#125;;static void __main_block_func_0(struct __main_block_impl_0 *__cself)&#123; // 在这里，将 block 的 a(指针) 复制进局部变量中。 // 此处是为了保证其原子性。 __Block_byref_a_0 *a = __cself-&gt;a; // 此处对应于block中的实现 (a-&gt;__forwarding-&gt;a) = (a-&gt;__forwarding-&gt;a) + 1; printf(\"hello, world! %d\", (a-&gt;__forwarding-&gt;a));&#125;// 与之前不同，这里新增了2个静态函数。//这里用来对block中的对象进行内存管理，// 在引用计数情况下，可以视为引用计数 +1static void __main_block_copy_0(struct __main_block_impl_0*dst, struct __main_block_impl_0*src)&#123; _Block_object_assign((void*)&amp;dst-&gt;a, (void*)src-&gt;a, 8/*BLOCK_FIELD_IS_BYREF*/);&#125;// 用来对block中的对象进行内存释放// 在引用计数情况下，可以视为引用计数 -1static void __main_block_dispose_0(struct __main_block_impl_0*src)&#123; _Block_object_dispose((void*)src-&gt;a, 8/*BLOCK_FIELD_IS_BYREF*/);&#125;// desc 新增了两个属性// 这两个属性，帮助其释放static struct __main_block_desc_0&#123; size_t reserved; size_t Block_size; void (*copy)(struct __main_block_impl_0*, struct __main_block_impl_0*); void (*dispose)(struct __main_block_impl_0*);&#125; __main_block_desc_0_DATA = &#123; 0, sizeof(struct __main_block_impl_0), __main_block_copy_0, __main_block_dispose_0&#125;;int main(int argc, const char * argv[])&#123; // 将 __block int a 初始化。 // 这里使用了列表初始化的方式将列表中对应的值赋给 a。 // 这里可以看到，a.__forwarding = &amp;a; // 这样，无论是在堆上还是栈上，都可以保证该变量能够准确的被调用。 __attribute__((__blocks__(byref))) __Block_byref_a_0 a = &#123; (void*)0, (__Block_byref_a_0 *)&amp;a, 0, sizeof(__Block_byref_a_0), 1 &#125;; // 对block的赋值和调用 void (*block)(void) = ((void (*)()) &amp; __main_block_impl_0( (void *)__main_block_func_0, &amp;__main_block_desc_0_DATA, (__Block_byref_a_0 *)&amp;a, 570425344)); ((void (*)(__block_impl *))((__block_impl *)block)-&gt;FuncPtr)((__block_impl *)block); return 0;&#125; 带有__block关键字的变量会生成一个新的结构体。这个结构体会保证，该变量能够正确的在block的作用域内进行变量的操作（特指更改变量）。 Block 循环引用首先，观察一段简单的代码： 123456789101112131415161718192021222324252627@interface HelloPrinter : NSObject-(void)sayHello;@end@implementation HelloPrinter-(void)sayHello &#123; printf(&quot;Hello\\n&quot;);&#125;@end int main(int argc, const char * argv[]) &#123; @autoreleasepool &#123; void (^block)(void); &#123; HelloPrinter *printer = [[HelloPrinter alloc] init]; block = ^void(void) &#123; [printer sayHello]; &#125;; &#125; block(); &#125; return 0;&#125; 这里肯定是打印出了 Hello\\n 。 显然，printer只能在当前的作用域内有效，那么可以肯定的是，block持有了printer。也就是printer的引用计数“+1”了，这样，printer才能在作用域外实行-sayHello方法。 对于循环引用的问题，可以观察以下代码： 12345678910111213141516171819202122232425@interface HelloPrinter : NSObject @property (copy) void (^block)(void);-(void)sayHello;@end@implementation HelloPrinter- (instancetype)init&#123; self = [super init]; if (self) &#123; self.block = ^&#123; [self sayHello]; &#125;; &#125; return self;&#125;-(void)sayHello &#123; printf(&quot;Hello\\n&quot;);&#125;@end 首先我们要确定以下两点： block当中的类会对调用实例方法的实例进行引用。 对带有copy，strong，等关键字的属性初始化时，实例会持有这个属性对应的类的引用。 那么，这就可以构成了循环引用的条件，也就是互相引用对方的实例。 要解决以上代码中的循环引用也很简单，如下： 1234567// 使用 __unsafe_unretained 关键字时，当weakSelf在所在的作用域中运行完后，不会设置为 nil。// __unsafe_unretained typeof(self) weakSelf = self;__weak typeof(self) weakSelf = self;self.block = ^&#123; [weakSelf sayHello];&#125;; 小结本篇主要介绍了如何定义Block这种非常有用的数据结构，分析了其内部实现，最最最主要就是对其产生的循环引用进行简单的分析。","categories":[{"name":"Objective-C","slug":"Objective-C","permalink":"http://www.zcating.tk/categories/Objective-C/"}],"tags":[]},{"title":"Objective-C 简析（1）—— ARC篇","slug":"Objective-C 简析（1）—— ARC篇","date":"2018-01-05T11:00:00.000Z","updated":"2019-03-17T15:34:49.563Z","comments":true,"path":"2018/01/05/cjzjryjzn000d2pl35f75sntf/","link":"","permalink":"http://www.zcating.tk/2018/01/05/cjzjryjzn000d2pl35f75sntf/","excerpt":"ARC（Automatic Reference Counting）——自动引用计数是一个编译器的feature，它提供了对Objective-C对象的内存管理，不用再去对对象进行retain或者release操作。","text":"ARC（Automatic Reference Counting）——自动引用计数是一个编译器的feature，它提供了对Objective-C对象的内存管理，不用再去对对象进行retain或者release操作。 内存管理简述要了解ARC，首先就要了解基本的内存管理机制。对于OOP来说，内存管理机制目前主流的方式有两种： 对其对象实例产生的引用进行计数，当计数变为零的时候，释放对象所持有的内存。 另外一种就是可达性分析算法，通过根对象作为起点来生成一棵引用树，通过不同对象的可达性，来对对象的实例进行内存回收。（可能有误，欢迎指出）。 在这里，Objective-C使用了第一种方式作为内存回收机制。图中展示的是一个简单的引用计数情况，他很好的展示了引用计数是如何运行的。 ARC简述ARC 主要的工作是使得OC对象能够在适当的时机合理地释放其内存。当开启ARC的时候，我们不需要手动的添加retain和release，clang编译器会自动评估所有对象的生命周期需求，并且在编译期自动的插入内联代码，使得几乎每一个对象的实例（循环引用？）都可以正确的分配和释放内存。同时，编译器会自动生成dealloc方法，一般来说，我们只需要在对象生成实例的时候分配其内存就OK了。 下图可以很好的展示ARC和非ARC运行耗时关系。这里主要是因为，ARC自动地在需要增加或减少引用计数的代码段中添加了内联汇编。这样，使得整个运行时的代码运行速度有所提升。 ARC的一些新规定以下是一些ARC的使用新规定，如果硬是要使用以下方法或对象，允许并开启ARC的编译器会对该代码进行错误提示，不会编译通过。 不能显式调用dealloc，或者是实现或调用 retain，release， retainCount， autorelease 。但是可以使用CFRetain和CFRelease等Core Foundation形式的对象。 不能使用NSAllocateObject 或者 NSDeallocateObject。 不能在结构体中使用OC的对象。 id和void*之间不能类型转换。 不能使用NSAutoreleasePool对象。 不能使用内存空间对象。 新增修饰符对于property属性，在ARC中，新增了一些新的生命周期修饰符和弱（Weak）引用。弱引用不会延伸到对象的生命周期，并且，当该对象没有任何强引用的时候，会自动设置为nil。 ARC引入了strong和weak作为property的新的attributes，示例代码如下： 1234//ARC开启时，strong是默认的property属性。@property(strong) NSObject *myObject; @property(weak) NSObject *myObject; 对于变量的修饰符，ARC引入了一下关键字： 1234567891011__strong ：对于所有对象变量，默认是__strong来修饰。__weak：不保留对象，只是简单的引用。当对象没有任何强引用的时候，变量会被设置成nil。 __unsafe_unretained： 不保留对象，只是简单引用。但是，当变量没有任何强引用的时候，不会设置为nil。可能会产生野指针的错误。 __autoreleasing： 用于标识(id*)的引用参数，或者需要自动释放的返回的对象。 要定义变量的修饰符，你需要这样来定义： 12345ClassName * qualifier variableName;举个例子：MyClass * __weak myWeakReference;MyClass * __unsafe_unretained myUnsafeReference; 小结这里我主要简单的介绍了内存管理和ARC的相关知识。","categories":[{"name":"Objective-C","slug":"Objective-C","permalink":"http://www.zcating.tk/categories/Objective-C/"}],"tags":[]},{"title":"简单爬虫，抓取近十年来的美剧的ed2k链接","slug":"简单爬虫，抓取近十年来的美剧的ed2k链接","date":"2017-08-12T11:00:00.000Z","updated":"2019-03-17T15:34:49.813Z","comments":true,"path":"2017/08/12/cjzjryk1k00202pl309ewzuqv/","link":"","permalink":"http://www.zcating.tk/2017/08/12/cjzjryk1k00202pl309ewzuqv/","excerpt":"最近剧荒，所以有个简单的想法，就是将某个网站上的所有美剧的下载链接爬出来。这个爬虫使用python来编写，编写的时候，使用到了两个经典的模块：BeautifulSoup和requests。这两个库，可以减轻很多的负担，更加专注于爬虫的内容上，而不是网页解析上。当然，可以尝试一下不用他们的时候，感觉会挺痛苦的。","text":"最近剧荒，所以有个简单的想法，就是将某个网站上的所有美剧的下载链接爬出来。这个爬虫使用python来编写，编写的时候，使用到了两个经典的模块：BeautifulSoup和requests。这两个库，可以减轻很多的负担，更加专注于爬虫的内容上，而不是网页解析上。当然，可以尝试一下不用他们的时候，感觉会挺痛苦的。 简单模拟浏览器行为首先，进入这个网站的下载列表页面需要登录才能浏览，也就是说，要模拟它的登录行为。通过对其登录流程抓包，发现，传输的数据如下：1account=zcating&amp;pwd=(明文)&amp;?_=0.32629091765153717 首先，用账户和密码都是明文传输（厉害了…），然后后面的?_是用js内置的随机数，生成的一个32位的浮点数。（登录流程有点粗糙啊…）登录后，这个浮点数将用于鉴权，观察网页的HTTPHeader，其形式如下：12345&apos;Accept&apos;:&apos;text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8&apos;,&apos;Refer&apos;: &apos;http://(网站的域名)/?_=0.32629091765153717&apos;,&apos;Upgrade-Insecure-Requests&apos;: &apos;1&apos;,&apos;User-Agent&apos;: &apos;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/59.0.3071.115 Safari/537.36&apos;,&apos;Cookie&apos;:&apos;一长串的Cookie&apos; 感觉，这是很多年前就采用的一种超级简单的鉴权模式啊，直接采用Cookie的头部应该就能获取下载页面的HTML了。于是，用上面的头部，作为所有请求的HTTP头部，用过requests模拟浏览器请求，可以请求到数据。解决了下载页面获取不了的问题。 列表请求快速获取已经有方法能够进入到下载页面后，就要抓取想要抓取的东西了。首先通过观察，每个下载页面都是这样的一个路由：1/resource/list/（对应剧集的标识符，数字） 那么思路也就是很明了，需要获取的就是这些一系列的对应的剧集的标识符。在这里，网站自带有一个搜索的路由：1/fresourcelist?page=(第几页)&amp;channel=(电影还是剧集)&amp;area=(发布地区)&amp;category=(分类)&amp;year=(年份)&amp;tvstation=(播出频道)&amp;sort=(排列顺序) 该路由，很显然应该通过get请求数据。在这里，我组装的数据是形式如下：12/fresourcelist?page=&#123;&#125;&amp;channel=tv&amp;area=%E7%BE%8E%E5%9B%BD&amp;category=&amp;year=&amp;tvstation=&amp;sort=PS: area=美国(url encode) 由于其每页展示的数量有限，所以通过对网页观察，获取其最大的页面数，通过page={}这种形式，循环去获取每一个页面。由于每一个页面的展示方式相同，这样我们只要对一个页面进行分析就能够获取所有页面的资料。通过浏览器的页面分析，对获取的HTML用BeautifulSoup进行以下解析:1234567891011soup = BeautifulSoup(response.text, &apos;html.parser&apos;)rawPrograms = soup.find(class_= &apos;resource-showlist has-point&apos;)programs = []for x in rawPrograms.findAll(&apos;a&apos;): href = x.get(&apos;href&apos;) if href != None and &apos;resource&apos; in href and x.find(&apos;img&apos;) == None: programTag = href.split(&apos;/&apos;)[2] name = standardized(x.text) program = &#123;&apos;name&apos;: name, &apos;resource&apos;: rawURL + programTag&#125; programs.append(program) program中，包含了一个剧集的名称和其资源标识符。programs则是我所需要的所有的剧集列表。之后，通过循环请求组装好的剧集下载页面，就可以获得所有下载页面的HTML。这里，需要做以下解析：123456789101112131415soup = BeautifulSoup(response.text, &apos;html.parser&apos;)mediaLists = soup.findAll(class_=&apos;media-list&apos;)for mediaList in mediaLists: h2 = mediaList.find(&apos;h2&apos;) noLink = mediaList.find(style=&apos;display: none;&apos;) # 只保留 HR-HDTV 或者 MP4 的下载列表 if h2 == None and h2.text != &apos;HR-HDTV&apos; and h2.text != &apos;MP4&apos; and noLink == None: continue # 只保留 ed2k 类型的下载链接 programs = mediaList.findAll(type=&apos;ed2k&apos;) for program in programs: ed2k = program.get(&apos;href&apos;) file.write(ed2k + &apos;\\n&apos;) 这样，就大功告成。 展示一下成果吧","categories":[{"name":"python","slug":"python","permalink":"http://www.zcating.tk/categories/python/"}],"tags":[]},{"title":"BLE简单重放攻击","slug":"BLE简单重放攻击","date":"2017-04-13T11:00:00.000Z","updated":"2019-03-17T15:34:49.473Z","comments":true,"path":"2017/04/13/cjzjryjzi00052pl3rm0tcndc/","link":"","permalink":"http://www.zcating.tk/2017/04/13/cjzjryjzi00052pl3rm0tcndc/","excerpt":"BLE是什么？BLE全称 Bluetooth Low Energy, 即是低功率蓝牙，它比其他传统的蓝牙设备更能控制能耗和成本，所以在发布后就立刻被广泛的应用于各种低功耗设备：运动手环、蓝牙鼠标、蓝牙键盘等。","text":"BLE是什么？BLE全称 Bluetooth Low Energy, 即是低功率蓝牙，它比其他传统的蓝牙设备更能控制能耗和成本，所以在发布后就立刻被广泛的应用于各种低功耗设备：运动手环、蓝牙鼠标、蓝牙键盘等。 BLE简介BLE是什么？BLE全称 Bluetooth Low Energy, 即是低功率蓝牙，它比其他传统的蓝牙设备更能控制能耗和成本，所以在发布后就立刻被广泛的应用于各种低功耗设备：运动手环、蓝牙鼠标、蓝牙键盘等。 BLE和传统蓝牙有着许多的不同之处。他们使用不同的Modulation参数，使用不同的频道，使用不同的频道跳频，使用不同的包格式。但是它们还是会使用传统的主控设备-从属设备模式。 简单分析下面开始简单的蓝牙分析。 蓝牙特点 高可靠性。 低成本，低功耗。 快速启动、瞬间连接。 传输距离极大提高。 较高的安全性。 低数据传输速率。 蓝牙协议栈 应用层：最上面的部分是应用层，GATT和ATT我们可以把她看作是同一层。 Host层：GAP是通用访问配置配置文件，它保证不同的蓝牙设备可以互相发现对方并且建立连接；SM是安全管理层，负责管理安全；L2CAP是逻辑链路控制和适配协议，它负责适配基带中的上层协议。 控制层：Link Layer是链路层，负责数据的传输。BLE Radio PHY是BLE的广播物理层，负责向频道发送广播。HCI是控制接口，主要负责接收信息。 蓝牙通讯过程 GAP-通用访问规范 BLE设备的链接、加密与签名协议的协商都在GAP建立的，比如BLE的两个安全模式，首先是Security Mode1，这个模式主要负责加密，有三个安全等级： LEVEL 1 无认证无加密 LEVEL 2 带加密的未认证配对 LEVEL 3 带加密的认证配对 其次是Security Mode2，这个模式主要是负责签名，有两个安全等级： LEVEL 1 带数据签名的未认证配对 LEVEL 2 带数据签名的认证配对 GATT-通用属性协议 GATT中的三个要素是Profile、Service、Characteristics以及它们的层级关系。其中比较重要的是Service和Characteristics。 Service可以理解为“类”，即功能对象的集合，Characteristics可以理解为“类中的函数”，是GATT中具体的功能对象，每个Service可以包含一个或多个Characteristics。 其实到这里写得还是有点乱，主要就是介绍了蓝牙的特性和协议，下面开始，就要开始比较重要的逆向的部分了。 BLE嗅探BLE嗅探设备介绍 如图，是一个嗅探器（德州仪器（TI）的CC254x系列蓝牙评估模块，配有官方的嗅探器的程序）。先介绍一下，嗅探器的特点： 在蓝牙设备连接前，其会在三个频道发送广播（channel 37 38 39），嗅探器会接收到。 当接收信号的设备发出CONN_REQ建立连接后，蓝牙设备不再向频道 37、38、39 发送广播，此时，他们的连接会重新建立在新的频道上，也就是会跳频。在这之后，他们之间便会进行资料传输。 嗅探器一次只能监听 三个频道中的任意一个（可以选择），当接收信号的设备发出的CONN_REQ信号在当前监听的频道时，我们才能看到他们跳频后传输的信息。 由以上特点，可以知道： 已经建立连接的主从设备，他们中间的交换数据是不会监听到的。 需要知道建立连接主设备的默认地址。 有三分之一的概率是可以监听到跳频后的信息。 在主从设备连接前就要开始监听。 有以上的嗅探工具，就可开始分析蓝牙设备与接收设备之间到底发送了什么信息，然后，伪造BLE的通信，这样便能完成一次完整的重放攻击。需要使用的软硬件有： CSR8510 蓝牙适配器 BlueZ 官方蓝牙协议栈 KALI Linux 发行版 在KALI Linux上安装BlueZ ，然后通过蓝牙适配器来获取发送或者获取信息，通过这样，我们就可以开始进行对蓝牙设备的分析。具体安装过程这里就不透露了，有心者自然可以找到。 蓝牙设备介绍在这里，我们以小米手环作为简单的学习工具。 可以通过蓝牙控制的硬件： 3个LED，可以调控颜色（现在的貌似移除了颜色这个选项了） 电容触摸传感器 震动器 计时器 内部功能： 显示电池状态 存储用户信息 实时步伐通知 存储步伐通知 睡眠监测 BLE嗅探分析连接： 写入一定的数据后，才能进行控制： 发送震动： 发送定时震动： 蓝牙应用逆向分析作为一个运动手环，肯定要收集信息，传输到主设备上，那么肯定有能够解析运动手环数据的软件。 对嗅探结果进行分析后，我发现，必须往AttHandle 0x0019这个地址写入数据，这样继续对蓝牙设备进行操作。也不用做什么简单的分析，应该可以肯定，这些数据就是用户的信息。首先，要对这个小米手环的软件进行简单的逆向。 对小米运动App进行逆向分析，定位到 UserInfo类。 编写这个软件的程序员估计是个宅男，默认初始化的人名使用的是知名影星冲田杏梨。 对这个类交叉编译，可以定位到一个非常有意思的地方。 再次定位，可以找到一个重要的逻辑，将infoBuffer的数据做了个CRC8处理。这里的GATTUtil应该就是蓝牙工具类，可以看出应该是用这个类去发送各种数据到小米手环上。 这个，CRC8算法，就是一个简单的HASH，它做了如下处理，前十九个字节都都是用户的信息，最后一个字节是校验用的。 字节 意义 1~4 UID 5 性别 6 年龄 7 身高 8 体重 9~10 类型 11~19 昵称（前十个字节） 20 校验字节 由于最后重放攻击是使用一个python脚本，所以用python写了这个CRC8。 这里我抓了两组不同的数据，都是从手机发送到蓝牙上的，跑一下上面的python，得到的结果，跟校验位一致。 好了，有了这些，就可以拿去Kali Linux上跑了。 结语最后，通过以上的分析，我们可以通过BlueZ的python封装，完成一个重放攻击脚本，启动定时震动功能。 附：Bluez API 介绍用这个命令扫描当前所有蓝牙设备。 1hcitool scanf 这里，扫描到的设备地址是 88:0F:10:EF:C4:11。 调用以下命令，连接设备 1gatttool -i hci0 -b 88:0F:10:EF:C4:11 -I 之后，用help ，列出所有命令。","categories":[{"name":"逆向分析","slug":"逆向分析","permalink":"http://www.zcating.tk/categories/逆向分析/"}],"tags":[]},{"title":"LeetCode—63th—Unique-Paths-II","slug":"LeetCode—63th—Unique-Paths-II","date":"2017-02-16T11:00:00.000Z","updated":"2019-03-17T15:34:49.562Z","comments":true,"path":"2017/02/16/cjzjryjzj00072pl3dads5j35/","link":"","permalink":"http://www.zcating.tk/2017/02/16/cjzjryjzj00072pl3dads5j35/","excerpt":"这是LeetCode上，关于动态规划的题目。","text":"这是LeetCode上，关于动态规划的题目。 题目描述Follow up for “Unique Paths”: Now consider if some obstacles are added to the grids. How many unique paths would there be? An obstacle and empty space is marked as 1 and 0 respectively in the grid. For example,There is one obstacle in the middle of a 3x3 grid as illustrated below.12345[ [0,0,0], [0,1,0], [0,0,0]] The total number of unique paths is 2. Note: m and n will be at most 100. 题目翻译这是”Unique Path”的续题： 现在我们不妨考虑往矩阵中添加一些障碍物。那么在矩阵上又会存在多少条独立路径呢？ 障碍标记为1，可行结点标记为0。 例如以下矩阵： 12345[ [0,0,0], [0,1,0], [0,0,0]] 它一共有两条独立路径。 注意：m和n最多不会100。 解题思路这一道题跟上面一道题很类似，只是增加了一个障碍物。令f(x, y)为从起点到终点的独立路径的数量，那么状态转移方程如下： 1f(x, y) = f(x - 1, y) + f(x, y - 1) 由于增加了障碍物，我们需要要判断这一结点是否可达，对于点(x, y)，它可达当且仅当点(x-1, y-1)也是可达的。也就是obstacleGrid[x-1][y-1] == 0时，以上状态转移方程才会成立。 对于边界条件，假设我们第一次往右移动，那么就要令f(0, 1) = 1。 有了边界条件和状态转移方程，我们很容易的写出代码，如下： 代码1234567891011121314151617int uniquePathsWithObstacles(vector&lt;vector&lt;int&gt;&gt;&amp; obstacleGrid) &#123; if (obstacleGrid.size() == 0) &#123; return 0; &#125; int n = (int)obstacleGrid.size(); int m = (int)obstacleGrid[0].size(); std::vector&lt;std::vector&lt;int&gt;&gt; dp(n + 1, std::vector&lt;int&gt;(m + 1, 0)); dp[0][1] = 1; for (int i = 1; i &lt;= n; i++) &#123; for (int j = 1; j &lt;= m; j++) &#123; if (obstacleGrid[i-1][j-1] == 0) &#123; dp[i][j] = dp[i - 1][j] + dp[i][j - 1]; &#125; &#125; &#125; return dp[n][m];&#125;","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://www.zcating.tk/categories/Algorithm/"}],"tags":[]},{"title":"LeetCode—62th—Unique-Paths","slug":"LeetCode—62th—Unique-Paths","date":"2017-02-16T11:00:00.000Z","updated":"2019-03-17T15:34:49.560Z","comments":true,"path":"2017/02/16/cjzjryjzk00082pl3cqplbhjh/","link":"","permalink":"http://www.zcating.tk/2017/02/16/cjzjryjzk00082pl3cqplbhjh/","excerpt":"这是LeetCode上，关于动态规划的题目。","text":"这是LeetCode上，关于动态规划的题目。 题目描述A robot is located at the top-left corner of a m x n grid (marked ‘Start’ in the diagram below). The robot can only move either down or right at any point in time. The robot is trying to reach the bottom-right corner of the grid (marked ‘Finish’ in the diagram below). How many possible unique paths are there? Above is a 3 x 7 grid. How many possible unique paths are there? 题目翻译一个机器人坐落在一个 m x n 的矩阵的左上方（如图，标记为 ‘Start’）。 这个机器人可以往下或者右进行任意次移动，这个机器人正在尝试到达矩阵的右下方（如图，标记为’End’）。 那么对于每一个矩阵来说，有多少条独立的路径存在？ 解题思路这是一道简单的动态规划问题，令f(x, y)为从起点到点(x, y)的路径的数量。那么，其状态转移方程如下： 1f(x, y) = f(x-1, y) + f(x, y-1) 由于直接从下或者直接从右移动都只有一条路径，所以我们对f(x, y)的第一行和第一列进行初始化。 代码1234567891011121314151617int uniquePaths(int m, int n) &#123; auto dp = vector&lt;vector&lt;int&gt;&gt;(m, vector&lt;int&gt;(n, 0)); dp[0][0] = 1; for(int i = 0; i &lt; n; i++) &#123; dp[0][i] = 1; &#125; for(int i = 0; i &lt; m; i++) &#123; dp[i][0] = 1; &#125; for(int i = 1; i &lt; m; i++) &#123; for(int j = 1; j &lt; n; j++) &#123; dp[i][j] = dp[i - 1][j] + dp[i][j - 1]; &#125; &#125; return dp[m-1][n-1];&#125;","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://www.zcating.tk/categories/Algorithm/"}],"tags":[]}]}